var ua = Object.defineProperty;
var fa = (Ct, Mt, Pt) => Mt in Ct ? ua(Ct, Mt, { enumerable: !0, configurable: !0, writable: !0, value: Pt }) : Ct[Mt] = Pt;
var Ut = (Ct, Mt, Pt) => (fa(Ct, typeof Mt != "symbol" ? Mt + "" : Mt, Pt), Pt), $n = (Ct, Mt, Pt) => {
  if (!Mt.has(Ct))
    throw TypeError("Cannot " + Pt);
};
var Lt = (Ct, Mt, Pt) => ($n(Ct, Mt, "read from private field"), Pt ? Pt.call(Ct) : Mt.get(Ct)), At = (Ct, Mt, Pt) => {
  if (Mt.has(Ct))
    throw TypeError("Cannot add the same private member more than once");
  Mt instanceof WeakSet ? Mt.add(Ct) : Mt.set(Ct, Pt);
}, pn = (Ct, Mt, Pt, Gt) => ($n(Ct, Mt, "write to private field"), Gt ? Gt.call(Ct, Pt) : Mt.set(Ct, Pt), Pt);
var it = (Ct, Mt, Pt) => ($n(Ct, Mt, "access private method"), Pt);
import "../../assets/PdfViewer.css";
import { jsx as jt, jsxs as fn, Fragment as da } from "react/jsx-runtime";
import { T as ga, D as jn, P as Un, V as xa } from "../../ThumbnailBar-C11DOWPt.js";
import ma from "./Controls.js";
import { ViewerProvider as pa, defaultState as ba, useViewerState as ya, useViewerDispatch as wa } from "../context/pdf-viewer-context.js";
var Jn = { exports: {} };
(function(Ct, Mt) {
  (function(Gt, Qt) {
    Ct.exports = Gt.pdfjsWorker = Qt();
  })(globalThis, () => (
    /******/
    (() => {
      var Pt = [
        ,
        /* 1 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.WorkerTask = b.WorkerMessageHandler = void 0;
          var n = ce(2), P = ce(3), D = ce(4), e = ce(6), t = ce(10), l = ce(68), V = ce(73), te = ce(104), E = ce(105), F = ce(72);
          class f {
            constructor(p) {
              this.name = p, this.terminated = !1, this._capability = new n.PromiseCapability();
            }
            get finished() {
              return this._capability.promise;
            }
            finish() {
              this._capability.resolve();
            }
            terminate() {
              this.terminated = !0;
            }
            ensureNotTerminated() {
              if (this.terminated)
                throw new Error("Worker task was terminated");
            }
          }
          b.WorkerTask = f;
          class x {
            static setup(p, O) {
              let M = !1;
              p.on("test", function(R) {
                M || (M = !0, p.send("test", R instanceof Uint8Array));
              }), p.on("configure", function(R) {
                (0, n.setVerbosityLevel)(R.verbosity);
              }), p.on("GetDocRequest", function(R) {
                return x.createDocumentHandler(R, O);
              });
            }
            static createDocumentHandler(p, O) {
              let M, R = !1, z = null;
              const W = /* @__PURE__ */ new Set(), g = (0, n.getVerbosityLevel)(), {
                docId: T,
                apiVersion: o
              } = p, c = "3.11.174";
              if (o !== c)
                throw new Error(`The API version "${o}" does not match the Worker version "${c}".`);
              const I = [];
              for (const S in [])
                I.push(S);
              if (I.length)
                throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + I.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
              const s = T + "_worker";
              let r = new te.MessageHandler(s, T, O);
              function u() {
                if (R)
                  throw new Error("Worker was terminated");
              }
              function C(S) {
                W.add(S);
              }
              function d(S) {
                S.finish(), W.delete(S);
              }
              async function y(S) {
                await M.ensureDoc("checkHeader"), await M.ensureDoc("parseStartXRef"), await M.ensureDoc("parse", [S]), await M.ensureDoc("checkFirstPage", [S]), await M.ensureDoc("checkLastPage", [S]);
                const v = await M.ensureDoc("isPureXfa");
                if (v) {
                  const j = new f("loadXfaFonts");
                  C(j), await Promise.all([M.loadXfaFonts(r, j).catch((G) => {
                  }).then(() => d(j)), M.loadXfaImages()]);
                }
                const [m, h] = await Promise.all([M.ensureDoc("numPages"), M.ensureDoc("fingerprints")]), A = v ? await M.ensureDoc("htmlForXfa") : null;
                return {
                  numPages: m,
                  fingerprints: h,
                  htmlForXfa: A
                };
              }
              function _({
                data: S,
                password: v,
                disableAutoFetch: m,
                rangeChunkSize: h,
                length: A,
                docBaseUrl: j,
                enableXfa: G,
                evaluatorOptions: J
              }) {
                const oe = {
                  source: null,
                  disableAutoFetch: m,
                  docBaseUrl: j,
                  docId: T,
                  enableXfa: G,
                  evaluatorOptions: J,
                  handler: r,
                  length: A,
                  password: v,
                  rangeChunkSize: h
                }, q = new n.PromiseCapability();
                let re;
                if (S) {
                  try {
                    oe.source = S, re = new e.LocalPdfManager(oe), q.resolve(re);
                  } catch (H) {
                    q.reject(H);
                  }
                  return q.promise;
                }
                let K, Z = [];
                try {
                  K = new E.PDFWorkerStream(r);
                } catch (H) {
                  return q.reject(H), q.promise;
                }
                const w = K.getFullReader();
                w.headersReady.then(function() {
                  if (w.isRangeSupported) {
                    oe.source = K, oe.length = w.contentLength, oe.disableAutoFetch || (oe.disableAutoFetch = w.isStreamingSupported), re = new e.NetworkPdfManager(oe);
                    for (const H of Z)
                      re.sendProgressiveData(H);
                    Z = [], q.resolve(re), z = null;
                  }
                }).catch(function(H) {
                  q.reject(H), z = null;
                });
                let k = 0;
                const X = function() {
                  const H = (0, P.arrayBuffersToBytes)(Z);
                  A && H.length !== A && (0, n.warn)("reported HTTP length is different from actual");
                  try {
                    oe.source = H, re = new e.LocalPdfManager(oe), q.resolve(re);
                  } catch (Y) {
                    q.reject(Y);
                  }
                  Z = [];
                };
                return new Promise(function(H, Y) {
                  const ie = function({
                    value: ne,
                    done: U
                  }) {
                    try {
                      if (u(), U) {
                        re || X(), z = null;
                        return;
                      }
                      k += ne.byteLength, w.isStreamingSupported || r.send("DocProgress", {
                        loaded: k,
                        total: Math.max(k, w.contentLength || 0)
                      }), re ? re.sendProgressiveData(ne) : Z.push(ne), w.read().then(ie, Y);
                    } catch (ae) {
                      Y(ae);
                    }
                  };
                  w.read().then(ie, Y);
                }).catch(function(H) {
                  q.reject(H), z = null;
                }), z = function(H) {
                  K.cancelAllRequests(H);
                }, q.promise;
              }
              function $(S) {
                function v(A) {
                  u(), r.send("GetDoc", {
                    pdfInfo: A
                  });
                }
                function m(A) {
                  if (u(), A instanceof n.PasswordException) {
                    const j = new f(`PasswordException: response ${A.code}`);
                    C(j), r.sendWithPromise("PasswordRequest", A).then(function({
                      password: G
                    }) {
                      d(j), M.updatePassword(G), h();
                    }).catch(function() {
                      d(j), r.send("DocException", A);
                    });
                  } else
                    A instanceof n.InvalidPDFException || A instanceof n.MissingPDFException || A instanceof n.UnexpectedResponseException || A instanceof n.UnknownErrorException ? r.send("DocException", A) : r.send("DocException", new n.UnknownErrorException(A.message, A.toString()));
                }
                function h() {
                  u(), y(!1).then(v, function(A) {
                    if (u(), !(A instanceof P.XRefParseException)) {
                      m(A);
                      return;
                    }
                    M.requestLoadedStream().then(function() {
                      u(), y(!0).then(v, m);
                    });
                  });
                }
                u(), _(S).then(function(A) {
                  if (R)
                    throw A.terminate(new n.AbortException("Worker was terminated.")), new Error("Worker was terminated");
                  M = A, M.requestLoadedStream(!0).then((j) => {
                    r.send("DataLoaded", {
                      length: j.bytes.byteLength
                    });
                  });
                }).then(h, m);
              }
              return r.on("GetPage", function(S) {
                return M.getPage(S.pageIndex).then(function(v) {
                  return Promise.all([M.ensure(v, "rotate"), M.ensure(v, "ref"), M.ensure(v, "userUnit"), M.ensure(v, "view")]).then(function([m, h, A, j]) {
                    return {
                      rotate: m,
                      ref: h,
                      userUnit: A,
                      view: j
                    };
                  });
                });
              }), r.on("GetPageIndex", function(S) {
                const v = D.Ref.get(S.num, S.gen);
                return M.ensureCatalog("getPageIndex", [v]);
              }), r.on("GetDestinations", function(S) {
                return M.ensureCatalog("destinations");
              }), r.on("GetDestination", function(S) {
                return M.ensureCatalog("getDestination", [S.id]);
              }), r.on("GetPageLabels", function(S) {
                return M.ensureCatalog("pageLabels");
              }), r.on("GetPageLayout", function(S) {
                return M.ensureCatalog("pageLayout");
              }), r.on("GetPageMode", function(S) {
                return M.ensureCatalog("pageMode");
              }), r.on("GetViewerPreferences", function(S) {
                return M.ensureCatalog("viewerPreferences");
              }), r.on("GetOpenAction", function(S) {
                return M.ensureCatalog("openAction");
              }), r.on("GetAttachments", function(S) {
                return M.ensureCatalog("attachments");
              }), r.on("GetDocJSActions", function(S) {
                return M.ensureCatalog("jsActions");
              }), r.on("GetPageJSActions", function({
                pageIndex: S
              }) {
                return M.getPage(S).then(function(v) {
                  return M.ensure(v, "jsActions");
                });
              }), r.on("GetOutline", function(S) {
                return M.ensureCatalog("documentOutline");
              }), r.on("GetOptionalContentConfig", function(S) {
                return M.ensureCatalog("optionalContentConfig");
              }), r.on("GetPermissions", function(S) {
                return M.ensureCatalog("permissions");
              }), r.on("GetMetadata", function(S) {
                return Promise.all([M.ensureDoc("documentInfo"), M.ensureCatalog("metadata")]);
              }), r.on("GetMarkInfo", function(S) {
                return M.ensureCatalog("markInfo");
              }), r.on("GetData", function(S) {
                return M.requestLoadedStream().then(function(v) {
                  return v.bytes;
                });
              }), r.on("GetAnnotations", function({
                pageIndex: S,
                intent: v
              }) {
                return M.getPage(S).then(function(m) {
                  const h = new f(`GetAnnotations: page ${S}`);
                  return C(h), m.getAnnotationsData(r, h, v).then((A) => (d(h), A), (A) => {
                    throw d(h), A;
                  });
                });
              }), r.on("GetFieldObjects", function(S) {
                return M.ensureDoc("fieldObjects");
              }), r.on("HasJSActions", function(S) {
                return M.ensureDoc("hasJSActions");
              }), r.on("GetCalculationOrderIds", function(S) {
                return M.ensureDoc("calculationOrderIds");
              }), r.on("SaveDocument", async function({
                isPureXfa: S,
                numPages: v,
                annotationStorage: m,
                filename: h
              }) {
                const A = [M.requestLoadedStream(), M.ensureCatalog("acroForm"), M.ensureCatalog("acroFormRef"), M.ensureDoc("startXRef"), M.ensureDoc("xref"), M.ensureDoc("linearization"), M.ensureCatalog("structTreeRoot")], j = [], G = S ? null : (0, P.getNewAnnotationsMap)(m), [J, oe, q, re, K, Z, w] = await Promise.all(A), k = K.trailer.getRaw("Root") || null;
                let X;
                if (G) {
                  w ? await w.canUpdateStructTree({
                    pdfManager: M,
                    newAnnotationsByPage: G
                  }) && (X = w) : await F.StructTreeRoot.canCreateStructureTree({
                    catalogRef: k,
                    pdfManager: M,
                    newAnnotationsByPage: G
                  }) && (X = null);
                  const ee = t.AnnotationFactory.generateImages(m.values(), K, M.evaluatorOptions.isOffscreenCanvasSupported), se = X === void 0 ? j : [];
                  for (const [le, ue] of G)
                    se.push(M.getPage(le).then((de) => {
                      const ge = new f(`Save (editor): page ${le}`);
                      return de.saveNewAnnotations(r, ge, ue, ee).finally(function() {
                        d(ge);
                      });
                    }));
                  X === null ? j.push(Promise.all(se).then(async (le) => (await F.StructTreeRoot.createStructureTree({
                    newAnnotationsByPage: G,
                    xref: K,
                    catalogRef: k,
                    pdfManager: M,
                    newRefs: le
                  }), le))) : X && j.push(Promise.all(se).then(async (le) => (await X.updateStructureTree({
                    newAnnotationsByPage: G,
                    pdfManager: M,
                    newRefs: le
                  }), le)));
                }
                if (S)
                  j.push(M.serializeXfaData(m));
                else
                  for (let ee = 0; ee < v; ee++)
                    j.push(M.getPage(ee).then(function(se) {
                      const le = new f(`Save: page ${ee}`);
                      return se.save(r, le, m).finally(function() {
                        d(le);
                      });
                    }));
                const H = await Promise.all(j);
                let Y = [], ie = null;
                if (S) {
                  if (ie = H[0], !ie)
                    return J.bytes;
                } else if (Y = H.flat(2), Y.length === 0)
                  return J.bytes;
                const ne = q && oe instanceof D.Dict && Y.some((ee) => ee.needAppearances), U = oe instanceof D.Dict && oe.get("XFA") || null;
                let ae = null, Q = !1;
                if (Array.isArray(U)) {
                  for (let ee = 0, se = U.length; ee < se; ee += 2)
                    U[ee] === "datasets" && (ae = U[ee + 1], Q = !0);
                  ae === null && (ae = K.getNewTemporaryRef());
                } else
                  U && (0, n.warn)("Unsupported XFA type.");
                let L = /* @__PURE__ */ Object.create(null);
                if (K.trailer) {
                  const ee = /* @__PURE__ */ Object.create(null), se = K.trailer.get("Info") || null;
                  se instanceof D.Dict && se.forEach((le, ue) => {
                    typeof ue == "string" && (ee[le] = (0, n.stringToPDFString)(ue));
                  }), L = {
                    rootRef: k,
                    encryptRef: K.trailer.getRaw("Encrypt") || null,
                    newRef: K.getNewTemporaryRef(),
                    infoRef: K.trailer.getRaw("Info") || null,
                    info: ee,
                    fileIds: K.trailer.get("ID") || null,
                    startXRef: Z ? re : K.lastXRefStreamPos ?? re,
                    filename: h
                  };
                }
                return (0, V.incrementalUpdate)({
                  originalData: J.bytes,
                  xrefInfo: L,
                  newRefs: Y,
                  xref: K,
                  hasXfa: !!U,
                  xfaDatasetsRef: ae,
                  hasXfaDatasetsEntry: Q,
                  needAppearances: ne,
                  acroFormRef: q,
                  acroForm: oe,
                  xfaData: ie
                }).finally(() => {
                  K.resetNewTemporaryRef();
                });
              }), r.on("GetOperatorList", function(S, v) {
                const m = S.pageIndex;
                M.getPage(m).then(function(h) {
                  const A = new f(`GetOperatorList: page ${m}`);
                  C(A);
                  const j = g >= n.VerbosityLevel.INFOS ? Date.now() : 0;
                  h.getOperatorList({
                    handler: r,
                    sink: v,
                    task: A,
                    intent: S.intent,
                    cacheKey: S.cacheKey,
                    annotationStorage: S.annotationStorage
                  }).then(function(G) {
                    d(A), j && (0, n.info)(`page=${m + 1} - getOperatorList: time=${Date.now() - j}ms, len=${G.length}`), v.close();
                  }, function(G) {
                    d(A), !A.terminated && v.error(G);
                  });
                });
              }), r.on("GetTextContent", function(S, v) {
                const {
                  pageIndex: m,
                  includeMarkedContent: h,
                  disableNormalization: A
                } = S;
                M.getPage(m).then(function(j) {
                  const G = new f("GetTextContent: page " + m);
                  C(G);
                  const J = g >= n.VerbosityLevel.INFOS ? Date.now() : 0;
                  j.extractTextContent({
                    handler: r,
                    task: G,
                    sink: v,
                    includeMarkedContent: h,
                    disableNormalization: A
                  }).then(function() {
                    d(G), J && (0, n.info)(`page=${m + 1} - getTextContent: time=${Date.now() - J}ms`), v.close();
                  }, function(oe) {
                    d(G), !G.terminated && v.error(oe);
                  });
                });
              }), r.on("GetStructTree", function(S) {
                return M.getPage(S.pageIndex).then(function(v) {
                  return M.ensure(v, "getStructTree");
                });
              }), r.on("FontFallback", function(S) {
                return M.fontFallback(S.id, r);
              }), r.on("Cleanup", function(S) {
                return M.cleanup(!0);
              }), r.on("Terminate", function(S) {
                R = !0;
                const v = [];
                if (M) {
                  M.terminate(new n.AbortException("Worker was terminated."));
                  const m = M.cleanup();
                  v.push(m), M = null;
                } else
                  (0, l.clearGlobalCaches)();
                z && z(new n.AbortException("Worker was terminated."));
                for (const m of W)
                  v.push(m.finished), m.terminate();
                return Promise.all(v).then(function() {
                  r.destroy(), r = null;
                });
              }), r.on("Ready", function(S) {
                $(p), p = null;
              }), s;
            }
            static initializeFromPort(p) {
              const O = new te.MessageHandler("worker", "main", p);
              x.setup(O, p), O.send("ready", null);
            }
          }
          b.WorkerMessageHandler = x;
          function a(N) {
            return typeof N.postMessage == "function" && "onmessage" in N;
          }
          typeof window > "u" && !n.isNodeJS && typeof self < "u" && a(self) && x.initializeFromPort(self);
        },
        /* 2 */
        /***/
        (Re, b) => {
          var Ae;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.VerbosityLevel = b.Util = b.UnknownErrorException = b.UnexpectedResponseException = b.TextRenderingMode = b.RenderingIntentFlag = b.PromiseCapability = b.PermissionFlag = b.PasswordResponses = b.PasswordException = b.PageActionEventType = b.OPS = b.MissingPDFException = b.MAX_IMAGE_SIZE_TO_CACHE = b.LINE_FACTOR = b.LINE_DESCENT_FACTOR = b.InvalidPDFException = b.ImageKind = b.IDENTITY_MATRIX = b.FormatError = b.FeatureTest = b.FONT_IDENTITY_MATRIX = b.DocumentActionEventType = b.CMapCompressionType = b.BaseException = b.BASELINE_FACTOR = b.AnnotationType = b.AnnotationReplyType = b.AnnotationPrefix = b.AnnotationMode = b.AnnotationFlag = b.AnnotationFieldFlag = b.AnnotationEditorType = b.AnnotationEditorPrefix = b.AnnotationEditorParamsType = b.AnnotationBorderStyleType = b.AnnotationActionEventType = b.AbortException = void 0, b.assert = $, b.bytesToString = K, b.createValidAbsoluteUrl = v, b.getModificationDate = ue, b.getUuid = xe, b.getVerbosityLevel = C, b.info = d, b.isArrayBuffer = se, b.isArrayEqual = le, b.isNodeJS = void 0, b.normalizeUnicode = pe, b.objectFromMap = X, b.objectSize = k, b.setVerbosityLevel = u, b.shadow = m, b.string32 = w, b.stringToBytes = Z, b.stringToPDFString = Q, b.stringToUTF8String = L, b.unreachable = _, b.utf8StringToString = ee, b.warn = y;
          const ce = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          b.isNodeJS = ce;
          const n = [1, 0, 0, 1, 0, 0];
          b.IDENTITY_MATRIX = n;
          const P = [1e-3, 0, 0, 1e-3, 0, 0];
          b.FONT_IDENTITY_MATRIX = P;
          const D = 1e7;
          b.MAX_IMAGE_SIZE_TO_CACHE = D;
          const e = 1.35;
          b.LINE_FACTOR = e;
          const t = 0.35;
          b.LINE_DESCENT_FACTOR = t;
          const l = t / e;
          b.BASELINE_FACTOR = l;
          const V = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            SAVE: 8,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          b.RenderingIntentFlag = V;
          const te = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          b.AnnotationMode = te;
          const E = "pdfjs_internal_editor_";
          b.AnnotationEditorPrefix = E;
          const F = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            STAMP: 13,
            INK: 15
          };
          b.AnnotationEditorType = F;
          const f = {
            RESIZE: 1,
            CREATE: 2,
            FREETEXT_SIZE: 11,
            FREETEXT_COLOR: 12,
            FREETEXT_OPACITY: 13,
            INK_COLOR: 21,
            INK_THICKNESS: 22,
            INK_OPACITY: 23
          };
          b.AnnotationEditorParamsType = f;
          const x = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          b.PermissionFlag = x;
          const a = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          b.TextRenderingMode = a;
          const N = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          b.ImageKind = N;
          const p = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          b.AnnotationType = p;
          const O = {
            GROUP: "Group",
            REPLY: "R"
          };
          b.AnnotationReplyType = O;
          const M = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          b.AnnotationFlag = M;
          const R = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          b.AnnotationFieldFlag = R;
          const z = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          b.AnnotationBorderStyleType = z;
          const W = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          b.AnnotationActionEventType = W;
          const g = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          b.DocumentActionEventType = g;
          const T = {
            O: "PageOpen",
            C: "PageClose"
          };
          b.PageActionEventType = T;
          const o = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          b.VerbosityLevel = o;
          const c = {
            NONE: 0,
            BINARY: 1
          };
          b.CMapCompressionType = c;
          const I = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          b.OPS = I;
          const s = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          b.PasswordResponses = s;
          let r = o.WARNINGS;
          function u(be) {
            Number.isInteger(be) && (r = be);
          }
          function C() {
            return r;
          }
          function d(be) {
            r >= o.INFOS && console.log(`Info: ${be}`);
          }
          function y(be) {
            r >= o.WARNINGS && console.log(`Warning: ${be}`);
          }
          function _(be) {
            throw new Error(be);
          }
          function $(be, he) {
            be || _(he);
          }
          function S(be) {
            switch (be == null ? void 0 : be.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function v(be, he = null, fe = null) {
            if (!be)
              return null;
            try {
              if (fe && typeof be == "string") {
                if (fe.addDefaultProtocol && be.startsWith("www.")) {
                  const ye = be.match(/\./g);
                  (ye == null ? void 0 : ye.length) >= 2 && (be = `http://${be}`);
                }
                if (fe.tryConvertEncoding)
                  try {
                    be = L(be);
                  } catch {
                  }
              }
              const Ce = he ? new URL(be, he) : new URL(be);
              if (S(Ce))
                return Ce;
            } catch {
            }
            return null;
          }
          function m(be, he, fe, Ce = !1) {
            return Object.defineProperty(be, he, {
              value: fe,
              enumerable: !Ce,
              configurable: !0,
              writable: !1
            }), fe;
          }
          const h = function() {
            function he(fe, Ce) {
              this.constructor === he && _("Cannot initialize BaseException."), this.message = fe, this.name = Ce;
            }
            return he.prototype = new Error(), he.constructor = he, he;
          }();
          b.BaseException = h;
          class A extends h {
            constructor(he, fe) {
              super(he, "PasswordException"), this.code = fe;
            }
          }
          b.PasswordException = A;
          class j extends h {
            constructor(he, fe) {
              super(he, "UnknownErrorException"), this.details = fe;
            }
          }
          b.UnknownErrorException = j;
          class G extends h {
            constructor(he) {
              super(he, "InvalidPDFException");
            }
          }
          b.InvalidPDFException = G;
          class J extends h {
            constructor(he) {
              super(he, "MissingPDFException");
            }
          }
          b.MissingPDFException = J;
          class oe extends h {
            constructor(he, fe) {
              super(he, "UnexpectedResponseException"), this.status = fe;
            }
          }
          b.UnexpectedResponseException = oe;
          class q extends h {
            constructor(he) {
              super(he, "FormatError");
            }
          }
          b.FormatError = q;
          class re extends h {
            constructor(he) {
              super(he, "AbortException");
            }
          }
          b.AbortException = re;
          function K(be) {
            (typeof be != "object" || (be == null ? void 0 : be.length) === void 0) && _("Invalid argument for bytesToString");
            const he = be.length, fe = 8192;
            if (he < fe)
              return String.fromCharCode.apply(null, be);
            const Ce = [];
            for (let ye = 0; ye < he; ye += fe) {
              const Le = Math.min(ye + fe, he), Be = be.subarray(ye, Le);
              Ce.push(String.fromCharCode.apply(null, Be));
            }
            return Ce.join("");
          }
          function Z(be) {
            typeof be != "string" && _("Invalid argument for stringToBytes");
            const he = be.length, fe = new Uint8Array(he);
            for (let Ce = 0; Ce < he; ++Ce)
              fe[Ce] = be.charCodeAt(Ce) & 255;
            return fe;
          }
          function w(be) {
            return String.fromCharCode(be >> 24 & 255, be >> 16 & 255, be >> 8 & 255, be & 255);
          }
          function k(be) {
            return Object.keys(be).length;
          }
          function X(be) {
            const he = /* @__PURE__ */ Object.create(null);
            for (const [fe, Ce] of be)
              he[fe] = Ce;
            return he;
          }
          function H() {
            const be = new Uint8Array(4);
            return be[0] = 1, new Uint32Array(be.buffer, 0, 1)[0] === 1;
          }
          function Y() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class ie {
            static get isLittleEndian() {
              return m(this, "isLittleEndian", H());
            }
            static get isEvalSupported() {
              return m(this, "isEvalSupported", Y());
            }
            static get isOffscreenCanvasSupported() {
              return m(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
            static get platform() {
              return typeof navigator > "u" ? m(this, "platform", {
                isWin: !1,
                isMac: !1
              }) : m(this, "platform", {
                isWin: navigator.platform.includes("Win"),
                isMac: navigator.platform.includes("Mac")
              });
            }
            static get isCSSRoundSupported() {
              var he, fe;
              return m(this, "isCSSRoundSupported", (fe = (he = globalThis.CSS) == null ? void 0 : he.supports) == null ? void 0 : fe.call(he, "width: round(1.5px, 1px)"));
            }
          }
          b.FeatureTest = ie;
          const ne = [...Array(256).keys()].map((be) => be.toString(16).padStart(2, "0"));
          class U {
            static makeHexColor(he, fe, Ce) {
              return `#${ne[he]}${ne[fe]}${ne[Ce]}`;
            }
            static scaleMinMax(he, fe) {
              let Ce;
              he[0] ? (he[0] < 0 && (Ce = fe[0], fe[0] = fe[1], fe[1] = Ce), fe[0] *= he[0], fe[1] *= he[0], he[3] < 0 && (Ce = fe[2], fe[2] = fe[3], fe[3] = Ce), fe[2] *= he[3], fe[3] *= he[3]) : (Ce = fe[0], fe[0] = fe[2], fe[2] = Ce, Ce = fe[1], fe[1] = fe[3], fe[3] = Ce, he[1] < 0 && (Ce = fe[2], fe[2] = fe[3], fe[3] = Ce), fe[2] *= he[1], fe[3] *= he[1], he[2] < 0 && (Ce = fe[0], fe[0] = fe[1], fe[1] = Ce), fe[0] *= he[2], fe[1] *= he[2]), fe[0] += he[4], fe[1] += he[4], fe[2] += he[5], fe[3] += he[5];
            }
            static transform(he, fe) {
              return [he[0] * fe[0] + he[2] * fe[1], he[1] * fe[0] + he[3] * fe[1], he[0] * fe[2] + he[2] * fe[3], he[1] * fe[2] + he[3] * fe[3], he[0] * fe[4] + he[2] * fe[5] + he[4], he[1] * fe[4] + he[3] * fe[5] + he[5]];
            }
            static applyTransform(he, fe) {
              const Ce = he[0] * fe[0] + he[1] * fe[2] + fe[4], ye = he[0] * fe[1] + he[1] * fe[3] + fe[5];
              return [Ce, ye];
            }
            static applyInverseTransform(he, fe) {
              const Ce = fe[0] * fe[3] - fe[1] * fe[2], ye = (he[0] * fe[3] - he[1] * fe[2] + fe[2] * fe[5] - fe[4] * fe[3]) / Ce, Le = (-he[0] * fe[1] + he[1] * fe[0] + fe[4] * fe[1] - fe[5] * fe[0]) / Ce;
              return [ye, Le];
            }
            static getAxialAlignedBoundingBox(he, fe) {
              const Ce = this.applyTransform(he, fe), ye = this.applyTransform(he.slice(2, 4), fe), Le = this.applyTransform([he[0], he[3]], fe), Be = this.applyTransform([he[2], he[1]], fe);
              return [Math.min(Ce[0], ye[0], Le[0], Be[0]), Math.min(Ce[1], ye[1], Le[1], Be[1]), Math.max(Ce[0], ye[0], Le[0], Be[0]), Math.max(Ce[1], ye[1], Le[1], Be[1])];
            }
            static inverseTransform(he) {
              const fe = he[0] * he[3] - he[1] * he[2];
              return [he[3] / fe, -he[1] / fe, -he[2] / fe, he[0] / fe, (he[2] * he[5] - he[4] * he[3]) / fe, (he[4] * he[1] - he[5] * he[0]) / fe];
            }
            static singularValueDecompose2dScale(he) {
              const fe = [he[0], he[2], he[1], he[3]], Ce = he[0] * fe[0] + he[1] * fe[2], ye = he[0] * fe[1] + he[1] * fe[3], Le = he[2] * fe[0] + he[3] * fe[2], Be = he[2] * fe[1] + he[3] * fe[3], nt = (Ce + Be) / 2, Oe = Math.sqrt((Ce + Be) ** 2 - 4 * (Ce * Be - Le * ye)) / 2, Je = nt + Oe || 1, Ve = nt - Oe || 1;
              return [Math.sqrt(Je), Math.sqrt(Ve)];
            }
            static normalizeRect(he) {
              const fe = he.slice(0);
              return he[0] > he[2] && (fe[0] = he[2], fe[2] = he[0]), he[1] > he[3] && (fe[1] = he[3], fe[3] = he[1]), fe;
            }
            static intersect(he, fe) {
              const Ce = Math.max(Math.min(he[0], he[2]), Math.min(fe[0], fe[2])), ye = Math.min(Math.max(he[0], he[2]), Math.max(fe[0], fe[2]));
              if (Ce > ye)
                return null;
              const Le = Math.max(Math.min(he[1], he[3]), Math.min(fe[1], fe[3])), Be = Math.min(Math.max(he[1], he[3]), Math.max(fe[1], fe[3]));
              return Le > Be ? null : [Ce, Le, ye, Be];
            }
            static bezierBoundingBox(he, fe, Ce, ye, Le, Be, nt, Oe) {
              const Je = [], Ve = [[], []];
              let Pe, Ge, dt, De, Qe, st, wt, Ot;
              for (let bt = 0; bt < 2; ++bt) {
                if (bt === 0 ? (Ge = 6 * he - 12 * Ce + 6 * Le, Pe = -3 * he + 9 * Ce - 9 * Le + 3 * nt, dt = 3 * Ce - 3 * he) : (Ge = 6 * fe - 12 * ye + 6 * Be, Pe = -3 * fe + 9 * ye - 9 * Be + 3 * Oe, dt = 3 * ye - 3 * fe), Math.abs(Pe) < 1e-12) {
                  if (Math.abs(Ge) < 1e-12)
                    continue;
                  De = -dt / Ge, 0 < De && De < 1 && Je.push(De);
                  continue;
                }
                wt = Ge * Ge - 4 * dt * Pe, Ot = Math.sqrt(wt), !(wt < 0) && (Qe = (-Ge + Ot) / (2 * Pe), 0 < Qe && Qe < 1 && Je.push(Qe), st = (-Ge - Ot) / (2 * Pe), 0 < st && st < 1 && Je.push(st));
              }
              let ze = Je.length, qe;
              const Ue = ze;
              for (; ze--; )
                De = Je[ze], qe = 1 - De, Ve[0][ze] = qe * qe * qe * he + 3 * qe * qe * De * Ce + 3 * qe * De * De * Le + De * De * De * nt, Ve[1][ze] = qe * qe * qe * fe + 3 * qe * qe * De * ye + 3 * qe * De * De * Be + De * De * De * Oe;
              return Ve[0][Ue] = he, Ve[1][Ue] = fe, Ve[0][Ue + 1] = nt, Ve[1][Ue + 1] = Oe, Ve[0].length = Ve[1].length = Ue + 2, [Math.min(...Ve[0]), Math.min(...Ve[1]), Math.max(...Ve[0]), Math.max(...Ve[1])];
            }
          }
          b.Util = U;
          const ae = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Q(be) {
            if (be[0] >= "ï") {
              let fe;
              if (be[0] === "þ" && be[1] === "ÿ" ? fe = "utf-16be" : be[0] === "ÿ" && be[1] === "þ" ? fe = "utf-16le" : be[0] === "ï" && be[1] === "»" && be[2] === "¿" && (fe = "utf-8"), fe)
                try {
                  const Ce = new TextDecoder(fe, {
                    fatal: !0
                  }), ye = Z(be);
                  return Ce.decode(ye);
                } catch (Ce) {
                  y(`stringToPDFString: "${Ce}".`);
                }
            }
            const he = [];
            for (let fe = 0, Ce = be.length; fe < Ce; fe++) {
              const ye = ae[be.charCodeAt(fe)];
              he.push(ye ? String.fromCharCode(ye) : be.charAt(fe));
            }
            return he.join("");
          }
          function L(be) {
            return decodeURIComponent(escape(be));
          }
          function ee(be) {
            return unescape(encodeURIComponent(be));
          }
          function se(be) {
            return typeof be == "object" && (be == null ? void 0 : be.byteLength) !== void 0;
          }
          function le(be, he) {
            if (be.length !== he.length)
              return !1;
            for (let fe = 0, Ce = be.length; fe < Ce; fe++)
              if (be[fe] !== he[fe])
                return !1;
            return !0;
          }
          function ue(be = /* @__PURE__ */ new Date()) {
            return [be.getUTCFullYear().toString(), (be.getUTCMonth() + 1).toString().padStart(2, "0"), be.getUTCDate().toString().padStart(2, "0"), be.getUTCHours().toString().padStart(2, "0"), be.getUTCMinutes().toString().padStart(2, "0"), be.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          class de {
            constructor() {
              At(this, Ae, !1);
              this.promise = new Promise((he, fe) => {
                this.resolve = (Ce) => {
                  pn(this, Ae, !0), he(Ce);
                }, this.reject = (Ce) => {
                  pn(this, Ae, !0), fe(Ce);
                };
              });
            }
            get settled() {
              return Lt(this, Ae);
            }
          }
          Ae = new WeakMap(), b.PromiseCapability = de;
          let ge = null, me = null;
          function pe(be) {
            return ge || (ge = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, me = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), be.replaceAll(ge, (he, fe, Ce) => fe ? fe.normalize("NFKC") : me.get(Ce));
          }
          function xe() {
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
              return crypto.randomUUID();
            const be = new Uint8Array(32);
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
              crypto.getRandomValues(be);
            else
              for (let he = 0; he < 32; he++)
                be[he] = Math.floor(Math.random() * 255);
            return K(be);
          }
          const we = "pdfjs_internal_id_";
          b.AnnotationPrefix = we;
        },
        /* 3 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XRefParseException = b.XRefEntryException = b.ParserEOFException = b.PDF_VERSION_REGEXP = b.MissingDataException = void 0, b.arrayBuffersToBytes = F, b.collectActions = o, b.encodeToXmlString = I, b.escapePDFName = W, b.escapeString = g, b.getInheritableProperty = f, b.getLookupTableFactory = t, b.getNewAnnotationsMap = d, b.getRotationMatrix = S, b.isAscii = y, b.isWhiteSpace = R, b.log2 = N, b.numberToString = C, b.parseXFAPath = z, b.readInt8 = p, b.readUint16 = O, b.readUint32 = M, b.recoverJsURL = u, b.stringToUTF16HexString = _, b.stringToUTF16String = $, b.toRomanNumerals = a, b.validateCSSFont = r, b.validateFontName = s;
          var n = ce(2), P = ce(4), D = ce(5);
          const e = /^[1-9]\.\d$/;
          b.PDF_VERSION_REGEXP = e;
          function t(v) {
            let m;
            return function() {
              return v && (m = /* @__PURE__ */ Object.create(null), v(m), v = null), m;
            };
          }
          class l extends n.BaseException {
            constructor(m, h) {
              super(`Missing data [${m}, ${h})`, "MissingDataException"), this.begin = m, this.end = h;
            }
          }
          b.MissingDataException = l;
          class V extends n.BaseException {
            constructor(m) {
              super(m, "ParserEOFException");
            }
          }
          b.ParserEOFException = V;
          class te extends n.BaseException {
            constructor(m) {
              super(m, "XRefEntryException");
            }
          }
          b.XRefEntryException = te;
          class E extends n.BaseException {
            constructor(m) {
              super(m, "XRefParseException");
            }
          }
          b.XRefParseException = E;
          function F(v) {
            const m = v.length;
            if (m === 0)
              return new Uint8Array(0);
            if (m === 1)
              return new Uint8Array(v[0]);
            let h = 0;
            for (let G = 0; G < m; G++)
              h += v[G].byteLength;
            const A = new Uint8Array(h);
            let j = 0;
            for (let G = 0; G < m; G++) {
              const J = new Uint8Array(v[G]);
              A.set(J, j), j += J.byteLength;
            }
            return A;
          }
          function f({
            dict: v,
            key: m,
            getArray: h = !1,
            stopWhenFound: A = !0
          }) {
            let j;
            const G = new P.RefSet();
            for (; v instanceof P.Dict && !(v.objId && G.has(v.objId)); ) {
              v.objId && G.put(v.objId);
              const J = h ? v.getArray(m) : v.get(m);
              if (J !== void 0) {
                if (A)
                  return J;
                (j || (j = [])).push(J);
              }
              v = v.get("Parent");
            }
            return j;
          }
          const x = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
          function a(v, m = !1) {
            (0, n.assert)(Number.isInteger(v) && v > 0, "The number should be a positive integer.");
            const h = [];
            let A;
            for (; v >= 1e3; )
              v -= 1e3, h.push("M");
            A = v / 100 | 0, v %= 100, h.push(x[A]), A = v / 10 | 0, v %= 10, h.push(x[10 + A]), h.push(x[20 + v]);
            const j = h.join("");
            return m ? j.toLowerCase() : j;
          }
          function N(v) {
            return v <= 0 ? 0 : Math.ceil(Math.log2(v));
          }
          function p(v, m) {
            return v[m] << 24 >> 24;
          }
          function O(v, m) {
            return v[m] << 8 | v[m + 1];
          }
          function M(v, m) {
            return (v[m] << 24 | v[m + 1] << 16 | v[m + 2] << 8 | v[m + 3]) >>> 0;
          }
          function R(v) {
            return v === 32 || v === 9 || v === 13 || v === 10;
          }
          function z(v) {
            const m = /(.+)\[(\d+)\]$/;
            return v.split(".").map((h) => {
              const A = h.match(m);
              return A ? {
                name: A[1],
                pos: parseInt(A[2], 10)
              } : {
                name: h,
                pos: 0
              };
            });
          }
          function W(v) {
            const m = [];
            let h = 0;
            for (let A = 0, j = v.length; A < j; A++) {
              const G = v.charCodeAt(A);
              (G < 33 || G > 126 || G === 35 || G === 40 || G === 41 || G === 60 || G === 62 || G === 91 || G === 93 || G === 123 || G === 125 || G === 47 || G === 37) && (h < A && m.push(v.substring(h, A)), m.push(`#${G.toString(16)}`), h = A + 1);
            }
            return m.length === 0 ? v : (h < v.length && m.push(v.substring(h, v.length)), m.join(""));
          }
          function g(v) {
            return v.replaceAll(/([()\\\n\r])/g, (m) => m === `
` ? "\\n" : m === "\r" ? "\\r" : `\\${m}`);
          }
          function T(v, m, h, A) {
            if (!v)
              return;
            let j = null;
            if (v instanceof P.Ref) {
              if (A.has(v))
                return;
              j = v, A.put(j), v = m.fetch(v);
            }
            if (Array.isArray(v))
              for (const G of v)
                T(G, m, h, A);
            else if (v instanceof P.Dict) {
              if ((0, P.isName)(v.get("S"), "JavaScript")) {
                const G = v.get("JS");
                let J;
                G instanceof D.BaseStream ? J = G.getString() : typeof G == "string" && (J = G), J && (J = (0, n.stringToPDFString)(J).replaceAll("\0", "")), J && h.push(J);
              }
              T(v.getRaw("Next"), m, h, A);
            }
            j && A.remove(j);
          }
          function o(v, m, h) {
            const A = /* @__PURE__ */ Object.create(null), j = f({
              dict: m,
              key: "AA",
              stopWhenFound: !1
            });
            if (j)
              for (let G = j.length - 1; G >= 0; G--) {
                const J = j[G];
                if (J instanceof P.Dict)
                  for (const oe of J.getKeys()) {
                    const q = h[oe];
                    if (!q)
                      continue;
                    const re = J.getRaw(oe), K = new P.RefSet(), Z = [];
                    T(re, v, Z, K), Z.length > 0 && (A[q] = Z);
                  }
              }
            if (m.has("A")) {
              const G = m.get("A"), J = new P.RefSet(), oe = [];
              T(G, v, oe, J), oe.length > 0 && (A.Action = oe);
            }
            return (0, n.objectSize)(A) > 0 ? A : null;
          }
          const c = {
            60: "&lt;",
            62: "&gt;",
            38: "&amp;",
            34: "&quot;",
            39: "&apos;"
          };
          function I(v) {
            const m = [];
            let h = 0;
            for (let A = 0, j = v.length; A < j; A++) {
              const G = v.codePointAt(A);
              if (32 <= G && G <= 126) {
                const J = c[G];
                J && (h < A && m.push(v.substring(h, A)), m.push(J), h = A + 1);
              } else
                h < A && m.push(v.substring(h, A)), m.push(`&#x${G.toString(16).toUpperCase()};`), G > 55295 && (G < 57344 || G > 65533) && A++, h = A + 1;
            }
            return m.length === 0 ? v : (h < v.length && m.push(v.substring(h, v.length)), m.join(""));
          }
          function s(v, m = !1) {
            const h = /^("|').*("|')$/.exec(v);
            if (h && h[1] === h[2]) {
              if (new RegExp(`[^\\\\]${h[1]}`).test(v.slice(1, -1)))
                return m && (0, n.warn)(`FontFamily contains unescaped ${h[1]}: ${v}.`), !1;
            } else
              for (const A of v.split(/[ \t]+/))
                if (/^(\d|(-(\d|-)))/.test(A) || !/^[\w-\\]+$/.test(A))
                  return m && (0, n.warn)(`FontFamily contains invalid <custom-ident>: ${v}.`), !1;
            return !0;
          }
          function r(v) {
            const m = "14", h = "400", A = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
              fontFamily: j,
              fontWeight: G,
              italicAngle: J
            } = v;
            if (!s(j, !0))
              return !1;
            const oe = G ? G.toString() : "";
            v.fontWeight = A.has(oe) ? oe : h;
            const q = parseFloat(J);
            return v.italicAngle = isNaN(q) || q < -90 || q > 90 ? m : J.toString(), !0;
          }
          function u(v) {
            const m = ["app.launchURL", "window.open", "xfa.host.gotoURL"], A = new RegExp("^\\s*(" + m.join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(v);
            if (A != null && A[2]) {
              const j = A[2];
              let G = !1;
              return A[3] === "true" && A[1] === "app.launchURL" && (G = !0), {
                url: j,
                newWindow: G
              };
            }
            return null;
          }
          function C(v) {
            if (Number.isInteger(v))
              return v.toString();
            const m = Math.round(v * 100);
            return m % 100 === 0 ? (m / 100).toString() : m % 10 === 0 ? v.toFixed(1) : v.toFixed(2);
          }
          function d(v) {
            if (!v)
              return null;
            const m = /* @__PURE__ */ new Map();
            for (const [h, A] of v) {
              if (!h.startsWith(n.AnnotationEditorPrefix))
                continue;
              let j = m.get(A.pageIndex);
              j || (j = [], m.set(A.pageIndex, j)), j.push(A);
            }
            return m.size > 0 ? m : null;
          }
          function y(v) {
            return /^[\x00-\x7F]*$/.test(v);
          }
          function _(v) {
            const m = [];
            for (let h = 0, A = v.length; h < A; h++) {
              const j = v.charCodeAt(h);
              m.push((j >> 8 & 255).toString(16).padStart(2, "0"), (j & 255).toString(16).padStart(2, "0"));
            }
            return m.join("");
          }
          function $(v, m = !1) {
            const h = [];
            m && h.push("þÿ");
            for (let A = 0, j = v.length; A < j; A++) {
              const G = v.charCodeAt(A);
              h.push(String.fromCharCode(G >> 8 & 255), String.fromCharCode(G & 255));
            }
            return h.join("");
          }
          function S(v, m, h) {
            switch (v) {
              case 90:
                return [0, 1, -1, 0, m, 0];
              case 180:
                return [-1, 0, 0, -1, m, h];
              case 270:
                return [0, -1, 1, 0, 0, h];
              default:
                throw new Error("Invalid rotation");
            }
          }
        },
        /* 4 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.RefSetCache = b.RefSet = b.Ref = b.Name = b.EOF = b.Dict = b.Cmd = b.CIRCULAR_REF = void 0, b.clearPrimitiveCaches = V, b.isCmd = O, b.isDict = M, b.isName = p, b.isRefsEqual = R;
          var n = ce(2);
          const P = Symbol("CIRCULAR_REF");
          b.CIRCULAR_REF = P;
          const D = Symbol("EOF");
          b.EOF = D;
          let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
          function V() {
            e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
          }
          class te {
            constructor(W) {
              this.name = W;
            }
            static get(W) {
              return t[W] || (t[W] = new te(W));
            }
          }
          b.Name = te;
          class E {
            constructor(W) {
              this.cmd = W;
            }
            static get(W) {
              return e[W] || (e[W] = new E(W));
            }
          }
          b.Cmd = E;
          const F = function() {
            return F;
          };
          class f {
            constructor(W = null) {
              this._map = /* @__PURE__ */ Object.create(null), this.xref = W, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = F;
            }
            assignXref(W) {
              this.xref = W;
            }
            get size() {
              return Object.keys(this._map).length;
            }
            get(W, g, T) {
              let o = this._map[W];
              return o === void 0 && g !== void 0 && (o = this._map[g], o === void 0 && T !== void 0 && (o = this._map[T])), o instanceof x && this.xref ? this.xref.fetch(o, this.suppressEncryption) : o;
            }
            async getAsync(W, g, T) {
              let o = this._map[W];
              return o === void 0 && g !== void 0 && (o = this._map[g], o === void 0 && T !== void 0 && (o = this._map[T])), o instanceof x && this.xref ? this.xref.fetchAsync(o, this.suppressEncryption) : o;
            }
            getArray(W, g, T) {
              let o = this._map[W];
              if (o === void 0 && g !== void 0 && (o = this._map[g], o === void 0 && T !== void 0 && (o = this._map[T])), o instanceof x && this.xref && (o = this.xref.fetch(o, this.suppressEncryption)), Array.isArray(o)) {
                o = o.slice();
                for (let c = 0, I = o.length; c < I; c++)
                  o[c] instanceof x && this.xref && (o[c] = this.xref.fetch(o[c], this.suppressEncryption));
              }
              return o;
            }
            getRaw(W) {
              return this._map[W];
            }
            getKeys() {
              return Object.keys(this._map);
            }
            getRawValues() {
              return Object.values(this._map);
            }
            set(W, g) {
              this._map[W] = g;
            }
            has(W) {
              return this._map[W] !== void 0;
            }
            forEach(W) {
              for (const g in this._map)
                W(g, this.get(g));
            }
            static get empty() {
              const W = new f(null);
              return W.set = (g, T) => {
                (0, n.unreachable)("Should not call `set` on the empty dictionary.");
              }, (0, n.shadow)(this, "empty", W);
            }
            static merge({
              xref: W,
              dictArray: g,
              mergeSubDicts: T = !1
            }) {
              const o = new f(W), c = /* @__PURE__ */ new Map();
              for (const I of g)
                if (I instanceof f)
                  for (const [s, r] of Object.entries(I._map)) {
                    let u = c.get(s);
                    if (u === void 0)
                      u = [], c.set(s, u);
                    else if (!T || !(r instanceof f))
                      continue;
                    u.push(r);
                  }
              for (const [I, s] of c) {
                if (s.length === 1 || !(s[0] instanceof f)) {
                  o._map[I] = s[0];
                  continue;
                }
                const r = new f(W);
                for (const u of s)
                  for (const [C, d] of Object.entries(u._map))
                    r._map[C] === void 0 && (r._map[C] = d);
                r.size > 0 && (o._map[I] = r);
              }
              return c.clear(), o.size > 0 ? o : f.empty;
            }
            clone() {
              const W = new f(this.xref);
              for (const g of this.getKeys())
                W.set(g, this.getRaw(g));
              return W;
            }
          }
          b.Dict = f;
          class x {
            constructor(W, g) {
              this.num = W, this.gen = g;
            }
            toString() {
              return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
            }
            static fromString(W) {
              const g = l[W];
              if (g)
                return g;
              const T = /^(\d+)R(\d*)$/.exec(W);
              return !T || T[1] === "0" ? null : l[W] = new x(parseInt(T[1]), T[2] ? parseInt(T[2]) : 0);
            }
            static get(W, g) {
              const T = g === 0 ? `${W}R` : `${W}R${g}`;
              return l[T] || (l[T] = new x(W, g));
            }
          }
          b.Ref = x;
          class a {
            constructor(W = null) {
              this._set = new Set(W == null ? void 0 : W._set);
            }
            has(W) {
              return this._set.has(W.toString());
            }
            put(W) {
              this._set.add(W.toString());
            }
            remove(W) {
              this._set.delete(W.toString());
            }
            [Symbol.iterator]() {
              return this._set.values();
            }
            clear() {
              this._set.clear();
            }
          }
          b.RefSet = a;
          class N {
            constructor() {
              this._map = /* @__PURE__ */ new Map();
            }
            get size() {
              return this._map.size;
            }
            get(W) {
              return this._map.get(W.toString());
            }
            has(W) {
              return this._map.has(W.toString());
            }
            put(W, g) {
              this._map.set(W.toString(), g);
            }
            putAlias(W, g) {
              this._map.set(W.toString(), this.get(g));
            }
            [Symbol.iterator]() {
              return this._map.values();
            }
            clear() {
              this._map.clear();
            }
          }
          b.RefSetCache = N;
          function p(z, W) {
            return z instanceof te && (W === void 0 || z.name === W);
          }
          function O(z, W) {
            return z instanceof E && (W === void 0 || z.cmd === W);
          }
          function M(z, W) {
            return z instanceof f && (W === void 0 || p(z.get("Type"), W));
          }
          function R(z, W) {
            return z.num === W.num && z.gen === W.gen;
          }
        },
        /* 5 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.BaseStream = void 0;
          var n = ce(2);
          class P {
            constructor() {
              this.constructor === P && (0, n.unreachable)("Cannot initialize BaseStream.");
            }
            get length() {
              (0, n.unreachable)("Abstract getter `length` accessed");
            }
            get isEmpty() {
              (0, n.unreachable)("Abstract getter `isEmpty` accessed");
            }
            get isDataLoaded() {
              return (0, n.shadow)(this, "isDataLoaded", !0);
            }
            getByte() {
              (0, n.unreachable)("Abstract method `getByte` called");
            }
            getBytes(e) {
              (0, n.unreachable)("Abstract method `getBytes` called");
            }
            peekByte() {
              const e = this.getByte();
              return e !== -1 && this.pos--, e;
            }
            peekBytes(e) {
              const t = this.getBytes(e);
              return this.pos -= t.length, t;
            }
            getUint16() {
              const e = this.getByte(), t = this.getByte();
              return e === -1 || t === -1 ? -1 : (e << 8) + t;
            }
            getInt32() {
              const e = this.getByte(), t = this.getByte(), l = this.getByte(), V = this.getByte();
              return (e << 24) + (t << 16) + (l << 8) + V;
            }
            getByteRange(e, t) {
              (0, n.unreachable)("Abstract method `getByteRange` called");
            }
            getString(e) {
              return (0, n.bytesToString)(this.getBytes(e));
            }
            skip(e) {
              this.pos += e || 1;
            }
            reset() {
              (0, n.unreachable)("Abstract method `reset` called");
            }
            moveStart() {
              (0, n.unreachable)("Abstract method `moveStart` called");
            }
            makeSubStream(e, t, l = null) {
              (0, n.unreachable)("Abstract method `makeSubStream` called");
            }
            getBaseStreams() {
              return null;
            }
          }
          b.BaseStream = P;
        },
        /* 6 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.NetworkPdfManager = b.LocalPdfManager = void 0;
          var n = ce(2), P = ce(7), D = ce(3), e = ce(9), t = ce(8);
          function l(F) {
            if (F) {
              const f = (0, n.createValidAbsoluteUrl)(F);
              if (f)
                return f.href;
              (0, n.warn)(`Invalid absolute docBaseUrl: "${F}".`);
            }
            return null;
          }
          class V {
            constructor(f) {
              var x;
              this.constructor === V && (0, n.unreachable)("Cannot initialize BasePdfManager."), this._docBaseUrl = l(f.docBaseUrl), this._docId = f.docId, this._password = f.password, this.enableXfa = f.enableXfa, (x = f.evaluatorOptions).isOffscreenCanvasSupported && (x.isOffscreenCanvasSupported = n.FeatureTest.isOffscreenCanvasSupported), this.evaluatorOptions = f.evaluatorOptions;
            }
            get docId() {
              return this._docId;
            }
            get password() {
              return this._password;
            }
            get docBaseUrl() {
              return this._docBaseUrl;
            }
            get catalog() {
              return this.pdfDocument.catalog;
            }
            ensureDoc(f, x) {
              return this.ensure(this.pdfDocument, f, x);
            }
            ensureXRef(f, x) {
              return this.ensure(this.pdfDocument.xref, f, x);
            }
            ensureCatalog(f, x) {
              return this.ensure(this.pdfDocument.catalog, f, x);
            }
            getPage(f) {
              return this.pdfDocument.getPage(f);
            }
            fontFallback(f, x) {
              return this.pdfDocument.fontFallback(f, x);
            }
            loadXfaFonts(f, x) {
              return this.pdfDocument.loadXfaFonts(f, x);
            }
            loadXfaImages() {
              return this.pdfDocument.loadXfaImages();
            }
            serializeXfaData(f) {
              return this.pdfDocument.serializeXfaData(f);
            }
            cleanup(f = !1) {
              return this.pdfDocument.cleanup(f);
            }
            async ensure(f, x, a) {
              (0, n.unreachable)("Abstract method `ensure` called");
            }
            requestRange(f, x) {
              (0, n.unreachable)("Abstract method `requestRange` called");
            }
            requestLoadedStream(f = !1) {
              (0, n.unreachable)("Abstract method `requestLoadedStream` called");
            }
            sendProgressiveData(f) {
              (0, n.unreachable)("Abstract method `sendProgressiveData` called");
            }
            updatePassword(f) {
              this._password = f;
            }
            terminate(f) {
              (0, n.unreachable)("Abstract method `terminate` called");
            }
          }
          class te extends V {
            constructor(f) {
              super(f);
              const x = new t.Stream(f.source);
              this.pdfDocument = new e.PDFDocument(this, x), this._loadedStreamPromise = Promise.resolve(x);
            }
            async ensure(f, x, a) {
              const N = f[x];
              return typeof N == "function" ? N.apply(f, a) : N;
            }
            requestRange(f, x) {
              return Promise.resolve();
            }
            requestLoadedStream(f = !1) {
              return this._loadedStreamPromise;
            }
            terminate(f) {
            }
          }
          b.LocalPdfManager = te;
          class E extends V {
            constructor(f) {
              super(f), this.streamManager = new P.ChunkedStreamManager(f.source, {
                msgHandler: f.handler,
                length: f.length,
                disableAutoFetch: f.disableAutoFetch,
                rangeChunkSize: f.rangeChunkSize
              }), this.pdfDocument = new e.PDFDocument(this, this.streamManager.getStream());
            }
            async ensure(f, x, a) {
              try {
                const N = f[x];
                return typeof N == "function" ? N.apply(f, a) : N;
              } catch (N) {
                if (!(N instanceof D.MissingDataException))
                  throw N;
                return await this.requestRange(N.begin, N.end), this.ensure(f, x, a);
              }
            }
            requestRange(f, x) {
              return this.streamManager.requestRange(f, x);
            }
            requestLoadedStream(f = !1) {
              return this.streamManager.requestAllChunks(f);
            }
            sendProgressiveData(f) {
              this.streamManager.onReceiveData({
                chunk: f
              });
            }
            terminate(f) {
              this.streamManager.abort(f);
            }
          }
          b.NetworkPdfManager = E;
        },
        /* 7 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ChunkedStreamManager = b.ChunkedStream = void 0;
          var n = ce(3), P = ce(2), D = ce(8);
          class e extends D.Stream {
            constructor(V, te, E) {
              super(new Uint8Array(V), 0, V, null), this.chunkSize = te, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(V / te), this.manager = E, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
            }
            getMissingChunks() {
              const V = [];
              for (let te = 0, E = this.numChunks; te < E; ++te)
                this._loadedChunks.has(te) || V.push(te);
              return V;
            }
            get numChunksLoaded() {
              return this._loadedChunks.size;
            }
            get isDataLoaded() {
              return this.numChunksLoaded === this.numChunks;
            }
            onReceiveData(V, te) {
              const E = this.chunkSize;
              if (V % E !== 0)
                throw new Error(`Bad begin offset: ${V}`);
              const F = V + te.byteLength;
              if (F % E !== 0 && F !== this.bytes.length)
                throw new Error(`Bad end offset: ${F}`);
              this.bytes.set(new Uint8Array(te), V);
              const f = Math.floor(V / E), x = Math.floor((F - 1) / E) + 1;
              for (let a = f; a < x; ++a)
                this._loadedChunks.add(a);
            }
            onReceiveProgressiveData(V) {
              let te = this.progressiveDataLength;
              const E = Math.floor(te / this.chunkSize);
              this.bytes.set(new Uint8Array(V), te), te += V.byteLength, this.progressiveDataLength = te;
              const F = te >= this.end ? this.numChunks : Math.floor(te / this.chunkSize);
              for (let f = E; f < F; ++f)
                this._loadedChunks.add(f);
            }
            ensureByte(V) {
              if (V < this.progressiveDataLength)
                return;
              const te = Math.floor(V / this.chunkSize);
              if (!(te > this.numChunks) && te !== this.lastSuccessfulEnsureByteChunk) {
                if (!this._loadedChunks.has(te))
                  throw new n.MissingDataException(V, V + 1);
                this.lastSuccessfulEnsureByteChunk = te;
              }
            }
            ensureRange(V, te) {
              if (V >= te || te <= this.progressiveDataLength)
                return;
              const E = Math.floor(V / this.chunkSize);
              if (E > this.numChunks)
                return;
              const F = Math.min(Math.floor((te - 1) / this.chunkSize) + 1, this.numChunks);
              for (let f = E; f < F; ++f)
                if (!this._loadedChunks.has(f))
                  throw new n.MissingDataException(V, te);
            }
            nextEmptyChunk(V) {
              const te = this.numChunks;
              for (let E = 0; E < te; ++E) {
                const F = (V + E) % te;
                if (!this._loadedChunks.has(F))
                  return F;
              }
              return null;
            }
            hasChunk(V) {
              return this._loadedChunks.has(V);
            }
            getByte() {
              const V = this.pos;
              return V >= this.end ? -1 : (V >= this.progressiveDataLength && this.ensureByte(V), this.bytes[this.pos++]);
            }
            getBytes(V) {
              const te = this.bytes, E = this.pos, F = this.end;
              if (!V)
                return F > this.progressiveDataLength && this.ensureRange(E, F), te.subarray(E, F);
              let f = E + V;
              return f > F && (f = F), f > this.progressiveDataLength && this.ensureRange(E, f), this.pos = f, te.subarray(E, f);
            }
            getByteRange(V, te) {
              return V < 0 && (V = 0), te > this.end && (te = this.end), te > this.progressiveDataLength && this.ensureRange(V, te), this.bytes.subarray(V, te);
            }
            makeSubStream(V, te, E = null) {
              te ? V + te > this.progressiveDataLength && this.ensureRange(V, V + te) : V >= this.progressiveDataLength && this.ensureByte(V);
              function F() {
              }
              F.prototype = Object.create(this), F.prototype.getMissingChunks = function() {
                const x = this.chunkSize, a = Math.floor(this.start / x), N = Math.floor((this.end - 1) / x) + 1, p = [];
                for (let O = a; O < N; ++O)
                  this._loadedChunks.has(O) || p.push(O);
                return p;
              }, Object.defineProperty(F.prototype, "isDataLoaded", {
                get() {
                  return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
                },
                configurable: !0
              });
              const f = new F();
              return f.pos = f.start = V, f.end = V + te || this.end, f.dict = E, f;
            }
            getBaseStreams() {
              return [this];
            }
          }
          b.ChunkedStream = e;
          class t {
            constructor(V, te) {
              this.length = te.length, this.chunkSize = te.rangeChunkSize, this.stream = new e(this.length, this.chunkSize, this), this.pdfNetworkStream = V, this.disableAutoFetch = te.disableAutoFetch, this.msgHandler = te.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = new P.PromiseCapability();
            }
            sendRequest(V, te) {
              const E = this.pdfNetworkStream.getRangeReader(V, te);
              E.isStreamingSupported || (E.onProgress = this.onProgress.bind(this));
              let F = [], f = 0;
              return new Promise((x, a) => {
                const N = ({
                  value: p,
                  done: O
                }) => {
                  try {
                    if (O) {
                      const M = (0, n.arrayBuffersToBytes)(F);
                      F = null, x(M);
                      return;
                    }
                    f += p.byteLength, E.isStreamingSupported && this.onProgress({
                      loaded: f
                    }), F.push(p), E.read().then(N, a);
                  } catch (M) {
                    a(M);
                  }
                };
                E.read().then(N, a);
              }).then((x) => {
                this.aborted || this.onReceiveData({
                  chunk: x,
                  begin: V
                });
              });
            }
            requestAllChunks(V = !1) {
              if (!V) {
                const te = this.stream.getMissingChunks();
                this._requestChunks(te);
              }
              return this._loadedStreamCapability.promise;
            }
            _requestChunks(V) {
              const te = this.currRequestId++, E = /* @__PURE__ */ new Set();
              this._chunksNeededByRequest.set(te, E);
              for (const x of V)
                this.stream.hasChunk(x) || E.add(x);
              if (E.size === 0)
                return Promise.resolve();
              const F = new P.PromiseCapability();
              this._promisesByRequest.set(te, F);
              const f = [];
              for (const x of E) {
                let a = this._requestsByChunk.get(x);
                a || (a = [], this._requestsByChunk.set(x, a), f.push(x)), a.push(te);
              }
              if (f.length > 0) {
                const x = this.groupChunks(f);
                for (const a of x) {
                  const N = a.beginChunk * this.chunkSize, p = Math.min(a.endChunk * this.chunkSize, this.length);
                  this.sendRequest(N, p).catch(F.reject);
                }
              }
              return F.promise.catch((x) => {
                if (!this.aborted)
                  throw x;
              });
            }
            getStream() {
              return this.stream;
            }
            requestRange(V, te) {
              te = Math.min(te, this.length);
              const E = this.getBeginChunk(V), F = this.getEndChunk(te), f = [];
              for (let x = E; x < F; ++x)
                f.push(x);
              return this._requestChunks(f);
            }
            requestRanges(V = []) {
              const te = [];
              for (const E of V) {
                const F = this.getBeginChunk(E.begin), f = this.getEndChunk(E.end);
                for (let x = F; x < f; ++x)
                  te.includes(x) || te.push(x);
              }
              return te.sort(function(E, F) {
                return E - F;
              }), this._requestChunks(te);
            }
            groupChunks(V) {
              const te = [];
              let E = -1, F = -1;
              for (let f = 0, x = V.length; f < x; ++f) {
                const a = V[f];
                E < 0 && (E = a), F >= 0 && F + 1 !== a && (te.push({
                  beginChunk: E,
                  endChunk: F + 1
                }), E = a), f + 1 === V.length && te.push({
                  beginChunk: E,
                  endChunk: a + 1
                }), F = a;
              }
              return te;
            }
            onProgress(V) {
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize + V.loaded,
                total: this.length
              });
            }
            onReceiveData(V) {
              const te = V.chunk, E = V.begin === void 0, F = E ? this.progressiveDataLength : V.begin, f = F + te.byteLength, x = Math.floor(F / this.chunkSize), a = f < this.length ? Math.floor(f / this.chunkSize) : Math.ceil(f / this.chunkSize);
              E ? (this.stream.onReceiveProgressiveData(te), this.progressiveDataLength = f) : this.stream.onReceiveData(F, te), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
              const N = [];
              for (let p = x; p < a; ++p) {
                const O = this._requestsByChunk.get(p);
                if (O) {
                  this._requestsByChunk.delete(p);
                  for (const M of O) {
                    const R = this._chunksNeededByRequest.get(M);
                    R.has(p) && R.delete(p), !(R.size > 0) && N.push(M);
                  }
                }
              }
              if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
                let p;
                if (this.stream.numChunksLoaded === 1) {
                  const O = this.stream.numChunks - 1;
                  this.stream.hasChunk(O) || (p = O);
                } else
                  p = this.stream.nextEmptyChunk(a);
                Number.isInteger(p) && this._requestChunks([p]);
              }
              for (const p of N) {
                const O = this._promisesByRequest.get(p);
                this._promisesByRequest.delete(p), O.resolve();
              }
              this.msgHandler.send("DocProgress", {
                loaded: this.stream.numChunksLoaded * this.chunkSize,
                total: this.length
              });
            }
            onError(V) {
              this._loadedStreamCapability.reject(V);
            }
            getBeginChunk(V) {
              return Math.floor(V / this.chunkSize);
            }
            getEndChunk(V) {
              return Math.floor((V - 1) / this.chunkSize) + 1;
            }
            abort(V) {
              var te;
              this.aborted = !0, (te = this.pdfNetworkStream) == null || te.cancelAllRequests(V);
              for (const E of this._promisesByRequest.values())
                E.reject(V);
            }
          }
          b.ChunkedStreamManager = t;
        },
        /* 8 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.StringStream = b.Stream = b.NullStream = void 0;
          var n = ce(5), P = ce(2);
          class D extends n.BaseStream {
            constructor(V, te, E, F) {
              super(), this.bytes = V instanceof Uint8Array ? V : new Uint8Array(V), this.start = te || 0, this.pos = this.start, this.end = te + E || this.bytes.length, this.dict = F;
            }
            get length() {
              return this.end - this.start;
            }
            get isEmpty() {
              return this.length === 0;
            }
            getByte() {
              return this.pos >= this.end ? -1 : this.bytes[this.pos++];
            }
            getBytes(V) {
              const te = this.bytes, E = this.pos, F = this.end;
              if (!V)
                return te.subarray(E, F);
              let f = E + V;
              return f > F && (f = F), this.pos = f, te.subarray(E, f);
            }
            getByteRange(V, te) {
              return V < 0 && (V = 0), te > this.end && (te = this.end), this.bytes.subarray(V, te);
            }
            reset() {
              this.pos = this.start;
            }
            moveStart() {
              this.start = this.pos;
            }
            makeSubStream(V, te, E = null) {
              return new D(this.bytes.buffer, V, te, E);
            }
          }
          b.Stream = D;
          class e extends D {
            constructor(V) {
              super((0, P.stringToBytes)(V));
            }
          }
          b.StringStream = e;
          class t extends D {
            constructor() {
              super(new Uint8Array(0));
            }
          }
          b.NullStream = t;
        },
        /* 9 */
        /***/
        (Re, b, ce) => {
          var y, _n, $, Xn;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Page = b.PDFDocument = void 0;
          var n = ce(2), P = ce(10), D = ce(3), e = ce(4), t = ce(51), l = ce(5), V = ce(74), te = ce(66), E = ce(68), F = ce(102), f = ce(16), x = ce(8), a = ce(76), N = ce(64), p = ce(13), O = ce(18), M = ce(72), R = ce(73), z = ce(77), W = ce(103);
          const g = 1, T = [0, 0, 612, 792];
          class o {
            constructor({
              pdfManager: m,
              xref: h,
              pageIndex: A,
              pageDict: j,
              ref: G,
              globalIdFactory: J,
              fontCache: oe,
              builtInCMapCache: q,
              standardFontDataCache: re,
              globalImageCache: K,
              systemFontCache: Z,
              nonBlendModesSet: w,
              xfaFactory: k
            }) {
              At(this, y);
              this.pdfManager = m, this.pageIndex = A, this.pageDict = j, this.xref = h, this.ref = G, this.fontCache = oe, this.builtInCMapCache = q, this.standardFontDataCache = re, this.globalImageCache = K, this.systemFontCache = Z, this.nonBlendModesSet = w, this.evaluatorOptions = m.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = k;
              const X = {
                obj: 0
              };
              this._localIdFactory = class extends J {
                static createObjId() {
                  return `p${A}_${++X.obj}`;
                }
                static getPageObjId() {
                  return `p${G.toString()}`;
                }
              };
            }
            _getInheritableProperty(m, h = !1) {
              const A = (0, D.getInheritableProperty)({
                dict: this.pageDict,
                key: m,
                getArray: h,
                stopWhenFound: !1
              });
              return Array.isArray(A) ? A.length === 1 || !(A[0] instanceof e.Dict) ? A[0] : e.Dict.merge({
                xref: this.xref,
                dictArray: A
              }) : A;
            }
            get content() {
              return this.pageDict.getArray("Contents");
            }
            get resources() {
              const m = this._getInheritableProperty("Resources");
              return (0, n.shadow)(this, "resources", m instanceof e.Dict ? m : e.Dict.empty);
            }
            _getBoundingBox(m) {
              if (this.xfaData)
                return this.xfaData.bbox;
              let h = this._getInheritableProperty(m, !0);
              if (Array.isArray(h) && h.length === 4) {
                if (h = n.Util.normalizeRect(h), h[2] - h[0] > 0 && h[3] - h[1] > 0)
                  return h;
                (0, n.warn)(`Empty, or invalid, /${m} entry.`);
              }
              return null;
            }
            get mediaBox() {
              return (0, n.shadow)(this, "mediaBox", this._getBoundingBox("MediaBox") || T);
            }
            get cropBox() {
              return (0, n.shadow)(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
            }
            get userUnit() {
              let m = this.pageDict.get("UserUnit");
              return (typeof m != "number" || m <= 0) && (m = g), (0, n.shadow)(this, "userUnit", m);
            }
            get view() {
              const {
                cropBox: m,
                mediaBox: h
              } = this;
              if (m !== h && !(0, n.isArrayEqual)(m, h)) {
                const A = n.Util.intersect(m, h);
                if (A && A[2] - A[0] > 0 && A[3] - A[1] > 0)
                  return (0, n.shadow)(this, "view", A);
                (0, n.warn)("Empty /CropBox and /MediaBox intersection.");
              }
              return (0, n.shadow)(this, "view", h);
            }
            get rotate() {
              let m = this._getInheritableProperty("Rotate") || 0;
              return m % 90 !== 0 ? m = 0 : m >= 360 ? m %= 360 : m < 0 && (m = (m % 360 + 360) % 360), (0, n.shadow)(this, "rotate", m);
            }
            _onSubStreamError(m, h) {
              if (this.evaluatorOptions.ignoreErrors) {
                (0, n.warn)(`getContentStream - ignoring sub-stream (${h}): "${m}".`);
                return;
              }
              throw m;
            }
            getContentStream() {
              return this.pdfManager.ensure(this, "content").then((m) => m instanceof l.BaseStream ? m : Array.isArray(m) ? new O.StreamsSequenceStream(m, this._onSubStreamError.bind(this)) : new x.NullStream());
            }
            get xfaData() {
              return (0, n.shadow)(this, "xfaData", this.xfaFactory ? {
                bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
              } : null);
            }
            async saveNewAnnotations(m, h, A, j) {
              if (this.xfaFactory)
                throw new Error("XFA: Cannot save new annotations.");
              const G = new p.PartialEvaluator({
                xref: this.xref,
                handler: m,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                systemFontCache: this.systemFontCache,
                options: this.evaluatorOptions
              }), J = new e.RefSet(), oe = new e.RefSet();
              it(this, y, _n).call(this, A, J, oe);
              const q = this.pageDict, re = this.annotations.filter((X) => !(X instanceof e.Ref && J.has(X))), K = await P.AnnotationFactory.saveNewAnnotations(G, h, A, j);
              for (const {
                ref: X
              } of K.annotations)
                X instanceof e.Ref && !oe.has(X) && re.push(X);
              const Z = q.get("Annots");
              q.set("Annots", re);
              const w = [];
              await (0, R.writeObject)(this.ref, q, w, this.xref), Z && q.set("Annots", Z);
              const k = K.dependencies;
              return k.push({
                ref: this.ref,
                data: w.join("")
              }, ...K.annotations), k;
            }
            save(m, h, A) {
              const j = new p.PartialEvaluator({
                xref: this.xref,
                handler: m,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                systemFontCache: this.systemFontCache,
                options: this.evaluatorOptions
              });
              return this._parsedAnnotations.then(function(G) {
                const J = [];
                for (const oe of G)
                  oe.mustBePrinted(A) && J.push(oe.save(j, h, A).catch(function(q) {
                    return (0, n.warn)(`save - ignoring annotation data during "${h.name}" task: "${q}".`), null;
                  }));
                return Promise.all(J).then(function(oe) {
                  return oe.filter((q) => !!q);
                });
              });
            }
            loadResources(m) {
              return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new a.ObjectLoader(this.resources, m, this.xref).load());
            }
            getOperatorList({
              handler: m,
              sink: h,
              task: A,
              intent: j,
              cacheKey: G,
              annotationStorage: J = null
            }) {
              const oe = this.getContentStream(), q = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), re = new p.PartialEvaluator({
                xref: this.xref,
                handler: m,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                systemFontCache: this.systemFontCache,
                options: this.evaluatorOptions
              }), K = this.xfaFactory ? null : (0, D.getNewAnnotationsMap)(J);
              let Z = null, w = Promise.resolve(null);
              if (K) {
                const H = K.get(this.pageIndex);
                if (H) {
                  const Y = this.pdfManager.ensureDoc("annotationGlobals");
                  let ie;
                  const ne = /* @__PURE__ */ new Set();
                  for (const {
                    bitmapId: ae,
                    bitmap: Q
                  } of H)
                    ae && !Q && !ne.has(ae) && ne.add(ae);
                  const {
                    isOffscreenCanvasSupported: U
                  } = this.evaluatorOptions;
                  if (ne.size > 0) {
                    const ae = H.slice();
                    for (const [Q, L] of J)
                      Q.startsWith(n.AnnotationEditorPrefix) && L.bitmap && ne.has(L.bitmapId) && ae.push(L);
                    ie = P.AnnotationFactory.generateImages(ae, this.xref, U);
                  } else
                    ie = P.AnnotationFactory.generateImages(H, this.xref, U);
                  Z = new e.RefSet(), it(this, y, _n).call(this, H, Z, null), w = Y.then((ae) => ae ? P.AnnotationFactory.printNewAnnotations(ae, re, A, H, ie) : null);
                }
              }
              const X = Promise.all([oe, q]).then(([H]) => {
                const Y = new N.OperatorList(j, h);
                return m.send("StartRenderPage", {
                  transparency: re.hasBlendModes(this.resources, this.nonBlendModesSet),
                  pageIndex: this.pageIndex,
                  cacheKey: G
                }), re.getOperatorList({
                  stream: H,
                  task: A,
                  resources: this.resources,
                  operatorList: Y
                }).then(function() {
                  return Y;
                });
              });
              return Promise.all([X, this._parsedAnnotations, w]).then(function([H, Y, ie]) {
                if (ie) {
                  Y = Y.filter((ee) => !(ee.ref && Z.has(ee.ref)));
                  for (let ee = 0, se = ie.length; ee < se; ee++) {
                    const le = ie[ee];
                    if (le.refToReplace) {
                      const ue = Y.findIndex((de) => de.ref && (0, e.isRefsEqual)(de.ref, le.refToReplace));
                      ue >= 0 && (Y.splice(ue, 1, le), ie.splice(ee--, 1), se--);
                    }
                  }
                  Y = Y.concat(ie);
                }
                if (Y.length === 0 || j & n.RenderingIntentFlag.ANNOTATIONS_DISABLE)
                  return H.flush(!0), {
                    length: H.totalLength
                  };
                const ne = !!(j & n.RenderingIntentFlag.ANNOTATIONS_FORMS), U = !!(j & n.RenderingIntentFlag.ANY), ae = !!(j & n.RenderingIntentFlag.DISPLAY), Q = !!(j & n.RenderingIntentFlag.PRINT), L = [];
                for (const ee of Y)
                  (U || ae && ee.mustBeViewed(J, ne) || Q && ee.mustBePrinted(J)) && L.push(ee.getOperatorList(re, A, j, ne, J).catch(function(se) {
                    return (0, n.warn)(`getOperatorList - ignoring annotation data during "${A.name}" task: "${se}".`), {
                      opList: null,
                      separateForm: !1,
                      separateCanvas: !1
                    };
                  }));
                return Promise.all(L).then(function(ee) {
                  let se = !1, le = !1;
                  for (const {
                    opList: ue,
                    separateForm: de,
                    separateCanvas: ge
                  } of ee)
                    H.addOpList(ue), se || (se = de), le || (le = ge);
                  return H.flush(!0, {
                    form: se,
                    canvas: le
                  }), {
                    length: H.totalLength
                  };
                });
              });
            }
            extractTextContent({
              handler: m,
              task: h,
              includeMarkedContent: A,
              disableNormalization: j,
              sink: G
            }) {
              const J = this.getContentStream(), oe = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]);
              return Promise.all([J, oe]).then(([re]) => new p.PartialEvaluator({
                xref: this.xref,
                handler: m,
                pageIndex: this.pageIndex,
                idFactory: this._localIdFactory,
                fontCache: this.fontCache,
                builtInCMapCache: this.builtInCMapCache,
                standardFontDataCache: this.standardFontDataCache,
                globalImageCache: this.globalImageCache,
                systemFontCache: this.systemFontCache,
                options: this.evaluatorOptions
              }).getTextContent({
                stream: re,
                task: h,
                resources: this.resources,
                includeMarkedContent: A,
                disableNormalization: j,
                sink: G,
                viewBox: this.view
              }));
            }
            async getStructTree() {
              const m = await this.pdfManager.ensureCatalog("structTreeRoot");
              return m ? (await this._parsedAnnotations, (await this.pdfManager.ensure(this, "_parseStructTree", [m])).serializable) : null;
            }
            _parseStructTree(m) {
              const h = new M.StructTreePage(m, this.pageDict);
              return h.parse(this.ref), h;
            }
            async getAnnotationsData(m, h, A) {
              const j = await this._parsedAnnotations;
              if (j.length === 0)
                return j;
              const G = [], J = [];
              let oe;
              const q = !!(A & n.RenderingIntentFlag.ANY), re = !!(A & n.RenderingIntentFlag.DISPLAY), K = !!(A & n.RenderingIntentFlag.PRINT);
              for (const Z of j) {
                const w = q || re && Z.viewable;
                (w || K && Z.printable) && G.push(Z.data), Z.hasTextContent && w && (oe || (oe = new p.PartialEvaluator({
                  xref: this.xref,
                  handler: m,
                  pageIndex: this.pageIndex,
                  idFactory: this._localIdFactory,
                  fontCache: this.fontCache,
                  builtInCMapCache: this.builtInCMapCache,
                  standardFontDataCache: this.standardFontDataCache,
                  globalImageCache: this.globalImageCache,
                  systemFontCache: this.systemFontCache,
                  options: this.evaluatorOptions
                })), J.push(Z.extractTextContent(oe, h, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(k) {
                  (0, n.warn)(`getAnnotationsData - ignoring textContent during "${h.name}" task: "${k}".`);
                })));
              }
              return await Promise.all(J), G;
            }
            get annotations() {
              const m = this._getInheritableProperty("Annots");
              return (0, n.shadow)(this, "annotations", Array.isArray(m) ? m : []);
            }
            get _parsedAnnotations() {
              const m = this.pdfManager.ensure(this, "annotations").then(async (h) => {
                if (h.length === 0)
                  return h;
                const A = await this.pdfManager.ensureDoc("annotationGlobals");
                if (!A)
                  return [];
                const j = [];
                for (const oe of h)
                  j.push(P.AnnotationFactory.create(this.xref, oe, A, this._localIdFactory, !1, this.ref).catch(function(q) {
                    return (0, n.warn)(`_parsedAnnotations: "${q}".`), null;
                  }));
                const G = [];
                let J;
                for (const oe of await Promise.all(j))
                  if (oe) {
                    if (oe instanceof P.PopupAnnotation) {
                      (J || (J = [])).push(oe);
                      continue;
                    }
                    G.push(oe);
                  }
                return J && G.push(...J), G;
              });
              return (0, n.shadow)(this, "_parsedAnnotations", m);
            }
            get jsActions() {
              const m = (0, D.collectActions)(this.xref, this.pageDict, n.PageActionEventType);
              return (0, n.shadow)(this, "jsActions", m);
            }
          }
          y = new WeakSet(), _n = function(m, h, A) {
            for (const j of m)
              if (j.id) {
                const G = e.Ref.fromString(j.id);
                if (!G) {
                  (0, n.warn)(`A non-linked annotation cannot be modified: ${j.id}`);
                  continue;
                }
                if (j.deleted) {
                  h.put(G);
                  continue;
                }
                A == null || A.put(G), j.ref = G, delete j.id;
              }
          }, b.Page = o;
          const c = new Uint8Array([37, 80, 68, 70, 45]), I = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), s = new Uint8Array([101, 110, 100, 111, 98, 106]), r = 1024, u = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
          function C(v, m, h = 1024, A = !1) {
            const j = m.length, G = v.peekBytes(h), J = G.length - j;
            if (J <= 0)
              return !1;
            if (A) {
              const oe = j - 1;
              let q = G.length - 1;
              for (; q >= oe; ) {
                let re = 0;
                for (; re < j && G[q - re] === m[oe - re]; )
                  re++;
                if (re >= j)
                  return v.pos += q - oe, !0;
                q--;
              }
            } else {
              let oe = 0;
              for (; oe <= J; ) {
                let q = 0;
                for (; q < j && G[oe + q] === m[q]; )
                  q++;
                if (q >= j)
                  return v.pos += oe, !0;
                oe++;
              }
            }
            return !1;
          }
          class d {
            constructor(m, h) {
              At(this, $);
              if (h.length <= 0)
                throw new n.InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
              this.pdfManager = m, this.stream = h, this.xref = new W.XRef(h, m), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
              const A = {
                font: 0
              };
              this._globalIdFactory = class {
                static getDocId() {
                  return `g_${m.docId}`;
                }
                static createFontId() {
                  return `f${++A.font}`;
                }
                static createObjId() {
                  (0, n.unreachable)("Abstract method `createObjId` called.");
                }
                static getPageObjId() {
                  (0, n.unreachable)("Abstract method `getPageObjId` called.");
                }
              };
            }
            parse(m) {
              this.xref.parse(m), this.catalog = new te.Catalog(this.pdfManager, this.xref);
            }
            get linearization() {
              let m = null;
              try {
                m = f.Linearization.create(this.stream);
              } catch (h) {
                if (h instanceof D.MissingDataException)
                  throw h;
                (0, n.info)(h);
              }
              return (0, n.shadow)(this, "linearization", m);
            }
            get startXRef() {
              const m = this.stream;
              let h = 0;
              if (this.linearization)
                m.reset(), C(m, s) && (h = m.pos + 6 - m.start);
              else {
                const j = I.length;
                let G = !1, J = m.end;
                for (; !G && J > 0; )
                  J -= 1024 - j, J < 0 && (J = 0), m.pos = J, G = C(m, I, 1024, !0);
                if (G) {
                  m.skip(9);
                  let oe;
                  do
                    oe = m.getByte();
                  while ((0, D.isWhiteSpace)(oe));
                  let q = "";
                  for (; oe >= 32 && oe <= 57; )
                    q += String.fromCharCode(oe), oe = m.getByte();
                  h = parseInt(q, 10), isNaN(h) && (h = 0);
                }
              }
              return (0, n.shadow)(this, "startXRef", h);
            }
            checkHeader() {
              const m = this.stream;
              if (m.reset(), !C(m, c))
                return;
              m.moveStart(), m.skip(c.length);
              let h = "", A;
              for (; (A = m.getByte()) > 32 && h.length < 7; )
                h += String.fromCharCode(A);
              D.PDF_VERSION_REGEXP.test(h) ? this._version = h : (0, n.warn)(`Invalid PDF header version: ${h}`);
            }
            parseStartXRef() {
              this.xref.setStartXRef(this.startXRef);
            }
            get numPages() {
              let m = 0;
              return this.catalog.hasActualNumPages ? m = this.catalog.numPages : this.xfaFactory ? m = this.xfaFactory.getNumPages() : this.linearization ? m = this.linearization.numPages : m = this.catalog.numPages, (0, n.shadow)(this, "numPages", m);
            }
            _hasOnlyDocumentSignatures(m, h = 0) {
              return Array.isArray(m) ? m.every((j) => {
                if (j = this.xref.fetchIfRef(j), !(j instanceof e.Dict))
                  return !1;
                if (j.has("Kids"))
                  return ++h > 10 ? ((0, n.warn)("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(j.get("Kids"), h);
                const G = (0, e.isName)(j.get("FT"), "Sig"), J = j.get("Rect"), oe = Array.isArray(J) && J.every((q) => q === 0);
                return G && oe;
              }) : !1;
            }
            get _xfaStreams() {
              const m = this.catalog.acroForm;
              if (!m)
                return null;
              const h = m.get("XFA"), A = {
                "xdp:xdp": "",
                template: "",
                datasets: "",
                config: "",
                connectionSet: "",
                localeSet: "",
                stylesheet: "",
                "/xdp:xdp": ""
              };
              if (h instanceof l.BaseStream && !h.isEmpty)
                return A["xdp:xdp"] = h, A;
              if (!Array.isArray(h) || h.length === 0)
                return null;
              for (let j = 0, G = h.length; j < G; j += 2) {
                let J;
                if (j === 0 ? J = "xdp:xdp" : j === G - 2 ? J = "/xdp:xdp" : J = h[j], !A.hasOwnProperty(J))
                  continue;
                const oe = this.xref.fetchIfRef(h[j + 1]);
                !(oe instanceof l.BaseStream) || oe.isEmpty || (A[J] = oe);
              }
              return A;
            }
            get xfaDatasets() {
              const m = this._xfaStreams;
              if (!m)
                return (0, n.shadow)(this, "xfaDatasets", null);
              for (const h of ["datasets", "xdp:xdp"]) {
                const A = m[h];
                if (A)
                  try {
                    const j = (0, n.stringToUTF8String)(A.getString()), G = {
                      [h]: j
                    };
                    return (0, n.shadow)(this, "xfaDatasets", new F.DatasetReader(G));
                  } catch {
                    (0, n.warn)("XFA - Invalid utf-8 string.");
                    break;
                  }
              }
              return (0, n.shadow)(this, "xfaDatasets", null);
            }
            get xfaData() {
              const m = this._xfaStreams;
              if (!m)
                return null;
              const h = /* @__PURE__ */ Object.create(null);
              for (const [A, j] of Object.entries(m))
                if (j)
                  try {
                    h[A] = (0, n.stringToUTF8String)(j.getString());
                  } catch {
                    return (0, n.warn)("XFA - Invalid utf-8 string."), null;
                  }
              return h;
            }
            get xfaFactory() {
              let m;
              return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (m = this.xfaData), (0, n.shadow)(this, "xfaFactory", m ? new z.XFAFactory(m) : null);
            }
            get isPureXfa() {
              return this.xfaFactory ? this.xfaFactory.isValid() : !1;
            }
            get htmlForXfa() {
              return this.xfaFactory ? this.xfaFactory.getPages() : null;
            }
            async loadXfaImages() {
              const m = await this.pdfManager.ensureCatalog("xfaImages");
              if (!m)
                return;
              const h = m.getKeys();
              await new a.ObjectLoader(m, h, this.xref).load();
              const j = /* @__PURE__ */ new Map();
              for (const G of h) {
                const J = m.get(G);
                J instanceof l.BaseStream && j.set(G, J.getBytes());
              }
              this.xfaFactory.setImages(j);
            }
            async loadXfaFonts(m, h) {
              const A = await this.pdfManager.ensureCatalog("acroForm");
              if (!A)
                return;
              const j = await A.getAsync("DR");
              if (!(j instanceof e.Dict))
                return;
              await new a.ObjectLoader(j, ["Font"], this.xref).load();
              const J = j.get("Font");
              if (!(J instanceof e.Dict))
                return;
              const oe = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
              oe.useSystemFonts = !1;
              const q = new p.PartialEvaluator({
                xref: this.xref,
                handler: m,
                pageIndex: -1,
                idFactory: this._globalIdFactory,
                fontCache: this.catalog.fontCache,
                builtInCMapCache: this.catalog.builtInCMapCache,
                standardFontDataCache: this.catalog.standardFontDataCache,
                options: oe
              }), re = new N.OperatorList(), K = [], Z = {
                get font() {
                  return K.at(-1);
                },
                set font(Y) {
                  K.push(Y);
                },
                clone() {
                  return this;
                }
              }, w = /* @__PURE__ */ new Map();
              J.forEach((Y, ie) => {
                w.set(Y, ie);
              });
              const k = [];
              for (const [Y, ie] of w) {
                const ne = ie.get("FontDescriptor");
                if (!(ne instanceof e.Dict))
                  continue;
                let U = ne.get("FontFamily");
                U = U.replaceAll(/[ ]+(\d)/g, "$1");
                const ae = ne.get("FontWeight"), Q = -ne.get("ItalicAngle"), L = {
                  fontFamily: U,
                  fontWeight: ae,
                  italicAngle: Q
                };
                (0, D.validateCSSFont)(L) && k.push(q.handleSetFont(j, [e.Name.get(Y), 1], null, re, h, Z, null, L).catch(function(ee) {
                  return (0, n.warn)(`loadXfaFonts: "${ee}".`), null;
                }));
              }
              await Promise.all(k);
              const X = this.xfaFactory.setFonts(K);
              if (!X)
                return;
              oe.ignoreErrors = !0, k.length = 0, K.length = 0;
              const H = /* @__PURE__ */ new Set();
              for (const Y of X)
                (0, t.getXfaFontName)(`${Y}-Regular`) || H.add(Y);
              H.size && X.push("PdfJS-Fallback");
              for (const Y of X)
                if (!H.has(Y))
                  for (const ie of [{
                    name: "Regular",
                    fontWeight: 400,
                    italicAngle: 0
                  }, {
                    name: "Bold",
                    fontWeight: 700,
                    italicAngle: 0
                  }, {
                    name: "Italic",
                    fontWeight: 400,
                    italicAngle: 12
                  }, {
                    name: "BoldItalic",
                    fontWeight: 700,
                    italicAngle: 12
                  }]) {
                    const ne = `${Y}-${ie.name}`, U = (0, t.getXfaFontDict)(ne);
                    k.push(q.handleSetFont(j, [e.Name.get(ne), 1], null, re, h, Z, U, {
                      fontFamily: Y,
                      fontWeight: ie.fontWeight,
                      italicAngle: ie.italicAngle
                    }).catch(function(ae) {
                      return (0, n.warn)(`loadXfaFonts: "${ae}".`), null;
                    }));
                  }
              await Promise.all(k), this.xfaFactory.appendFonts(K, H);
            }
            async serializeXfaData(m) {
              return this.xfaFactory ? this.xfaFactory.serializeData(m) : null;
            }
            get version() {
              return this.catalog.version || this._version;
            }
            get formInfo() {
              const m = {
                hasFields: !1,
                hasAcroForm: !1,
                hasXfa: !1,
                hasSignatures: !1
              }, h = this.catalog.acroForm;
              if (!h)
                return (0, n.shadow)(this, "formInfo", m);
              try {
                const A = h.get("Fields"), j = Array.isArray(A) && A.length > 0;
                m.hasFields = j;
                const G = h.get("XFA");
                m.hasXfa = Array.isArray(G) && G.length > 0 || G instanceof l.BaseStream && !G.isEmpty;
                const oe = !!(h.get("SigFlags") & 1), q = oe && this._hasOnlyDocumentSignatures(A);
                m.hasAcroForm = j && !q, m.hasSignatures = oe;
              } catch (A) {
                if (A instanceof D.MissingDataException)
                  throw A;
                (0, n.warn)(`Cannot fetch form information: "${A}".`);
              }
              return (0, n.shadow)(this, "formInfo", m);
            }
            get documentInfo() {
              const m = {
                PDFFormatVersion: this.version,
                Language: this.catalog.lang,
                EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
                IsLinearized: !!this.linearization,
                IsAcroFormPresent: this.formInfo.hasAcroForm,
                IsXFAPresent: this.formInfo.hasXfa,
                IsCollectionPresent: !!this.catalog.collection,
                IsSignaturesPresent: this.formInfo.hasSignatures
              };
              let h;
              try {
                h = this.xref.trailer.get("Info");
              } catch (A) {
                if (A instanceof D.MissingDataException)
                  throw A;
                (0, n.info)("The document information dictionary is invalid.");
              }
              if (!(h instanceof e.Dict))
                return (0, n.shadow)(this, "documentInfo", m);
              for (const A of h.getKeys()) {
                const j = h.get(A);
                switch (A) {
                  case "Title":
                  case "Author":
                  case "Subject":
                  case "Keywords":
                  case "Creator":
                  case "Producer":
                  case "CreationDate":
                  case "ModDate":
                    if (typeof j == "string") {
                      m[A] = (0, n.stringToPDFString)(j);
                      continue;
                    }
                    break;
                  case "Trapped":
                    if (j instanceof e.Name) {
                      m[A] = j;
                      continue;
                    }
                    break;
                  default:
                    let G;
                    switch (typeof j) {
                      case "string":
                        G = (0, n.stringToPDFString)(j);
                        break;
                      case "number":
                      case "boolean":
                        G = j;
                        break;
                      default:
                        j instanceof e.Name && (G = j);
                        break;
                    }
                    if (G === void 0) {
                      (0, n.warn)(`Bad value, for custom key "${A}", in Info: ${j}.`);
                      continue;
                    }
                    m.Custom || (m.Custom = /* @__PURE__ */ Object.create(null)), m.Custom[A] = G;
                    continue;
                }
                (0, n.warn)(`Bad value, for key "${A}", in Info: ${j}.`);
              }
              return (0, n.shadow)(this, "documentInfo", m);
            }
            get fingerprints() {
              function m(J) {
                return typeof J == "string" && J.length > 0 && J !== u;
              }
              function h(J) {
                const oe = [];
                for (const q of J) {
                  const re = q.toString(16);
                  oe.push(re.padStart(2, "0"));
                }
                return oe.join("");
              }
              const A = this.xref.trailer.get("ID");
              let j, G;
              return Array.isArray(A) && m(A[0]) ? (j = (0, n.stringToBytes)(A[0]), A[1] !== A[0] && m(A[1]) && (G = (0, n.stringToBytes)(A[1]))) : j = (0, V.calculateMD5)(this.stream.getByteRange(0, r), 0, r), (0, n.shadow)(this, "fingerprints", [h(j), G ? h(G) : null]);
            }
            async _getLinearizationPage(m) {
              const {
                catalog: h,
                linearization: A,
                xref: j
              } = this, G = e.Ref.get(A.objectNumberFirst, 0);
              try {
                const J = await j.fetchAsync(G);
                if (J instanceof e.Dict) {
                  let oe = J.getRaw("Type");
                  if (oe instanceof e.Ref && (oe = await j.fetchAsync(oe)), (0, e.isName)(oe, "Page") || !J.has("Type") && !J.has("Kids"))
                    return h.pageKidsCountCache.has(G) || h.pageKidsCountCache.put(G, 1), h.pageIndexCache.has(G) || h.pageIndexCache.put(G, 0), [J, G];
                }
                throw new n.FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
              } catch (J) {
                return (0, n.warn)(`_getLinearizationPage: "${J.message}".`), h.getPageDict(m);
              }
            }
            getPage(m) {
              const h = this._pagePromises.get(m);
              if (h)
                return h;
              const {
                catalog: A,
                linearization: j,
                xfaFactory: G
              } = this;
              let J;
              return G ? J = Promise.resolve([e.Dict.empty, null]) : (j == null ? void 0 : j.pageFirst) === m ? J = this._getLinearizationPage(m) : J = A.getPageDict(m), J = J.then(([oe, q]) => new o({
                pdfManager: this.pdfManager,
                xref: this.xref,
                pageIndex: m,
                pageDict: oe,
                ref: q,
                globalIdFactory: this._globalIdFactory,
                fontCache: A.fontCache,
                builtInCMapCache: A.builtInCMapCache,
                standardFontDataCache: A.standardFontDataCache,
                globalImageCache: A.globalImageCache,
                systemFontCache: A.systemFontCache,
                nonBlendModesSet: A.nonBlendModesSet,
                xfaFactory: G
              })), this._pagePromises.set(m, J), J;
            }
            async checkFirstPage(m = !1) {
              if (!m)
                try {
                  await this.getPage(0);
                } catch (h) {
                  if (h instanceof D.XRefEntryException)
                    throw this._pagePromises.delete(0), await this.cleanup(), new D.XRefParseException();
                }
            }
            async checkLastPage(m = !1) {
              const {
                catalog: h,
                pdfManager: A
              } = this;
              h.setActualNumPages();
              let j;
              try {
                if (await Promise.all([A.ensureDoc("xfaFactory"), A.ensureDoc("linearization"), A.ensureCatalog("numPages")]), this.xfaFactory)
                  return;
                if (this.linearization ? j = this.linearization.numPages : j = h.numPages, Number.isInteger(j)) {
                  if (j <= 1)
                    return;
                } else
                  throw new n.FormatError("Page count is not an integer.");
                await this.getPage(j - 1);
              } catch (G) {
                if (this._pagePromises.delete(j - 1), await this.cleanup(), G instanceof D.XRefEntryException && !m)
                  throw new D.XRefParseException();
                (0, n.warn)(`checkLastPage - invalid /Pages tree /Count: ${j}.`);
                let J;
                try {
                  J = await h.getAllPageDicts(m);
                } catch (oe) {
                  if (oe instanceof D.XRefEntryException && !m)
                    throw new D.XRefParseException();
                  h.setActualNumPages(1);
                  return;
                }
                for (const [oe, [q, re]] of J) {
                  let K;
                  q instanceof Error ? (K = Promise.reject(q), K.catch(() => {
                  })) : K = Promise.resolve(new o({
                    pdfManager: A,
                    xref: this.xref,
                    pageIndex: oe,
                    pageDict: q,
                    ref: re,
                    globalIdFactory: this._globalIdFactory,
                    fontCache: h.fontCache,
                    builtInCMapCache: h.builtInCMapCache,
                    standardFontDataCache: h.standardFontDataCache,
                    globalImageCache: h.globalImageCache,
                    systemFontCache: h.systemFontCache,
                    nonBlendModesSet: h.nonBlendModesSet,
                    xfaFactory: null
                  })), this._pagePromises.set(oe, K);
                }
                h.setActualNumPages(J.size);
              }
            }
            fontFallback(m, h) {
              return this.catalog.fontFallback(m, h);
            }
            async cleanup(m = !1) {
              return this.catalog ? this.catalog.cleanup(m) : (0, E.clearGlobalCaches)();
            }
            get fieldObjects() {
              if (!this.formInfo.hasFields)
                return (0, n.shadow)(this, "fieldObjects", Promise.resolve(null));
              const m = this.pdfManager.ensureDoc("annotationGlobals").then(async (h) => {
                if (!h)
                  return null;
                const A = /* @__PURE__ */ Object.create(null), j = /* @__PURE__ */ new Map();
                for (const J of this.catalog.acroForm.get("Fields"))
                  it(this, $, Xn).call(this, "", J, j, h);
                const G = [];
                for (const [J, oe] of j)
                  G.push(Promise.all(oe).then((q) => {
                    q = q.filter((re) => !!re), q.length > 0 && (A[J] = q);
                  }));
                return await Promise.all(G), A;
              });
              return (0, n.shadow)(this, "fieldObjects", m);
            }
            get hasJSActions() {
              const m = this.pdfManager.ensureDoc("_parseHasJSActions");
              return (0, n.shadow)(this, "hasJSActions", m);
            }
            async _parseHasJSActions() {
              const [m, h] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
              return m ? !0 : h ? Object.values(h).some((A) => A.some((j) => j.actions !== null)) : !1;
            }
            get calculationOrderIds() {
              const m = this.catalog.acroForm;
              if (!(m != null && m.has("CO")))
                return (0, n.shadow)(this, "calculationOrderIds", null);
              const h = m.get("CO");
              if (!Array.isArray(h) || h.length === 0)
                return (0, n.shadow)(this, "calculationOrderIds", null);
              const A = [];
              for (const j of h)
                j instanceof e.Ref && A.push(j.toString());
              return A.length === 0 ? (0, n.shadow)(this, "calculationOrderIds", null) : (0, n.shadow)(this, "calculationOrderIds", A);
            }
            get annotationGlobals() {
              return (0, n.shadow)(this, "annotationGlobals", P.AnnotationFactory.createGlobals(this.pdfManager));
            }
          }
          $ = new WeakSet(), Xn = function(m, h, A, j) {
            const G = this.xref.fetchIfRef(h);
            if (G.has("T")) {
              const J = (0, n.stringToPDFString)(G.get("T"));
              m = m === "" ? J : `${m}.${J}`;
            }
            if (A.has(m) || A.set(m, []), A.get(m).push(P.AnnotationFactory.create(this.xref, h, j, this._localIdFactory, !0, null).then((J) => J == null ? void 0 : J.getFieldObject()).catch(function(J) {
              return (0, n.warn)(`#collectFieldObjects: "${J}".`), null;
            })), G.has("Kids"))
              for (const J of G.get("Kids"))
                it(this, $, Xn).call(this, m, J, A, j);
          }, b.PDFDocument = d;
        },
        /* 10 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PopupAnnotation = b.MarkupAnnotation = b.AnnotationFactory = b.AnnotationBorderStyle = b.Annotation = void 0, b.getQuadPoints = z;
          var n = ce(2), P = ce(3), D = ce(11), e = ce(4), t = ce(8), l = ce(5), V = ce(60), te = ce(66), E = ce(12), F = ce(69), f = ce(26), x = ce(76), a = ce(64), N = ce(73), p = ce(77);
          class O {
            static createGlobals(w) {
              return Promise.all([w.ensureCatalog("acroForm"), w.ensureDoc("xfaDatasets"), w.ensureCatalog("structTreeRoot"), w.ensureCatalog("baseUrl"), w.ensureCatalog("attachments")]).then(([k, X, H, Y, ie]) => ({
                pdfManager: w,
                acroForm: k instanceof e.Dict ? k : e.Dict.empty,
                xfaDatasets: X,
                structTreeRoot: H,
                baseUrl: Y,
                attachments: ie
              }), (k) => ((0, n.warn)(`createGlobals: "${k}".`), null));
            }
            static async create(w, k, X, H, Y, ie) {
              const ne = Y ? await this._getPageIndex(w, k, X.pdfManager) : null;
              return X.pdfManager.ensure(this, "_create", [w, k, X, H, Y, ne, ie]);
            }
            static _create(w, k, X, H, Y = !1, ie = null, ne = null) {
              const U = w.fetchIfRef(k);
              if (!(U instanceof e.Dict))
                return;
              const {
                acroForm: ae,
                pdfManager: Q
              } = X, L = k instanceof e.Ref ? k.toString() : `annot_${H.createObjId()}`;
              let ee = U.get("Subtype");
              ee = ee instanceof e.Name ? ee.name : null;
              const se = {
                xref: w,
                ref: k,
                dict: U,
                subtype: ee,
                id: L,
                annotationGlobals: X,
                collectFields: Y,
                needAppearances: !Y && ae.get("NeedAppearances") === !0,
                pageIndex: ie,
                evaluatorOptions: Q.evaluatorOptions,
                pageRef: ne
              };
              switch (ee) {
                case "Link":
                  return new d(se);
                case "Text":
                  return new C(se);
                case "Widget":
                  let le = (0, P.getInheritableProperty)({
                    dict: U,
                    key: "FT"
                  });
                  switch (le = le instanceof e.Name ? le.name : null, le) {
                    case "Tx":
                      return new I(se);
                    case "Btn":
                      return new s(se);
                    case "Ch":
                      return new r(se);
                    case "Sig":
                      return new u(se);
                  }
                  return (0, n.warn)(`Unimplemented widget field type "${le}", falling back to base field type.`), new c(se);
                case "Popup":
                  return new y(se);
                case "FreeText":
                  return new _(se);
                case "Line":
                  return new $(se);
                case "Square":
                  return new S(se);
                case "Circle":
                  return new v(se);
                case "PolyLine":
                  return new m(se);
                case "Polygon":
                  return new h(se);
                case "Caret":
                  return new A(se);
                case "Ink":
                  return new j(se);
                case "Highlight":
                  return new G(se);
                case "Underline":
                  return new J(se);
                case "Squiggly":
                  return new oe(se);
                case "StrikeOut":
                  return new q(se);
                case "Stamp":
                  return new re(se);
                case "FileAttachment":
                  return new K(se);
                default:
                  return Y || (ee ? (0, n.warn)(`Unimplemented annotation type "${ee}", falling back to base annotation.`) : (0, n.warn)("Annotation is missing the required /Subtype.")), new g(se);
              }
            }
            static async _getPageIndex(w, k, X) {
              try {
                const H = await w.fetchIfRefAsync(k);
                if (!(H instanceof e.Dict))
                  return -1;
                const Y = H.getRaw("P");
                if (Y instanceof e.Ref)
                  try {
                    return await X.ensureCatalog("getPageIndex", [Y]);
                  } catch (ne) {
                    (0, n.info)(`_getPageIndex -- not a valid page reference: "${ne}".`);
                  }
                if (H.has("Kids"))
                  return -1;
                const ie = await X.ensureDoc("numPages");
                for (let ne = 0; ne < ie; ne++) {
                  const U = await X.getPage(ne), ae = await X.ensure(U, "annotations");
                  for (const Q of ae)
                    if (Q instanceof e.Ref && (0, e.isRefsEqual)(Q, k))
                      return ne;
                }
              } catch (H) {
                (0, n.warn)(`_getPageIndex: "${H}".`);
              }
              return -1;
            }
            static generateImages(w, k, X) {
              if (!X)
                return (0, n.warn)("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
              let H;
              for (const {
                bitmapId: Y,
                bitmap: ie
              } of w)
                ie && (H || (H = /* @__PURE__ */ new Map()), H.set(Y, re.createImage(ie, k)));
              return H;
            }
            static async saveNewAnnotations(w, k, X, H) {
              const Y = w.xref;
              let ie;
              const ne = [], U = [], {
                isOffscreenCanvasSupported: ae
              } = w.options;
              for (const Q of X)
                if (!Q.deleted)
                  switch (Q.annotationType) {
                    case n.AnnotationEditorType.FREETEXT:
                      if (!ie) {
                        const ee = new e.Dict(Y);
                        ee.set("BaseFont", e.Name.get("Helvetica")), ee.set("Type", e.Name.get("Font")), ee.set("Subtype", e.Name.get("Type1")), ee.set("Encoding", e.Name.get("WinAnsiEncoding"));
                        const se = [];
                        ie = Y.getNewTemporaryRef(), await (0, N.writeObject)(ie, ee, se, Y), ne.push({
                          ref: ie,
                          data: se.join("")
                        });
                      }
                      U.push(_.createNewAnnotation(Y, Q, ne, {
                        evaluator: w,
                        task: k,
                        baseFontRef: ie
                      }));
                      break;
                    case n.AnnotationEditorType.INK:
                      U.push(j.createNewAnnotation(Y, Q, ne));
                      break;
                    case n.AnnotationEditorType.STAMP:
                      if (!ae)
                        break;
                      const L = await H.get(Q.bitmapId);
                      if (L.imageStream) {
                        const {
                          imageStream: ee,
                          smaskStream: se
                        } = L, le = [];
                        if (se) {
                          const de = Y.getNewTemporaryRef();
                          await (0, N.writeObject)(de, se, le, Y), ne.push({
                            ref: de,
                            data: le.join("")
                          }), ee.dict.set("SMask", de), le.length = 0;
                        }
                        const ue = L.imageRef = Y.getNewTemporaryRef();
                        await (0, N.writeObject)(ue, ee, le, Y), ne.push({
                          ref: ue,
                          data: le.join("")
                        }), L.imageStream = L.smaskStream = null;
                      }
                      U.push(re.createNewAnnotation(Y, Q, ne, {
                        image: L
                      }));
                      break;
                  }
              return {
                annotations: await Promise.all(U),
                dependencies: ne
              };
            }
            static async printNewAnnotations(w, k, X, H, Y) {
              if (!H)
                return null;
              const {
                options: ie,
                xref: ne
              } = k, U = [];
              for (const ae of H)
                if (!ae.deleted)
                  switch (ae.annotationType) {
                    case n.AnnotationEditorType.FREETEXT:
                      U.push(_.createNewPrintAnnotation(w, ne, ae, {
                        evaluator: k,
                        task: X,
                        evaluatorOptions: ie
                      }));
                      break;
                    case n.AnnotationEditorType.INK:
                      U.push(j.createNewPrintAnnotation(w, ne, ae, {
                        evaluatorOptions: ie
                      }));
                      break;
                    case n.AnnotationEditorType.STAMP:
                      if (!ie.isOffscreenCanvasSupported)
                        break;
                      const Q = await Y.get(ae.bitmapId);
                      if (Q.imageStream) {
                        const {
                          imageStream: L,
                          smaskStream: ee
                        } = Q;
                        ee && L.dict.set("SMask", ee), Q.imageRef = new f.JpegStream(L, L.length), Q.imageStream = Q.smaskStream = null;
                      }
                      U.push(re.createNewPrintAnnotation(w, ne, ae, {
                        image: Q,
                        evaluatorOptions: ie
                      }));
                      break;
                  }
              return Promise.all(U);
            }
          }
          b.AnnotationFactory = O;
          function M(Z, w = new Uint8ClampedArray(3)) {
            if (!Array.isArray(Z))
              return w;
            const k = w || new Uint8ClampedArray(3);
            switch (Z.length) {
              case 0:
                return null;
              case 1:
                return E.ColorSpace.singletons.gray.getRgbItem(Z, 0, k, 0), k;
              case 3:
                return E.ColorSpace.singletons.rgb.getRgbItem(Z, 0, k, 0), k;
              case 4:
                return E.ColorSpace.singletons.cmyk.getRgbItem(Z, 0, k, 0), k;
              default:
                return w;
            }
          }
          function R(Z) {
            return Array.from(Z, (w) => w / 255);
          }
          function z(Z, w) {
            const k = Z.getArray("QuadPoints");
            if (!Array.isArray(k) || k.length === 0 || k.length % 8 > 0)
              return null;
            const X = [];
            for (let H = 0, Y = k.length / 8; H < Y; H++) {
              let ie = 1 / 0, ne = -1 / 0, U = 1 / 0, ae = -1 / 0;
              for (let Q = H * 8, L = H * 8 + 8; Q < L; Q += 2) {
                const ee = k[Q], se = k[Q + 1];
                ie = Math.min(ee, ie), ne = Math.max(ee, ne), U = Math.min(se, U), ae = Math.max(se, ae);
              }
              if (w !== null && (ie < w[0] || ne > w[2] || U < w[1] || ae > w[3]))
                return null;
              X.push([{
                x: ie,
                y: ae
              }, {
                x: ne,
                y: ae
              }, {
                x: ie,
                y: U
              }, {
                x: ne,
                y: U
              }]);
            }
            return X;
          }
          function W(Z, w, k) {
            const [X, H, Y, ie] = n.Util.getAxialAlignedBoundingBox(w, k);
            if (X === Y || H === ie)
              return [1, 0, 0, 1, Z[0], Z[1]];
            const ne = (Z[2] - Z[0]) / (Y - X), U = (Z[3] - Z[1]) / (ie - H);
            return [ne, 0, 0, U, Z[0] - X * ne, Z[1] - H * U];
          }
          class g {
            constructor(w) {
              const {
                dict: k,
                xref: X,
                annotationGlobals: H
              } = w;
              this.setTitle(k.get("T")), this.setContents(k.get("Contents")), this.setModificationDate(k.get("M")), this.setFlags(k.get("F")), this.setRectangle(k.getArray("Rect")), this.setColor(k.getArray("C")), this.setBorderStyle(k), this.setAppearance(k), this.setOptionalContent(k);
              const Y = k.get("MK");
              this.setBorderAndBackgroundColors(Y), this.setRotation(Y, k), this.ref = w.ref instanceof e.Ref ? w.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
              const ie = !!(this.flags & n.AnnotationFlag.LOCKED), ne = !!(this.flags & n.AnnotationFlag.LOCKEDCONTENTS);
              if (H.structTreeRoot) {
                let U = k.get("StructParent");
                U = Number.isInteger(U) && U >= 0 ? U : -1, H.structTreeRoot.addAnnotationIdToPage(w.pageRef, U);
              }
              if (this.data = {
                annotationFlags: this.flags,
                borderStyle: this.borderStyle,
                color: this.color,
                backgroundColor: this.backgroundColor,
                borderColor: this.borderColor,
                rotation: this.rotation,
                contentsObj: this._contents,
                hasAppearance: !!this.appearance,
                id: w.id,
                modificationDate: this.modificationDate,
                rect: this.rectangle,
                subtype: w.subtype,
                hasOwnCanvas: !1,
                noRotate: !!(this.flags & n.AnnotationFlag.NOROTATE),
                noHTML: ie && ne
              }, w.collectFields) {
                const U = k.get("Kids");
                if (Array.isArray(U)) {
                  const ae = [];
                  for (const Q of U)
                    Q instanceof e.Ref && ae.push(Q.toString());
                  ae.length !== 0 && (this.data.kidIds = ae);
                }
                this.data.actions = (0, P.collectActions)(X, k, n.AnnotationActionEventType), this.data.fieldName = this._constructFieldName(k), this.data.pageIndex = w.pageIndex;
              }
              this._isOffscreenCanvasSupported = w.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
            }
            _hasFlag(w, k) {
              return !!(w & k);
            }
            _isViewable(w) {
              return !this._hasFlag(w, n.AnnotationFlag.INVISIBLE) && !this._hasFlag(w, n.AnnotationFlag.NOVIEW);
            }
            _isPrintable(w) {
              return this._hasFlag(w, n.AnnotationFlag.PRINT) && !this._hasFlag(w, n.AnnotationFlag.HIDDEN) && !this._hasFlag(w, n.AnnotationFlag.INVISIBLE);
            }
            mustBeViewed(w, k) {
              var H;
              const X = (H = w == null ? void 0 : w.get(this.data.id)) == null ? void 0 : H.noView;
              return X !== void 0 ? !X : this.viewable && !this._hasFlag(this.flags, n.AnnotationFlag.HIDDEN);
            }
            mustBePrinted(w) {
              var X;
              const k = (X = w == null ? void 0 : w.get(this.data.id)) == null ? void 0 : X.noPrint;
              return k !== void 0 ? !k : this.printable;
            }
            get viewable() {
              return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
            }
            get printable() {
              return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
            }
            _parseStringHelper(w) {
              const k = typeof w == "string" ? (0, n.stringToPDFString)(w) : "", X = k && (0, V.bidi)(k).dir === "rtl" ? "rtl" : "ltr";
              return {
                str: k,
                dir: X
              };
            }
            setDefaultAppearance(w) {
              const {
                dict: k,
                annotationGlobals: X
              } = w, H = (0, P.getInheritableProperty)({
                dict: k,
                key: "DA"
              }) || X.acroForm.get("DA");
              this._defaultAppearance = typeof H == "string" ? H : "", this.data.defaultAppearanceData = (0, D.parseDefaultAppearance)(this._defaultAppearance);
            }
            setTitle(w) {
              this._title = this._parseStringHelper(w);
            }
            setContents(w) {
              this._contents = this._parseStringHelper(w);
            }
            setModificationDate(w) {
              this.modificationDate = typeof w == "string" ? w : null;
            }
            setFlags(w) {
              this.flags = Number.isInteger(w) && w > 0 ? w : 0;
            }
            hasFlag(w) {
              return this._hasFlag(this.flags, w);
            }
            setRectangle(w) {
              this.rectangle = Array.isArray(w) && w.length === 4 ? n.Util.normalizeRect(w) : [0, 0, 0, 0];
            }
            setColor(w) {
              this.color = M(w);
            }
            setLineEndings(w) {
              if (this.lineEndings = ["None", "None"], Array.isArray(w) && w.length === 2)
                for (let k = 0; k < 2; k++) {
                  const X = w[k];
                  if (X instanceof e.Name)
                    switch (X.name) {
                      case "None":
                        continue;
                      case "Square":
                      case "Circle":
                      case "Diamond":
                      case "OpenArrow":
                      case "ClosedArrow":
                      case "Butt":
                      case "ROpenArrow":
                      case "RClosedArrow":
                      case "Slash":
                        this.lineEndings[k] = X.name;
                        continue;
                    }
                  (0, n.warn)(`Ignoring invalid lineEnding: ${X}`);
                }
            }
            setRotation(w, k) {
              this.rotation = 0;
              let X = w instanceof e.Dict ? w.get("R") || 0 : k.get("Rotate") || 0;
              Number.isInteger(X) && X !== 0 && (X %= 360, X < 0 && (X += 360), X % 90 === 0 && (this.rotation = X));
            }
            setBorderAndBackgroundColors(w) {
              w instanceof e.Dict ? (this.borderColor = M(w.getArray("BC"), null), this.backgroundColor = M(w.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
            }
            setBorderStyle(w) {
              if (this.borderStyle = new T(), w instanceof e.Dict)
                if (w.has("BS")) {
                  const k = w.get("BS"), X = k.get("Type");
                  (!X || (0, e.isName)(X, "Border")) && (this.borderStyle.setWidth(k.get("W"), this.rectangle), this.borderStyle.setStyle(k.get("S")), this.borderStyle.setDashArray(k.getArray("D")));
                } else if (w.has("Border")) {
                  const k = w.getArray("Border");
                  Array.isArray(k) && k.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(k[0]), this.borderStyle.setVerticalCornerRadius(k[1]), this.borderStyle.setWidth(k[2], this.rectangle), k.length === 4 && this.borderStyle.setDashArray(k[3], !0));
                } else
                  this.borderStyle.setWidth(0);
            }
            setAppearance(w) {
              this.appearance = null;
              const k = w.get("AP");
              if (!(k instanceof e.Dict))
                return;
              const X = k.get("N");
              if (X instanceof l.BaseStream) {
                this.appearance = X;
                return;
              }
              if (!(X instanceof e.Dict))
                return;
              const H = w.get("AS");
              if (!(H instanceof e.Name) || !X.has(H.name))
                return;
              const Y = X.get(H.name);
              Y instanceof l.BaseStream && (this.appearance = Y);
            }
            setOptionalContent(w) {
              this.oc = null;
              const k = w.get("OC");
              k instanceof e.Name ? (0, n.warn)("setOptionalContent: Support for /Name-entry is not implemented.") : k instanceof e.Dict && (this.oc = k);
            }
            loadResources(w, k) {
              return k.dict.getAsync("Resources").then((X) => X ? new x.ObjectLoader(X, w, X.xref).load().then(function() {
                return X;
              }) : void 0);
            }
            async getOperatorList(w, k, X, H, Y) {
              const ie = this.data;
              let ne = this.appearance;
              const U = !!(this.data.hasOwnCanvas && X & n.RenderingIntentFlag.DISPLAY);
              if (!ne) {
                if (!U)
                  return {
                    opList: new a.OperatorList(),
                    separateForm: !1,
                    separateCanvas: !1
                  };
                ne = new t.StringStream(""), ne.dict = new e.Dict();
              }
              const ae = ne.dict, Q = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], ne), L = ae.getArray("BBox") || [0, 0, 1, 1], ee = ae.getArray("Matrix") || [1, 0, 0, 1, 0, 0], se = W(ie.rect, L, ee), le = new a.OperatorList();
              let ue;
              return this.oc && (ue = await w.parseMarkedContentProps(this.oc, null)), ue !== void 0 && le.addOp(n.OPS.beginMarkedContentProps, ["OC", ue]), le.addOp(n.OPS.beginAnnotation, [ie.id, ie.rect, se, ee, U]), await w.getOperatorList({
                stream: ne,
                task: k,
                resources: Q,
                operatorList: le,
                fallbackFontDict: this._fallbackFontDict
              }), le.addOp(n.OPS.endAnnotation, []), ue !== void 0 && le.addOp(n.OPS.endMarkedContent, []), this.reset(), {
                opList: le,
                separateForm: !1,
                separateCanvas: U
              };
            }
            async save(w, k, X) {
              return null;
            }
            get hasTextContent() {
              return !1;
            }
            async extractTextContent(w, k, X) {
              if (!this.appearance)
                return;
              const H = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), Y = [], ie = [];
              let ne = null;
              const U = {
                desiredSize: Math.Infinity,
                ready: !0,
                enqueue(ae, Q) {
                  for (const L of ae.items)
                    L.str !== void 0 && (ne || (ne = L.transform.slice(-2)), ie.push(L.str), L.hasEOL && (Y.push(ie.join("")), ie.length = 0));
                }
              };
              if (await w.getTextContent({
                stream: this.appearance,
                task: k,
                resources: H,
                includeMarkedContent: !0,
                sink: U,
                viewBox: X
              }), this.reset(), ie.length && Y.push(ie.join("")), Y.length > 1 || Y[0]) {
                const ae = this.appearance.dict, Q = ae.getArray("BBox") || [0, 0, 1, 1], L = ae.getArray("Matrix") || [1, 0, 0, 1, 0, 0], ee = this.data.rect, se = W(ee, Q, L);
                se[4] -= ee[0], se[5] -= ee[1], ne = n.Util.applyTransform(ne, se), ne = n.Util.applyTransform(ne, L), this.data.textPosition = ne, this.data.textContent = Y;
              }
            }
            getFieldObject() {
              return this.data.kidIds ? {
                id: this.data.id,
                actions: this.data.actions,
                name: this.data.fieldName,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                type: "",
                kidIds: this.data.kidIds,
                page: this.data.pageIndex,
                rotation: this.rotation
              } : null;
            }
            reset() {
              for (const w of this._streams)
                w.reset();
            }
            _constructFieldName(w) {
              if (!w.has("T") && !w.has("Parent"))
                return (0, n.warn)("Unknown field name, falling back to empty field name."), "";
              if (!w.has("Parent"))
                return (0, n.stringToPDFString)(w.get("T"));
              const k = [];
              w.has("T") && k.unshift((0, n.stringToPDFString)(w.get("T")));
              let X = w;
              const H = new e.RefSet();
              for (w.objId && H.put(w.objId); X.has("Parent") && (X = X.get("Parent"), !(!(X instanceof e.Dict) || X.objId && H.has(X.objId))); )
                X.objId && H.put(X.objId), X.has("T") && k.unshift((0, n.stringToPDFString)(X.get("T")));
              return k.join(".");
            }
          }
          b.Annotation = g;
          class T {
            constructor() {
              this.width = 1, this.style = n.AnnotationBorderStyleType.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
            }
            setWidth(w, k = [0, 0, 0, 0]) {
              if (w instanceof e.Name) {
                this.width = 0;
                return;
              }
              if (typeof w == "number") {
                if (w > 0) {
                  const X = (k[2] - k[0]) / 2, H = (k[3] - k[1]) / 2;
                  X > 0 && H > 0 && (w > X || w > H) && ((0, n.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${w}`), w = 1);
                }
                this.width = w;
              }
            }
            setStyle(w) {
              if (w instanceof e.Name)
                switch (w.name) {
                  case "S":
                    this.style = n.AnnotationBorderStyleType.SOLID;
                    break;
                  case "D":
                    this.style = n.AnnotationBorderStyleType.DASHED;
                    break;
                  case "B":
                    this.style = n.AnnotationBorderStyleType.BEVELED;
                    break;
                  case "I":
                    this.style = n.AnnotationBorderStyleType.INSET;
                    break;
                  case "U":
                    this.style = n.AnnotationBorderStyleType.UNDERLINE;
                    break;
                }
            }
            setDashArray(w, k = !1) {
              if (Array.isArray(w) && w.length > 0) {
                let X = !0, H = !0;
                for (const Y of w)
                  if (+Y >= 0)
                    Y > 0 && (H = !1);
                  else {
                    X = !1;
                    break;
                  }
                X && !H ? (this.dashArray = w, k && this.setStyle(e.Name.get("D"))) : this.width = 0;
              } else
                w && (this.width = 0);
            }
            setHorizontalCornerRadius(w) {
              Number.isInteger(w) && (this.horizontalCornerRadius = w);
            }
            setVerticalCornerRadius(w) {
              Number.isInteger(w) && (this.verticalCornerRadius = w);
            }
          }
          b.AnnotationBorderStyle = T;
          class o extends g {
            constructor(w) {
              super(w);
              const {
                dict: k
              } = w;
              if (k.has("IRT")) {
                const H = k.getRaw("IRT");
                this.data.inReplyTo = H instanceof e.Ref ? H.toString() : null;
                const Y = k.get("RT");
                this.data.replyType = Y instanceof e.Name ? Y.name : n.AnnotationReplyType.REPLY;
              }
              let X = null;
              if (this.data.replyType === n.AnnotationReplyType.GROUP) {
                const H = k.get("IRT");
                this.setTitle(H.get("T")), this.data.titleObj = this._title, this.setContents(H.get("Contents")), this.data.contentsObj = this._contents, H.has("CreationDate") ? (this.setCreationDate(H.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, H.has("M") ? (this.setModificationDate(H.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, X = H.getRaw("Popup"), H.has("C") ? (this.setColor(H.getArray("C")), this.data.color = this.color) : this.data.color = null;
              } else
                this.data.titleObj = this._title, this.setCreationDate(k.get("CreationDate")), this.data.creationDate = this.creationDate, X = k.getRaw("Popup"), k.has("C") || (this.data.color = null);
              this.data.popupRef = X instanceof e.Ref ? X.toString() : null, k.has("RC") && (this.data.richText = p.XFAFactory.getRichTextAsHtml(k.get("RC")));
            }
            setCreationDate(w) {
              this.creationDate = typeof w == "string" ? w : null;
            }
            _setDefaultAppearance({
              xref: w,
              extra: k,
              strokeColor: X,
              fillColor: H,
              blendMode: Y,
              strokeAlpha: ie,
              fillAlpha: ne,
              pointsCallback: U
            }) {
              let ae = Number.MAX_VALUE, Q = Number.MAX_VALUE, L = Number.MIN_VALUE, ee = Number.MIN_VALUE;
              const se = ["q"];
              k && se.push(k), X && se.push(`${X[0]} ${X[1]} ${X[2]} RG`), H && se.push(`${H[0]} ${H[1]} ${H[2]} rg`);
              let le = this.data.quadPoints;
              le || (le = [[{
                x: this.rectangle[0],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[3]
              }, {
                x: this.rectangle[0],
                y: this.rectangle[1]
              }, {
                x: this.rectangle[2],
                y: this.rectangle[1]
              }]]);
              for (const be of le) {
                const [he, fe, Ce, ye] = U(se, be);
                ae = Math.min(ae, he), L = Math.max(L, fe), Q = Math.min(Q, Ce), ee = Math.max(ee, ye);
              }
              se.push("Q");
              const ue = new e.Dict(w), de = new e.Dict(w);
              de.set("Subtype", e.Name.get("Form"));
              const ge = new t.StringStream(se.join(" "));
              ge.dict = de, ue.set("Fm0", ge);
              const me = new e.Dict(w);
              Y && me.set("BM", e.Name.get(Y)), typeof ie == "number" && me.set("CA", ie), typeof ne == "number" && me.set("ca", ne);
              const pe = new e.Dict(w);
              pe.set("GS0", me);
              const xe = new e.Dict(w);
              xe.set("ExtGState", pe), xe.set("XObject", ue);
              const we = new e.Dict(w);
              we.set("Resources", xe);
              const Ae = this.data.rect = [ae, Q, L, ee];
              we.set("BBox", Ae), this.appearance = new t.StringStream("/GS0 gs /Fm0 Do"), this.appearance.dict = we, this._streams.push(this.appearance, ge);
            }
            static async createNewAnnotation(w, k, X, H) {
              const Y = k.ref || (k.ref = w.getNewTemporaryRef()), ie = await this.createNewAppearanceStream(k, w, H), ne = [];
              let U;
              if (ie) {
                const ae = w.getNewTemporaryRef();
                U = this.createNewDict(k, w, {
                  apRef: ae
                }), await (0, N.writeObject)(ae, ie, ne, w), X.push({
                  ref: ae,
                  data: ne.join("")
                });
              } else
                U = this.createNewDict(k, w, {});
              return Number.isInteger(k.parentTreeId) && U.set("StructParent", k.parentTreeId), ne.length = 0, await (0, N.writeObject)(Y, U, ne, w), {
                ref: Y,
                data: ne.join("")
              };
            }
            static async createNewPrintAnnotation(w, k, X, H) {
              const Y = await this.createNewAppearanceStream(X, k, H), ie = this.createNewDict(X, k, {
                ap: Y
              }), ne = new this.prototype.constructor({
                dict: ie,
                xref: k,
                annotationGlobals: w,
                evaluatorOptions: H.evaluatorOptions
              });
              return X.ref && (ne.ref = ne.refToReplace = X.ref), ne;
            }
          }
          b.MarkupAnnotation = o;
          class c extends g {
            constructor(w) {
              var ee;
              super(w);
              const {
                dict: k,
                xref: X,
                annotationGlobals: H
              } = w, Y = this.data;
              this._needAppearances = w.needAppearances, Y.annotationType = n.AnnotationType.WIDGET, Y.fieldName === void 0 && (Y.fieldName = this._constructFieldName(k)), Y.actions === void 0 && (Y.actions = (0, P.collectActions)(X, k, n.AnnotationActionEventType));
              let ie = (0, P.getInheritableProperty)({
                dict: k,
                key: "V",
                getArray: !0
              });
              Y.fieldValue = this._decodeFormValue(ie);
              const ne = (0, P.getInheritableProperty)({
                dict: k,
                key: "DV",
                getArray: !0
              });
              if (Y.defaultFieldValue = this._decodeFormValue(ne), ie === void 0 && H.xfaDatasets) {
                const se = this._title.str;
                se && (this._hasValueFromXFA = !0, Y.fieldValue = ie = H.xfaDatasets.getValue(se));
              }
              ie === void 0 && Y.defaultFieldValue !== null && (Y.fieldValue = Y.defaultFieldValue), Y.alternativeText = (0, n.stringToPDFString)(k.get("TU") || ""), this.setDefaultAppearance(w), Y.hasAppearance || (Y.hasAppearance = this._needAppearances && Y.fieldValue !== void 0 && Y.fieldValue !== null);
              const U = (0, P.getInheritableProperty)({
                dict: k,
                key: "FT"
              });
              Y.fieldType = U instanceof e.Name ? U.name : null;
              const ae = (0, P.getInheritableProperty)({
                dict: k,
                key: "DR"
              }), Q = H.acroForm.get("DR"), L = (ee = this.appearance) == null ? void 0 : ee.dict.get("Resources");
              this._fieldResources = {
                localResources: ae,
                acroFormResources: Q,
                appearanceResources: L,
                mergedResources: e.Dict.merge({
                  xref: X,
                  dictArray: [ae, L, Q],
                  mergeSubDicts: !0
                })
              }, Y.fieldFlags = (0, P.getInheritableProperty)({
                dict: k,
                key: "Ff"
              }), (!Number.isInteger(Y.fieldFlags) || Y.fieldFlags < 0) && (Y.fieldFlags = 0), Y.readOnly = this.hasFieldFlag(n.AnnotationFieldFlag.READONLY), Y.required = this.hasFieldFlag(n.AnnotationFieldFlag.REQUIRED), Y.hidden = this._hasFlag(Y.annotationFlags, n.AnnotationFlag.HIDDEN) || this._hasFlag(Y.annotationFlags, n.AnnotationFlag.NOVIEW);
            }
            _decodeFormValue(w) {
              return Array.isArray(w) ? w.filter((k) => typeof k == "string").map((k) => (0, n.stringToPDFString)(k)) : w instanceof e.Name ? (0, n.stringToPDFString)(w.name) : typeof w == "string" ? (0, n.stringToPDFString)(w) : null;
            }
            hasFieldFlag(w) {
              return !!(this.data.fieldFlags & w);
            }
            _isViewable(w) {
              return !this._hasFlag(w, n.AnnotationFlag.INVISIBLE);
            }
            mustBeViewed(w, k) {
              return k ? this.viewable : super.mustBeViewed(w, k) && !this._hasFlag(this.flags, n.AnnotationFlag.NOVIEW);
            }
            getRotationMatrix(w) {
              var Y;
              let k = (Y = w == null ? void 0 : w.get(this.data.id)) == null ? void 0 : Y.rotation;
              if (k === void 0 && (k = this.rotation), k === 0)
                return n.IDENTITY_MATRIX;
              const X = this.data.rect[2] - this.data.rect[0], H = this.data.rect[3] - this.data.rect[1];
              return (0, P.getRotationMatrix)(k, X, H);
            }
            getBorderAndBackgroundAppearances(w) {
              var ne;
              let k = (ne = w == null ? void 0 : w.get(this.data.id)) == null ? void 0 : ne.rotation;
              if (k === void 0 && (k = this.rotation), !this.backgroundColor && !this.borderColor)
                return "";
              const X = this.data.rect[2] - this.data.rect[0], H = this.data.rect[3] - this.data.rect[1], Y = k === 0 || k === 180 ? `0 0 ${X} ${H} re` : `0 0 ${H} ${X} re`;
              let ie = "";
              if (this.backgroundColor && (ie = `${(0, D.getPdfColor)(this.backgroundColor, !0)} ${Y} f `), this.borderColor) {
                const U = this.borderStyle.width || 1;
                ie += `${U} w ${(0, D.getPdfColor)(this.borderColor, !1)} ${Y} S `;
              }
              return ie;
            }
            async getOperatorList(w, k, X, H, Y) {
              if (H && !(this instanceof u) && !this.data.noHTML && !this.data.hasOwnCanvas)
                return {
                  opList: new a.OperatorList(),
                  separateForm: !0,
                  separateCanvas: !1
                };
              if (!this._hasText)
                return super.getOperatorList(w, k, X, H, Y);
              const ie = await this._getAppearance(w, k, X, Y);
              if (this.appearance && ie === null)
                return super.getOperatorList(w, k, X, H, Y);
              const ne = new a.OperatorList();
              if (!this._defaultAppearance || ie === null)
                return {
                  opList: ne,
                  separateForm: !1,
                  separateCanvas: !1
                };
              const U = !!(this.data.hasOwnCanvas && X & n.RenderingIntentFlag.DISPLAY), ae = [1, 0, 0, 1, 0, 0], Q = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], L = W(this.data.rect, Q, ae);
              let ee;
              this.oc && (ee = await w.parseMarkedContentProps(this.oc, null)), ee !== void 0 && ne.addOp(n.OPS.beginMarkedContentProps, ["OC", ee]), ne.addOp(n.OPS.beginAnnotation, [this.data.id, this.data.rect, L, this.getRotationMatrix(Y), U]);
              const se = new t.StringStream(ie);
              return await w.getOperatorList({
                stream: se,
                task: k,
                resources: this._fieldResources.mergedResources,
                operatorList: ne
              }), ne.addOp(n.OPS.endAnnotation, []), ee !== void 0 && ne.addOp(n.OPS.endMarkedContent, []), {
                opList: ne,
                separateForm: !1,
                separateCanvas: U
              };
            }
            _getMKDict(w) {
              const k = new e.Dict(null);
              return w && k.set("R", w), this.borderColor && k.set("BC", R(this.borderColor)), this.backgroundColor && k.set("BG", R(this.backgroundColor)), k.size > 0 ? k : null;
            }
            amendSavedDict(w, k) {
            }
            async save(w, k, X) {
              const H = X == null ? void 0 : X.get(this.data.id);
              let Y = H == null ? void 0 : H.value, ie = H == null ? void 0 : H.rotation;
              if (Y === this.data.fieldValue || Y === void 0) {
                if (!this._hasValueFromXFA && ie === void 0)
                  return null;
                Y || (Y = this.data.fieldValue);
              }
              if (ie === void 0 && !this._hasValueFromXFA && Array.isArray(Y) && Array.isArray(this.data.fieldValue) && Y.length === this.data.fieldValue.length && Y.every((ge, me) => ge === this.data.fieldValue[me]))
                return null;
              ie === void 0 && (ie = this.rotation);
              let ne = null;
              if (!this._needAppearances && (ne = await this._getAppearance(w, k, n.RenderingIntentFlag.SAVE, X), ne === null))
                return null;
              let U = !1;
              ne != null && ne.needAppearances && (U = !0, ne = null);
              const {
                xref: ae
              } = w, Q = ae.fetchIfRef(this.ref);
              if (!(Q instanceof e.Dict))
                return null;
              const L = new e.Dict(ae);
              for (const ge of Q.getKeys())
                ge !== "AP" && L.set(ge, Q.getRaw(ge));
              const ee = {
                path: this.data.fieldName,
                value: Y
              }, se = (ge) => (0, P.isAscii)(ge) ? ge : (0, P.stringToUTF16String)(ge, !0);
              L.set("V", Array.isArray(Y) ? Y.map(se) : se(Y)), this.amendSavedDict(X, L);
              const le = this._getMKDict(ie);
              le && L.set("MK", le);
              const ue = [], de = [{
                ref: this.ref,
                data: "",
                xfa: ee,
                needAppearances: U
              }];
              if (ne !== null) {
                const ge = ae.getNewTemporaryRef(), me = new e.Dict(ae);
                L.set("AP", me), me.set("N", ge);
                const pe = this._getSaveFieldResources(ae), xe = new t.StringStream(ne), we = xe.dict = new e.Dict(ae);
                we.set("Subtype", e.Name.get("Form")), we.set("Resources", pe), we.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
                const Ae = this.getRotationMatrix(X);
                Ae !== n.IDENTITY_MATRIX && we.set("Matrix", Ae), await (0, N.writeObject)(ge, xe, ue, ae), de.push({
                  ref: ge,
                  data: ue.join(""),
                  xfa: null,
                  needAppearances: !1
                }), ue.length = 0;
              }
              return L.set("M", `D:${(0, n.getModificationDate)()}`), await (0, N.writeObject)(this.ref, L, ue, ae), de[0].data = ue.join(""), de;
            }
            async _getAppearance(w, k, X, H) {
              if (this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD))
                return null;
              const ie = H == null ? void 0 : H.get(this.data.id);
              let ne, U;
              if (ie && (ne = ie.formattedValue || ie.value, U = ie.rotation), U === void 0 && ne === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
                return null;
              const ae = this.getBorderAndBackgroundAppearances(H);
              if (ne === void 0 && (ne = this.data.fieldValue, !ne))
                return `/Tx BMC q ${ae}Q EMC`;
              if (Array.isArray(ne) && ne.length === 1 && (ne = ne[0]), (0, n.assert)(typeof ne == "string", "Expected `value` to be a string."), ne = ne.trim(), this.data.combo) {
                const Le = this.data.options.find(({
                  exportValue: Be
                }) => ne === Be);
                ne = (Le == null ? void 0 : Le.displayValue) || ne;
              }
              if (ne === "")
                return `/Tx BMC q ${ae}Q EMC`;
              U === void 0 && (U = this.rotation);
              let Q = -1, L;
              this.data.multiLine ? (L = ne.split(/\r\n?|\n/).map((Le) => Le.normalize("NFC")), Q = L.length) : L = [ne.replace(/\r\n?|\n/, "").normalize("NFC")];
              const ee = 1, se = 2;
              let le = this.data.rect[3] - this.data.rect[1], ue = this.data.rect[2] - this.data.rect[0];
              (U === 90 || U === 270) && ([ue, le] = [le, ue]), this._defaultAppearance || (this.data.defaultAppearanceData = (0, D.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              let de = await c._getFontData(w, k, this.data.defaultAppearanceData, this._fieldResources.mergedResources), ge, me, pe;
              const xe = [];
              let we = !1;
              for (const Le of L) {
                const Be = de.encodeString(Le);
                Be.length > 1 && (we = !0), xe.push(Be.join(""));
              }
              if (we && X & n.RenderingIntentFlag.SAVE)
                return {
                  needAppearances: !0
                };
              if (we && this._isOffscreenCanvasSupported) {
                const Le = this.data.comb ? "monospace" : "sans-serif", Be = new D.FakeUnicodeFont(w.xref, Le), nt = Be.createFontResources(L.join("")), Oe = nt.getRaw("Font");
                if (this._fieldResources.mergedResources.has("Font")) {
                  const Pe = this._fieldResources.mergedResources.get("Font");
                  for (const Ge of Oe.getKeys())
                    Pe.set(Ge, Oe.getRaw(Ge));
                } else
                  this._fieldResources.mergedResources.set("Font", Oe);
                const Je = Be.fontName.name;
                de = await c._getFontData(w, k, {
                  fontName: Je,
                  fontSize: 0
                }, nt);
                for (let Pe = 0, Ge = xe.length; Pe < Ge; Pe++)
                  xe[Pe] = (0, P.stringToUTF16String)(L[Pe]);
                const Ve = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
                this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = Je, [ge, me, pe] = this._computeFontSize(le - 2 * ee, ue - 2 * se, ne, de, Q), this.data.defaultAppearanceData = Ve;
              } else
                this._isOffscreenCanvasSupported || (0, n.warn)("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [ge, me, pe] = this._computeFontSize(le - 2 * ee, ue - 2 * se, ne, de, Q);
              let Ae = de.descent;
              isNaN(Ae) ? Ae = n.BASELINE_FACTOR * pe : Ae = Math.max(n.BASELINE_FACTOR * pe, Math.abs(Ae) * me);
              const be = Math.min(Math.floor((le - me) / 2), ee), he = this.data.textAlignment;
              if (this.data.multiLine)
                return this._getMultilineAppearance(ge, xe, de, me, ue, le, he, se, be, Ae, pe, H);
              if (this.data.comb)
                return this._getCombAppearance(ge, de, xe[0], me, ue, le, se, be, Ae, pe, H);
              const fe = be + Ae;
              if (he === 0 || he > 2)
                return `/Tx BMC q ${ae}BT ` + ge + ` 1 0 0 1 ${(0, P.numberToString)(se)} ${(0, P.numberToString)(fe)} Tm (${(0, P.escapeString)(xe[0])}) Tj ET Q EMC`;
              const Ce = {
                shift: 0
              }, ye = this._renderText(xe[0], de, me, ue, he, Ce, se, fe);
              return `/Tx BMC q ${ae}BT ` + ge + ` 1 0 0 1 0 0 Tm ${ye} ET Q EMC`;
            }
            static async _getFontData(w, k, X, H) {
              const Y = new a.OperatorList(), ie = {
                font: null,
                clone() {
                  return this;
                }
              }, {
                fontName: ne,
                fontSize: U
              } = X;
              return await w.handleSetFont(H, [ne && e.Name.get(ne), U], null, Y, k, ie, null), ie.font;
            }
            _getTextWidth(w, k) {
              return k.charsToGlyphs(w).reduce((X, H) => X + H.width, 0) / 1e3;
            }
            _computeFontSize(w, k, X, H, Y) {
              let {
                fontSize: ie
              } = this.data.defaultAppearanceData, ne = (ie || 12) * n.LINE_FACTOR, U = Math.round(w / ne);
              if (!ie) {
                const ae = (ee) => Math.floor(ee * 100) / 100;
                if (Y === -1) {
                  const ee = this._getTextWidth(X, H);
                  ie = ae(Math.min(w / n.LINE_FACTOR, ee > k ? k / ee : 1 / 0)), U = 1;
                } else {
                  const ee = X.split(/\r\n?|\n/), se = [];
                  for (const ue of ee) {
                    const de = H.encodeString(ue).join(""), ge = H.charsToGlyphs(de), me = H.getCharPositions(de);
                    se.push({
                      line: de,
                      glyphs: ge,
                      positions: me
                    });
                  }
                  const le = (ue) => {
                    let de = 0;
                    for (const ge of se) {
                      const me = this._splitLine(null, H, ue, k, ge);
                      if (de += me.length * ue, de > w)
                        return !0;
                    }
                    return !1;
                  };
                  for (U = Math.max(U, Y); ; ) {
                    if (ne = w / U, ie = ae(ne / n.LINE_FACTOR), le(ie)) {
                      U++;
                      continue;
                    }
                    break;
                  }
                }
                const {
                  fontName: Q,
                  fontColor: L
                } = this.data.defaultAppearanceData;
                this._defaultAppearance = (0, D.createDefaultAppearance)({
                  fontSize: ie,
                  fontName: Q,
                  fontColor: L
                });
              }
              return [this._defaultAppearance, ie, w / U];
            }
            _renderText(w, k, X, H, Y, ie, ne, U) {
              let ae;
              if (Y === 1) {
                const L = this._getTextWidth(w, k) * X;
                ae = (H - L) / 2;
              } else if (Y === 2) {
                const L = this._getTextWidth(w, k) * X;
                ae = H - L - ne;
              } else
                ae = ne;
              const Q = (0, P.numberToString)(ae - ie.shift);
              return ie.shift = ae, U = (0, P.numberToString)(U), `${Q} ${U} Td (${(0, P.escapeString)(w)}) Tj`;
            }
            _getSaveFieldResources(w) {
              var ie;
              const {
                localResources: k,
                appearanceResources: X,
                acroFormResources: H
              } = this._fieldResources, Y = (ie = this.data.defaultAppearanceData) == null ? void 0 : ie.fontName;
              if (!Y)
                return k || e.Dict.empty;
              for (const ne of [k, X])
                if (ne instanceof e.Dict) {
                  const U = ne.get("Font");
                  if (U instanceof e.Dict && U.has(Y))
                    return ne;
                }
              if (H instanceof e.Dict) {
                const ne = H.get("Font");
                if (ne instanceof e.Dict && ne.has(Y)) {
                  const U = new e.Dict(w);
                  U.set(Y, ne.getRaw(Y));
                  const ae = new e.Dict(w);
                  return ae.set("Font", U), e.Dict.merge({
                    xref: w,
                    dictArray: [ae, k],
                    mergeSubDicts: !0
                  });
                }
              }
              return k || e.Dict.empty;
            }
            getFieldObject() {
              return null;
            }
          }
          class I extends c {
            constructor(w) {
              super(w), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0;
              const k = w.dict;
              typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
              let X = (0, P.getInheritableProperty)({
                dict: k,
                key: "Q"
              });
              (!Number.isInteger(X) || X < 0 || X > 2) && (X = null), this.data.textAlignment = X;
              let H = (0, P.getInheritableProperty)({
                dict: k,
                key: "MaxLen"
              });
              (!Number.isInteger(H) || H < 0) && (H = 0), this.data.maxLen = H, this.data.multiLine = this.hasFieldFlag(n.AnnotationFieldFlag.MULTILINE), this.data.comb = this.hasFieldFlag(n.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(n.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(n.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(n.AnnotationFieldFlag.DONOTSCROLL);
            }
            get hasTextContent() {
              return !!this.appearance && !this._needAppearances;
            }
            _getCombAppearance(w, k, X, H, Y, ie, ne, U, ae, Q, L) {
              const ee = Y / this.data.maxLen, se = this.getBorderAndBackgroundAppearances(L), le = [], ue = k.getCharPositions(X);
              for (const [ge, me] of ue)
                le.push(`(${(0, P.escapeString)(X.substring(ge, me))}) Tj`);
              const de = le.join(` ${(0, P.numberToString)(ee)} 0 Td `);
              return `/Tx BMC q ${se}BT ` + w + ` 1 0 0 1 ${(0, P.numberToString)(ne)} ${(0, P.numberToString)(U + ae)} Tm ${de} ET Q EMC`;
            }
            _getMultilineAppearance(w, k, X, H, Y, ie, ne, U, ae, Q, L, ee) {
              const se = [], le = Y - 2 * U, ue = {
                shift: 0
              };
              for (let me = 0, pe = k.length; me < pe; me++) {
                const xe = k[me], we = this._splitLine(xe, X, H, le);
                for (let Ae = 0, be = we.length; Ae < be; Ae++) {
                  const he = we[Ae], fe = me === 0 && Ae === 0 ? -ae - (L - Q) : -L;
                  se.push(this._renderText(he, X, H, Y, ne, ue, U, fe));
                }
              }
              const de = this.getBorderAndBackgroundAppearances(ee), ge = se.join(`
`);
              return `/Tx BMC q ${de}BT ` + w + ` 1 0 0 1 0 ${(0, P.numberToString)(ie)} Tm ${ge} ET Q EMC`;
            }
            _splitLine(w, k, X, H, Y = {}) {
              w = Y.line || w;
              const ie = Y.glyphs || k.charsToGlyphs(w);
              if (ie.length <= 1)
                return [w];
              const ne = Y.positions || k.getCharPositions(w), U = X / 1e3, ae = [];
              let Q = -1, L = -1, ee = -1, se = 0, le = 0;
              for (let ue = 0, de = ie.length; ue < de; ue++) {
                const [ge, me] = ne[ue], pe = ie[ue], xe = pe.width * U;
                pe.unicode === " " ? le + xe > H ? (ae.push(w.substring(se, ge)), se = ge, le = xe, Q = -1, ee = -1) : (le += xe, Q = ge, L = me, ee = ue) : le + xe > H ? Q !== -1 ? (ae.push(w.substring(se, L)), se = L, ue = ee + 1, Q = -1, le = 0) : (ae.push(w.substring(se, ge)), se = ge, le = xe) : le += xe;
              }
              return se < w.length && ae.push(w.substring(se, w.length)), ae;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: this.data.fieldValue,
                defaultValue: this.data.defaultFieldValue || "",
                multiline: this.data.multiLine,
                password: this.hasFieldFlag(n.AnnotationFieldFlag.PASSWORD),
                charLimit: this.data.maxLen,
                comb: this.data.comb,
                editable: !this.data.readOnly,
                hidden: this.data.hidden,
                name: this.data.fieldName,
                rect: this.data.rect,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: "text"
              };
            }
          }
          class s extends c {
            constructor(w) {
              super(w), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(n.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(n.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(n.AnnotationFieldFlag.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(w) : this.data.radioButton ? this._processRadioButton(w) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this._processPushButton(w)) : (0, n.warn)("Invalid field flags for button widget annotation");
            }
            async getOperatorList(w, k, X, H, Y) {
              if (this.data.pushButton)
                return super.getOperatorList(w, k, X, !1, Y);
              let ie = null, ne = null;
              if (Y) {
                const ae = Y.get(this.data.id);
                ie = ae ? ae.value : null, ne = ae ? ae.rotation : null;
              }
              if (ie === null && this.appearance)
                return super.getOperatorList(w, k, X, H, Y);
              ie == null && (ie = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
              const U = ie ? this.checkedAppearance : this.uncheckedAppearance;
              if (U) {
                const ae = this.appearance, Q = U.dict.getArray("Matrix") || n.IDENTITY_MATRIX;
                ne && U.dict.set("Matrix", this.getRotationMatrix(Y)), this.appearance = U;
                const L = super.getOperatorList(w, k, X, H, Y);
                return this.appearance = ae, U.dict.set("Matrix", Q), L;
              }
              return {
                opList: new a.OperatorList(),
                separateForm: !1,
                separateCanvas: !1
              };
            }
            async save(w, k, X) {
              return this.data.checkBox ? this._saveCheckbox(w, k, X) : this.data.radioButton ? this._saveRadioButton(w, k, X) : null;
            }
            async _saveCheckbox(w, k, X) {
              if (!X)
                return null;
              const H = X.get(this.data.id);
              let Y = H == null ? void 0 : H.rotation, ie = H == null ? void 0 : H.value;
              if (Y === void 0 && (ie === void 0 || this.data.fieldValue === this.data.exportValue === ie))
                return null;
              const ne = w.xref.fetchIfRef(this.ref);
              if (!(ne instanceof e.Dict))
                return null;
              Y === void 0 && (Y = this.rotation), ie === void 0 && (ie = this.data.fieldValue === this.data.exportValue);
              const U = {
                path: this.data.fieldName,
                value: ie ? this.data.exportValue : ""
              }, ae = e.Name.get(ie ? this.data.exportValue : "Off");
              ne.set("V", ae), ne.set("AS", ae), ne.set("M", `D:${(0, n.getModificationDate)()}`);
              const Q = this._getMKDict(Y);
              Q && ne.set("MK", Q);
              const L = [];
              return await (0, N.writeObject)(this.ref, ne, L, w.xref), [{
                ref: this.ref,
                data: L.join(""),
                xfa: U
              }];
            }
            async _saveRadioButton(w, k, X) {
              if (!X)
                return null;
              const H = X.get(this.data.id);
              let Y = H == null ? void 0 : H.rotation, ie = H == null ? void 0 : H.value;
              if (Y === void 0 && (ie === void 0 || this.data.fieldValue === this.data.buttonValue === ie))
                return null;
              const ne = w.xref.fetchIfRef(this.ref);
              if (!(ne instanceof e.Dict))
                return null;
              ie === void 0 && (ie = this.data.fieldValue === this.data.buttonValue), Y === void 0 && (Y = this.rotation);
              const U = {
                path: this.data.fieldName,
                value: ie ? this.data.buttonValue : ""
              }, ae = e.Name.get(ie ? this.data.buttonValue : "Off"), Q = [];
              let L = null;
              if (ie)
                if (this.parent instanceof e.Ref) {
                  const le = w.xref.fetch(this.parent);
                  le.set("V", ae), await (0, N.writeObject)(this.parent, le, Q, w.xref), L = Q.join(""), Q.length = 0;
                } else
                  this.parent instanceof e.Dict && this.parent.set("V", ae);
              ne.set("AS", ae), ne.set("M", `D:${(0, n.getModificationDate)()}`);
              const ee = this._getMKDict(Y);
              ee && ne.set("MK", ee), await (0, N.writeObject)(this.ref, ne, Q, w.xref);
              const se = [{
                ref: this.ref,
                data: Q.join(""),
                xfa: U
              }];
              return L && se.push({
                ref: this.parent,
                data: L,
                xfa: null
              }), se;
            }
            _getDefaultCheckedAppearance(w, k) {
              const X = this.data.rect[2] - this.data.rect[0], H = this.data.rect[3] - this.data.rect[1], Y = [0, 0, X, H], ne = Math.min(X, H) * 0.8;
              let U, ae;
              k === "check" ? (U = {
                width: 0.755 * ne,
                height: 0.705 * ne
              }, ae = "3") : k === "disc" ? (U = {
                width: 0.791 * ne,
                height: 0.705 * ne
              }, ae = "l") : (0, n.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${k}`);
              const Q = (0, P.numberToString)((X - U.width) / 2), L = (0, P.numberToString)((H - U.height) / 2), ee = `q BT /PdfJsZaDb ${ne} Tf 0 g ${Q} ${L} Td (${ae}) Tj ET Q`, se = new e.Dict(w.xref);
              se.set("FormType", 1), se.set("Subtype", e.Name.get("Form")), se.set("Type", e.Name.get("XObject")), se.set("BBox", Y), se.set("Matrix", [1, 0, 0, 1, 0, 0]), se.set("Length", ee.length);
              const le = new e.Dict(w.xref), ue = new e.Dict(w.xref);
              ue.set("PdfJsZaDb", this.fallbackFontDict), le.set("Font", ue), se.set("Resources", le), this.checkedAppearance = new t.StringStream(ee), this.checkedAppearance.dict = se, this._streams.push(this.checkedAppearance);
            }
            _processCheckBox(w) {
              const k = w.dict.get("AP");
              if (!(k instanceof e.Dict))
                return;
              const X = k.get("N");
              if (!(X instanceof e.Dict))
                return;
              const H = this._decodeFormValue(w.dict.get("AS"));
              typeof H == "string" && (this.data.fieldValue = H);
              const Y = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", ie = X.getKeys();
              if (ie.length === 0)
                ie.push("Off", Y);
              else if (ie.length === 1)
                ie[0] === "Off" ? ie.push(Y) : ie.unshift("Off");
              else if (ie.includes(Y))
                ie.length = 0, ie.push("Off", Y);
              else {
                const ae = ie.find((Q) => Q !== "Off");
                ie.length = 0, ie.push("Off", ae);
              }
              ie.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = ie[1];
              const ne = X.get(this.data.exportValue);
              this.checkedAppearance = ne instanceof l.BaseStream ? ne : null;
              const U = X.get("Off");
              this.uncheckedAppearance = U instanceof l.BaseStream ? U : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(w, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
            }
            _processRadioButton(w) {
              this.data.fieldValue = this.data.buttonValue = null;
              const k = w.dict.get("Parent");
              if (k instanceof e.Dict) {
                this.parent = w.dict.getRaw("Parent");
                const ne = k.get("V");
                ne instanceof e.Name && (this.data.fieldValue = this._decodeFormValue(ne));
              }
              const X = w.dict.get("AP");
              if (!(X instanceof e.Dict))
                return;
              const H = X.get("N");
              if (!(H instanceof e.Dict))
                return;
              for (const ne of H.getKeys())
                if (ne !== "Off") {
                  this.data.buttonValue = this._decodeFormValue(ne);
                  break;
                }
              const Y = H.get(this.data.buttonValue);
              this.checkedAppearance = Y instanceof l.BaseStream ? Y : null;
              const ie = H.get("Off");
              this.uncheckedAppearance = ie instanceof l.BaseStream ? ie : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(w, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
            }
            _processPushButton(w) {
              const {
                dict: k,
                annotationGlobals: X
              } = w;
              if (!k.has("A") && !k.has("AA") && !this.data.alternativeText) {
                (0, n.warn)("Push buttons without action dictionaries are not supported");
                return;
              }
              this.data.isTooltipOnly = !k.has("A") && !k.has("AA"), te.Catalog.parseDestDictionary({
                destDict: k,
                resultObj: this.data,
                docBaseUrl: X.baseUrl,
                docAttachments: X.attachments
              });
            }
            getFieldObject() {
              let w = "button", k;
              return this.data.checkBox ? (w = "checkbox", k = this.data.exportValue) : this.data.radioButton && (w = "radiobutton", k = this.data.buttonValue), {
                id: this.data.id,
                value: this.data.fieldValue || "Off",
                defaultValue: this.data.defaultFieldValue,
                exportValues: k,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: w
              };
            }
            get fallbackFontDict() {
              const w = new e.Dict();
              return w.set("BaseFont", e.Name.get("ZapfDingbats")), w.set("Type", e.Name.get("FallbackType")), w.set("Subtype", e.Name.get("FallbackType")), w.set("Encoding", e.Name.get("ZapfDingbatsEncoding")), (0, n.shadow)(this, "fallbackFontDict", w);
            }
          }
          class r extends c {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              this.indices = k.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
              const H = (0, P.getInheritableProperty)({
                dict: k,
                key: "Opt"
              });
              if (Array.isArray(H))
                for (let Y = 0, ie = H.length; Y < ie; Y++) {
                  const ne = X.fetchIfRef(H[Y]), U = Array.isArray(ne);
                  this.data.options[Y] = {
                    exportValue: this._decodeFormValue(U ? X.fetchIfRef(ne[0]) : ne),
                    displayValue: this._decodeFormValue(U ? X.fetchIfRef(ne[1]) : ne)
                  };
                }
              if (!this.hasIndices)
                typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
              else {
                this.data.fieldValue = [];
                const Y = this.data.options.length;
                for (const ie of this.indices)
                  Number.isInteger(ie) && ie >= 0 && ie < Y && this.data.fieldValue.push(this.data.options[ie].exportValue);
              }
              this.data.combo = this.hasFieldFlag(n.AnnotationFieldFlag.COMBO), this.data.multiSelect = this.hasFieldFlag(n.AnnotationFieldFlag.MULTISELECT), this._hasText = !0;
            }
            getFieldObject() {
              const w = this.data.combo ? "combobox" : "listbox", k = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
              return {
                id: this.data.id,
                value: k,
                defaultValue: this.data.defaultFieldValue,
                editable: !this.data.readOnly,
                name: this.data.fieldName,
                rect: this.data.rect,
                numItems: this.data.fieldValue.length,
                multipleSelection: this.data.multiSelect,
                hidden: this.data.hidden,
                actions: this.data.actions,
                items: this.data.options,
                page: this.data.pageIndex,
                strokeColor: this.data.borderColor,
                fillColor: this.data.backgroundColor,
                rotation: this.rotation,
                type: w
              };
            }
            amendSavedDict(w, k) {
              var ie;
              if (!this.hasIndices)
                return;
              let X = (ie = w == null ? void 0 : w.get(this.data.id)) == null ? void 0 : ie.value;
              Array.isArray(X) || (X = [X]);
              const H = [], {
                options: Y
              } = this.data;
              for (let ne = 0, U = 0, ae = Y.length; ne < ae; ne++)
                Y[ne].exportValue === X[U] && (H.push(ne), U += 1);
              k.set("I", H);
            }
            async _getAppearance(w, k, X, H) {
              if (this.data.combo)
                return super._getAppearance(w, k, X, H);
              let Y, ie;
              const ne = H == null ? void 0 : H.get(this.data.id);
              if (ne && (ie = ne.rotation, Y = ne.value), ie === void 0 && Y === void 0 && !this._needAppearances)
                return null;
              Y === void 0 ? Y = this.data.fieldValue : Array.isArray(Y) || (Y = [Y]);
              const U = 1, ae = 2;
              let Q = this.data.rect[3] - this.data.rect[1], L = this.data.rect[2] - this.data.rect[0];
              (ie === 90 || ie === 270) && ([L, Q] = [Q, L]);
              const ee = this.data.options.length, se = [];
              for (let he = 0; he < ee; he++) {
                const {
                  exportValue: fe
                } = this.data.options[he];
                Y.includes(fe) && se.push(he);
              }
              this._defaultAppearance || (this.data.defaultAppearanceData = (0, D.parseDefaultAppearance)(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
              const le = await c._getFontData(w, k, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
              let ue, {
                fontSize: de
              } = this.data.defaultAppearanceData;
              if (de)
                ue = this._defaultAppearance;
              else {
                const he = (Q - U) / ee;
                let fe = -1, Ce;
                for (const {
                  displayValue: ye
                } of this.data.options) {
                  const Le = this._getTextWidth(ye, le);
                  Le > fe && (fe = Le, Ce = ye);
                }
                [ue, de] = this._computeFontSize(he, L - 2 * ae, Ce, le, -1);
              }
              const ge = de * n.LINE_FACTOR, me = (ge - de) / 2, pe = Math.floor(Q / ge);
              let xe = 0;
              if (se.length > 0) {
                const he = Math.min(...se), fe = Math.max(...se);
                xe = Math.max(0, fe - pe + 1), xe > he && (xe = he);
              }
              const we = Math.min(xe + pe + 1, ee), Ae = ["/Tx BMC q", `1 1 ${L} ${Q} re W n`];
              if (se.length) {
                Ae.push("0.600006 0.756866 0.854904 rg");
                for (const he of se)
                  xe <= he && he < we && Ae.push(`1 ${Q - (he - xe + 1) * ge} ${L} ${ge} re f`);
              }
              Ae.push("BT", ue, `1 0 0 1 0 ${Q} Tm`);
              const be = {
                shift: 0
              };
              for (let he = xe; he < we; he++) {
                const {
                  displayValue: fe
                } = this.data.options[he], Ce = he === xe ? me : 0;
                Ae.push(this._renderText(fe, le, de, L, 0, be, ae, -ge + Ce));
              }
              return Ae.push("ET Q EMC"), Ae.join(`
`);
            }
          }
          class u extends c {
            constructor(w) {
              super(w), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate;
            }
            getFieldObject() {
              return {
                id: this.data.id,
                value: null,
                page: this.data.pageIndex,
                type: "signature"
              };
            }
          }
          class C extends o {
            constructor(w) {
              super(w), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate;
              const {
                dict: X
              } = w;
              this.data.annotationType = n.AnnotationType.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = X.has("Name") ? X.get("Name").name : "Note"), X.has("State") ? (this.data.state = X.get("State") || null, this.data.stateModel = X.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
            }
          }
          class d extends g {
            constructor(w) {
              var Y;
              super(w);
              const {
                dict: k,
                annotationGlobals: X
              } = w;
              this.data.annotationType = n.AnnotationType.LINK;
              const H = z(k, this.rectangle);
              H && (this.data.quadPoints = H), (Y = this.data).borderColor || (Y.borderColor = this.data.color), te.Catalog.parseDestDictionary({
                destDict: k,
                resultObj: this.data,
                docBaseUrl: X.baseUrl,
                docAttachments: X.attachments
              });
            }
          }
          class y extends g {
            constructor(w) {
              super(w);
              const {
                dict: k
              } = w;
              this.data.annotationType = n.AnnotationType.POPUP, (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) && (this.data.rect = null);
              let X = k.get("Parent");
              if (!X) {
                (0, n.warn)("Popup annotation has a missing or invalid parent annotation.");
                return;
              }
              const H = X.getArray("Rect");
              this.data.parentRect = Array.isArray(H) && H.length === 4 ? n.Util.normalizeRect(H) : null;
              const Y = X.get("RT");
              if ((0, e.isName)(Y, n.AnnotationReplyType.GROUP) && (X = X.get("IRT")), X.has("M") ? (this.setModificationDate(X.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, X.has("C") ? (this.setColor(X.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
                const ie = X.get("F");
                this._isViewable(ie) && this.setFlags(ie);
              }
              this.setTitle(X.get("T")), this.data.titleObj = this._title, this.setContents(X.get("Contents")), this.data.contentsObj = this._contents, X.has("RC") && (this.data.richText = p.XFAFactory.getRichTextAsHtml(X.get("RC"))), this.data.open = !!k.get("Open");
            }
          }
          b.PopupAnnotation = y;
          class _ extends o {
            constructor(w) {
              var H;
              super(w), this.data.hasOwnCanvas = !0;
              const {
                evaluatorOptions: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.FREETEXT, this.setDefaultAppearance(w), this.appearance) {
                const {
                  fontColor: Y,
                  fontSize: ie
                } = (0, D.parseAppearanceStream)(this.appearance, k, X);
                this.data.defaultAppearanceData.fontColor = Y, this.data.defaultAppearanceData.fontSize = ie || 10;
              } else if (this._isOffscreenCanvasSupported) {
                const Y = w.dict.get("CA"), ie = new D.FakeUnicodeFont(X, "sans-serif");
                (H = this.data.defaultAppearanceData).fontSize || (H.fontSize = 10);
                const {
                  fontColor: ne,
                  fontSize: U
                } = this.data.defaultAppearanceData;
                this.appearance = ie.createAppearance(this._contents.str, this.rectangle, this.rotation, U, ne, Y), this._streams.push(this.appearance, D.FakeUnicodeFont.toUnicodeStream);
              } else
                (0, n.warn)("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
            }
            get hasTextContent() {
              return !!this.appearance;
            }
            static createNewDict(w, k, {
              apRef: X,
              ap: H
            }) {
              const {
                color: Y,
                fontSize: ie,
                rect: ne,
                rotation: U,
                user: ae,
                value: Q
              } = w, L = new e.Dict(k);
              L.set("Type", e.Name.get("Annot")), L.set("Subtype", e.Name.get("FreeText")), L.set("CreationDate", `D:${(0, n.getModificationDate)()}`), L.set("Rect", ne);
              const ee = `/Helv ${ie} Tf ${(0, D.getPdfColor)(Y, !0)}`;
              if (L.set("DA", ee), L.set("Contents", (0, P.isAscii)(Q) ? Q : (0, P.stringToUTF16String)(Q, !0)), L.set("F", 4), L.set("Border", [0, 0, 0]), L.set("Rotate", U), ae && L.set("T", (0, P.isAscii)(ae) ? ae : (0, P.stringToUTF16String)(ae, !0)), X || H) {
                const se = new e.Dict(k);
                L.set("AP", se), X ? se.set("N", X) : se.set("N", H);
              }
              return L;
            }
            static async createNewAppearanceStream(w, k, X) {
              const {
                baseFontRef: H,
                evaluator: Y,
                task: ie
              } = X, {
                color: ne,
                fontSize: U,
                rect: ae,
                rotation: Q,
                value: L
              } = w, ee = new e.Dict(k), se = new e.Dict(k);
              if (H)
                se.set("Helv", H);
              else {
                const wt = new e.Dict(k);
                wt.set("BaseFont", e.Name.get("Helvetica")), wt.set("Type", e.Name.get("Font")), wt.set("Subtype", e.Name.get("Type1")), wt.set("Encoding", e.Name.get("WinAnsiEncoding")), se.set("Helv", wt);
              }
              ee.set("Font", se);
              const le = await c._getFontData(Y, ie, {
                fontName: "Helv",
                fontSize: U
              }, ee), [ue, de, ge, me] = ae;
              let pe = ge - ue, xe = me - de;
              Q % 180 !== 0 && ([pe, xe] = [xe, pe]);
              const we = L.split(`
`), Ae = U / 1e3;
              let be = -1 / 0;
              const he = [];
              for (let wt of we) {
                const Ot = le.encodeString(wt);
                if (Ot.length > 1)
                  return null;
                wt = Ot.join(""), he.push(wt);
                let ze = 0;
                const qe = le.charsToGlyphs(wt);
                for (const Ue of qe)
                  ze += Ue.width * Ae;
                be = Math.max(be, ze);
              }
              let fe = 1;
              be > pe && (fe = pe / be);
              let Ce = 1;
              const ye = n.LINE_FACTOR * U, Le = (n.LINE_FACTOR - n.LINE_DESCENT_FACTOR) * U, Be = ye * we.length;
              Be > xe && (Ce = xe / Be);
              const nt = Math.min(fe, Ce), Oe = U * nt;
              let Je, Ve, Pe;
              switch (Q) {
                case 0:
                  Pe = [1, 0, 0, 1], Ve = [ae[0], ae[1], pe, xe], Je = [ae[0], ae[3] - Le];
                  break;
                case 90:
                  Pe = [0, 1, -1, 0], Ve = [ae[1], -ae[2], pe, xe], Je = [ae[1], -ae[0] - Le];
                  break;
                case 180:
                  Pe = [-1, 0, 0, -1], Ve = [-ae[2], -ae[3], pe, xe], Je = [-ae[2], -ae[1] - Le];
                  break;
                case 270:
                  Pe = [0, -1, 1, 0], Ve = [-ae[3], ae[0], pe, xe], Je = [-ae[3], ae[2] - Le];
                  break;
              }
              const Ge = ["q", `${Pe.join(" ")} 0 0 cm`, `${Ve.join(" ")} re W n`, "BT", `${(0, D.getPdfColor)(ne, !0)}`, `0 Tc /Helv ${(0, P.numberToString)(Oe)} Tf`];
              Ge.push(`${Je.join(" ")} Td (${(0, P.escapeString)(he[0])}) Tj`);
              const dt = (0, P.numberToString)(ye);
              for (let wt = 1, Ot = he.length; wt < Ot; wt++) {
                const ze = he[wt];
                Ge.push(`0 -${dt} Td (${(0, P.escapeString)(ze)}) Tj`);
              }
              Ge.push("ET", "Q");
              const De = Ge.join(`
`), Qe = new e.Dict(k);
              Qe.set("FormType", 1), Qe.set("Subtype", e.Name.get("Form")), Qe.set("Type", e.Name.get("XObject")), Qe.set("BBox", ae), Qe.set("Resources", ee), Qe.set("Matrix", [1, 0, 0, 1, -ae[0], -ae[1]]);
              const st = new t.StringStream(De);
              return st.dict = Qe, st;
            }
          }
          class $ extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              this.data.annotationType = n.AnnotationType.LINE, this.data.hasOwnCanvas = this.data.noRotate;
              const H = k.getArray("L");
              if (this.data.lineCoordinates = n.Util.normalizeRect(H), this.setLineEndings(k.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
                const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA"), ne = M(k.getArray("IC"), null), U = ne ? R(ne) : null, ae = U ? ie : null, Q = this.borderStyle.width || 1, L = 2 * Q, ee = [this.data.lineCoordinates[0] - L, this.data.lineCoordinates[1] - L, this.data.lineCoordinates[2] + L, this.data.lineCoordinates[3] + L];
                n.Util.intersect(this.rectangle, ee) || (this.rectangle = ee), this._setDefaultAppearance({
                  xref: X,
                  extra: `${Q} w`,
                  strokeColor: Y,
                  fillColor: U,
                  strokeAlpha: ie,
                  fillAlpha: ae,
                  pointsCallback: (se, le) => (se.push(`${H[0]} ${H[1]} m`, `${H[2]} ${H[3]} l`, "S"), [le[0].x - Q, le[1].x + Q, le[3].y - Q, le[1].y + Q])
                });
              }
            }
          }
          class S extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, !this.appearance) {
                const H = this.color ? R(this.color) : [0, 0, 0], Y = k.get("CA"), ie = M(k.getArray("IC"), null), ne = ie ? R(ie) : null, U = ne ? Y : null;
                if (this.borderStyle.width === 0 && !ne)
                  return;
                this._setDefaultAppearance({
                  xref: X,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: H,
                  fillColor: ne,
                  strokeAlpha: Y,
                  fillAlpha: U,
                  pointsCallback: (ae, Q) => {
                    const L = Q[2].x + this.borderStyle.width / 2, ee = Q[2].y + this.borderStyle.width / 2, se = Q[3].x - Q[2].x - this.borderStyle.width, le = Q[1].y - Q[3].y - this.borderStyle.width;
                    return ae.push(`${L} ${ee} ${se} ${le} re`), ne ? ae.push("B") : ae.push("S"), [Q[0].x, Q[1].x, Q[3].y, Q[1].y];
                  }
                });
              }
            }
          }
          class v extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.CIRCLE, !this.appearance) {
                const H = this.color ? R(this.color) : [0, 0, 0], Y = k.get("CA"), ie = M(k.getArray("IC"), null), ne = ie ? R(ie) : null, U = ne ? Y : null;
                if (this.borderStyle.width === 0 && !ne)
                  return;
                const ae = 4 / 3 * Math.tan(Math.PI / (2 * 4));
                this._setDefaultAppearance({
                  xref: X,
                  extra: `${this.borderStyle.width} w`,
                  strokeColor: H,
                  fillColor: ne,
                  strokeAlpha: Y,
                  fillAlpha: U,
                  pointsCallback: (Q, L) => {
                    const ee = L[0].x + this.borderStyle.width / 2, se = L[0].y - this.borderStyle.width / 2, le = L[3].x - this.borderStyle.width / 2, ue = L[3].y + this.borderStyle.width / 2, de = ee + (le - ee) / 2, ge = se + (ue - se) / 2, me = (le - ee) / 2 * ae, pe = (ue - se) / 2 * ae;
                    return Q.push(`${de} ${ue} m`, `${de + me} ${ue} ${le} ${ge + pe} ${le} ${ge} c`, `${le} ${ge - pe} ${de + me} ${se} ${de} ${se} c`, `${de - me} ${se} ${ee} ${ge - pe} ${ee} ${ge} c`, `${ee} ${ge + pe} ${de - me} ${ue} ${de} ${ue} c`, "h"), ne ? Q.push("B") : Q.push("S"), [L[0].x, L[1].x, L[3].y, L[1].y];
                  }
                });
              }
            }
          }
          class m extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              this.data.annotationType = n.AnnotationType.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.vertices = [], this instanceof h || (this.setLineEndings(k.getArray("LE")), this.data.lineEndings = this.lineEndings);
              const H = k.getArray("Vertices");
              if (Array.isArray(H)) {
                for (let Y = 0, ie = H.length; Y < ie; Y += 2)
                  this.data.vertices.push({
                    x: H[Y],
                    y: H[Y + 1]
                  });
                if (!this.appearance) {
                  const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA"), ne = this.borderStyle.width || 1, U = 2 * ne, ae = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (const Q of this.data.vertices)
                    ae[0] = Math.min(ae[0], Q.x - U), ae[1] = Math.min(ae[1], Q.y - U), ae[2] = Math.max(ae[2], Q.x + U), ae[3] = Math.max(ae[3], Q.y + U);
                  n.Util.intersect(this.rectangle, ae) || (this.rectangle = ae), this._setDefaultAppearance({
                    xref: X,
                    extra: `${ne} w`,
                    strokeColor: Y,
                    strokeAlpha: ie,
                    pointsCallback: (Q, L) => {
                      const ee = this.data.vertices;
                      for (let se = 0, le = ee.length; se < le; se++)
                        Q.push(`${ee[se].x} ${ee[se].y} ${se === 0 ? "m" : "l"}`);
                      return Q.push("S"), [L[0].x, L[1].x, L[3].y, L[1].y];
                    }
                  });
                }
              }
            }
          }
          class h extends m {
            constructor(w) {
              super(w), this.data.annotationType = n.AnnotationType.POLYGON;
            }
          }
          class A extends o {
            constructor(w) {
              super(w), this.data.annotationType = n.AnnotationType.CARET;
            }
          }
          class j extends o {
            constructor(w) {
              super(w), this.data.hasOwnCanvas = this.data.noRotate;
              const {
                dict: k,
                xref: X
              } = w;
              this.data.annotationType = n.AnnotationType.INK, this.data.inkLists = [];
              const H = k.getArray("InkList");
              if (Array.isArray(H)) {
                for (let Y = 0, ie = H.length; Y < ie; ++Y) {
                  this.data.inkLists.push([]);
                  for (let ne = 0, U = H[Y].length; ne < U; ne += 2)
                    this.data.inkLists[Y].push({
                      x: X.fetchIfRef(H[Y][ne]),
                      y: X.fetchIfRef(H[Y][ne + 1])
                    });
                }
                if (!this.appearance) {
                  const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA"), ne = this.borderStyle.width || 1, U = 2 * ne, ae = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (const Q of this.data.inkLists)
                    for (const L of Q)
                      ae[0] = Math.min(ae[0], L.x - U), ae[1] = Math.min(ae[1], L.y - U), ae[2] = Math.max(ae[2], L.x + U), ae[3] = Math.max(ae[3], L.y + U);
                  n.Util.intersect(this.rectangle, ae) || (this.rectangle = ae), this._setDefaultAppearance({
                    xref: X,
                    extra: `${ne} w`,
                    strokeColor: Y,
                    strokeAlpha: ie,
                    pointsCallback: (Q, L) => {
                      for (const ee of this.data.inkLists) {
                        for (let se = 0, le = ee.length; se < le; se++)
                          Q.push(`${ee[se].x} ${ee[se].y} ${se === 0 ? "m" : "l"}`);
                        Q.push("S");
                      }
                      return [L[0].x, L[1].x, L[3].y, L[1].y];
                    }
                  });
                }
              }
            }
            static createNewDict(w, k, {
              apRef: X,
              ap: H
            }) {
              const {
                color: Y,
                opacity: ie,
                paths: ne,
                rect: U,
                rotation: ae,
                thickness: Q
              } = w, L = new e.Dict(k);
              L.set("Type", e.Name.get("Annot")), L.set("Subtype", e.Name.get("Ink")), L.set("CreationDate", `D:${(0, n.getModificationDate)()}`), L.set("Rect", U), L.set("InkList", ne.map((le) => le.points)), L.set("F", 4), L.set("Rotate", ae);
              const ee = new e.Dict(k);
              L.set("BS", ee), ee.set("W", Q), L.set("C", Array.from(Y, (le) => le / 255)), L.set("CA", ie);
              const se = new e.Dict(k);
              return L.set("AP", se), X ? se.set("N", X) : se.set("N", H), L;
            }
            static async createNewAppearanceStream(w, k, X) {
              const {
                color: H,
                rect: Y,
                paths: ie,
                thickness: ne,
                opacity: U
              } = w, ae = [`${ne} w 1 J 1 j`, `${(0, D.getPdfColor)(H, !1)}`];
              U !== 1 && ae.push("/R0 gs");
              const Q = [];
              for (const {
                bezier: le
              } of ie) {
                Q.length = 0, Q.push(`${(0, P.numberToString)(le[0])} ${(0, P.numberToString)(le[1])} m`);
                for (let ue = 2, de = le.length; ue < de; ue += 6) {
                  const ge = le.slice(ue, ue + 6).map(P.numberToString).join(" ");
                  Q.push(`${ge} c`);
                }
                Q.push("S"), ae.push(Q.join(`
`));
              }
              const L = ae.join(`
`), ee = new e.Dict(k);
              if (ee.set("FormType", 1), ee.set("Subtype", e.Name.get("Form")), ee.set("Type", e.Name.get("XObject")), ee.set("BBox", Y), ee.set("Length", L.length), U !== 1) {
                const le = new e.Dict(k), ue = new e.Dict(k), de = new e.Dict(k);
                de.set("CA", U), de.set("Type", e.Name.get("ExtGState")), ue.set("R0", de), le.set("ExtGState", ue), ee.set("Resources", le);
              }
              const se = new t.StringStream(L);
              return se.dict = ee, se;
            }
          }
          class G extends o {
            constructor(w) {
              var Y;
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.HIGHLIGHT, this.data.quadPoints = z(k, null)) {
                const ie = (Y = this.appearance) == null ? void 0 : Y.dict.get("Resources");
                if (!this.appearance || !(ie != null && ie.has("ExtGState"))) {
                  this.appearance && (0, n.warn)("HighlightAnnotation - ignoring built-in appearance stream.");
                  const ne = this.color ? R(this.color) : [1, 1, 0], U = k.get("CA");
                  this._setDefaultAppearance({
                    xref: X,
                    fillColor: ne,
                    blendMode: "Multiply",
                    fillAlpha: U,
                    pointsCallback: (ae, Q) => (ae.push(`${Q[0].x} ${Q[0].y} m`, `${Q[1].x} ${Q[1].y} l`, `${Q[3].x} ${Q[3].y} l`, `${Q[2].x} ${Q[2].y} l`, "f"), [Q[0].x, Q[1].x, Q[3].y, Q[1].y])
                  });
                }
              } else
                this.data.popupRef = null;
            }
          }
          class J extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.UNDERLINE, this.data.quadPoints = z(k, null)) {
                if (!this.appearance) {
                  const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA");
                  this._setDefaultAppearance({
                    xref: X,
                    extra: "[] 0 d 0.571 w",
                    strokeColor: Y,
                    strokeAlpha: ie,
                    pointsCallback: (ne, U) => (ne.push(`${U[2].x} ${U[2].y + 1.3} m`, `${U[3].x} ${U[3].y + 1.3} l`, "S"), [U[0].x, U[1].x, U[3].y, U[1].y])
                  });
                }
              } else
                this.data.popupRef = null;
            }
          }
          class oe extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.SQUIGGLY, this.data.quadPoints = z(k, null)) {
                if (!this.appearance) {
                  const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA");
                  this._setDefaultAppearance({
                    xref: X,
                    extra: "[] 0 d 1 w",
                    strokeColor: Y,
                    strokeAlpha: ie,
                    pointsCallback: (ne, U) => {
                      const ae = (U[0].y - U[2].y) / 6;
                      let Q = ae, L = U[2].x;
                      const ee = U[2].y, se = U[3].x;
                      ne.push(`${L} ${ee + Q} m`);
                      do
                        L += 2, Q = Q === 0 ? ae : 0, ne.push(`${L} ${ee + Q} l`);
                      while (L < se);
                      return ne.push("S"), [U[2].x, se, ee - 2 * ae, ee + 2 * ae];
                    }
                  });
                }
              } else
                this.data.popupRef = null;
            }
          }
          class q extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w;
              if (this.data.annotationType = n.AnnotationType.STRIKEOUT, this.data.quadPoints = z(k, null)) {
                if (!this.appearance) {
                  const Y = this.color ? R(this.color) : [0, 0, 0], ie = k.get("CA");
                  this._setDefaultAppearance({
                    xref: X,
                    extra: "[] 0 d 1 w",
                    strokeColor: Y,
                    strokeAlpha: ie,
                    pointsCallback: (ne, U) => (ne.push(`${(U[0].x + U[2].x) / 2} ${(U[0].y + U[2].y) / 2} m`, `${(U[1].x + U[3].x) / 2} ${(U[1].y + U[3].y) / 2} l`, "S"), [U[0].x, U[1].x, U[3].y, U[1].y])
                  });
                }
              } else
                this.data.popupRef = null;
            }
          }
          class re extends o {
            constructor(w) {
              super(w), this.data.annotationType = n.AnnotationType.STAMP, this.data.hasOwnCanvas = this.data.noRotate;
            }
            static async createImage(w, k) {
              const {
                width: X,
                height: H
              } = w, Y = new OffscreenCanvas(X, H), ie = Y.getContext("2d", {
                alpha: !0
              });
              ie.drawImage(w, 0, 0);
              const ne = ie.getImageData(0, 0, X, H).data, U = new Uint32Array(ne.buffer), ae = U.some(n.FeatureTest.isLittleEndian ? (de) => de >>> 24 !== 255 : (de) => (de & 255) !== 255);
              ae && (ie.fillStyle = "white", ie.fillRect(0, 0, X, H), ie.drawImage(w, 0, 0));
              const Q = Y.convertToBlob({
                type: "image/jpeg",
                quality: 1
              }).then((de) => de.arrayBuffer()), L = e.Name.get("XObject"), ee = e.Name.get("Image"), se = new e.Dict(k);
              se.set("Type", L), se.set("Subtype", ee), se.set("BitsPerComponent", 8), se.set("ColorSpace", e.Name.get("DeviceRGB")), se.set("Filter", e.Name.get("DCTDecode")), se.set("BBox", [0, 0, X, H]), se.set("Width", X), se.set("Height", H);
              let le = null;
              if (ae) {
                const de = new Uint8Array(U.length);
                if (n.FeatureTest.isLittleEndian)
                  for (let me = 0, pe = U.length; me < pe; me++)
                    de[me] = U[me] >>> 24;
                else
                  for (let me = 0, pe = U.length; me < pe; me++)
                    de[me] = U[me] & 255;
                const ge = new e.Dict(k);
                ge.set("Type", L), ge.set("Subtype", ee), ge.set("BitsPerComponent", 8), ge.set("ColorSpace", e.Name.get("DeviceGray")), ge.set("Width", X), ge.set("Height", H), le = new t.Stream(de, 0, 0, ge);
              }
              return {
                imageStream: new t.Stream(await Q, 0, 0, se),
                smaskStream: le,
                width: X,
                height: H
              };
            }
            static createNewDict(w, k, {
              apRef: X,
              ap: H
            }) {
              const {
                rect: Y,
                rotation: ie,
                user: ne
              } = w, U = new e.Dict(k);
              if (U.set("Type", e.Name.get("Annot")), U.set("Subtype", e.Name.get("Stamp")), U.set("CreationDate", `D:${(0, n.getModificationDate)()}`), U.set("Rect", Y), U.set("F", 4), U.set("Border", [0, 0, 0]), U.set("Rotate", ie), ne && U.set("T", (0, P.isAscii)(ne) ? ne : (0, P.stringToUTF16String)(ne, !0)), X || H) {
                const ae = new e.Dict(k);
                U.set("AP", ae), X ? ae.set("N", X) : ae.set("N", H);
              }
              return U;
            }
            static async createNewAppearanceStream(w, k, X) {
              const {
                rotation: H
              } = w, {
                imageRef: Y,
                width: ie,
                height: ne
              } = X.image, U = new e.Dict(k), ae = new e.Dict(k);
              U.set("XObject", ae), ae.set("Im0", Y);
              const Q = `q ${ie} 0 0 ${ne} 0 0 cm /Im0 Do Q`, L = new e.Dict(k);
              if (L.set("FormType", 1), L.set("Subtype", e.Name.get("Form")), L.set("Type", e.Name.get("XObject")), L.set("BBox", [0, 0, ie, ne]), L.set("Resources", U), H) {
                const se = (0, P.getRotationMatrix)(H, ie, ne);
                L.set("Matrix", se);
              }
              const ee = new t.StringStream(Q);
              return ee.dict = L, ee;
            }
          }
          class K extends o {
            constructor(w) {
              super(w);
              const {
                dict: k,
                xref: X
              } = w, H = new F.FileSpec(k.get("FS"), X);
              this.data.annotationType = n.AnnotationType.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.file = H.serializable;
              const Y = k.get("Name");
              this.data.name = Y instanceof e.Name ? (0, n.stringToPDFString)(Y.name) : "PushPin";
              const ie = k.get("ca");
              this.data.fillAlpha = typeof ie == "number" && ie >= 0 && ie <= 1 ? ie : null;
            }
          }
        },
        /* 11 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.FakeUnicodeFont = void 0, b.createDefaultAppearance = N, b.getPdfColor = a, b.parseAppearanceStream = x, b.parseDefaultAppearance = F;
          var n = ce(4), P = ce(3), D = ce(2), e = ce(12), t = ce(13), l = ce(59), V = ce(57), te = ce(8);
          class E extends t.EvaluatorPreprocessor {
            constructor(M) {
              super(new te.StringStream(M));
            }
            parse() {
              const M = {
                fn: 0,
                args: []
              }, R = {
                fontSize: 0,
                fontName: "",
                fontColor: new Uint8ClampedArray(3)
              };
              try {
                for (; M.args.length = 0, !!this.read(M); ) {
                  if (this.savedStatesDepth !== 0)
                    continue;
                  const {
                    fn: z,
                    args: W
                  } = M;
                  switch (z | 0) {
                    case D.OPS.setFont:
                      const [g, T] = W;
                      g instanceof n.Name && (R.fontName = g.name), typeof T == "number" && T > 0 && (R.fontSize = T);
                      break;
                    case D.OPS.setFillRGBColor:
                      e.ColorSpace.singletons.rgb.getRgbItem(W, 0, R.fontColor, 0);
                      break;
                    case D.OPS.setFillGray:
                      e.ColorSpace.singletons.gray.getRgbItem(W, 0, R.fontColor, 0);
                      break;
                    case D.OPS.setFillCMYKColor:
                      e.ColorSpace.singletons.cmyk.getRgbItem(W, 0, R.fontColor, 0);
                      break;
                  }
                }
              } catch (z) {
                (0, D.warn)(`parseDefaultAppearance - ignoring errors: "${z}".`);
              }
              return R;
            }
          }
          function F(O) {
            return new E(O).parse();
          }
          class f extends t.EvaluatorPreprocessor {
            constructor(M, R, z) {
              var W;
              super(M), this.stream = M, this.evaluatorOptions = R, this.xref = z, this.resources = (W = M.dict) == null ? void 0 : W.get("Resources");
            }
            parse() {
              const M = {
                fn: 0,
                args: []
              };
              let R = {
                scaleFactor: 1,
                fontSize: 0,
                fontName: "",
                fontColor: new Uint8ClampedArray(3),
                fillColorSpace: e.ColorSpace.singletons.gray
              }, z = !1;
              const W = [];
              try {
                for (; M.args.length = 0, !(z || !this.read(M)); ) {
                  const {
                    fn: g,
                    args: T
                  } = M;
                  switch (g | 0) {
                    case D.OPS.save:
                      W.push({
                        scaleFactor: R.scaleFactor,
                        fontSize: R.fontSize,
                        fontName: R.fontName,
                        fontColor: R.fontColor.slice(),
                        fillColorSpace: R.fillColorSpace
                      });
                      break;
                    case D.OPS.restore:
                      R = W.pop() || R;
                      break;
                    case D.OPS.setTextMatrix:
                      R.scaleFactor *= Math.hypot(T[0], T[1]);
                      break;
                    case D.OPS.setFont:
                      const [o, c] = T;
                      o instanceof n.Name && (R.fontName = o.name), typeof c == "number" && c > 0 && (R.fontSize = c * R.scaleFactor);
                      break;
                    case D.OPS.setFillColorSpace:
                      R.fillColorSpace = e.ColorSpace.parse({
                        cs: T[0],
                        xref: this.xref,
                        resources: this.resources,
                        pdfFunctionFactory: this._pdfFunctionFactory,
                        localColorSpaceCache: this._localColorSpaceCache
                      });
                      break;
                    case D.OPS.setFillColor:
                      R.fillColorSpace.getRgbItem(T, 0, R.fontColor, 0);
                      break;
                    case D.OPS.setFillRGBColor:
                      e.ColorSpace.singletons.rgb.getRgbItem(T, 0, R.fontColor, 0);
                      break;
                    case D.OPS.setFillGray:
                      e.ColorSpace.singletons.gray.getRgbItem(T, 0, R.fontColor, 0);
                      break;
                    case D.OPS.setFillCMYKColor:
                      e.ColorSpace.singletons.cmyk.getRgbItem(T, 0, R.fontColor, 0);
                      break;
                    case D.OPS.showText:
                    case D.OPS.showSpacedText:
                    case D.OPS.nextLineShowText:
                    case D.OPS.nextLineSetSpacingShowText:
                      z = !0;
                      break;
                  }
                }
              } catch (g) {
                (0, D.warn)(`parseAppearanceStream - ignoring errors: "${g}".`);
              }
              return this.stream.reset(), delete R.scaleFactor, delete R.fillColorSpace, R;
            }
            get _localColorSpaceCache() {
              return (0, D.shadow)(this, "_localColorSpaceCache", new l.LocalColorSpaceCache());
            }
            get _pdfFunctionFactory() {
              const M = new V.PDFFunctionFactory({
                xref: this.xref,
                isEvalSupported: this.evaluatorOptions.isEvalSupported
              });
              return (0, D.shadow)(this, "_pdfFunctionFactory", M);
            }
          }
          function x(O, M, R) {
            return new f(O, M, R).parse();
          }
          function a(O, M) {
            if (O[0] === O[1] && O[1] === O[2]) {
              const R = O[0] / 255;
              return `${(0, P.numberToString)(R)} ${M ? "g" : "G"}`;
            }
            return Array.from(O, (R) => (0, P.numberToString)(R / 255)).join(" ") + ` ${M ? "rg" : "RG"}`;
          }
          function N({
            fontSize: O,
            fontName: M,
            fontColor: R
          }) {
            return `/${(0, P.escapePDFName)(M)} ${O} Tf ${a(R, !0)}`;
          }
          class p {
            constructor(M, R) {
              this.xref = M, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = R;
              const z = new OffscreenCanvas(1, 1);
              this.ctxMeasure = z.getContext("2d"), p._fontNameId || (p._fontNameId = 1), this.fontName = n.Name.get(`InvalidPDFjsFont_${R}_${p._fontNameId++}`);
            }
            get toUnicodeRef() {
              if (!p._toUnicodeRef) {
                const M = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo
<< /Registry (Adobe)
/Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000> <FFFF>
endcodespacerange
1 beginbfrange
<0000> <FFFF> <0000>
endbfrange
endcmap CMapName currentdict /CMap defineresource pop end end`, R = p.toUnicodeStream = new te.StringStream(M), z = new n.Dict(this.xref);
                R.dict = z, z.set("Length", M.length), p._toUnicodeRef = this.xref.getNewPersistentRef(R);
              }
              return p._toUnicodeRef;
            }
            get fontDescriptorRef() {
              if (!p._fontDescriptorRef) {
                const M = new n.Dict(this.xref);
                M.set("Type", n.Name.get("FontDescriptor")), M.set("FontName", this.fontName), M.set("FontFamily", "MyriadPro Regular"), M.set("FontBBox", [0, 0, 0, 0]), M.set("FontStretch", n.Name.get("Normal")), M.set("FontWeight", 400), M.set("ItalicAngle", 0), p._fontDescriptorRef = this.xref.getNewPersistentRef(M);
              }
              return p._fontDescriptorRef;
            }
            get descendantFontRef() {
              const M = new n.Dict(this.xref);
              M.set("BaseFont", this.fontName), M.set("Type", n.Name.get("Font")), M.set("Subtype", n.Name.get("CIDFontType0")), M.set("CIDToGIDMap", n.Name.get("Identity")), M.set("FirstChar", this.firstChar), M.set("LastChar", this.lastChar), M.set("FontDescriptor", this.fontDescriptorRef), M.set("DW", 1e3);
              const R = [], z = [...this.widths.entries()].sort();
              let W = null, g = null;
              for (const [o, c] of z) {
                if (!W) {
                  W = o, g = [c];
                  continue;
                }
                o === W + g.length ? g.push(c) : (R.push(W, g), W = o, g = [c]);
              }
              W && R.push(W, g), M.set("W", R);
              const T = new n.Dict(this.xref);
              return T.set("Ordering", "Identity"), T.set("Registry", "Adobe"), T.set("Supplement", 0), M.set("CIDSystemInfo", T), this.xref.getNewPersistentRef(M);
            }
            get baseFontRef() {
              const M = new n.Dict(this.xref);
              return M.set("BaseFont", this.fontName), M.set("Type", n.Name.get("Font")), M.set("Subtype", n.Name.get("Type0")), M.set("Encoding", n.Name.get("Identity-H")), M.set("DescendantFonts", [this.descendantFontRef]), M.set("ToUnicode", this.toUnicodeRef), this.xref.getNewPersistentRef(M);
            }
            get resources() {
              const M = new n.Dict(this.xref), R = new n.Dict(this.xref);
              return R.set(this.fontName.name, this.baseFontRef), M.set("Font", R), M;
            }
            _createContext() {
              return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
            }
            createFontResources(M) {
              const R = this._createContext();
              for (const z of M.split(/\r\n?|\n/))
                for (const W of z.split("")) {
                  const g = W.charCodeAt(0);
                  if (this.widths.has(g))
                    continue;
                  const T = R.measureText(W), o = Math.ceil(T.width);
                  this.widths.set(g, o), this.firstChar = Math.min(g, this.firstChar), this.lastChar = Math.max(g, this.lastChar);
                }
              return this.resources;
            }
            createAppearance(M, R, z, W, g, T) {
              const o = this._createContext(), c = [];
              let I = -1 / 0;
              for (const K of M.split(/\r\n?|\n/)) {
                c.push(K);
                const Z = o.measureText(K).width;
                I = Math.max(I, Z);
                for (const w of K.split("")) {
                  const k = w.charCodeAt(0);
                  let X = this.widths.get(k);
                  if (X === void 0) {
                    const H = o.measureText(w);
                    X = Math.ceil(H.width), this.widths.set(k, X), this.firstChar = Math.min(k, this.firstChar), this.lastChar = Math.max(k, this.lastChar);
                  }
                }
              }
              I *= W / 1e3;
              const [s, r, u, C] = R;
              let d = u - s, y = C - r;
              z % 180 !== 0 && ([d, y] = [y, d]);
              let _ = 1;
              I > d && (_ = d / I);
              let $ = 1;
              const S = D.LINE_FACTOR * W, v = D.LINE_DESCENT_FACTOR * W, m = S * c.length;
              m > y && ($ = y / m);
              const h = Math.min(_, $), A = W * h, j = ["q", `0 0 ${(0, P.numberToString)(d)} ${(0, P.numberToString)(y)} re W n`, "BT", `1 0 0 1 0 ${(0, P.numberToString)(y + v)} Tm 0 Tc ${a(g, !0)}`, `/${this.fontName.name} ${(0, P.numberToString)(A)} Tf`], {
                resources: G
              } = this;
              if (T = typeof T == "number" && T >= 0 && T <= 1 ? T : 1, T !== 1) {
                j.push("/R0 gs");
                const K = new n.Dict(this.xref), Z = new n.Dict(this.xref);
                Z.set("ca", T), Z.set("CA", T), Z.set("Type", n.Name.get("ExtGState")), K.set("R0", Z), G.set("ExtGState", K);
              }
              const J = (0, P.numberToString)(S);
              for (const K of c)
                j.push(`0 -${J} Td <${(0, P.stringToUTF16HexString)(K)}> Tj`);
              j.push("ET", "Q");
              const oe = j.join(`
`), q = new n.Dict(this.xref);
              if (q.set("Subtype", n.Name.get("Form")), q.set("Type", n.Name.get("XObject")), q.set("BBox", [0, 0, d, y]), q.set("Length", oe.length), q.set("Resources", G), z) {
                const K = (0, P.getRotationMatrix)(z, d, y);
                q.set("Matrix", K);
              }
              const re = new te.StringStream(oe);
              return re.dict = q, re;
            }
          }
          b.FakeUnicodeFont = p;
        },
        /* 12 */
        /***/
        (Re, b, ce) => {
          var O, Hn, R, zn, W, g, T, o, c, I, s, r, u, sn, d, Zn, _, Qn, S, bn, m, rn, A, on, G, ea, oe, ta, re, na, Z, Gn, X, yn, Y, wn, ne, qn;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ColorSpace = void 0;
          var n = ce(2), P = ce(4), D = ce(5), e = ce(3);
          function t(ae, Q, L, ee, se, le, ue) {
            ue = ue !== 1 ? 0 : ue;
            const ge = L / se, me = ee / le;
            let pe = 0, xe;
            const we = new Uint16Array(se), Ae = L * 3;
            for (let be = 0; be < se; be++)
              we[be] = Math.floor(be * ge) * 3;
            for (let be = 0; be < le; be++) {
              const he = Math.floor(be * me) * Ae;
              for (let fe = 0; fe < se; fe++)
                xe = he + we[fe], Q[pe++] = ae[xe++], Q[pe++] = ae[xe++], Q[pe++] = ae[xe++], pe += ue;
            }
          }
          class l {
            constructor(Q, L) {
              this.constructor === l && (0, n.unreachable)("Cannot initialize ColorSpace."), this.name = Q, this.numComps = L;
            }
            getRgb(Q, L) {
              const ee = new Uint8ClampedArray(3);
              return this.getRgbItem(Q, L, ee, 0), ee;
            }
            getRgbItem(Q, L, ee, se) {
              (0, n.unreachable)("Should not call ColorSpace.getRgbItem");
            }
            getRgbBuffer(Q, L, ee, se, le, ue, de) {
              (0, n.unreachable)("Should not call ColorSpace.getRgbBuffer");
            }
            getOutputLength(Q, L) {
              (0, n.unreachable)("Should not call ColorSpace.getOutputLength");
            }
            isPassthrough(Q) {
              return !1;
            }
            isDefaultDecode(Q, L) {
              return l.isDefaultDecode(Q, this.numComps);
            }
            fillRgb(Q, L, ee, se, le, ue, de, ge, me) {
              const pe = L * ee;
              let xe = null;
              const we = 1 << de, Ae = ee !== le || L !== se;
              if (this.isPassthrough(de))
                xe = ge;
              else if (this.numComps === 1 && pe > we && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                const be = de <= 8 ? new Uint8Array(we) : new Uint16Array(we);
                for (let fe = 0; fe < we; fe++)
                  be[fe] = fe;
                const he = new Uint8ClampedArray(we * 3);
                if (this.getRgbBuffer(be, 0, we, he, 0, de, 0), Ae) {
                  xe = new Uint8Array(pe * 3);
                  let fe = 0;
                  for (let Ce = 0; Ce < pe; ++Ce) {
                    const ye = ge[Ce] * 3;
                    xe[fe++] = he[ye], xe[fe++] = he[ye + 1], xe[fe++] = he[ye + 2];
                  }
                } else {
                  let fe = 0;
                  for (let Ce = 0; Ce < pe; ++Ce) {
                    const ye = ge[Ce] * 3;
                    Q[fe++] = he[ye], Q[fe++] = he[ye + 1], Q[fe++] = he[ye + 2], fe += me;
                  }
                }
              } else
                Ae ? (xe = new Uint8ClampedArray(pe * 3), this.getRgbBuffer(ge, 0, pe, xe, 0, de, 0)) : this.getRgbBuffer(ge, 0, se * ue, Q, 0, de, me);
              if (xe)
                if (Ae)
                  t(xe, Q, L, ee, se, le, me);
                else {
                  let be = 0, he = 0;
                  for (let fe = 0, Ce = se * ue; fe < Ce; fe++)
                    Q[be++] = xe[he++], Q[be++] = xe[he++], Q[be++] = xe[he++], be += me;
                }
            }
            get usesZeroToOneRange() {
              return (0, n.shadow)(this, "usesZeroToOneRange", !0);
            }
            static _cache(Q, L, ee, se) {
              if (!ee)
                throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
              if (!se)
                throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
              let le, ue;
              Q instanceof P.Ref && (ue = Q, Q = L.fetch(Q)), Q instanceof P.Name && (le = Q.name), (le || ue) && ee.set(le, ue, se);
            }
            static getCached(Q, L, ee) {
              if (!ee)
                throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
              if (Q instanceof P.Ref) {
                const se = ee.getByRef(Q);
                if (se)
                  return se;
                try {
                  Q = L.fetch(Q);
                } catch (le) {
                  if (le instanceof e.MissingDataException)
                    throw le;
                }
              }
              if (Q instanceof P.Name) {
                const se = ee.getByName(Q.name);
                if (se)
                  return se;
              }
              return null;
            }
            static async parseAsync({
              cs: Q,
              xref: L,
              resources: ee = null,
              pdfFunctionFactory: se,
              localColorSpaceCache: le
            }) {
              const ue = this._parse(Q, L, ee, se);
              return this._cache(Q, L, le, ue), ue;
            }
            static parse({
              cs: Q,
              xref: L,
              resources: ee = null,
              pdfFunctionFactory: se,
              localColorSpaceCache: le
            }) {
              const ue = this.getCached(Q, L, le);
              if (ue)
                return ue;
              const de = this._parse(Q, L, ee, se);
              return this._cache(Q, L, le, de), de;
            }
            static _parse(Q, L, ee = null, se) {
              if (Q = L.fetchIfRef(Q), Q instanceof P.Name)
                switch (Q.name) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "Pattern":
                    return new te(null);
                  default:
                    if (ee instanceof P.Dict) {
                      const le = ee.get("ColorSpace");
                      if (le instanceof P.Dict) {
                        const ue = le.get(Q.name);
                        if (ue) {
                          if (ue instanceof P.Name)
                            return this._parse(ue, L, ee, se);
                          Q = ue;
                          break;
                        }
                      }
                    }
                    throw new n.FormatError(`Unrecognized ColorSpace: ${Q.name}`);
                }
              if (Array.isArray(Q)) {
                const le = L.fetchIfRef(Q[0]).name;
                let ue, de, ge, me, pe, xe;
                switch (le) {
                  case "G":
                  case "DeviceGray":
                    return this.singletons.gray;
                  case "RGB":
                  case "DeviceRGB":
                    return this.singletons.rgb;
                  case "CMYK":
                  case "DeviceCMYK":
                    return this.singletons.cmyk;
                  case "CalGray":
                    return ue = L.fetchIfRef(Q[1]), me = ue.getArray("WhitePoint"), pe = ue.getArray("BlackPoint"), xe = ue.get("Gamma"), new a(me, pe, xe);
                  case "CalRGB":
                    ue = L.fetchIfRef(Q[1]), me = ue.getArray("WhitePoint"), pe = ue.getArray("BlackPoint"), xe = ue.getArray("Gamma");
                    const we = ue.getArray("Matrix");
                    return new N(me, pe, xe, we);
                  case "ICCBased":
                    const be = L.fetchIfRef(Q[1]).dict;
                    de = be.get("N");
                    const he = be.get("Alternate");
                    if (he) {
                      const nt = this._parse(he, L, ee, se);
                      if (nt.numComps === de)
                        return nt;
                      (0, n.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                    }
                    if (de === 1)
                      return this.singletons.gray;
                    if (de === 3)
                      return this.singletons.rgb;
                    if (de === 4)
                      return this.singletons.cmyk;
                    break;
                  case "Pattern":
                    return ge = Q[1] || null, ge && (ge = this._parse(ge, L, ee, se)), new te(ge);
                  case "I":
                  case "Indexed":
                    ge = this._parse(Q[1], L, ee, se);
                    const fe = L.fetchIfRef(Q[2]) + 1, Ce = L.fetchIfRef(Q[3]);
                    return new E(ge, fe, Ce);
                  case "Separation":
                  case "DeviceN":
                    const ye = L.fetchIfRef(Q[1]);
                    de = Array.isArray(ye) ? ye.length : 1, ge = this._parse(Q[2], L, ee, se);
                    const Le = se.create(Q[3]);
                    return new V(de, ge, Le);
                  case "Lab":
                    ue = L.fetchIfRef(Q[1]), me = ue.getArray("WhitePoint"), pe = ue.getArray("BlackPoint");
                    const Be = ue.getArray("Range");
                    return new p(me, pe, Be);
                  default:
                    throw new n.FormatError(`Unimplemented ColorSpace object: ${le}`);
                }
              }
              throw new n.FormatError(`Unrecognized ColorSpace object: ${Q}`);
            }
            static isDefaultDecode(Q, L) {
              if (!Array.isArray(Q))
                return !0;
              if (L * 2 !== Q.length)
                return (0, n.warn)("The decode map is not the correct length"), !0;
              for (let ee = 0, se = Q.length; ee < se; ee += 2)
                if (Q[ee] !== 0 || Q[ee + 1] !== 1)
                  return !1;
              return !0;
            }
            static get singletons() {
              return (0, n.shadow)(this, "singletons", {
                get gray() {
                  return (0, n.shadow)(this, "gray", new F());
                },
                get rgb() {
                  return (0, n.shadow)(this, "rgb", new f());
                },
                get cmyk() {
                  return (0, n.shadow)(this, "cmyk", new x());
                }
              });
            }
          }
          b.ColorSpace = l;
          class V extends l {
            constructor(Q, L, ee) {
              super("Alternate", Q), this.base = L, this.tintFn = ee, this.tmpBuf = new Float32Array(L.numComps);
            }
            getRgbItem(Q, L, ee, se) {
              const le = this.tmpBuf;
              this.tintFn(Q, L, le, 0), this.base.getRgbItem(le, 0, ee, se);
            }
            getRgbBuffer(Q, L, ee, se, le, ue, de) {
              const ge = this.tintFn, me = this.base, pe = 1 / ((1 << ue) - 1), xe = me.numComps, we = me.usesZeroToOneRange, Ae = (me.isPassthrough(8) || !we) && de === 0;
              let be = Ae ? le : 0;
              const he = Ae ? se : new Uint8ClampedArray(xe * ee), fe = this.numComps, Ce = new Float32Array(fe), ye = new Float32Array(xe);
              let Le, Be;
              for (Le = 0; Le < ee; Le++) {
                for (Be = 0; Be < fe; Be++)
                  Ce[Be] = Q[L++] * pe;
                if (ge(Ce, 0, ye, 0), we)
                  for (Be = 0; Be < xe; Be++)
                    he[be++] = ye[Be] * 255;
                else
                  me.getRgbItem(ye, 0, he, be), be += xe;
              }
              Ae || me.getRgbBuffer(he, 0, ee, se, le, 8, de);
            }
            getOutputLength(Q, L) {
              return this.base.getOutputLength(Q * this.base.numComps / this.numComps, L);
            }
          }
          class te extends l {
            constructor(Q) {
              super("Pattern", null), this.base = Q;
            }
            isDefaultDecode(Q, L) {
              (0, n.unreachable)("Should not call PatternCS.isDefaultDecode");
            }
          }
          class E extends l {
            constructor(Q, L, ee) {
              super("Indexed", 1), this.base = Q, this.highVal = L;
              const se = Q.numComps * L;
              if (this.lookup = new Uint8Array(se), ee instanceof D.BaseStream) {
                const le = ee.getBytes(se);
                this.lookup.set(le);
              } else if (typeof ee == "string")
                for (let le = 0; le < se; ++le)
                  this.lookup[le] = ee.charCodeAt(le) & 255;
              else
                throw new n.FormatError(`IndexedCS - unrecognized lookup table: ${ee}`);
            }
            getRgbItem(Q, L, ee, se) {
              const le = this.base.numComps, ue = Q[L] * le;
              this.base.getRgbBuffer(this.lookup, ue, 1, ee, se, 8, 0);
            }
            getRgbBuffer(Q, L, ee, se, le, ue, de) {
              const ge = this.base, me = ge.numComps, pe = ge.getOutputLength(me, de), xe = this.lookup;
              for (let we = 0; we < ee; ++we) {
                const Ae = Q[L++] * me;
                ge.getRgbBuffer(xe, Ae, 1, se, le, 8, de), le += pe;
              }
            }
            getOutputLength(Q, L) {
              return this.base.getOutputLength(Q * this.base.numComps, L);
            }
            isDefaultDecode(Q, L) {
              return Array.isArray(Q) ? Q.length !== 2 ? ((0, n.warn)("Decode map length is not correct"), !0) : !Number.isInteger(L) || L < 1 ? ((0, n.warn)("Bits per component is not correct"), !0) : Q[0] === 0 && Q[1] === (1 << L) - 1 : !0;
            }
          }
          class F extends l {
            constructor() {
              super("DeviceGray", 1);
            }
            getRgbItem(Q, L, ee, se) {
              const le = Q[L] * 255;
              ee[se] = ee[se + 1] = ee[se + 2] = le;
            }
            getRgbBuffer(Q, L, ee, se, le, ue, de) {
              const ge = 255 / ((1 << ue) - 1);
              let me = L, pe = le;
              for (let xe = 0; xe < ee; ++xe) {
                const we = ge * Q[me++];
                se[pe++] = we, se[pe++] = we, se[pe++] = we, pe += de;
              }
            }
            getOutputLength(Q, L) {
              return Q * (3 + L);
            }
          }
          class f extends l {
            constructor() {
              super("DeviceRGB", 3);
            }
            getRgbItem(Q, L, ee, se) {
              ee[se] = Q[L] * 255, ee[se + 1] = Q[L + 1] * 255, ee[se + 2] = Q[L + 2] * 255;
            }
            getRgbBuffer(Q, L, ee, se, le, ue, de) {
              if (ue === 8 && de === 0) {
                se.set(Q.subarray(L, L + ee * 3), le);
                return;
              }
              const ge = 255 / ((1 << ue) - 1);
              let me = L, pe = le;
              for (let xe = 0; xe < ee; ++xe)
                se[pe++] = ge * Q[me++], se[pe++] = ge * Q[me++], se[pe++] = ge * Q[me++], pe += de;
            }
            getOutputLength(Q, L) {
              return Q * (3 + L) / 3 | 0;
            }
            isPassthrough(Q) {
              return Q === 8;
            }
          }
          class x extends l {
            constructor() {
              super("DeviceCMYK", 4);
              At(this, O);
            }
            getRgbItem(L, ee, se, le) {
              it(this, O, Hn).call(this, L, ee, 1, se, le);
            }
            getRgbBuffer(L, ee, se, le, ue, de, ge) {
              const me = 1 / ((1 << de) - 1);
              for (let pe = 0; pe < se; pe++)
                it(this, O, Hn).call(this, L, ee, me, le, ue), ee += 4, ue += 3 + ge;
            }
            getOutputLength(L, ee) {
              return L / 4 * (3 + ee) | 0;
            }
          }
          O = new WeakSet(), Hn = function(L, ee, se, le, ue) {
            const de = L[ee] * se, ge = L[ee + 1] * se, me = L[ee + 2] * se, pe = L[ee + 3] * se;
            le[ue] = 255 + de * (-4.387332384609988 * de + 54.48615194189176 * ge + 18.82290502165302 * me + 212.25662451639585 * pe + -285.2331026137004) + ge * (1.7149763477362134 * ge - 5.6096736904047315 * me + -17.873870861415444 * pe - 5.497006427196366) + me * (-2.5217340131683033 * me - 21.248923337353073 * pe + 17.5119270841813) + pe * (-21.86122147463605 * pe - 189.48180835922747), le[ue + 1] = 255 + de * (8.841041422036149 * de + 60.118027045597366 * ge + 6.871425592049007 * me + 31.159100130055922 * pe + -79.2970844816548) + ge * (-15.310361306967817 * ge + 17.575251261109482 * me + 131.35250912493976 * pe - 190.9453302588951) + me * (4.444339102852739 * me + 9.8632861493405 * pe - 24.86741582555878) + pe * (-20.737325471181034 * pe - 187.80453709719578), le[ue + 2] = 255 + de * (0.8842522430003296 * de + 8.078677503112928 * ge + 30.89978309703729 * me - 0.23883238689178934 * pe + -14.183576799673286) + ge * (10.49593273432072 * ge + 63.02378494754052 * me + 50.606957656360734 * pe - 112.23884253719248) + me * (0.03296041114873217 * me + 115.60384449646641 * pe + -193.58209356861505) + pe * (-22.33816807309886 * pe - 180.12613974708367);
          };
          class a extends l {
            constructor(L, ee, se) {
              super("CalGray", 1);
              At(this, R);
              if (!L)
                throw new n.FormatError("WhitePoint missing - required for color space CalGray");
              if ([this.XW, this.YW, this.ZW] = L, [this.XB, this.YB, this.ZB] = ee || [0, 0, 0], this.G = se || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                throw new n.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
              (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, n.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && (0, n.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && ((0, n.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
            }
            getRgbItem(L, ee, se, le) {
              it(this, R, zn).call(this, L, ee, se, le, 1);
            }
            getRgbBuffer(L, ee, se, le, ue, de, ge) {
              const me = 1 / ((1 << de) - 1);
              for (let pe = 0; pe < se; ++pe)
                it(this, R, zn).call(this, L, ee, le, ue, me), ee += 1, ue += 3 + ge;
            }
            getOutputLength(L, ee) {
              return L * (3 + ee);
            }
          }
          R = new WeakSet(), zn = function(L, ee, se, le, ue) {
            const ge = (L[ee] * ue) ** this.G, me = this.YW * ge, pe = Math.max(295.8 * me ** 0.3333333333333333 - 40.8, 0);
            se[le] = pe, se[le + 1] = pe, se[le + 2] = pe;
          };
          const k = class k extends l {
            constructor(L, ee, se, le) {
              super("CalRGB", 3);
              At(this, u);
              At(this, d);
              At(this, _);
              At(this, S);
              At(this, m);
              At(this, A);
              At(this, G);
              At(this, oe);
              At(this, re);
              At(this, Z);
              if (!L)
                throw new n.FormatError("WhitePoint missing - required for color space CalRGB");
              const [ue, de, ge] = this.whitePoint = L, [me, pe, xe] = this.blackPoint = ee || new Float32Array(3);
              if ([this.GR, this.GG, this.GB] = se || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = le || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), ue < 0 || ge < 0 || de !== 1)
                throw new n.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
              (me < 0 || pe < 0 || xe < 0) && ((0, n.info)(`Invalid BlackPoint for ${this.name} [${me}, ${pe}, ${xe}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && ((0, n.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
            }
            getRgbItem(L, ee, se, le) {
              it(this, Z, Gn).call(this, L, ee, se, le, 1);
            }
            getRgbBuffer(L, ee, se, le, ue, de, ge) {
              const me = 1 / ((1 << de) - 1);
              for (let pe = 0; pe < se; ++pe)
                it(this, Z, Gn).call(this, L, ee, le, ue, me), ee += 3, ue += 3 + ge;
            }
            getOutputLength(L, ee) {
              return L * (3 + ee) / 3 | 0;
            }
          };
          W = new WeakMap(), g = new WeakMap(), T = new WeakMap(), o = new WeakMap(), c = new WeakMap(), I = new WeakMap(), s = new WeakMap(), r = new WeakMap(), u = new WeakSet(), sn = function(L, ee, se) {
            se[0] = L[0] * ee[0] + L[1] * ee[1] + L[2] * ee[2], se[1] = L[3] * ee[0] + L[4] * ee[1] + L[5] * ee[2], se[2] = L[6] * ee[0] + L[7] * ee[1] + L[8] * ee[2];
          }, d = new WeakSet(), Zn = function(L, ee, se) {
            se[0] = ee[0] * 1 / L[0], se[1] = ee[1] * 1 / L[1], se[2] = ee[2] * 1 / L[2];
          }, _ = new WeakSet(), Qn = function(L, ee, se) {
            se[0] = ee[0] * 0.95047 / L[0], se[1] = ee[1] * 1 / L[1], se[2] = ee[2] * 1.08883 / L[2];
          }, S = new WeakSet(), bn = function(L) {
            return L <= 31308e-7 ? it(this, m, rn).call(this, 0, 1, 12.92 * L) : L >= 0.99554525 ? 1 : it(this, m, rn).call(this, 0, 1, 1.055 * L ** 0.4166666666666667 - 0.055);
          }, m = new WeakSet(), rn = function(L, ee, se) {
            return Math.max(L, Math.min(ee, se));
          }, A = new WeakSet(), on = function(L) {
            return L < 0 ? -it(this, A, on).call(this, -L) : L > 8 ? ((L + 16) / 116) ** 3 : L * Lt(k, r);
          }, G = new WeakSet(), ea = function(L, ee, se) {
            if (L[0] === 0 && L[1] === 0 && L[2] === 0) {
              se[0] = ee[0], se[1] = ee[1], se[2] = ee[2];
              return;
            }
            const le = it(this, A, on).call(this, 0), ue = le, de = it(this, A, on).call(this, L[0]), ge = le, me = it(this, A, on).call(this, L[1]), pe = le, xe = it(this, A, on).call(this, L[2]), we = (1 - ue) / (1 - de), Ae = 1 - we, be = (1 - ge) / (1 - me), he = 1 - be, fe = (1 - pe) / (1 - xe), Ce = 1 - fe;
            se[0] = ee[0] * we + Ae, se[1] = ee[1] * be + he, se[2] = ee[2] * fe + Ce;
          }, oe = new WeakSet(), ta = function(L, ee, se) {
            if (L[0] === 1 && L[2] === 1) {
              se[0] = ee[0], se[1] = ee[1], se[2] = ee[2];
              return;
            }
            const le = se;
            it(this, u, sn).call(this, Lt(k, W), ee, le);
            const ue = Lt(k, c);
            it(this, d, Zn).call(this, L, le, ue), it(this, u, sn).call(this, Lt(k, g), ue, se);
          }, re = new WeakSet(), na = function(L, ee, se) {
            const le = se;
            it(this, u, sn).call(this, Lt(k, W), ee, le);
            const ue = Lt(k, c);
            it(this, _, Qn).call(this, L, le, ue), it(this, u, sn).call(this, Lt(k, g), ue, se);
          }, Z = new WeakSet(), Gn = function(L, ee, se, le, ue) {
            const de = it(this, m, rn).call(this, 0, 1, L[ee] * ue), ge = it(this, m, rn).call(this, 0, 1, L[ee + 1] * ue), me = it(this, m, rn).call(this, 0, 1, L[ee + 2] * ue), pe = de === 1 ? 1 : de ** this.GR, xe = ge === 1 ? 1 : ge ** this.GG, we = me === 1 ? 1 : me ** this.GB, Ae = this.MXA * pe + this.MXB * xe + this.MXC * we, be = this.MYA * pe + this.MYB * xe + this.MYC * we, he = this.MZA * pe + this.MZB * xe + this.MZC * we, fe = Lt(k, I);
            fe[0] = Ae, fe[1] = be, fe[2] = he;
            const Ce = Lt(k, s);
            it(this, oe, ta).call(this, this.whitePoint, fe, Ce);
            const ye = Lt(k, I);
            it(this, G, ea).call(this, this.blackPoint, Ce, ye);
            const Le = Lt(k, s);
            it(this, re, na).call(this, Lt(k, o), ye, Le);
            const Be = Lt(k, I);
            it(this, u, sn).call(this, Lt(k, T), Le, Be), se[le] = it(this, S, bn).call(this, Be[0]) * 255, se[le + 1] = it(this, S, bn).call(this, Be[1]) * 255, se[le + 2] = it(this, S, bn).call(this, Be[2]) * 255;
          }, At(k, W, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296])), At(k, g, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867])), At(k, T, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252])), At(k, o, new Float32Array([1, 1, 1])), At(k, c, new Float32Array(3)), At(k, I, new Float32Array(3)), At(k, s, new Float32Array(3)), At(k, r, 0.0011070564598794539);
          let N = k;
          class p extends l {
            constructor(L, ee, se) {
              super("Lab", 3);
              At(this, X);
              At(this, Y);
              At(this, ne);
              if (!L)
                throw new n.FormatError("WhitePoint missing - required for color space Lab");
              if ([this.XW, this.YW, this.ZW] = L, [this.amin, this.amax, this.bmin, this.bmax] = se || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = ee || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
                throw new n.FormatError("Invalid WhitePoint components, no fallback available");
              (this.XB < 0 || this.YB < 0 || this.ZB < 0) && ((0, n.info)("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && ((0, n.info)("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
            }
            getRgbItem(L, ee, se, le) {
              it(this, ne, qn).call(this, L, ee, !1, se, le);
            }
            getRgbBuffer(L, ee, se, le, ue, de, ge) {
              const me = (1 << de) - 1;
              for (let pe = 0; pe < se; pe++)
                it(this, ne, qn).call(this, L, ee, me, le, ue), ee += 3, ue += 3 + ge;
            }
            getOutputLength(L, ee) {
              return L * (3 + ee) / 3 | 0;
            }
            isDefaultDecode(L, ee) {
              return !0;
            }
            get usesZeroToOneRange() {
              return (0, n.shadow)(this, "usesZeroToOneRange", !1);
            }
          }
          X = new WeakSet(), yn = function(L) {
            return L >= 0.20689655172413793 ? L ** 3 : 0.12841854934601665 * (L - 0.13793103448275862);
          }, Y = new WeakSet(), wn = function(L, ee, se, le) {
            return se + L * (le - se) / ee;
          }, ne = new WeakSet(), qn = function(L, ee, se, le, ue) {
            let de = L[ee], ge = L[ee + 1], me = L[ee + 2];
            se !== !1 && (de = it(this, Y, wn).call(this, de, se, 0, 100), ge = it(this, Y, wn).call(this, ge, se, this.amin, this.amax), me = it(this, Y, wn).call(this, me, se, this.bmin, this.bmax)), ge > this.amax ? ge = this.amax : ge < this.amin && (ge = this.amin), me > this.bmax ? me = this.bmax : me < this.bmin && (me = this.bmin);
            const pe = (de + 16) / 116, xe = pe + ge / 500, we = pe - me / 200, Ae = this.XW * it(this, X, yn).call(this, xe), be = this.YW * it(this, X, yn).call(this, pe), he = this.ZW * it(this, X, yn).call(this, we);
            let fe, Ce, ye;
            this.ZW < 1 ? (fe = Ae * 3.1339 + be * -1.617 + he * -0.4906, Ce = Ae * -0.9785 + be * 1.916 + he * 0.0333, ye = Ae * 0.072 + be * -0.229 + he * 1.4057) : (fe = Ae * 3.2406 + be * -1.5372 + he * -0.4986, Ce = Ae * -0.9689 + be * 1.8758 + he * 0.0415, ye = Ae * 0.0557 + be * -0.204 + he * 1.057), le[ue] = Math.sqrt(fe) * 255, le[ue + 1] = Math.sqrt(Ce) * 255, le[ue + 2] = Math.sqrt(ye) * 255;
          };
        },
        /* 13 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PartialEvaluator = b.EvaluatorPreprocessor = void 0;
          var n = ce(2), P = ce(14), D = ce(4), e = ce(34), t = ce(37), l = ce(41), V = ce(50), te = ce(51), E = ce(42), F = ce(57), f = ce(16), x = ce(59), a = ce(8), N = ce(5), p = ce(60), O = ce(12), M = ce(18), R = ce(38), z = ce(61), W = ce(39), g = ce(45), T = ce(40), o = ce(62), c = ce(63), I = ce(64), s = ce(65);
          const r = Object.freeze({
            maxImageSize: -1,
            disableFontFace: !1,
            ignoreErrors: !1,
            isEvalSupported: !0,
            isOffscreenCanvasSupported: !1,
            canvasMaxAreaInBytes: -1,
            fontExtraProperties: !1,
            useSystemFonts: !0,
            cMapUrl: null,
            standardFontDataUrl: null
          }), u = {
            TILING: 1,
            SHADING: 2
          }, C = 10, d = Promise.resolve();
          function y(oe, q = !1) {
            if (Array.isArray(oe)) {
              for (const re of oe) {
                const K = y(re, !0);
                if (K)
                  return K;
              }
              return (0, n.warn)(`Unsupported blend mode Array: ${oe}`), "source-over";
            }
            if (!(oe instanceof D.Name))
              return q ? null : "source-over";
            switch (oe.name) {
              case "Normal":
              case "Compatible":
                return "source-over";
              case "Multiply":
                return "multiply";
              case "Screen":
                return "screen";
              case "Overlay":
                return "overlay";
              case "Darken":
                return "darken";
              case "Lighten":
                return "lighten";
              case "ColorDodge":
                return "color-dodge";
              case "ColorBurn":
                return "color-burn";
              case "HardLight":
                return "hard-light";
              case "SoftLight":
                return "soft-light";
              case "Difference":
                return "difference";
              case "Exclusion":
                return "exclusion";
              case "Hue":
                return "hue";
              case "Saturation":
                return "saturation";
              case "Color":
                return "color";
              case "Luminosity":
                return "luminosity";
            }
            return q ? null : ((0, n.warn)(`Unsupported blend mode: ${oe.name}`), "source-over");
          }
          function _(oe) {
            var q;
            oe.fn === n.OPS.paintImageMaskXObject && ((q = oe.args[0]) == null ? void 0 : q.count) > 0 && oe.args[0].count++;
          }
          const G = class G {
            constructor() {
              this.reset();
            }
            check() {
              return ++this.checked < G.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
            }
            reset() {
              this.endTime = Date.now() + G.TIME_SLOT_DURATION_MS, this.checked = 0;
            }
          };
          Ut(G, "TIME_SLOT_DURATION_MS", 20), Ut(G, "CHECK_TIME_EVERY", 100);
          let $ = G;
          class S {
            constructor({
              xref: q,
              handler: re,
              pageIndex: K,
              idFactory: Z,
              fontCache: w,
              builtInCMapCache: k,
              standardFontDataCache: X,
              globalImageCache: H,
              systemFontCache: Y,
              options: ie = null
            }) {
              this.xref = q, this.handler = re, this.pageIndex = K, this.idFactory = Z, this.fontCache = w, this.builtInCMapCache = k, this.standardFontDataCache = X, this.globalImageCache = H, this.systemFontCache = Y, this.options = ie || r, this.parsingType3Font = !1, this._regionalImageCache = new x.RegionalImageCache(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), o.ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes);
            }
            get _pdfFunctionFactory() {
              const q = new F.PDFFunctionFactory({
                xref: this.xref,
                isEvalSupported: this.options.isEvalSupported
              });
              return (0, n.shadow)(this, "_pdfFunctionFactory", q);
            }
            clone(q = null) {
              const re = Object.create(this);
              return re.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, q), re;
            }
            hasBlendModes(q, re) {
              if (!(q instanceof D.Dict) || q.objId && re.has(q.objId))
                return !1;
              const K = new D.RefSet(re);
              q.objId && K.put(q.objId);
              const Z = [q], w = this.xref;
              for (; Z.length; ) {
                const k = Z.shift(), X = k.get("ExtGState");
                if (X instanceof D.Dict)
                  for (let Y of X.getRawValues()) {
                    if (Y instanceof D.Ref) {
                      if (K.has(Y))
                        continue;
                      try {
                        Y = w.fetch(Y);
                      } catch (ne) {
                        K.put(Y), (0, n.info)(`hasBlendModes - ignoring ExtGState: "${ne}".`);
                        continue;
                      }
                    }
                    if (!(Y instanceof D.Dict))
                      continue;
                    Y.objId && K.put(Y.objId);
                    const ie = Y.get("BM");
                    if (ie instanceof D.Name) {
                      if (ie.name !== "Normal")
                        return !0;
                      continue;
                    }
                    if (ie !== void 0 && Array.isArray(ie)) {
                      for (const ne of ie)
                        if (ne instanceof D.Name && ne.name !== "Normal")
                          return !0;
                    }
                  }
                const H = k.get("XObject");
                if (H instanceof D.Dict)
                  for (let Y of H.getRawValues()) {
                    if (Y instanceof D.Ref) {
                      if (K.has(Y))
                        continue;
                      try {
                        Y = w.fetch(Y);
                      } catch (ne) {
                        K.put(Y), (0, n.info)(`hasBlendModes - ignoring XObject: "${ne}".`);
                        continue;
                      }
                    }
                    if (!(Y instanceof N.BaseStream))
                      continue;
                    Y.dict.objId && K.put(Y.dict.objId);
                    const ie = Y.dict.get("Resources");
                    ie instanceof D.Dict && (ie.objId && K.has(ie.objId) || (Z.push(ie), ie.objId && K.put(ie.objId)));
                  }
              }
              for (const k of K)
                re.put(k);
              return !1;
            }
            async fetchBuiltInCMap(q) {
              const re = this.builtInCMapCache.get(q);
              if (re)
                return re;
              let K;
              if (this.options.cMapUrl !== null) {
                const Z = `${this.options.cMapUrl}${q}.bcmap`, w = await fetch(Z);
                if (!w.ok)
                  throw new Error(`fetchBuiltInCMap: failed to fetch file "${Z}" with "${w.statusText}".`);
                K = {
                  cMapData: new Uint8Array(await w.arrayBuffer()),
                  compressionType: n.CMapCompressionType.BINARY
                };
              } else
                K = await this.handler.sendWithPromise("FetchBuiltInCMap", {
                  name: q
                });
              return K.compressionType !== n.CMapCompressionType.NONE && this.builtInCMapCache.set(q, K), K;
            }
            async fetchStandardFontData(q) {
              const re = this.standardFontDataCache.get(q);
              if (re)
                return new a.Stream(re);
              if (this.options.useSystemFonts && q !== "Symbol" && q !== "ZapfDingbats")
                return null;
              const K = (0, l.getFontNameToFileMap)(), Z = K[q];
              let w;
              if (this.options.standardFontDataUrl !== null) {
                const k = `${this.options.standardFontDataUrl}${Z}`, X = await fetch(k);
                X.ok ? w = await X.arrayBuffer() : (0, n.warn)(`fetchStandardFontData: failed to fetch file "${k}" with "${X.statusText}".`);
              } else
                try {
                  w = await this.handler.sendWithPromise("FetchStandardFontData", {
                    filename: Z
                  });
                } catch (k) {
                  (0, n.warn)(`fetchStandardFontData: failed to fetch file "${Z}" with "${k}".`);
                }
              return w ? (this.standardFontDataCache.set(q, w), new a.Stream(w)) : null;
            }
            async buildFormXObject(q, re, K, Z, w, k, X) {
              const H = re.dict, Y = H.getArray("Matrix");
              let ie = H.getArray("BBox");
              ie = Array.isArray(ie) && ie.length === 4 ? n.Util.normalizeRect(ie) : null;
              let ne, U;
              H.has("OC") && (ne = await this.parseMarkedContentProps(H.get("OC"), q)), ne !== void 0 && Z.addOp(n.OPS.beginMarkedContentProps, ["OC", ne]);
              const ae = H.get("Group");
              if (ae) {
                U = {
                  matrix: Y,
                  bbox: ie,
                  smask: K,
                  isolated: !1,
                  knockout: !1
                };
                const L = ae.get("S");
                let ee = null;
                if ((0, D.isName)(L, "Transparency") && (U.isolated = ae.get("I") || !1, U.knockout = ae.get("K") || !1, ae.has("CS"))) {
                  const se = ae.getRaw("CS"), le = O.ColorSpace.getCached(se, this.xref, X);
                  le ? ee = le : ee = await this.parseColorSpace({
                    cs: se,
                    resources: q,
                    localColorSpaceCache: X
                  });
                }
                K != null && K.backdrop && (ee || (ee = O.ColorSpace.singletons.rgb), K.backdrop = ee.getRgb(K.backdrop, 0)), Z.addOp(n.OPS.beginGroup, [U]);
              }
              const Q = ae ? [Y, null] : [Y, ie];
              return Z.addOp(n.OPS.paintFormXObjectBegin, Q), this.getOperatorList({
                stream: re,
                task: w,
                resources: H.get("Resources") || q,
                operatorList: Z,
                initialState: k
              }).then(function() {
                Z.addOp(n.OPS.paintFormXObjectEnd, []), ae && Z.addOp(n.OPS.endGroup, [U]), ne !== void 0 && Z.addOp(n.OPS.endMarkedContent, []);
              });
            }
            _sendImgData(q, re, K = !1) {
              const Z = re ? [re.bitmap || re.data.buffer] : null;
              return this.parsingType3Font || K ? this.handler.send("commonobj", [q, "Image", re], Z) : this.handler.send("obj", [q, this.pageIndex, "Image", re], Z);
            }
            async buildPaintImageXObject({
              resources: q,
              image: re,
              isInline: K = !1,
              operatorList: Z,
              cacheKey: w,
              localImageCache: k,
              localColorSpaceCache: X
            }) {
              const H = re.dict, Y = H.objId, ie = H.get("W", "Width"), ne = H.get("H", "Height");
              if (!(ie && typeof ie == "number") || !(ne && typeof ne == "number")) {
                (0, n.warn)("Image dimensions are missing, or not numbers.");
                return;
              }
              const U = this.options.maxImageSize;
              if (U !== -1 && ie * ne > U) {
                const de = "Image exceeded maximum allowed size and was removed.";
                if (this.options.ignoreErrors) {
                  (0, n.warn)(de);
                  return;
                }
                throw new Error(de);
              }
              let ae;
              H.has("OC") && (ae = await this.parseMarkedContentProps(H.get("OC"), q));
              const Q = H.get("IM", "ImageMask") || !1;
              let L, ee;
              if (Q) {
                const de = H.get("I", "Interpolate"), ge = ie + 7 >> 3, me = re.getBytes(ge * ne), pe = H.getArray("D", "Decode");
                if (this.parsingType3Font) {
                  if (L = s.PDFImage.createRawMask({
                    imgArray: me,
                    width: ie,
                    height: ne,
                    imageIsFromDecodeStream: re instanceof M.DecodeStream,
                    inverseDecode: (pe == null ? void 0 : pe[0]) > 0,
                    interpolate: de
                  }), L.cached = !!w, ee = [L], Z.addImageOps(n.OPS.paintImageMaskXObject, ee, ae), w) {
                    const we = {
                      fn: n.OPS.paintImageMaskXObject,
                      args: ee,
                      optionalContent: ae
                    };
                    k.set(w, Y, we), Y && this._regionalImageCache.set(null, Y, we);
                  }
                  return;
                }
                if (L = await s.PDFImage.createMask({
                  imgArray: me,
                  width: ie,
                  height: ne,
                  imageIsFromDecodeStream: re instanceof M.DecodeStream,
                  inverseDecode: (pe == null ? void 0 : pe[0]) > 0,
                  interpolate: de,
                  isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
                }), L.isSingleOpaquePixel) {
                  if (Z.addImageOps(n.OPS.paintSolidColorImageMask, [], ae), w) {
                    const we = {
                      fn: n.OPS.paintSolidColorImageMask,
                      args: [],
                      optionalContent: ae
                    };
                    k.set(w, Y, we), Y && this._regionalImageCache.set(null, Y, we);
                  }
                  return;
                }
                const xe = `mask_${this.idFactory.createObjId()}`;
                if (Z.addDependency(xe), this._sendImgData(xe, L), ee = [{
                  data: xe,
                  width: L.width,
                  height: L.height,
                  interpolate: L.interpolate,
                  count: 1
                }], Z.addImageOps(n.OPS.paintImageMaskXObject, ee, ae), w) {
                  const we = {
                    fn: n.OPS.paintImageMaskXObject,
                    args: ee,
                    optionalContent: ae
                  };
                  k.set(w, Y, we), Y && this._regionalImageCache.set(null, Y, we);
                }
                return;
              }
              if (K && !H.has("SMask") && !H.has("Mask") && ie + ne < 200) {
                L = await new s.PDFImage({
                  xref: this.xref,
                  res: q,
                  image: re,
                  isInline: K,
                  pdfFunctionFactory: this._pdfFunctionFactory,
                  localColorSpaceCache: X
                }).createImageData(!0, !1), Z.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, Z.addImageOps(n.OPS.paintInlineImageXObject, [L], ae);
                return;
              }
              let le = `img_${this.idFactory.createObjId()}`, ue = !1;
              if (this.parsingType3Font ? le = `${this.idFactory.getDocId()}_type3_${le}` : Y && (ue = this.globalImageCache.shouldCache(Y, this.pageIndex), ue && (le = `${this.idFactory.getDocId()}_${le}`)), Z.addDependency(le), ee = [le, ie, ne], s.PDFImage.buildImage({
                xref: this.xref,
                res: q,
                image: re,
                isInline: K,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: X
              }).then(async (de) => {
                if (L = await de.createImageData(!1, this.options.isOffscreenCanvasSupported), w && Y && ue) {
                  const ge = L.bitmap ? L.width * L.height * 4 : L.data.length;
                  this.globalImageCache.addByteSize(Y, ge);
                }
                return this._sendImgData(le, L, ue);
              }).catch((de) => ((0, n.warn)(`Unable to decode image "${le}": "${de}".`), this._sendImgData(le, null, ue))), Z.addImageOps(n.OPS.paintImageXObject, ee, ae), w) {
                const de = {
                  fn: n.OPS.paintImageXObject,
                  args: ee,
                  optionalContent: ae
                };
                k.set(w, Y, de), Y && (this._regionalImageCache.set(null, Y, de), ue && ((0, n.assert)(!K, "Cannot cache an inline image globally."), this.globalImageCache.setData(Y, {
                  objId: le,
                  fn: n.OPS.paintImageXObject,
                  args: ee,
                  optionalContent: ae,
                  byteSize: 0
                })));
              }
            }
            handleSMask(q, re, K, Z, w, k) {
              const X = q.get("G"), H = {
                subtype: q.get("S").name,
                backdrop: q.get("BC")
              }, Y = q.get("TR");
              if ((0, F.isPDFFunction)(Y)) {
                const ie = this._pdfFunctionFactory.create(Y), ne = new Uint8Array(256), U = new Float32Array(1);
                for (let ae = 0; ae < 256; ae++)
                  U[0] = ae / 255, ie(U, 0, U, 0), ne[ae] = U[0] * 255 | 0;
                H.transferMap = ne;
              }
              return this.buildFormXObject(re, X, H, K, Z, w.state.clone(), k);
            }
            handleTransferFunction(q) {
              let re;
              if (Array.isArray(q))
                re = q;
              else if ((0, F.isPDFFunction)(q))
                re = [q];
              else
                return null;
              const K = [];
              let Z = 0, w = 0;
              for (const k of re) {
                const X = this.xref.fetchIfRef(k);
                if (Z++, (0, D.isName)(X, "Identity")) {
                  K.push(null);
                  continue;
                } else if (!(0, F.isPDFFunction)(X))
                  return null;
                const H = this._pdfFunctionFactory.create(X), Y = new Uint8Array(256), ie = new Float32Array(1);
                for (let ne = 0; ne < 256; ne++)
                  ie[0] = ne / 255, H(ie, 0, ie, 0), Y[ne] = ie[0] * 255 | 0;
                K.push(Y), w++;
              }
              return !(Z === 1 || Z === 4) || w === 0 ? null : K;
            }
            handleTilingType(q, re, K, Z, w, k, X, H) {
              const Y = new I.OperatorList(), ie = D.Dict.merge({
                xref: this.xref,
                dictArray: [w.get("Resources"), K]
              });
              return this.getOperatorList({
                stream: Z,
                task: X,
                resources: ie,
                operatorList: Y
              }).then(function() {
                const ne = Y.getIR(), U = (0, V.getTilingPatternIR)(ne, w, re);
                k.addDependencies(Y.dependencies), k.addOp(q, U), w.objId && H.set(null, w.objId, {
                  operatorListIR: ne,
                  dict: w
                });
              }).catch((ne) => {
                if (!(ne instanceof n.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, n.warn)(`handleTilingType - ignoring pattern: "${ne}".`);
                    return;
                  }
                  throw ne;
                }
              });
            }
            handleSetFont(q, re, K, Z, w, k, X = null, H = null) {
              const Y = (re == null ? void 0 : re[0]) instanceof D.Name ? re[0].name : null;
              return this.loadFont(Y, K, q, X, H).then((ie) => ie.font.isType3Font ? ie.loadType3Data(this, q, w).then(function() {
                return Z.addDependencies(ie.type3Dependencies), ie;
              }).catch((ne) => new v({
                loadedName: "g_font_error",
                font: new e.ErrorFont(`Type3 font load error: ${ne}`),
                dict: ie.font,
                evaluatorOptions: this.options
              })) : ie).then((ie) => (k.font = ie.font, ie.send(this.handler), ie.loadedName));
            }
            handleText(q, re) {
              const K = re.font, Z = K.charsToGlyphs(q);
              return K.data && (re.textRenderingMode & n.TextRenderingMode.ADD_TO_PATH_FLAG || re.fillColorSpace.name === "Pattern" || K.disableFontFace || this.options.disableFontFace) && S.buildFontPaths(K, Z, this.handler, this.options), Z;
            }
            ensureStateFont(q) {
              if (q.font)
                return;
              const re = new n.FormatError("Missing setFont (Tf) operator before text rendering operator.");
              if (this.options.ignoreErrors) {
                (0, n.warn)(`ensureStateFont: "${re}".`);
                return;
              }
              throw re;
            }
            async setGState({
              resources: q,
              gState: re,
              operatorList: K,
              cacheKey: Z,
              task: w,
              stateManager: k,
              localGStateCache: X,
              localColorSpaceCache: H
            }) {
              const Y = re.objId;
              let ie = !0;
              const ne = [];
              let U = Promise.resolve();
              for (const ae of re.getKeys()) {
                const Q = re.get(ae);
                switch (ae) {
                  case "Type":
                    break;
                  case "LW":
                  case "LC":
                  case "LJ":
                  case "ML":
                  case "D":
                  case "RI":
                  case "FL":
                  case "CA":
                  case "ca":
                    ne.push([ae, Q]);
                    break;
                  case "Font":
                    ie = !1, U = U.then(() => this.handleSetFont(q, null, Q[0], K, w, k.state).then(function(ee) {
                      K.addDependency(ee), ne.push([ae, [ee, Q[1]]]);
                    }));
                    break;
                  case "BM":
                    ne.push([ae, y(Q)]);
                    break;
                  case "SMask":
                    if ((0, D.isName)(Q, "None")) {
                      ne.push([ae, !1]);
                      break;
                    }
                    Q instanceof D.Dict ? (ie = !1, U = U.then(() => this.handleSMask(Q, q, K, w, k, H)), ne.push([ae, !0])) : (0, n.warn)("Unsupported SMask type");
                    break;
                  case "TR":
                    const L = this.handleTransferFunction(Q);
                    ne.push([ae, L]);
                    break;
                  case "OP":
                  case "op":
                  case "OPM":
                  case "BG":
                  case "BG2":
                  case "UCR":
                  case "UCR2":
                  case "TR2":
                  case "HT":
                  case "SM":
                  case "SA":
                  case "AIS":
                  case "TK":
                    (0, n.info)("graphic state operator " + ae);
                    break;
                  default:
                    (0, n.info)("Unknown graphic state operator " + ae);
                    break;
                }
              }
              return U.then(function() {
                ne.length > 0 && K.addOp(n.OPS.setGState, [ne]), ie && X.set(Z, Y, ne);
              });
            }
            loadFont(q, re, K, Z = null, w = null) {
              const k = async () => new v({
                loadedName: "g_font_error",
                font: new e.ErrorFont(`Font "${q}" is not available.`),
                dict: re,
                evaluatorOptions: this.options
              });
              let X;
              if (re)
                re instanceof D.Ref && (X = re);
              else {
                const Q = K.get("Font");
                Q && (X = Q.getRaw(q));
              }
              if (X) {
                if (this.parsingType3Font && this.type3FontRefs.has(X))
                  return k();
                if (this.fontCache.has(X))
                  return this.fontCache.get(X);
                re = this.xref.fetchIfRef(X);
              }
              if (!(re instanceof D.Dict)) {
                if (!this.options.ignoreErrors && !this.parsingType3Font)
                  return (0, n.warn)(`Font "${q}" is not available.`), k();
                (0, n.warn)(`Font "${q}" is not available -- attempting to fallback to a default font.`), re = Z || S.fallbackFontDict;
              }
              if (re.cacheKey && this.fontCache.has(re.cacheKey))
                return this.fontCache.get(re.cacheKey);
              const H = new n.PromiseCapability();
              let Y;
              try {
                Y = this.preEvaluateFont(re), Y.cssFontInfo = w;
              } catch (Q) {
                return (0, n.warn)(`loadFont - preEvaluateFont failed: "${Q}".`), k();
              }
              const {
                descriptor: ie,
                hash: ne
              } = Y, U = X instanceof D.Ref;
              let ae;
              if (ne && ie instanceof D.Dict) {
                const Q = ie.fontAliases || (ie.fontAliases = /* @__PURE__ */ Object.create(null));
                if (Q[ne]) {
                  const L = Q[ne].aliasRef;
                  if (U && L && this.fontCache.has(L))
                    return this.fontCache.putAlias(X, L), this.fontCache.get(X);
                } else
                  Q[ne] = {
                    fontID: this.idFactory.createFontId()
                  };
                U && (Q[ne].aliasRef = X), ae = Q[ne].fontID;
              } else
                ae = this.idFactory.createFontId();
              return (0, n.assert)(ae == null ? void 0 : ae.startsWith("f"), 'The "fontID" must be (correctly) defined.'), U ? this.fontCache.put(X, H.promise) : (re.cacheKey = `cacheKey_${ae}`, this.fontCache.put(re.cacheKey, H.promise)), re.loadedName = `${this.idFactory.getDocId()}_${ae}`, this.translateFont(Y).then((Q) => {
                H.resolve(new v({
                  loadedName: re.loadedName,
                  font: Q,
                  dict: re,
                  evaluatorOptions: this.options
                }));
              }).catch((Q) => {
                (0, n.warn)(`loadFont - translateFont failed: "${Q}".`), H.resolve(new v({
                  loadedName: re.loadedName,
                  font: new e.ErrorFont(Q instanceof Error ? Q.message : Q),
                  dict: re,
                  evaluatorOptions: this.options
                }));
              }), H.promise;
            }
            buildPath(q, re, K, Z = !1) {
              const w = q.length - 1;
              if (K || (K = []), w < 0 || q.fnArray[w] !== n.OPS.constructPath) {
                Z && ((0, n.warn)(`Encountered path operator "${re}" inside of a text object.`), q.addOp(n.OPS.save, null));
                let k;
                switch (re) {
                  case n.OPS.rectangle:
                    const X = K[0] + K[2], H = K[1] + K[3];
                    k = [Math.min(K[0], X), Math.max(K[0], X), Math.min(K[1], H), Math.max(K[1], H)];
                    break;
                  case n.OPS.moveTo:
                  case n.OPS.lineTo:
                    k = [K[0], K[0], K[1], K[1]];
                    break;
                  default:
                    k = [1 / 0, -1 / 0, 1 / 0, -1 / 0];
                    break;
                }
                q.addOp(n.OPS.constructPath, [[re], K, k]), Z && q.addOp(n.OPS.restore, null);
              } else {
                const k = q.argsArray[w];
                k[0].push(re), k[1].push(...K);
                const X = k[2];
                switch (re) {
                  case n.OPS.rectangle:
                    const H = K[0] + K[2], Y = K[1] + K[3];
                    X[0] = Math.min(X[0], K[0], H), X[1] = Math.max(X[1], K[0], H), X[2] = Math.min(X[2], K[1], Y), X[3] = Math.max(X[3], K[1], Y);
                    break;
                  case n.OPS.moveTo:
                  case n.OPS.lineTo:
                    X[0] = Math.min(X[0], K[0]), X[1] = Math.max(X[1], K[0]), X[2] = Math.min(X[2], K[1]), X[3] = Math.max(X[3], K[1]);
                    break;
                }
              }
            }
            parseColorSpace({
              cs: q,
              resources: re,
              localColorSpaceCache: K
            }) {
              return O.ColorSpace.parseAsync({
                cs: q,
                xref: this.xref,
                resources: re,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: K
              }).catch((Z) => {
                if (Z instanceof n.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return (0, n.warn)(`parseColorSpace - ignoring ColorSpace: "${Z}".`), null;
                throw Z;
              });
            }
            parseShading({
              shading: q,
              resources: re,
              localColorSpaceCache: K,
              localShadingPatternCache: Z
            }) {
              let w = Z.get(q);
              if (!w) {
                var k = V.Pattern.parseShading(q, this.xref, re, this._pdfFunctionFactory, K);
                const X = k.getIR();
                w = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (w = `${this.idFactory.getDocId()}_type3_${w}`), Z.set(q, w), this.parsingType3Font ? this.handler.send("commonobj", [w, "Pattern", X]) : this.handler.send("obj", [w, this.pageIndex, "Pattern", X]);
              }
              return w;
            }
            handleColorN(q, re, K, Z, w, k, X, H, Y, ie) {
              const ne = K.pop();
              if (ne instanceof D.Name) {
                const U = w.getRaw(ne.name), ae = U instanceof D.Ref && Y.getByRef(U);
                if (ae)
                  try {
                    const L = Z.base ? Z.base.getRgb(K, 0) : null, ee = (0, V.getTilingPatternIR)(ae.operatorListIR, ae.dict, L);
                    q.addOp(re, ee);
                    return;
                  } catch {
                  }
                const Q = this.xref.fetchIfRef(U);
                if (Q) {
                  const L = Q instanceof N.BaseStream ? Q.dict : Q, ee = L.get("PatternType");
                  if (ee === u.TILING) {
                    const se = Z.base ? Z.base.getRgb(K, 0) : null;
                    return this.handleTilingType(re, se, k, Q, L, q, X, Y);
                  } else if (ee === u.SHADING) {
                    const se = L.get("Shading"), le = L.getArray("Matrix"), ue = this.parseShading({
                      shading: se,
                      resources: k,
                      localColorSpaceCache: H,
                      localShadingPatternCache: ie
                    });
                    q.addOp(re, ["Shading", ue, le]);
                    return;
                  }
                  throw new n.FormatError(`Unknown PatternType: ${ee}`);
                }
              }
              throw new n.FormatError(`Unknown PatternName: ${ne}`);
            }
            _parseVisibilityExpression(q, re, K) {
              if (++re > 10) {
                (0, n.warn)("Visibility expression is too deeply nested");
                return;
              }
              const w = q.length, k = this.xref.fetchIfRef(q[0]);
              if (w < 2 || !(k instanceof D.Name)) {
                (0, n.warn)("Invalid visibility expression");
                return;
              }
              switch (k.name) {
                case "And":
                case "Or":
                case "Not":
                  K.push(k.name);
                  break;
                default:
                  (0, n.warn)(`Invalid operator ${k.name} in visibility expression`);
                  return;
              }
              for (let X = 1; X < w; X++) {
                const H = q[X], Y = this.xref.fetchIfRef(H);
                if (Array.isArray(Y)) {
                  const ie = [];
                  K.push(ie), this._parseVisibilityExpression(Y, re, ie);
                } else
                  H instanceof D.Ref && K.push(H.toString());
              }
            }
            async parseMarkedContentProps(q, re) {
              var w;
              let K;
              if (q instanceof D.Name)
                K = re.get("Properties").get(q.name);
              else if (q instanceof D.Dict)
                K = q;
              else
                throw new n.FormatError("Optional content properties malformed.");
              const Z = (w = K.get("Type")) == null ? void 0 : w.name;
              if (Z === "OCG")
                return {
                  type: Z,
                  id: K.objId
                };
              if (Z === "OCMD") {
                const k = K.get("VE");
                if (Array.isArray(k)) {
                  const H = [];
                  if (this._parseVisibilityExpression(k, 0, H), H.length > 0)
                    return {
                      type: "OCMD",
                      expression: H
                    };
                }
                const X = K.get("OCGs");
                if (Array.isArray(X) || X instanceof D.Dict) {
                  const H = [];
                  if (Array.isArray(X))
                    for (const Y of X)
                      H.push(Y.toString());
                  else
                    H.push(X.objId);
                  return {
                    type: Z,
                    ids: H,
                    policy: K.get("P") instanceof D.Name ? K.get("P").name : null,
                    expression: null
                  };
                } else if (X instanceof D.Ref)
                  return {
                    type: Z,
                    id: X.toString()
                  };
              }
              return null;
            }
            getOperatorList({
              stream: q,
              task: re,
              resources: K,
              operatorList: Z,
              initialState: w = null,
              fallbackFontDict: k = null
            }) {
              if (K || (K = D.Dict.empty), w || (w = new A()), !Z)
                throw new Error('getOperatorList: missing "operatorList" parameter');
              const X = this, H = this.xref;
              let Y = !1;
              const ie = new x.LocalImageCache(), ne = new x.LocalColorSpaceCache(), U = new x.LocalGStateCache(), ae = new x.LocalTilingPatternCache(), Q = /* @__PURE__ */ new Map(), L = K.get("XObject") || D.Dict.empty, ee = K.get("Pattern") || D.Dict.empty, se = new m(w), le = new j(q, H, se), ue = new $();
              function de(ge) {
                for (let me = 0, pe = le.savedStatesDepth; me < pe; me++)
                  Z.addOp(n.OPS.restore, []);
              }
              return new Promise(function ge(me, pe) {
                const xe = function(Pe) {
                  Promise.all([Pe, Z.ready]).then(function() {
                    try {
                      ge(me, pe);
                    } catch (Ge) {
                      pe(Ge);
                    }
                  }, pe);
                };
                re.ensureNotTerminated(), ue.reset();
                const we = {};
                let Ae, be, he, fe, Ce, ye;
                for (; !(Ae = ue.check()) && (we.args = null, !!le.read(we)); ) {
                  let Pe = we.args, Ge = we.fn;
                  switch (Ge | 0) {
                    case n.OPS.paintXObject:
                      if (ye = Pe[0] instanceof D.Name, Ce = Pe[0].name, ye) {
                        const De = ie.getByName(Ce);
                        if (De) {
                          Z.addImageOps(De.fn, De.args, De.optionalContent), _(De), Pe = null;
                          continue;
                        }
                      }
                      xe(new Promise(function(De, Qe) {
                        if (!ye)
                          throw new n.FormatError("XObject must be referred to by name.");
                        let st = L.getRaw(Ce);
                        if (st instanceof D.Ref) {
                          const Ot = ie.getByRef(st) || X._regionalImageCache.getByRef(st);
                          if (Ot) {
                            Z.addImageOps(Ot.fn, Ot.args, Ot.optionalContent), _(Ot), De();
                            return;
                          }
                          const ze = X.globalImageCache.getData(st, X.pageIndex);
                          if (ze) {
                            Z.addDependency(ze.objId), Z.addImageOps(ze.fn, ze.args, ze.optionalContent), De();
                            return;
                          }
                          st = H.fetch(st);
                        }
                        if (!(st instanceof N.BaseStream))
                          throw new n.FormatError("XObject should be a stream");
                        const wt = st.dict.get("Subtype");
                        if (!(wt instanceof D.Name))
                          throw new n.FormatError("XObject should have a Name subtype");
                        if (wt.name === "Form") {
                          se.save(), X.buildFormXObject(K, st, null, Z, re, se.state.clone(), ne).then(function() {
                            se.restore(), De();
                          }, Qe);
                          return;
                        } else if (wt.name === "Image") {
                          X.buildPaintImageXObject({
                            resources: K,
                            image: st,
                            operatorList: Z,
                            cacheKey: Ce,
                            localImageCache: ie,
                            localColorSpaceCache: ne
                          }).then(De, Qe);
                          return;
                        } else if (wt.name === "PS")
                          (0, n.info)("Ignored XObject subtype PS");
                        else
                          throw new n.FormatError(`Unhandled XObject subtype ${wt.name}`);
                        De();
                      }).catch(function(De) {
                        if (!(De instanceof n.AbortException)) {
                          if (X.options.ignoreErrors) {
                            (0, n.warn)(`getOperatorList - ignoring XObject: "${De}".`);
                            return;
                          }
                          throw De;
                        }
                      }));
                      return;
                    case n.OPS.setFont:
                      var Le = Pe[1];
                      xe(X.handleSetFont(K, Pe, null, Z, re, se.state, k).then(function(De) {
                        Z.addDependency(De), Z.addOp(n.OPS.setFont, [De, Le]);
                      }));
                      return;
                    case n.OPS.beginText:
                      Y = !0;
                      break;
                    case n.OPS.endText:
                      Y = !1;
                      break;
                    case n.OPS.endInlineImage:
                      var Be = Pe[0].cacheKey;
                      if (Be) {
                        const De = ie.getByName(Be);
                        if (De) {
                          Z.addImageOps(De.fn, De.args, De.optionalContent), _(De), Pe = null;
                          continue;
                        }
                      }
                      xe(X.buildPaintImageXObject({
                        resources: K,
                        image: Pe[0],
                        isInline: !0,
                        operatorList: Z,
                        cacheKey: Be,
                        localImageCache: ie,
                        localColorSpaceCache: ne
                      }));
                      return;
                    case n.OPS.showText:
                      if (!se.state.font) {
                        X.ensureStateFont(se.state);
                        continue;
                      }
                      Pe[0] = X.handleText(Pe[0], se.state);
                      break;
                    case n.OPS.showSpacedText:
                      if (!se.state.font) {
                        X.ensureStateFont(se.state);
                        continue;
                      }
                      var nt = [], Oe = se.state;
                      for (const De of Pe[0])
                        typeof De == "string" ? nt.push(...X.handleText(De, Oe)) : typeof De == "number" && nt.push(De);
                      Pe[0] = nt, Ge = n.OPS.showText;
                      break;
                    case n.OPS.nextLineShowText:
                      if (!se.state.font) {
                        X.ensureStateFont(se.state);
                        continue;
                      }
                      Z.addOp(n.OPS.nextLine), Pe[0] = X.handleText(Pe[0], se.state), Ge = n.OPS.showText;
                      break;
                    case n.OPS.nextLineSetSpacingShowText:
                      if (!se.state.font) {
                        X.ensureStateFont(se.state);
                        continue;
                      }
                      Z.addOp(n.OPS.nextLine), Z.addOp(n.OPS.setWordSpacing, [Pe.shift()]), Z.addOp(n.OPS.setCharSpacing, [Pe.shift()]), Pe[0] = X.handleText(Pe[0], se.state), Ge = n.OPS.showText;
                      break;
                    case n.OPS.setTextRenderingMode:
                      se.state.textRenderingMode = Pe[0];
                      break;
                    case n.OPS.setFillColorSpace: {
                      const De = O.ColorSpace.getCached(Pe[0], H, ne);
                      if (De) {
                        se.state.fillColorSpace = De;
                        continue;
                      }
                      xe(X.parseColorSpace({
                        cs: Pe[0],
                        resources: K,
                        localColorSpaceCache: ne
                      }).then(function(Qe) {
                        Qe && (se.state.fillColorSpace = Qe);
                      }));
                      return;
                    }
                    case n.OPS.setStrokeColorSpace: {
                      const De = O.ColorSpace.getCached(Pe[0], H, ne);
                      if (De) {
                        se.state.strokeColorSpace = De;
                        continue;
                      }
                      xe(X.parseColorSpace({
                        cs: Pe[0],
                        resources: K,
                        localColorSpaceCache: ne
                      }).then(function(Qe) {
                        Qe && (se.state.strokeColorSpace = Qe);
                      }));
                      return;
                    }
                    case n.OPS.setFillColor:
                      fe = se.state.fillColorSpace, Pe = fe.getRgb(Pe, 0), Ge = n.OPS.setFillRGBColor;
                      break;
                    case n.OPS.setStrokeColor:
                      fe = se.state.strokeColorSpace, Pe = fe.getRgb(Pe, 0), Ge = n.OPS.setStrokeRGBColor;
                      break;
                    case n.OPS.setFillGray:
                      se.state.fillColorSpace = O.ColorSpace.singletons.gray, Pe = O.ColorSpace.singletons.gray.getRgb(Pe, 0), Ge = n.OPS.setFillRGBColor;
                      break;
                    case n.OPS.setStrokeGray:
                      se.state.strokeColorSpace = O.ColorSpace.singletons.gray, Pe = O.ColorSpace.singletons.gray.getRgb(Pe, 0), Ge = n.OPS.setStrokeRGBColor;
                      break;
                    case n.OPS.setFillCMYKColor:
                      se.state.fillColorSpace = O.ColorSpace.singletons.cmyk, Pe = O.ColorSpace.singletons.cmyk.getRgb(Pe, 0), Ge = n.OPS.setFillRGBColor;
                      break;
                    case n.OPS.setStrokeCMYKColor:
                      se.state.strokeColorSpace = O.ColorSpace.singletons.cmyk, Pe = O.ColorSpace.singletons.cmyk.getRgb(Pe, 0), Ge = n.OPS.setStrokeRGBColor;
                      break;
                    case n.OPS.setFillRGBColor:
                      se.state.fillColorSpace = O.ColorSpace.singletons.rgb, Pe = O.ColorSpace.singletons.rgb.getRgb(Pe, 0);
                      break;
                    case n.OPS.setStrokeRGBColor:
                      se.state.strokeColorSpace = O.ColorSpace.singletons.rgb, Pe = O.ColorSpace.singletons.rgb.getRgb(Pe, 0);
                      break;
                    case n.OPS.setFillColorN:
                      if (fe = se.state.fillColorSpace, fe.name === "Pattern") {
                        xe(X.handleColorN(Z, n.OPS.setFillColorN, Pe, fe, ee, K, re, ne, ae, Q));
                        return;
                      }
                      Pe = fe.getRgb(Pe, 0), Ge = n.OPS.setFillRGBColor;
                      break;
                    case n.OPS.setStrokeColorN:
                      if (fe = se.state.strokeColorSpace, fe.name === "Pattern") {
                        xe(X.handleColorN(Z, n.OPS.setStrokeColorN, Pe, fe, ee, K, re, ne, ae, Q));
                        return;
                      }
                      Pe = fe.getRgb(Pe, 0), Ge = n.OPS.setStrokeRGBColor;
                      break;
                    case n.OPS.shadingFill:
                      var Je = K.get("Shading");
                      if (!Je)
                        throw new n.FormatError("No shading resource found");
                      var Ve = Je.get(Pe[0].name);
                      if (!Ve)
                        throw new n.FormatError("No shading object found");
                      Pe = [X.parseShading({
                        shading: Ve,
                        resources: K,
                        localColorSpaceCache: ne,
                        localShadingPatternCache: Q
                      })], Ge = n.OPS.shadingFill;
                      break;
                    case n.OPS.setGState:
                      if (ye = Pe[0] instanceof D.Name, Ce = Pe[0].name, ye) {
                        const De = U.getByName(Ce);
                        if (De) {
                          De.length > 0 && Z.addOp(n.OPS.setGState, [De]), Pe = null;
                          continue;
                        }
                      }
                      xe(new Promise(function(De, Qe) {
                        if (!ye)
                          throw new n.FormatError("GState must be referred to by name.");
                        const st = K.get("ExtGState");
                        if (!(st instanceof D.Dict))
                          throw new n.FormatError("ExtGState should be a dictionary.");
                        const wt = st.get(Ce);
                        if (!(wt instanceof D.Dict))
                          throw new n.FormatError("GState should be a dictionary.");
                        X.setGState({
                          resources: K,
                          gState: wt,
                          operatorList: Z,
                          cacheKey: Ce,
                          task: re,
                          stateManager: se,
                          localGStateCache: U,
                          localColorSpaceCache: ne
                        }).then(De, Qe);
                      }).catch(function(De) {
                        if (!(De instanceof n.AbortException)) {
                          if (X.options.ignoreErrors) {
                            (0, n.warn)(`getOperatorList - ignoring ExtGState: "${De}".`);
                            return;
                          }
                          throw De;
                        }
                      }));
                      return;
                    case n.OPS.moveTo:
                    case n.OPS.lineTo:
                    case n.OPS.curveTo:
                    case n.OPS.curveTo2:
                    case n.OPS.curveTo3:
                    case n.OPS.closePath:
                    case n.OPS.rectangle:
                      X.buildPath(Z, Ge, Pe, Y);
                      continue;
                    case n.OPS.markPoint:
                    case n.OPS.markPointProps:
                    case n.OPS.beginCompat:
                    case n.OPS.endCompat:
                      continue;
                    case n.OPS.beginMarkedContentProps:
                      if (!(Pe[0] instanceof D.Name)) {
                        (0, n.warn)(`Expected name for beginMarkedContentProps arg0=${Pe[0]}`);
                        continue;
                      }
                      if (Pe[0].name === "OC") {
                        xe(X.parseMarkedContentProps(Pe[1], K).then((De) => {
                          Z.addOp(n.OPS.beginMarkedContentProps, ["OC", De]);
                        }).catch((De) => {
                          if (!(De instanceof n.AbortException)) {
                            if (X.options.ignoreErrors) {
                              (0, n.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${De}".`);
                              return;
                            }
                            throw De;
                          }
                        }));
                        return;
                      }
                      Pe = [Pe[0].name, Pe[1] instanceof D.Dict ? Pe[1].get("MCID") : null];
                      break;
                    case n.OPS.beginMarkedContent:
                    case n.OPS.endMarkedContent:
                    default:
                      if (Pe !== null) {
                        for (be = 0, he = Pe.length; be < he && !(Pe[be] instanceof D.Dict); be++)
                          ;
                        if (be < he) {
                          (0, n.warn)("getOperatorList - ignoring operator: " + Ge);
                          continue;
                        }
                      }
                  }
                  Z.addOp(Ge, Pe);
                }
                if (Ae) {
                  xe(d);
                  return;
                }
                de(), me();
              }).catch((ge) => {
                if (!(ge instanceof n.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, n.warn)(`getOperatorList - ignoring errors during "${re.name}" task: "${ge}".`), de();
                    return;
                  }
                  throw ge;
                }
              });
            }
            getTextContent({
              stream: q,
              task: re,
              resources: K,
              stateManager: Z = null,
              includeMarkedContent: w = !1,
              sink: k,
              seenStyles: X = /* @__PURE__ */ new Set(),
              viewBox: H,
              markedContentData: Y = null,
              disableNormalization: ie = !1
            }) {
              K || (K = D.Dict.empty), Z || (Z = new m(new h())), w && (Y || (Y = {
                level: 0
              }));
              const ne = {
                items: [],
                styles: /* @__PURE__ */ Object.create(null)
              }, U = {
                initialized: !1,
                str: [],
                totalWidth: 0,
                totalHeight: 0,
                width: 0,
                height: 0,
                vertical: !1,
                prevTransform: null,
                textAdvanceScale: 0,
                spaceInFlowMin: 0,
                spaceInFlowMax: 0,
                trackingSpaceMin: 1 / 0,
                negativeSpaceMax: -1 / 0,
                notASpace: -1 / 0,
                transform: null,
                fontName: null,
                hasEOL: !1
              }, ae = [" ", " "];
              let Q = 0;
              function L(ze) {
                const qe = (Q + 1) % 2, Ue = ae[Q] !== " " && ae[qe] === " ";
                return ae[Q] = ze, Q = qe, Ue;
              }
              function ee() {
                return ae[Q] !== " " && ae[(Q + 1) % 2] === " ";
              }
              function se() {
                ae[0] = ae[1] = " ", Q = 0;
              }
              const le = 0.102, ue = 0.03, de = -0.2, ge = 0.102, me = 0.6, pe = 0.25, xe = this, we = this.xref, Ae = [];
              let be = null;
              const he = new x.LocalImageCache(), fe = new x.LocalGStateCache(), Ce = new j(q, we, Z);
              let ye;
              function Le({
                width: ze = 0,
                height: qe = 0,
                transform: Ue = U.prevTransform,
                fontName: bt = U.fontName
              }) {
                ne.items.push({
                  str: " ",
                  dir: "ltr",
                  width: ze,
                  height: qe,
                  transform: Ue,
                  fontName: bt,
                  hasEOL: !1
                });
              }
              function Be() {
                const ze = ye.font, qe = [ye.fontSize * ye.textHScale, 0, 0, ye.fontSize, 0, ye.textRise];
                if (ze.isType3Font && (ye.fontSize <= 1 || ze.isCharBBox) && !(0, n.isArrayEqual)(ye.fontMatrix, n.FONT_IDENTITY_MATRIX)) {
                  const Ue = ze.bbox[3] - ze.bbox[1];
                  Ue > 0 && (qe[3] *= Ue * ye.fontMatrix[3]);
                }
                return n.Util.transform(ye.ctm, n.Util.transform(ye.textMatrix, qe));
              }
              function nt() {
                if (U.initialized)
                  return U;
                const {
                  font: ze,
                  loadedName: qe
                } = ye;
                X.has(qe) || (X.add(qe), ne.styles[qe] = {
                  fontFamily: ze.fallbackName,
                  ascent: ze.ascent,
                  descent: ze.descent,
                  vertical: ze.vertical
                }), U.fontName = qe;
                const Ue = U.transform = Be();
                ze.vertical ? (U.width = U.totalWidth = Math.hypot(Ue[0], Ue[1]), U.height = U.totalHeight = 0, U.vertical = !0) : (U.width = U.totalWidth = 0, U.height = U.totalHeight = Math.hypot(Ue[2], Ue[3]), U.vertical = !1);
                const bt = Math.hypot(ye.textLineMatrix[0], ye.textLineMatrix[1]), It = Math.hypot(ye.ctm[0], ye.ctm[1]);
                U.textAdvanceScale = It * bt;
                const {
                  fontSize: kt
                } = ye;
                return U.trackingSpaceMin = kt * le, U.notASpace = kt * ue, U.negativeSpaceMax = kt * de, U.spaceInFlowMin = kt * ge, U.spaceInFlowMax = kt * me, U.hasEOL = !1, U.initialized = !0, U;
              }
              function Oe() {
                if (!U.initialized)
                  return;
                const ze = Math.hypot(ye.textLineMatrix[0], ye.textLineMatrix[1]), Ue = Math.hypot(ye.ctm[0], ye.ctm[1]) * ze;
                Ue !== U.textAdvanceScale && (U.vertical ? (U.totalHeight += U.height * U.textAdvanceScale, U.height = 0) : (U.totalWidth += U.width * U.textAdvanceScale, U.width = 0), U.textAdvanceScale = Ue);
              }
              function Je(ze) {
                let qe = ze.str.join("");
                ie || (qe = (0, n.normalizeUnicode)(qe));
                const Ue = (0, p.bidi)(qe, -1, ze.vertical);
                return {
                  str: Ue.str,
                  dir: Ue.dir,
                  width: Math.abs(ze.totalWidth),
                  height: Math.abs(ze.totalHeight),
                  transform: ze.transform,
                  fontName: ze.fontName,
                  hasEOL: ze.hasEOL
                };
              }
              function Ve(ze, qe) {
                return xe.loadFont(ze, qe, K).then(function(Ue) {
                  return Ue.font.isType3Font ? Ue.loadType3Data(xe, K, re).catch(function() {
                  }).then(function() {
                    return Ue;
                  }) : Ue;
                }).then(function(Ue) {
                  ye.loadedName = Ue.loadedName, ye.font = Ue.font, ye.fontMatrix = Ue.font.fontMatrix || n.FONT_IDENTITY_MATRIX;
                });
              }
              function Pe(ze, qe, Ue) {
                const bt = Math.hypot(Ue[0], Ue[1]);
                return [(Ue[0] * ze + Ue[1] * qe) / bt, (Ue[2] * ze + Ue[3] * qe) / bt];
              }
              function Ge(ze) {
                var Fe;
                const qe = Be();
                let Ue = qe[4], bt = qe[5];
                if ((Fe = ye.font) != null && Fe.vertical) {
                  if (Ue < H[0] || Ue > H[2] || bt + ze < H[1] || bt > H[3])
                    return !1;
                } else if (Ue + ze < H[0] || Ue > H[2] || bt < H[1] || bt > H[3])
                  return !1;
                if (!ye.font || !U.prevTransform)
                  return !0;
                let It = U.prevTransform[4], kt = U.prevTransform[5];
                if (It === Ue && kt === bt)
                  return !0;
                let ht = -1;
                switch (qe[0] && qe[1] === 0 && qe[2] === 0 ? ht = qe[0] > 0 ? 0 : 180 : qe[1] && qe[0] === 0 && qe[3] === 0 && (ht = qe[1] > 0 ? 90 : 270), ht) {
                  case 0:
                    break;
                  case 90:
                    [Ue, bt] = [bt, Ue], [It, kt] = [kt, It];
                    break;
                  case 180:
                    [Ue, bt, It, kt] = [-Ue, -bt, -It, -kt];
                    break;
                  case 270:
                    [Ue, bt] = [-bt, -Ue], [It, kt] = [-kt, -It];
                    break;
                  default:
                    [Ue, bt] = Pe(Ue, bt, qe), [It, kt] = Pe(It, kt, U.prevTransform);
                }
                if (ye.font.vertical) {
                  const Me = (kt - bt) / U.textAdvanceScale, Ne = Ue - It, je = Math.sign(U.height);
                  return Me < je * U.negativeSpaceMax ? Math.abs(Ne) > 0.5 * U.width ? (De(), !0) : (se(), st(), !0) : Math.abs(Ne) > U.width ? (De(), !0) : (Me <= je * U.notASpace && se(), Me <= je * U.trackingSpaceMin ? ee() ? (se(), st(), Le({
                    height: Math.abs(Me)
                  })) : U.height += Me : Qe(Me, U.prevTransform, je) || (U.str.length === 0 ? (se(), Le({
                    height: Math.abs(Me)
                  })) : U.height += Me), Math.abs(Ne) > U.width * pe && st(), !0);
                }
                const Rt = (Ue - It) / U.textAdvanceScale, _t = bt - kt, Ie = Math.sign(U.width);
                return Rt < Ie * U.negativeSpaceMax ? Math.abs(_t) > 0.5 * U.height ? (De(), !0) : (se(), st(), !0) : Math.abs(_t) > U.height ? (De(), !0) : (Rt <= Ie * U.notASpace && se(), Rt <= Ie * U.trackingSpaceMin ? ee() ? (se(), st(), Le({
                  width: Math.abs(Rt)
                })) : U.width += Rt : Qe(Rt, U.prevTransform, Ie) || (U.str.length === 0 ? (se(), Le({
                  width: Math.abs(Rt)
                })) : U.width += Rt), Math.abs(_t) > U.height * pe && st(), !0);
              }
              function dt({
                chars: ze,
                extraSpacing: qe
              }) {
                const Ue = ye.font;
                if (!ze) {
                  const kt = ye.charSpacing + qe;
                  kt && (Ue.vertical ? ye.translateTextMatrix(0, -kt) : ye.translateTextMatrix(kt * ye.textHScale, 0));
                  return;
                }
                const bt = Ue.charsToGlyphs(ze), It = ye.fontMatrix[0] * ye.fontSize;
                for (let kt = 0, ht = bt.length; kt < ht; kt++) {
                  const Rt = bt[kt], {
                    category: _t
                  } = Rt;
                  if (_t.isInvisibleFormatMark)
                    continue;
                  let Ie = ye.charSpacing + (kt + 1 === ht ? qe : 0), Fe = Rt.width;
                  Ue.vertical && (Fe = Rt.vmetric ? Rt.vmetric[0] : -Fe);
                  let Me = Fe * It;
                  if (_t.isWhitespace) {
                    Ue.vertical ? (Ie += -Me + ye.wordSpacing, ye.translateTextMatrix(0, -Ie)) : (Ie += Me + ye.wordSpacing, ye.translateTextMatrix(Ie * ye.textHScale, 0)), L(" ");
                    continue;
                  }
                  if (!_t.isZeroWidthDiacritic && !Ge(Me)) {
                    Ue.vertical ? ye.translateTextMatrix(0, Me) : ye.translateTextMatrix(Me * ye.textHScale, 0);
                    continue;
                  }
                  const Ne = nt();
                  _t.isZeroWidthDiacritic && (Me = 0), Ue.vertical ? (ye.translateTextMatrix(0, Me), Me = Math.abs(Me), Ne.height += Me) : (Me *= ye.textHScale, ye.translateTextMatrix(Me, 0), Ne.width += Me), Me && (Ne.prevTransform = Be());
                  const je = Rt.unicode;
                  L(je) && Ne.str.push(" "), Ne.str.push(je), Ie && (Ue.vertical ? ye.translateTextMatrix(0, -Ie) : ye.translateTextMatrix(Ie * ye.textHScale, 0));
                }
              }
              function De() {
                se(), U.initialized ? (U.hasEOL = !0, st()) : ne.items.push({
                  str: "",
                  dir: "ltr",
                  width: 0,
                  height: 0,
                  transform: Be(),
                  fontName: ye.loadedName,
                  hasEOL: !0
                });
              }
              function Qe(ze, qe, Ue) {
                if (Ue * U.spaceInFlowMin <= ze && ze <= Ue * U.spaceInFlowMax)
                  return U.initialized && (se(), U.str.push(" ")), !1;
                const bt = U.fontName;
                let It = 0;
                return U.vertical && (It = ze, ze = 0), st(), se(), Le({
                  width: Math.abs(ze),
                  height: Math.abs(It),
                  transform: qe || Be(),
                  fontName: bt
                }), !0;
              }
              function st() {
                !U.initialized || !U.str || (U.vertical ? U.totalHeight += U.height * U.textAdvanceScale : U.totalWidth += U.width * U.textAdvanceScale, ne.items.push(Je(U)), U.initialized = !1, U.str.length = 0);
              }
              function wt(ze = !1) {
                const qe = ne.items.length;
                qe !== 0 && (ze && qe < C || (k.enqueue(ne, qe), ne.items = [], ne.styles = /* @__PURE__ */ Object.create(null)));
              }
              const Ot = new $();
              return new Promise(function ze(qe, Ue) {
                const bt = function(Me) {
                  wt(!0), Promise.all([Me, k.ready]).then(function() {
                    try {
                      ze(qe, Ue);
                    } catch (Ne) {
                      Ue(Ne);
                    }
                  }, Ue);
                };
                re.ensureNotTerminated(), Ot.reset();
                const It = {};
                let kt, ht = [];
                for (; !(kt = Ot.check()) && (ht.length = 0, It.args = ht, !!Ce.read(It)); ) {
                  const Me = ye;
                  ye = Z.state;
                  const Ne = It.fn;
                  switch (ht = It.args, Ne | 0) {
                    case n.OPS.setFont:
                      var Rt = ht[0].name, _t = ht[1];
                      if (ye.font && Rt === ye.fontName && _t === ye.fontSize)
                        break;
                      st(), ye.fontName = Rt, ye.fontSize = _t, bt(Ve(Rt, null));
                      return;
                    case n.OPS.setTextRise:
                      ye.textRise = ht[0];
                      break;
                    case n.OPS.setHScale:
                      ye.textHScale = ht[0] / 100;
                      break;
                    case n.OPS.setLeading:
                      ye.leading = ht[0];
                      break;
                    case n.OPS.moveText:
                      ye.translateTextLineMatrix(ht[0], ht[1]), ye.textMatrix = ye.textLineMatrix.slice();
                      break;
                    case n.OPS.setLeadingMoveText:
                      ye.leading = -ht[1], ye.translateTextLineMatrix(ht[0], ht[1]), ye.textMatrix = ye.textLineMatrix.slice();
                      break;
                    case n.OPS.nextLine:
                      ye.carriageReturn();
                      break;
                    case n.OPS.setTextMatrix:
                      ye.setTextMatrix(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5]), ye.setTextLineMatrix(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5]), Oe();
                      break;
                    case n.OPS.setCharSpacing:
                      ye.charSpacing = ht[0];
                      break;
                    case n.OPS.setWordSpacing:
                      ye.wordSpacing = ht[0];
                      break;
                    case n.OPS.beginText:
                      ye.textMatrix = n.IDENTITY_MATRIX.slice(), ye.textLineMatrix = n.IDENTITY_MATRIX.slice();
                      break;
                    case n.OPS.showSpacedText:
                      if (!Z.state.font) {
                        xe.ensureStateFont(Z.state);
                        continue;
                      }
                      const je = (ye.font.vertical ? 1 : -1) * ye.fontSize / 1e3, et = ht[0];
                      for (let $e = 0, Ee = et.length; $e < Ee; $e++) {
                        const He = et[$e];
                        if (typeof He == "string")
                          Ae.push(He);
                        else if (typeof He == "number" && He !== 0) {
                          const rt = Ae.join("");
                          Ae.length = 0, dt({
                            chars: rt,
                            extraSpacing: He * je
                          });
                        }
                      }
                      if (Ae.length > 0) {
                        const $e = Ae.join("");
                        Ae.length = 0, dt({
                          chars: $e,
                          extraSpacing: 0
                        });
                      }
                      break;
                    case n.OPS.showText:
                      if (!Z.state.font) {
                        xe.ensureStateFont(Z.state);
                        continue;
                      }
                      dt({
                        chars: ht[0],
                        extraSpacing: 0
                      });
                      break;
                    case n.OPS.nextLineShowText:
                      if (!Z.state.font) {
                        xe.ensureStateFont(Z.state);
                        continue;
                      }
                      ye.carriageReturn(), dt({
                        chars: ht[0],
                        extraSpacing: 0
                      });
                      break;
                    case n.OPS.nextLineSetSpacingShowText:
                      if (!Z.state.font) {
                        xe.ensureStateFont(Z.state);
                        continue;
                      }
                      ye.wordSpacing = ht[0], ye.charSpacing = ht[1], ye.carriageReturn(), dt({
                        chars: ht[2],
                        extraSpacing: 0
                      });
                      break;
                    case n.OPS.paintXObject:
                      st(), be || (be = K.get("XObject") || D.Dict.empty);
                      var Ie = ht[0] instanceof D.Name, Fe = ht[0].name;
                      if (Ie && he.getByName(Fe))
                        break;
                      bt(new Promise(function($e, Ee) {
                        if (!Ie)
                          throw new n.FormatError("XObject must be referred to by name.");
                        let He = be.getRaw(Fe);
                        if (He instanceof D.Ref) {
                          if (he.getByRef(He)) {
                            $e();
                            return;
                          }
                          if (xe.globalImageCache.getData(He, xe.pageIndex)) {
                            $e();
                            return;
                          }
                          He = we.fetch(He);
                        }
                        if (!(He instanceof N.BaseStream))
                          throw new n.FormatError("XObject should be a stream");
                        const rt = He.dict.get("Subtype");
                        if (!(rt instanceof D.Name))
                          throw new n.FormatError("XObject should have a Name subtype");
                        if (rt.name !== "Form") {
                          he.set(Fe, He.dict.objId, !0), $e();
                          return;
                        }
                        const mt = Z.state.clone(), tt = new m(mt), at = He.dict.getArray("Matrix");
                        Array.isArray(at) && at.length === 6 && tt.transform(at), wt();
                        const ft = {
                          enqueueInvoked: !1,
                          enqueue(We, ot) {
                            this.enqueueInvoked = !0, k.enqueue(We, ot);
                          },
                          get desiredSize() {
                            return k.desiredSize;
                          },
                          get ready() {
                            return k.ready;
                          }
                        };
                        xe.getTextContent({
                          stream: He,
                          task: re,
                          resources: He.dict.get("Resources") || K,
                          stateManager: tt,
                          includeMarkedContent: w,
                          sink: ft,
                          seenStyles: X,
                          viewBox: H,
                          markedContentData: Y,
                          disableNormalization: ie
                        }).then(function() {
                          ft.enqueueInvoked || he.set(Fe, He.dict.objId, !0), $e();
                        }, Ee);
                      }).catch(function($e) {
                        if (!($e instanceof n.AbortException)) {
                          if (xe.options.ignoreErrors) {
                            (0, n.warn)(`getTextContent - ignoring XObject: "${$e}".`);
                            return;
                          }
                          throw $e;
                        }
                      }));
                      return;
                    case n.OPS.setGState:
                      if (Ie = ht[0] instanceof D.Name, Fe = ht[0].name, Ie && fe.getByName(Fe))
                        break;
                      bt(new Promise(function($e, Ee) {
                        if (!Ie)
                          throw new n.FormatError("GState must be referred to by name.");
                        const He = K.get("ExtGState");
                        if (!(He instanceof D.Dict))
                          throw new n.FormatError("ExtGState should be a dictionary.");
                        const rt = He.get(Fe);
                        if (!(rt instanceof D.Dict))
                          throw new n.FormatError("GState should be a dictionary.");
                        const mt = rt.get("Font");
                        if (!mt) {
                          fe.set(Fe, rt.objId, !0), $e();
                          return;
                        }
                        st(), ye.fontName = null, ye.fontSize = mt[1], Ve(null, mt[0]).then($e, Ee);
                      }).catch(function($e) {
                        if (!($e instanceof n.AbortException)) {
                          if (xe.options.ignoreErrors) {
                            (0, n.warn)(`getTextContent - ignoring ExtGState: "${$e}".`);
                            return;
                          }
                          throw $e;
                        }
                      }));
                      return;
                    case n.OPS.beginMarkedContent:
                      st(), w && (Y.level++, ne.items.push({
                        type: "beginMarkedContent",
                        tag: ht[0] instanceof D.Name ? ht[0].name : null
                      }));
                      break;
                    case n.OPS.beginMarkedContentProps:
                      if (st(), w) {
                        Y.level++;
                        let $e = null;
                        ht[1] instanceof D.Dict && ($e = ht[1].get("MCID")), ne.items.push({
                          type: "beginMarkedContentProps",
                          id: Number.isInteger($e) ? `${xe.idFactory.getPageObjId()}_mc${$e}` : null,
                          tag: ht[0] instanceof D.Name ? ht[0].name : null
                        });
                      }
                      break;
                    case n.OPS.endMarkedContent:
                      if (st(), w) {
                        if (Y.level === 0)
                          break;
                        Y.level--, ne.items.push({
                          type: "endMarkedContent"
                        });
                      }
                      break;
                    case n.OPS.restore:
                      Me && (Me.font !== ye.font || Me.fontSize !== ye.fontSize || Me.fontName !== ye.fontName) && st();
                      break;
                  }
                  if (ne.items.length >= k.desiredSize) {
                    kt = !0;
                    break;
                  }
                }
                if (kt) {
                  bt(d);
                  return;
                }
                st(), wt(), qe();
              }).catch((ze) => {
                if (!(ze instanceof n.AbortException)) {
                  if (this.options.ignoreErrors) {
                    (0, n.warn)(`getTextContent - ignoring errors during "${re.name}" task: "${ze}".`), st(), wt();
                    return;
                  }
                  throw ze;
                }
              });
            }
            extractDataStructures(q, re, K) {
              const Z = this.xref;
              let w;
              const k = this.readToUnicode(K.toUnicode || q.get("ToUnicode") || re.get("ToUnicode"));
              if (K.composite) {
                const U = q.get("CIDSystemInfo");
                U instanceof D.Dict && (K.cidSystemInfo = {
                  registry: (0, n.stringToPDFString)(U.get("Registry")),
                  ordering: (0, n.stringToPDFString)(U.get("Ordering")),
                  supplement: U.get("Supplement")
                });
                try {
                  const ae = q.get("CIDToGIDMap");
                  ae instanceof N.BaseStream && (w = ae.getBytes());
                } catch (ae) {
                  if (!this.options.ignoreErrors)
                    throw ae;
                  (0, n.warn)(`extractDataStructures - ignoring CIDToGIDMap data: "${ae}".`);
                }
              }
              const X = [];
              let H = null, Y;
              if (q.has("Encoding")) {
                if (Y = q.get("Encoding"), Y instanceof D.Dict) {
                  if (H = Y.get("BaseEncoding"), H = H instanceof D.Name ? H.name : null, Y.has("Differences")) {
                    const U = Y.get("Differences");
                    let ae = 0;
                    for (const Q of U) {
                      const L = Z.fetchIfRef(Q);
                      if (typeof L == "number")
                        ae = L;
                      else if (L instanceof D.Name)
                        X[ae++] = L.name;
                      else
                        throw new n.FormatError(`Invalid entry in 'Differences' array: ${L}`);
                    }
                  }
                } else if (Y instanceof D.Name)
                  H = Y.name;
                else {
                  const U = "Encoding is not a Name nor a Dict";
                  if (!this.options.ignoreErrors)
                    throw new n.FormatError(U);
                  (0, n.warn)(U);
                }
                H !== "MacRomanEncoding" && H !== "MacExpertEncoding" && H !== "WinAnsiEncoding" && (H = null);
              }
              const ie = !K.file || K.isInternalFont, ne = (0, l.getSymbolsFonts)()[K.name];
              if (H && ie && ne && (H = null), H)
                K.defaultEncoding = (0, t.getEncoding)(H);
              else {
                const U = !!(K.flags & R.FontFlags.Symbolic), ae = !!(K.flags & R.FontFlags.Nonsymbolic);
                Y = t.StandardEncoding, K.type === "TrueType" && !ae && (Y = t.WinAnsiEncoding), (U || ne) && (Y = t.MacRomanEncoding, ie && (/Symbol/i.test(K.name) ? Y = t.SymbolSetEncoding : /Dingbats/i.test(K.name) ? Y = t.ZapfDingbatsEncoding : /Wingdings/i.test(K.name) && (Y = t.WinAnsiEncoding))), K.defaultEncoding = Y;
              }
              return K.differences = X, K.baseEncodingName = H, K.hasEncoding = !!H || X.length > 0, K.dict = q, k.then((U) => (K.toUnicode = U, this.buildToUnicode(K))).then((U) => (K.toUnicode = U, w && (K.cidToGidMap = this.readCidToGidMap(w, U)), K));
            }
            _simpleFontToUnicode(q, re = !1) {
              (0, n.assert)(!q.composite, "Must be a simple font.");
              const K = [], Z = q.defaultEncoding.slice(), w = q.baseEncodingName, k = q.differences;
              for (const H in k) {
                const Y = k[H];
                Y !== ".notdef" && (Z[H] = Y);
              }
              const X = (0, W.getGlyphsUnicode)();
              for (const H in Z) {
                let Y = Z[H];
                if (Y === "")
                  continue;
                let ie = X[Y];
                if (ie !== void 0) {
                  K[H] = String.fromCharCode(ie);
                  continue;
                }
                let ne = 0;
                switch (Y[0]) {
                  case "G":
                    Y.length === 3 && (ne = parseInt(Y.substring(1), 16));
                    break;
                  case "g":
                    Y.length === 5 && (ne = parseInt(Y.substring(1), 16));
                    break;
                  case "C":
                  case "c":
                    if (Y.length >= 3 && Y.length <= 4) {
                      const U = Y.substring(1);
                      if (re) {
                        ne = parseInt(U, 16);
                        break;
                      }
                      if (ne = +U, Number.isNaN(ne) && Number.isInteger(parseInt(U, 16)))
                        return this._simpleFontToUnicode(q, !0);
                    }
                    break;
                  case "u":
                    ie = (0, T.getUnicodeForGlyph)(Y, X), ie !== -1 && (ne = ie);
                    break;
                  default:
                    switch (Y) {
                      case "f_h":
                      case "f_t":
                      case "T_h":
                        K[H] = Y.replaceAll("_", "");
                        continue;
                    }
                    break;
                }
                if (ne > 0 && ne <= 1114111 && Number.isInteger(ne)) {
                  if (w && ne === +H) {
                    const U = (0, t.getEncoding)(w);
                    if (U && (Y = U[H])) {
                      K[H] = String.fromCharCode(X[Y]);
                      continue;
                    }
                  }
                  K[H] = String.fromCodePoint(ne);
                }
              }
              return K;
            }
            async buildToUnicode(q) {
              var re;
              if (q.hasIncludedToUnicodeMap = ((re = q.toUnicode) == null ? void 0 : re.length) > 0, q.hasIncludedToUnicodeMap)
                return !q.composite && q.hasEncoding && (q.fallbackToUnicode = this._simpleFontToUnicode(q)), q.toUnicode;
              if (!q.composite)
                return new E.ToUnicodeMap(this._simpleFontToUnicode(q));
              if (q.composite && (q.cMap.builtInCMap && !(q.cMap instanceof P.IdentityCMap) || q.cidSystemInfo.registry === "Adobe" && (q.cidSystemInfo.ordering === "GB1" || q.cidSystemInfo.ordering === "CNS1" || q.cidSystemInfo.ordering === "Japan1" || q.cidSystemInfo.ordering === "Korea1"))) {
                const {
                  registry: K,
                  ordering: Z
                } = q.cidSystemInfo, w = D.Name.get(`${K}-${Z}-UCS2`), k = await P.CMapFactory.create({
                  encoding: w,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                }), X = [], H = [];
                return q.cMap.forEach(function(Y, ie) {
                  if (ie > 65535)
                    throw new n.FormatError("Max size of CID is 65,535");
                  const ne = k.lookup(ie);
                  if (ne) {
                    H.length = 0;
                    for (let U = 0, ae = ne.length; U < ae; U += 2)
                      H.push((ne.charCodeAt(U) << 8) + ne.charCodeAt(U + 1));
                    X[Y] = String.fromCharCode(...H);
                  }
                }), new E.ToUnicodeMap(X);
              }
              return new E.IdentityToUnicodeMap(q.firstChar, q.lastChar);
            }
            readToUnicode(q) {
              return q ? q instanceof D.Name ? P.CMapFactory.create({
                encoding: q,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(re) {
                return re instanceof P.IdentityCMap ? new E.IdentityToUnicodeMap(0, 65535) : new E.ToUnicodeMap(re.getMap());
              }) : q instanceof N.BaseStream ? P.CMapFactory.create({
                encoding: q,
                fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                useCMap: null
              }).then(function(re) {
                if (re instanceof P.IdentityCMap)
                  return new E.IdentityToUnicodeMap(0, 65535);
                const K = new Array(re.length);
                return re.forEach(function(Z, w) {
                  if (typeof w == "number") {
                    K[Z] = String.fromCodePoint(w);
                    return;
                  }
                  const k = [];
                  for (let X = 0; X < w.length; X += 2) {
                    const H = w.charCodeAt(X) << 8 | w.charCodeAt(X + 1);
                    if ((H & 63488) !== 55296) {
                      k.push(H);
                      continue;
                    }
                    X += 2;
                    const Y = w.charCodeAt(X) << 8 | w.charCodeAt(X + 1);
                    k.push(((H & 1023) << 10) + (Y & 1023) + 65536);
                  }
                  K[Z] = String.fromCodePoint(...k);
                }), new E.ToUnicodeMap(K);
              }, (re) => {
                if (re instanceof n.AbortException)
                  return null;
                if (this.options.ignoreErrors)
                  return (0, n.warn)(`readToUnicode - ignoring ToUnicode data: "${re}".`), null;
                throw re;
              }) : Promise.resolve(null) : Promise.resolve(null);
            }
            readCidToGidMap(q, re) {
              const K = [];
              for (let Z = 0, w = q.length; Z < w; Z++) {
                const k = q[Z++] << 8 | q[Z], X = Z >> 1;
                k === 0 && !re.has(X) || (K[X] = k);
              }
              return K;
            }
            extractWidths(q, re, K) {
              const Z = this.xref;
              let w = [], k = 0;
              const X = [];
              let H, Y, ie, ne, U, ae, Q, L;
              if (K.composite) {
                if (k = q.has("DW") ? q.get("DW") : 1e3, L = q.get("W"), L)
                  for (Y = 0, ie = L.length; Y < ie; Y++)
                    if (ae = Z.fetchIfRef(L[Y++]), Q = Z.fetchIfRef(L[Y]), Array.isArray(Q))
                      for (ne = 0, U = Q.length; ne < U; ne++)
                        w[ae++] = Z.fetchIfRef(Q[ne]);
                    else {
                      const le = Z.fetchIfRef(L[++Y]);
                      for (ne = ae; ne <= Q; ne++)
                        w[ne] = le;
                    }
                if (K.vertical) {
                  let le = q.getArray("DW2") || [880, -1e3];
                  if (H = [le[1], k * 0.5, le[0]], le = q.get("W2"), le)
                    for (Y = 0, ie = le.length; Y < ie; Y++)
                      if (ae = Z.fetchIfRef(le[Y++]), Q = Z.fetchIfRef(le[Y]), Array.isArray(Q))
                        for (ne = 0, U = Q.length; ne < U; ne++)
                          X[ae++] = [Z.fetchIfRef(Q[ne++]), Z.fetchIfRef(Q[ne++]), Z.fetchIfRef(Q[ne])];
                      else {
                        const ue = [Z.fetchIfRef(le[++Y]), Z.fetchIfRef(le[++Y]), Z.fetchIfRef(le[++Y])];
                        for (ne = ae; ne <= Q; ne++)
                          X[ne] = ue;
                      }
                }
              } else {
                const le = K.firstChar;
                if (L = q.get("Widths"), L) {
                  for (ne = le, Y = 0, ie = L.length; Y < ie; Y++)
                    w[ne++] = Z.fetchIfRef(L[Y]);
                  k = parseFloat(re.get("MissingWidth")) || 0;
                } else {
                  const ue = q.get("BaseFont");
                  if (ue instanceof D.Name) {
                    const de = this.getBaseFontMetrics(ue.name);
                    w = this.buildCharCodeToWidth(de.widths, K), k = de.defaultWidth;
                  }
                }
              }
              let ee = !0, se = k;
              for (const le in w) {
                const ue = w[le];
                if (ue) {
                  if (!se) {
                    se = ue;
                    continue;
                  }
                  if (se !== ue) {
                    ee = !1;
                    break;
                  }
                }
              }
              ee ? K.flags |= R.FontFlags.FixedPitch : K.flags &= ~R.FontFlags.FixedPitch, K.defaultWidth = k, K.widths = w, K.defaultVMetrics = H, K.vmetrics = X;
            }
            isSerifFont(q) {
              const re = q.split("-")[0];
              return re in (0, l.getSerifFonts)() || /serif/gi.test(re);
            }
            getBaseFontMetrics(q) {
              let re = 0, K = /* @__PURE__ */ Object.create(null), Z = !1, k = (0, l.getStdFontMap)()[q] || q;
              const X = (0, g.getMetrics)();
              k in X || (k = this.isSerifFont(q) ? "Times-Roman" : "Helvetica");
              const H = X[k];
              return typeof H == "number" ? (re = H, Z = !0) : K = H(), {
                defaultWidth: re,
                monospace: Z,
                widths: K
              };
            }
            buildCharCodeToWidth(q, re) {
              const K = /* @__PURE__ */ Object.create(null), Z = re.differences, w = re.defaultEncoding;
              for (let k = 0; k < 256; k++) {
                if (k in Z && q[Z[k]]) {
                  K[k] = q[Z[k]];
                  continue;
                }
                if (k in w && q[w[k]]) {
                  K[k] = q[w[k]];
                  continue;
                }
              }
              return K;
            }
            preEvaluateFont(q) {
              const re = q;
              let K = q.get("Subtype");
              if (!(K instanceof D.Name))
                throw new n.FormatError("invalid font Subtype");
              let Z = !1, w, k;
              if (K.name === "Type0") {
                const ie = q.get("DescendantFonts");
                if (!ie)
                  throw new n.FormatError("Descendant fonts are not specified");
                if (q = Array.isArray(ie) ? this.xref.fetchIfRef(ie[0]) : ie, !(q instanceof D.Dict))
                  throw new n.FormatError("Descendant font is not a dictionary.");
                if (K = q.get("Subtype"), !(K instanceof D.Name))
                  throw new n.FormatError("invalid font Subtype");
                Z = !0;
              }
              const X = q.get("FirstChar") || 0, H = q.get("LastChar") || (Z ? 65535 : 255), Y = q.get("FontDescriptor");
              if (Y) {
                w = new c.MurmurHash3_64();
                const ie = re.getRaw("Encoding");
                if (ie instanceof D.Name)
                  w.update(ie.name);
                else if (ie instanceof D.Ref)
                  w.update(ie.toString());
                else if (ie instanceof D.Dict) {
                  for (const U of ie.getRawValues())
                    if (U instanceof D.Name)
                      w.update(U.name);
                    else if (U instanceof D.Ref)
                      w.update(U.toString());
                    else if (Array.isArray(U)) {
                      const ae = U.length, Q = new Array(ae);
                      for (let L = 0; L < ae; L++) {
                        const ee = U[L];
                        ee instanceof D.Name ? Q[L] = ee.name : (typeof ee == "number" || ee instanceof D.Ref) && (Q[L] = ee.toString());
                      }
                      w.update(Q.join());
                    }
                }
                if (w.update(`${X}-${H}`), k = q.get("ToUnicode") || re.get("ToUnicode"), k instanceof N.BaseStream) {
                  const U = k.str || k, ae = U.buffer ? new Uint8Array(U.buffer.buffer, 0, U.bufferLength) : new Uint8Array(U.bytes.buffer, U.start, U.end - U.start);
                  w.update(ae);
                } else
                  k instanceof D.Name && w.update(k.name);
                const ne = q.get("Widths") || re.get("Widths");
                if (Array.isArray(ne)) {
                  const U = [];
                  for (const ae of ne)
                    (typeof ae == "number" || ae instanceof D.Ref) && U.push(ae.toString());
                  w.update(U.join());
                }
                if (Z) {
                  w.update("compositeFont");
                  const U = q.get("W") || re.get("W");
                  if (Array.isArray(U)) {
                    const Q = [];
                    for (const L of U)
                      if (typeof L == "number" || L instanceof D.Ref)
                        Q.push(L.toString());
                      else if (Array.isArray(L)) {
                        const ee = [];
                        for (const se of L)
                          (typeof se == "number" || se instanceof D.Ref) && ee.push(se.toString());
                        Q.push(`[${ee.join()}]`);
                      }
                    w.update(Q.join());
                  }
                  const ae = q.getRaw("CIDToGIDMap") || re.getRaw("CIDToGIDMap");
                  ae instanceof D.Name ? w.update(ae.name) : ae instanceof D.Ref ? w.update(ae.toString()) : ae instanceof N.BaseStream && w.update(ae.peekBytes());
                }
              }
              return {
                descriptor: Y,
                dict: q,
                baseDict: re,
                composite: Z,
                type: K.name,
                firstChar: X,
                lastChar: H,
                toUnicode: k,
                hash: w ? w.hexdigest() : ""
              };
            }
            async translateFont({
              descriptor: q,
              dict: re,
              baseDict: K,
              composite: Z,
              type: w,
              firstChar: k,
              lastChar: X,
              toUnicode: H,
              cssFontInfo: Y
            }) {
              const ie = w === "Type3";
              let ne;
              if (!q)
                if (ie)
                  q = new D.Dict(null), q.set("FontName", D.Name.get(w)), q.set("FontBBox", re.getArray("FontBBox") || [0, 0, 0, 0]);
                else {
                  let xe = re.get("BaseFont");
                  if (!(xe instanceof D.Name))
                    throw new n.FormatError("Base font is not specified");
                  xe = xe.name.replaceAll(/[,_]/g, "-");
                  const we = this.getBaseFontMetrics(xe), Ae = xe.split("-")[0], be = (this.isSerifFont(Ae) ? R.FontFlags.Serif : 0) | (we.monospace ? R.FontFlags.FixedPitch : 0) | ((0, l.getSymbolsFonts)()[Ae] ? R.FontFlags.Symbolic : R.FontFlags.Nonsymbolic);
                  ne = {
                    type: w,
                    name: xe,
                    loadedName: K.loadedName,
                    systemFontInfo: null,
                    widths: we.widths,
                    defaultWidth: we.defaultWidth,
                    isSimulatedFlags: !0,
                    flags: be,
                    firstChar: k,
                    lastChar: X,
                    toUnicode: H,
                    xHeight: 0,
                    capHeight: 0,
                    italicAngle: 0,
                    isType3Font: ie
                  };
                  const he = re.get("Widths"), fe = (0, l.getStandardFontName)(xe);
                  let Ce = null;
                  return fe && (Ce = await this.fetchStandardFontData(fe), ne.isInternalFont = !!Ce), !ne.isInternalFont && this.options.useSystemFonts && (ne.systemFontInfo = (0, z.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, xe, fe)), this.extractDataStructures(re, re, ne).then((ye) => {
                    if (he) {
                      const Le = [];
                      let Be = k;
                      for (const nt of he)
                        Le[Be++] = this.xref.fetchIfRef(nt);
                      ye.widths = Le;
                    } else
                      ye.widths = this.buildCharCodeToWidth(we.widths, ye);
                    return new e.Font(xe, Ce, ye);
                  });
                }
              let U = q.get("FontName"), ae = re.get("BaseFont");
              typeof U == "string" && (U = D.Name.get(U)), typeof ae == "string" && (ae = D.Name.get(ae));
              const Q = U == null ? void 0 : U.name, L = ae == null ? void 0 : ae.name;
              if (!ie && Q !== L && ((0, n.info)(`The FontDescriptor's FontName is "${Q}" but should be the same as the Font's BaseFont "${L}".`), Q && L && (L.startsWith(Q) || !(0, l.isKnownFontName)(Q) && (0, l.isKnownFontName)(L)) && (U = null)), U || (U = ae), !(U instanceof D.Name))
                throw new n.FormatError("invalid font name");
              let ee, se, le, ue, de;
              try {
                ee = q.get("FontFile", "FontFile2", "FontFile3");
              } catch (xe) {
                if (!this.options.ignoreErrors)
                  throw xe;
                (0, n.warn)(`translateFont - fetching "${U.name}" font file: "${xe}".`), ee = new a.NullStream();
              }
              let ge = !1, me = null, pe = null;
              if (ee) {
                if (ee.dict) {
                  const xe = ee.dict.get("Subtype");
                  xe instanceof D.Name && (se = xe.name), le = ee.dict.get("Length1"), ue = ee.dict.get("Length2"), de = ee.dict.get("Length3");
                }
              } else if (Y) {
                const xe = (0, te.getXfaFontName)(U.name);
                xe && (Y.fontFamily = `${Y.fontFamily}-PdfJS-XFA`, Y.metrics = xe.metrics || null, me = xe.factors || null, ee = await this.fetchStandardFontData(xe.name), ge = !!ee, K = re = (0, te.getXfaFontDict)(U.name), Z = !0);
              } else if (!ie) {
                const xe = (0, l.getStandardFontName)(U.name);
                xe && (ee = await this.fetchStandardFontData(xe), ge = !!ee), !ge && this.options.useSystemFonts && (pe = (0, z.getFontSubstitution)(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, U.name, xe));
              }
              if (ne = {
                type: w,
                name: U.name,
                subtype: se,
                file: ee,
                length1: le,
                length2: ue,
                length3: de,
                isInternalFont: ge,
                loadedName: K.loadedName,
                composite: Z,
                fixedPitch: !1,
                fontMatrix: re.getArray("FontMatrix") || n.FONT_IDENTITY_MATRIX,
                firstChar: k,
                lastChar: X,
                toUnicode: H,
                bbox: q.getArray("FontBBox") || re.getArray("FontBBox"),
                ascent: q.get("Ascent"),
                descent: q.get("Descent"),
                xHeight: q.get("XHeight") || 0,
                capHeight: q.get("CapHeight") || 0,
                flags: q.get("Flags"),
                italicAngle: q.get("ItalicAngle") || 0,
                isType3Font: ie,
                cssFontInfo: Y,
                scaleFactors: me,
                systemFontInfo: pe
              }, Z) {
                const xe = K.get("Encoding");
                xe instanceof D.Name && (ne.cidEncoding = xe.name);
                const we = await P.CMapFactory.create({
                  encoding: xe,
                  fetchBuiltInCMap: this._fetchBuiltInCMapBound,
                  useCMap: null
                });
                ne.cMap = we, ne.vertical = ne.cMap.vertical;
              }
              return this.extractDataStructures(re, K, ne).then((xe) => (this.extractWidths(re, q, xe), new e.Font(U.name, ee, xe)));
            }
            static buildFontPaths(q, re, K, Z) {
              function w(k) {
                const X = `${q.loadedName}_path_${k}`;
                try {
                  if (q.renderer.hasBuiltPath(k))
                    return;
                  K.send("commonobj", [X, "FontPath", q.renderer.getPathJs(k)]);
                } catch (H) {
                  if (Z.ignoreErrors) {
                    (0, n.warn)(`buildFontPaths - ignoring ${X} glyph: "${H}".`);
                    return;
                  }
                  throw H;
                }
              }
              for (const k of re) {
                w(k.fontChar);
                const X = k.accent;
                X != null && X.fontChar && w(X.fontChar);
              }
            }
            static get fallbackFontDict() {
              const q = new D.Dict();
              return q.set("BaseFont", D.Name.get("Helvetica")), q.set("Type", D.Name.get("FallbackType")), q.set("Subtype", D.Name.get("FallbackType")), q.set("Encoding", D.Name.get("WinAnsiEncoding")), (0, n.shadow)(this, "fallbackFontDict", q);
            }
          }
          b.PartialEvaluator = S;
          class v {
            constructor({
              loadedName: q,
              font: re,
              dict: K,
              evaluatorOptions: Z
            }) {
              this.loadedName = q, this.font = re, this.dict = K, this._evaluatorOptions = Z || r, this.type3Loaded = null, this.type3Dependencies = re.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
            }
            send(q) {
              this.sent || (this.sent = !0, q.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
            }
            fallback(q) {
              this.font.data && (this.font.disableFontFace = !0, S.buildFontPaths(this.font, this.font.glyphCacheValues, q, this._evaluatorOptions));
            }
            loadType3Data(q, re, K) {
              if (this.type3Loaded)
                return this.type3Loaded;
              if (!this.font.isType3Font)
                throw new Error("Must be a Type3 font.");
              const Z = q.clone({
                ignoreErrors: !1
              });
              Z.parsingType3Font = !0;
              const w = new D.RefSet(q.type3FontRefs);
              this.dict.objId && !w.has(this.dict.objId) && w.put(this.dict.objId), Z.type3FontRefs = w;
              const k = this.font, X = this.type3Dependencies;
              let H = Promise.resolve();
              const Y = this.dict.get("CharProcs"), ie = this.dict.get("Resources") || re, ne = /* @__PURE__ */ Object.create(null), U = n.Util.normalizeRect(k.bbox || [0, 0, 0, 0]), ae = U[2] - U[0], Q = U[3] - U[1], L = Math.hypot(ae, Q);
              for (const ee of Y.getKeys())
                H = H.then(() => {
                  const se = Y.get(ee), le = new I.OperatorList();
                  return Z.getOperatorList({
                    stream: se,
                    task: K,
                    resources: ie,
                    operatorList: le
                  }).then(() => {
                    le.fnArray[0] === n.OPS.setCharWidthAndBounds && this._removeType3ColorOperators(le, L), ne[ee] = le.getIR();
                    for (const ue of le.dependencies)
                      X.add(ue);
                  }).catch(function(ue) {
                    (0, n.warn)(`Type3 font resource "${ee}" is not available.`);
                    const de = new I.OperatorList();
                    ne[ee] = de.getIR();
                  });
                });
              return this.type3Loaded = H.then(() => {
                k.charProcOperatorList = ne, this._bbox && (k.isCharBBox = !0, k.bbox = this._bbox);
              }), this.type3Loaded;
            }
            _removeType3ColorOperators(q, re = NaN) {
              const K = n.Util.normalizeRect(q.argsArray[0].slice(2)), Z = K[2] - K[0], w = K[3] - K[1], k = Math.hypot(Z, w);
              Z === 0 || w === 0 ? (q.fnArray.splice(0, 1), q.argsArray.splice(0, 1)) : (re === 0 || Math.round(k / re) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], K[0]), this._bbox[1] = Math.min(this._bbox[1], K[1]), this._bbox[2] = Math.max(this._bbox[2], K[2]), this._bbox[3] = Math.max(this._bbox[3], K[3]));
              let X = 0, H = q.length;
              for (; X < H; ) {
                switch (q.fnArray[X]) {
                  case n.OPS.setCharWidthAndBounds:
                    break;
                  case n.OPS.setStrokeColorSpace:
                  case n.OPS.setFillColorSpace:
                  case n.OPS.setStrokeColor:
                  case n.OPS.setStrokeColorN:
                  case n.OPS.setFillColor:
                  case n.OPS.setFillColorN:
                  case n.OPS.setStrokeGray:
                  case n.OPS.setFillGray:
                  case n.OPS.setStrokeRGBColor:
                  case n.OPS.setFillRGBColor:
                  case n.OPS.setStrokeCMYKColor:
                  case n.OPS.setFillCMYKColor:
                  case n.OPS.shadingFill:
                  case n.OPS.setRenderingIntent:
                    q.fnArray.splice(X, 1), q.argsArray.splice(X, 1), H--;
                    continue;
                  case n.OPS.setGState:
                    const [Y] = q.argsArray[X];
                    let ie = 0, ne = Y.length;
                    for (; ie < ne; ) {
                      const [U] = Y[ie];
                      switch (U) {
                        case "TR":
                        case "TR2":
                        case "HT":
                        case "BG":
                        case "BG2":
                        case "UCR":
                        case "UCR2":
                          Y.splice(ie, 1), ne--;
                          continue;
                      }
                      ie++;
                    }
                    break;
                }
                X++;
              }
            }
          }
          class m {
            constructor(q = new A()) {
              this.state = q, this.stateStack = [];
            }
            save() {
              const q = this.state;
              this.stateStack.push(this.state), this.state = q.clone();
            }
            restore() {
              const q = this.stateStack.pop();
              q && (this.state = q);
            }
            transform(q) {
              this.state.ctm = n.Util.transform(this.state.ctm, q);
            }
          }
          class h {
            constructor() {
              this.ctm = new Float32Array(n.IDENTITY_MATRIX), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.textMatrix = n.IDENTITY_MATRIX.slice(), this.textLineMatrix = n.IDENTITY_MATRIX.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
            }
            setTextMatrix(q, re, K, Z, w, k) {
              const X = this.textMatrix;
              X[0] = q, X[1] = re, X[2] = K, X[3] = Z, X[4] = w, X[5] = k;
            }
            setTextLineMatrix(q, re, K, Z, w, k) {
              const X = this.textLineMatrix;
              X[0] = q, X[1] = re, X[2] = K, X[3] = Z, X[4] = w, X[5] = k;
            }
            translateTextMatrix(q, re) {
              const K = this.textMatrix;
              K[4] = K[0] * q + K[2] * re + K[4], K[5] = K[1] * q + K[3] * re + K[5];
            }
            translateTextLineMatrix(q, re) {
              const K = this.textLineMatrix;
              K[4] = K[0] * q + K[2] * re + K[4], K[5] = K[1] * q + K[3] * re + K[5];
            }
            carriageReturn() {
              this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
            }
            clone() {
              const q = Object.create(this);
              return q.textMatrix = this.textMatrix.slice(), q.textLineMatrix = this.textLineMatrix.slice(), q.fontMatrix = this.fontMatrix.slice(), q;
            }
          }
          class A {
            constructor() {
              this.ctm = new Float32Array(n.IDENTITY_MATRIX), this.font = null, this.textRenderingMode = n.TextRenderingMode.FILL, this.fillColorSpace = O.ColorSpace.singletons.gray, this.strokeColorSpace = O.ColorSpace.singletons.gray;
            }
            clone() {
              return Object.create(this);
            }
          }
          const J = class J {
            static get opMap() {
              return (0, n.shadow)(this, "opMap", {
                w: {
                  id: n.OPS.setLineWidth,
                  numArgs: 1,
                  variableArgs: !1
                },
                J: {
                  id: n.OPS.setLineCap,
                  numArgs: 1,
                  variableArgs: !1
                },
                j: {
                  id: n.OPS.setLineJoin,
                  numArgs: 1,
                  variableArgs: !1
                },
                M: {
                  id: n.OPS.setMiterLimit,
                  numArgs: 1,
                  variableArgs: !1
                },
                d: {
                  id: n.OPS.setDash,
                  numArgs: 2,
                  variableArgs: !1
                },
                ri: {
                  id: n.OPS.setRenderingIntent,
                  numArgs: 1,
                  variableArgs: !1
                },
                i: {
                  id: n.OPS.setFlatness,
                  numArgs: 1,
                  variableArgs: !1
                },
                gs: {
                  id: n.OPS.setGState,
                  numArgs: 1,
                  variableArgs: !1
                },
                q: {
                  id: n.OPS.save,
                  numArgs: 0,
                  variableArgs: !1
                },
                Q: {
                  id: n.OPS.restore,
                  numArgs: 0,
                  variableArgs: !1
                },
                cm: {
                  id: n.OPS.transform,
                  numArgs: 6,
                  variableArgs: !1
                },
                m: {
                  id: n.OPS.moveTo,
                  numArgs: 2,
                  variableArgs: !1
                },
                l: {
                  id: n.OPS.lineTo,
                  numArgs: 2,
                  variableArgs: !1
                },
                c: {
                  id: n.OPS.curveTo,
                  numArgs: 6,
                  variableArgs: !1
                },
                v: {
                  id: n.OPS.curveTo2,
                  numArgs: 4,
                  variableArgs: !1
                },
                y: {
                  id: n.OPS.curveTo3,
                  numArgs: 4,
                  variableArgs: !1
                },
                h: {
                  id: n.OPS.closePath,
                  numArgs: 0,
                  variableArgs: !1
                },
                re: {
                  id: n.OPS.rectangle,
                  numArgs: 4,
                  variableArgs: !1
                },
                S: {
                  id: n.OPS.stroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                s: {
                  id: n.OPS.closeStroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                f: {
                  id: n.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                },
                F: {
                  id: n.OPS.fill,
                  numArgs: 0,
                  variableArgs: !1
                },
                "f*": {
                  id: n.OPS.eoFill,
                  numArgs: 0,
                  variableArgs: !1
                },
                B: {
                  id: n.OPS.fillStroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                "B*": {
                  id: n.OPS.eoFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                b: {
                  id: n.OPS.closeFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                "b*": {
                  id: n.OPS.closeEOFillStroke,
                  numArgs: 0,
                  variableArgs: !1
                },
                n: {
                  id: n.OPS.endPath,
                  numArgs: 0,
                  variableArgs: !1
                },
                W: {
                  id: n.OPS.clip,
                  numArgs: 0,
                  variableArgs: !1
                },
                "W*": {
                  id: n.OPS.eoClip,
                  numArgs: 0,
                  variableArgs: !1
                },
                BT: {
                  id: n.OPS.beginText,
                  numArgs: 0,
                  variableArgs: !1
                },
                ET: {
                  id: n.OPS.endText,
                  numArgs: 0,
                  variableArgs: !1
                },
                Tc: {
                  id: n.OPS.setCharSpacing,
                  numArgs: 1,
                  variableArgs: !1
                },
                Tw: {
                  id: n.OPS.setWordSpacing,
                  numArgs: 1,
                  variableArgs: !1
                },
                Tz: {
                  id: n.OPS.setHScale,
                  numArgs: 1,
                  variableArgs: !1
                },
                TL: {
                  id: n.OPS.setLeading,
                  numArgs: 1,
                  variableArgs: !1
                },
                Tf: {
                  id: n.OPS.setFont,
                  numArgs: 2,
                  variableArgs: !1
                },
                Tr: {
                  id: n.OPS.setTextRenderingMode,
                  numArgs: 1,
                  variableArgs: !1
                },
                Ts: {
                  id: n.OPS.setTextRise,
                  numArgs: 1,
                  variableArgs: !1
                },
                Td: {
                  id: n.OPS.moveText,
                  numArgs: 2,
                  variableArgs: !1
                },
                TD: {
                  id: n.OPS.setLeadingMoveText,
                  numArgs: 2,
                  variableArgs: !1
                },
                Tm: {
                  id: n.OPS.setTextMatrix,
                  numArgs: 6,
                  variableArgs: !1
                },
                "T*": {
                  id: n.OPS.nextLine,
                  numArgs: 0,
                  variableArgs: !1
                },
                Tj: {
                  id: n.OPS.showText,
                  numArgs: 1,
                  variableArgs: !1
                },
                TJ: {
                  id: n.OPS.showSpacedText,
                  numArgs: 1,
                  variableArgs: !1
                },
                "'": {
                  id: n.OPS.nextLineShowText,
                  numArgs: 1,
                  variableArgs: !1
                },
                '"': {
                  id: n.OPS.nextLineSetSpacingShowText,
                  numArgs: 3,
                  variableArgs: !1
                },
                d0: {
                  id: n.OPS.setCharWidth,
                  numArgs: 2,
                  variableArgs: !1
                },
                d1: {
                  id: n.OPS.setCharWidthAndBounds,
                  numArgs: 6,
                  variableArgs: !1
                },
                CS: {
                  id: n.OPS.setStrokeColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                },
                cs: {
                  id: n.OPS.setFillColorSpace,
                  numArgs: 1,
                  variableArgs: !1
                },
                SC: {
                  id: n.OPS.setStrokeColor,
                  numArgs: 4,
                  variableArgs: !0
                },
                SCN: {
                  id: n.OPS.setStrokeColorN,
                  numArgs: 33,
                  variableArgs: !0
                },
                sc: {
                  id: n.OPS.setFillColor,
                  numArgs: 4,
                  variableArgs: !0
                },
                scn: {
                  id: n.OPS.setFillColorN,
                  numArgs: 33,
                  variableArgs: !0
                },
                G: {
                  id: n.OPS.setStrokeGray,
                  numArgs: 1,
                  variableArgs: !1
                },
                g: {
                  id: n.OPS.setFillGray,
                  numArgs: 1,
                  variableArgs: !1
                },
                RG: {
                  id: n.OPS.setStrokeRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                },
                rg: {
                  id: n.OPS.setFillRGBColor,
                  numArgs: 3,
                  variableArgs: !1
                },
                K: {
                  id: n.OPS.setStrokeCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                },
                k: {
                  id: n.OPS.setFillCMYKColor,
                  numArgs: 4,
                  variableArgs: !1
                },
                sh: {
                  id: n.OPS.shadingFill,
                  numArgs: 1,
                  variableArgs: !1
                },
                BI: {
                  id: n.OPS.beginInlineImage,
                  numArgs: 0,
                  variableArgs: !1
                },
                ID: {
                  id: n.OPS.beginImageData,
                  numArgs: 0,
                  variableArgs: !1
                },
                EI: {
                  id: n.OPS.endInlineImage,
                  numArgs: 1,
                  variableArgs: !1
                },
                Do: {
                  id: n.OPS.paintXObject,
                  numArgs: 1,
                  variableArgs: !1
                },
                MP: {
                  id: n.OPS.markPoint,
                  numArgs: 1,
                  variableArgs: !1
                },
                DP: {
                  id: n.OPS.markPointProps,
                  numArgs: 2,
                  variableArgs: !1
                },
                BMC: {
                  id: n.OPS.beginMarkedContent,
                  numArgs: 1,
                  variableArgs: !1
                },
                BDC: {
                  id: n.OPS.beginMarkedContentProps,
                  numArgs: 2,
                  variableArgs: !1
                },
                EMC: {
                  id: n.OPS.endMarkedContent,
                  numArgs: 0,
                  variableArgs: !1
                },
                BX: {
                  id: n.OPS.beginCompat,
                  numArgs: 0,
                  variableArgs: !1
                },
                EX: {
                  id: n.OPS.endCompat,
                  numArgs: 0,
                  variableArgs: !1
                },
                BM: null,
                BD: null,
                true: null,
                fa: null,
                fal: null,
                fals: null,
                false: null,
                nu: null,
                nul: null,
                null: null
              });
            }
            constructor(q, re, K = new m()) {
              this.parser = new f.Parser({
                lexer: new f.Lexer(q, J.opMap),
                xref: re
              }), this.stateManager = K, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
            }
            get savedStatesDepth() {
              return this.stateManager.stateStack.length;
            }
            read(q) {
              let re = q.args;
              for (; ; ) {
                const K = this.parser.getObj();
                if (K instanceof D.Cmd) {
                  const Z = K.cmd, w = J.opMap[Z];
                  if (!w) {
                    (0, n.warn)(`Unknown command "${Z}".`);
                    continue;
                  }
                  const k = w.id, X = w.numArgs;
                  let H = re !== null ? re.length : 0;
                  if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = k >= n.OPS.moveTo && k <= n.OPS.endPath, w.variableArgs)
                    H > X && (0, n.info)(`Command ${Z}: expected [0, ${X}] args, but received ${H} args.`);
                  else {
                    if (H !== X) {
                      const Y = this.nonProcessedArgs;
                      for (; H > X; )
                        Y.push(re.shift()), H--;
                      for (; H < X && Y.length !== 0; )
                        re === null && (re = []), re.unshift(Y.pop()), H++;
                    }
                    if (H < X) {
                      const Y = `command ${Z}: expected ${X} args, but received ${H} args.`;
                      if (this._isPathOp && ++this._numInvalidPathOPS > J.MAX_INVALID_PATH_OPS)
                        throw new n.FormatError(`Invalid ${Y}`);
                      (0, n.warn)(`Skipping ${Y}`), re !== null && (re.length = 0);
                      continue;
                    }
                  }
                  return this.preprocessCommand(k, re), q.fn = k, q.args = re, !0;
                }
                if (K === D.EOF)
                  return !1;
                if (K !== null && (re === null && (re = []), re.push(K), re.length > 33))
                  throw new n.FormatError("Too many arguments");
              }
            }
            preprocessCommand(q, re) {
              switch (q | 0) {
                case n.OPS.save:
                  this.stateManager.save();
                  break;
                case n.OPS.restore:
                  this.stateManager.restore();
                  break;
                case n.OPS.transform:
                  this.stateManager.transform(re);
                  break;
              }
            }
          };
          Ut(J, "MAX_INVALID_PATH_OPS", 10);
          let j = J;
          b.EvaluatorPreprocessor = j;
        },
        /* 14 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.IdentityCMap = b.CMapFactory = b.CMap = void 0;
          var n = ce(2), P = ce(4), D = ce(5), e = ce(15), t = ce(16), l = ce(3), V = ce(8);
          const te = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], E = 2 ** 24 - 1;
          class F {
            constructor(r = !1) {
              this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = r;
            }
            addCodespaceRange(r, u, C) {
              this.codespaceRanges[r - 1].push(u, C), this.numCodespaceRanges++;
            }
            mapCidRange(r, u, C) {
              if (u - r > E)
                throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
              for (; r <= u; )
                this._map[r++] = C++;
            }
            mapBfRange(r, u, C) {
              if (u - r > E)
                throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
              const d = C.length - 1;
              for (; r <= u; ) {
                this._map[r++] = C;
                const y = C.charCodeAt(d) + 1;
                if (y > 255) {
                  C = C.substring(0, d - 1) + String.fromCharCode(C.charCodeAt(d - 1) + 1) + "\0";
                  continue;
                }
                C = C.substring(0, d) + String.fromCharCode(y);
              }
            }
            mapBfRangeToArray(r, u, C) {
              if (u - r > E)
                throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
              const d = C.length;
              let y = 0;
              for (; r <= u && y < d; )
                this._map[r] = C[y++], ++r;
            }
            mapOne(r, u) {
              this._map[r] = u;
            }
            lookup(r) {
              return this._map[r];
            }
            contains(r) {
              return this._map[r] !== void 0;
            }
            forEach(r) {
              const u = this._map, C = u.length;
              if (C <= 65536)
                for (let d = 0; d < C; d++)
                  u[d] !== void 0 && r(d, u[d]);
              else
                for (const d in u)
                  r(d, u[d]);
            }
            charCodeOf(r) {
              const u = this._map;
              if (u.length <= 65536)
                return u.indexOf(r);
              for (const C in u)
                if (u[C] === r)
                  return C | 0;
              return -1;
            }
            getMap() {
              return this._map;
            }
            readCharCode(r, u, C) {
              let d = 0;
              const y = this.codespaceRanges;
              for (let _ = 0, $ = y.length; _ < $; _++) {
                d = (d << 8 | r.charCodeAt(u + _)) >>> 0;
                const S = y[_];
                for (let v = 0, m = S.length; v < m; ) {
                  const h = S[v++], A = S[v++];
                  if (d >= h && d <= A) {
                    C.charcode = d, C.length = _ + 1;
                    return;
                  }
                }
              }
              C.charcode = 0, C.length = 1;
            }
            getCharCodeLength(r) {
              const u = this.codespaceRanges;
              for (let C = 0, d = u.length; C < d; C++) {
                const y = u[C];
                for (let _ = 0, $ = y.length; _ < $; ) {
                  const S = y[_++], v = y[_++];
                  if (r >= S && r <= v)
                    return C + 1;
                }
              }
              return 1;
            }
            get length() {
              return this._map.length;
            }
            get isIdentityCMap() {
              if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
                return !1;
              for (let r = 0; r < 65536; r++)
                if (this._map[r] !== r)
                  return !1;
              return !0;
            }
          }
          b.CMap = F;
          class f extends F {
            constructor(r, u) {
              super(), this.vertical = r, this.addCodespaceRange(u, 0, 65535);
            }
            mapCidRange(r, u, C) {
              (0, n.unreachable)("should not call mapCidRange");
            }
            mapBfRange(r, u, C) {
              (0, n.unreachable)("should not call mapBfRange");
            }
            mapBfRangeToArray(r, u, C) {
              (0, n.unreachable)("should not call mapBfRangeToArray");
            }
            mapOne(r, u) {
              (0, n.unreachable)("should not call mapCidOne");
            }
            lookup(r) {
              return Number.isInteger(r) && r <= 65535 ? r : void 0;
            }
            contains(r) {
              return Number.isInteger(r) && r <= 65535;
            }
            forEach(r) {
              for (let u = 0; u <= 65535; u++)
                r(u, u);
            }
            charCodeOf(r) {
              return Number.isInteger(r) && r <= 65535 ? r : -1;
            }
            getMap() {
              const r = new Array(65536);
              for (let u = 0; u <= 65535; u++)
                r[u] = u;
              return r;
            }
            get length() {
              return 65536;
            }
            get isIdentityCMap() {
              (0, n.unreachable)("should not access .isIdentityCMap");
            }
          }
          b.IdentityCMap = f;
          function x(s) {
            let r = 0;
            for (let u = 0; u < s.length; u++)
              r = r << 8 | s.charCodeAt(u);
            return r >>> 0;
          }
          function a(s) {
            if (typeof s != "string")
              throw new n.FormatError("Malformed CMap: expected string.");
          }
          function N(s) {
            if (!Number.isInteger(s))
              throw new n.FormatError("Malformed CMap: expected int.");
          }
          function p(s, r) {
            for (; ; ) {
              let u = r.getObj();
              if (u === P.EOF)
                break;
              if ((0, P.isCmd)(u, "endbfchar"))
                return;
              a(u);
              const C = x(u);
              u = r.getObj(), a(u);
              const d = u;
              s.mapOne(C, d);
            }
          }
          function O(s, r) {
            for (; ; ) {
              let u = r.getObj();
              if (u === P.EOF)
                break;
              if ((0, P.isCmd)(u, "endbfrange"))
                return;
              a(u);
              const C = x(u);
              u = r.getObj(), a(u);
              const d = x(u);
              if (u = r.getObj(), Number.isInteger(u) || typeof u == "string") {
                const y = Number.isInteger(u) ? String.fromCharCode(u) : u;
                s.mapBfRange(C, d, y);
              } else if ((0, P.isCmd)(u, "[")) {
                u = r.getObj();
                const y = [];
                for (; !(0, P.isCmd)(u, "]") && u !== P.EOF; )
                  y.push(u), u = r.getObj();
                s.mapBfRangeToArray(C, d, y);
              } else
                break;
            }
            throw new n.FormatError("Invalid bf range.");
          }
          function M(s, r) {
            for (; ; ) {
              let u = r.getObj();
              if (u === P.EOF)
                break;
              if ((0, P.isCmd)(u, "endcidchar"))
                return;
              a(u);
              const C = x(u);
              u = r.getObj(), N(u);
              const d = u;
              s.mapOne(C, d);
            }
          }
          function R(s, r) {
            for (; ; ) {
              let u = r.getObj();
              if (u === P.EOF)
                break;
              if ((0, P.isCmd)(u, "endcidrange"))
                return;
              a(u);
              const C = x(u);
              u = r.getObj(), a(u);
              const d = x(u);
              u = r.getObj(), N(u);
              const y = u;
              s.mapCidRange(C, d, y);
            }
          }
          function z(s, r) {
            for (; ; ) {
              let u = r.getObj();
              if (u === P.EOF)
                break;
              if ((0, P.isCmd)(u, "endcodespacerange"))
                return;
              if (typeof u != "string")
                break;
              const C = x(u);
              if (u = r.getObj(), typeof u != "string")
                break;
              const d = x(u);
              s.addCodespaceRange(u.length, C, d);
            }
            throw new n.FormatError("Invalid codespace range.");
          }
          function W(s, r) {
            const u = r.getObj();
            Number.isInteger(u) && (s.vertical = !!u);
          }
          function g(s, r) {
            const u = r.getObj();
            u instanceof P.Name && (s.name = u.name);
          }
          async function T(s, r, u, C) {
            let d, y;
            e:
              for (; ; )
                try {
                  const _ = r.getObj();
                  if (_ === P.EOF)
                    break;
                  if (_ instanceof P.Name)
                    _.name === "WMode" ? W(s, r) : _.name === "CMapName" && g(s, r), d = _;
                  else if (_ instanceof P.Cmd)
                    switch (_.cmd) {
                      case "endcmap":
                        break e;
                      case "usecmap":
                        d instanceof P.Name && (y = d.name);
                        break;
                      case "begincodespacerange":
                        z(s, r);
                        break;
                      case "beginbfchar":
                        p(s, r);
                        break;
                      case "begincidchar":
                        M(s, r);
                        break;
                      case "beginbfrange":
                        O(s, r);
                        break;
                      case "begincidrange":
                        R(s, r);
                        break;
                    }
                } catch (_) {
                  if (_ instanceof l.MissingDataException)
                    throw _;
                  (0, n.warn)("Invalid cMap data: " + _);
                  continue;
                }
            return !C && y && (C = y), C ? o(s, u, C) : s;
          }
          async function o(s, r, u) {
            if (s.useCMap = await c(u, r), s.numCodespaceRanges === 0) {
              const C = s.useCMap.codespaceRanges;
              for (let d = 0; d < C.length; d++)
                s.codespaceRanges[d] = C[d].slice();
              s.numCodespaceRanges = s.useCMap.numCodespaceRanges;
            }
            return s.useCMap.forEach(function(C, d) {
              s.contains(C) || s.mapOne(C, s.useCMap.lookup(C));
            }), s;
          }
          async function c(s, r) {
            if (s === "Identity-H")
              return new f(!1, 2);
            if (s === "Identity-V")
              return new f(!0, 2);
            if (!te.includes(s))
              throw new Error("Unknown CMap name: " + s);
            if (!r)
              throw new Error("Built-in CMap parameters are not provided.");
            const {
              cMapData: u,
              compressionType: C
            } = await r(s), d = new F(!0);
            if (C === n.CMapCompressionType.BINARY)
              return new e.BinaryCMapReader().process(u, d, (y) => o(d, r, y));
            if (C === n.CMapCompressionType.NONE) {
              const y = new t.Lexer(new V.Stream(u));
              return T(d, y, r, null);
            }
            throw new Error(`Invalid CMap "compressionType" value: ${C}`);
          }
          class I {
            static async create({
              encoding: r,
              fetchBuiltInCMap: u,
              useCMap: C
            }) {
              if (r instanceof P.Name)
                return c(r.name, u);
              if (r instanceof D.BaseStream) {
                const d = await T(new F(), new t.Lexer(r), u, C);
                return d.isIdentityCMap ? c(d.name, u) : d;
              }
              throw new Error("Encoding required.");
            }
          }
          b.CMapFactory = I;
        },
        /* 15 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.BinaryCMapReader = void 0;
          var n = ce(2);
          function P(F, f) {
            let x = 0;
            for (let a = 0; a <= f; a++)
              x = x << 8 | F[a];
            return x >>> 0;
          }
          function D(F, f) {
            return f === 1 ? String.fromCharCode(F[0], F[1]) : f === 3 ? String.fromCharCode(F[0], F[1], F[2], F[3]) : String.fromCharCode(...F.subarray(0, f + 1));
          }
          function e(F, f, x) {
            let a = 0;
            for (let N = x; N >= 0; N--)
              a += F[N] + f[N], F[N] = a & 255, a >>= 8;
          }
          function t(F, f) {
            let x = 1;
            for (let a = f; a >= 0 && x > 0; a--)
              x += F[a], F[a] = x & 255, x >>= 8;
          }
          const l = 16, V = 19;
          class te {
            constructor(f) {
              this.buffer = f, this.pos = 0, this.end = f.length, this.tmpBuf = new Uint8Array(V);
            }
            readByte() {
              return this.pos >= this.end ? -1 : this.buffer[this.pos++];
            }
            readNumber() {
              let f = 0, x;
              do {
                const a = this.readByte();
                if (a < 0)
                  throw new n.FormatError("unexpected EOF in bcmap");
                x = !(a & 128), f = f << 7 | a & 127;
              } while (!x);
              return f;
            }
            readSigned() {
              const f = this.readNumber();
              return f & 1 ? ~(f >>> 1) : f >>> 1;
            }
            readHex(f, x) {
              f.set(this.buffer.subarray(this.pos, this.pos + x + 1)), this.pos += x + 1;
            }
            readHexNumber(f, x) {
              let a;
              const N = this.tmpBuf;
              let p = 0;
              do {
                const z = this.readByte();
                if (z < 0)
                  throw new n.FormatError("unexpected EOF in bcmap");
                a = !(z & 128), N[p++] = z & 127;
              } while (!a);
              let O = x, M = 0, R = 0;
              for (; O >= 0; ) {
                for (; R < 8 && N.length > 0; )
                  M |= N[--p] << R, R += 7;
                f[O] = M & 255, O--, M >>= 8, R -= 8;
              }
            }
            readHexSigned(f, x) {
              this.readHexNumber(f, x);
              const a = f[x] & 1 ? 255 : 0;
              let N = 0;
              for (let p = 0; p <= x; p++)
                N = (N & 1) << 8 | f[p], f[p] = N >> 1 ^ a;
            }
            readString() {
              const f = this.readNumber(), x = new Array(f);
              for (let a = 0; a < f; a++)
                x[a] = this.readNumber();
              return String.fromCharCode(...x);
            }
          }
          class E {
            async process(f, x, a) {
              const N = new te(f), p = N.readByte();
              x.vertical = !!(p & 1);
              let O = null;
              const M = new Uint8Array(l), R = new Uint8Array(l), z = new Uint8Array(l), W = new Uint8Array(l), g = new Uint8Array(l);
              let T, o;
              for (; (o = N.readByte()) >= 0; ) {
                const c = o >> 5;
                if (c === 7) {
                  switch (o & 31) {
                    case 0:
                      N.readString();
                      break;
                    case 1:
                      O = N.readString();
                      break;
                  }
                  continue;
                }
                const I = !!(o & 16), s = o & 15;
                if (s + 1 > l)
                  throw new Error("BinaryCMapReader.process: Invalid dataSize.");
                const r = 1, u = N.readNumber();
                switch (c) {
                  case 0:
                    N.readHex(M, s), N.readHexNumber(R, s), e(R, M, s), x.addCodespaceRange(s + 1, P(M, s), P(R, s));
                    for (let C = 1; C < u; C++)
                      t(R, s), N.readHexNumber(M, s), e(M, R, s), N.readHexNumber(R, s), e(R, M, s), x.addCodespaceRange(s + 1, P(M, s), P(R, s));
                    break;
                  case 1:
                    N.readHex(M, s), N.readHexNumber(R, s), e(R, M, s), N.readNumber();
                    for (let C = 1; C < u; C++)
                      t(R, s), N.readHexNumber(M, s), e(M, R, s), N.readHexNumber(R, s), e(R, M, s), N.readNumber();
                    break;
                  case 2:
                    N.readHex(z, s), T = N.readNumber(), x.mapOne(P(z, s), T);
                    for (let C = 1; C < u; C++)
                      t(z, s), I || (N.readHexNumber(g, s), e(z, g, s)), T = N.readSigned() + (T + 1), x.mapOne(P(z, s), T);
                    break;
                  case 3:
                    N.readHex(M, s), N.readHexNumber(R, s), e(R, M, s), T = N.readNumber(), x.mapCidRange(P(M, s), P(R, s), T);
                    for (let C = 1; C < u; C++)
                      t(R, s), I ? M.set(R) : (N.readHexNumber(M, s), e(M, R, s)), N.readHexNumber(R, s), e(R, M, s), T = N.readNumber(), x.mapCidRange(P(M, s), P(R, s), T);
                    break;
                  case 4:
                    N.readHex(z, r), N.readHex(W, s), x.mapOne(P(z, r), D(W, s));
                    for (let C = 1; C < u; C++)
                      t(z, r), I || (N.readHexNumber(g, r), e(z, g, r)), t(W, s), N.readHexSigned(g, s), e(W, g, s), x.mapOne(P(z, r), D(W, s));
                    break;
                  case 5:
                    N.readHex(M, r), N.readHexNumber(R, r), e(R, M, r), N.readHex(W, s), x.mapBfRange(P(M, r), P(R, r), D(W, s));
                    for (let C = 1; C < u; C++)
                      t(R, r), I ? M.set(R) : (N.readHexNumber(M, r), e(M, R, r)), N.readHexNumber(R, r), e(R, M, r), N.readHex(W, s), x.mapBfRange(P(M, r), P(R, r), D(W, s));
                    break;
                  default:
                    throw new Error(`BinaryCMapReader.process - unknown type: ${c}`);
                }
              }
              return O ? a(O) : x;
            }
          }
          b.BinaryCMapReader = E;
        },
        /* 16 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Parser = b.Linearization = b.Lexer = void 0;
          var n = ce(2), P = ce(4), D = ce(3), e = ce(8), t = ce(17), l = ce(19), V = ce(20), te = ce(22), E = ce(23), F = ce(26), f = ce(29), x = ce(31), a = ce(32), N = ce(33);
          const p = 1e3;
          function O(T) {
            const o = [], c = T.length;
            let I = 0;
            for (; I < c - 1; )
              o.push(T[I++] << 8 | T[I++]);
            return I < c && o.push(T[I]), c + "_" + String.fromCharCode.apply(null, o);
          }
          class M {
            constructor({
              lexer: o,
              xref: c,
              allowStreams: I = !1,
              recoveryMode: s = !1
            }) {
              this.lexer = o, this.xref = c, this.allowStreams = I, this.recoveryMode = s, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
            }
            refill() {
              this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
            }
            shift() {
              this.buf2 instanceof P.Cmd && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
            }
            tryShift() {
              try {
                return this.shift(), !0;
              } catch (o) {
                if (o instanceof D.MissingDataException)
                  throw o;
                return !1;
              }
            }
            getObj(o = null) {
              const c = this.buf1;
              if (this.shift(), c instanceof P.Cmd)
                switch (c.cmd) {
                  case "BI":
                    return this.makeInlineImage(o);
                  case "[":
                    const I = [];
                    for (; !(0, P.isCmd)(this.buf1, "]") && this.buf1 !== P.EOF; )
                      I.push(this.getObj(o));
                    if (this.buf1 === P.EOF) {
                      if (this.recoveryMode)
                        return I;
                      throw new D.ParserEOFException("End of file inside array.");
                    }
                    return this.shift(), I;
                  case "<<":
                    const s = new P.Dict(this.xref);
                    for (; !(0, P.isCmd)(this.buf1, ">>") && this.buf1 !== P.EOF; ) {
                      if (!(this.buf1 instanceof P.Name)) {
                        (0, n.info)("Malformed dictionary: key must be a name object"), this.shift();
                        continue;
                      }
                      const r = this.buf1.name;
                      if (this.shift(), this.buf1 === P.EOF)
                        break;
                      s.set(r, this.getObj(o));
                    }
                    if (this.buf1 === P.EOF) {
                      if (this.recoveryMode)
                        return s;
                      throw new D.ParserEOFException("End of file inside dictionary.");
                    }
                    return (0, P.isCmd)(this.buf2, "stream") ? this.allowStreams ? this.makeStream(s, o) : s : (this.shift(), s);
                  default:
                    return c;
                }
              if (Number.isInteger(c)) {
                if (Number.isInteger(this.buf1) && (0, P.isCmd)(this.buf2, "R")) {
                  const I = P.Ref.get(c, this.buf1);
                  return this.shift(), this.shift(), I;
                }
                return c;
              }
              return typeof c == "string" && o ? o.decryptString(c) : c;
            }
            findDefaultInlineStreamEnd(o) {
              const {
                knownCommands: d
              } = this.lexer, y = o.pos, _ = 15;
              let $ = 0, S, v;
              for (; (S = o.getByte()) !== -1; )
                if ($ === 0)
                  $ = S === 69 ? 1 : 0;
                else if ($ === 1)
                  $ = S === 73 ? 2 : 0;
                else if (S === 32 || S === 10 || S === 13) {
                  v = o.pos;
                  const h = o.peekBytes(_), A = h.length;
                  if (A === 0)
                    break;
                  for (let J = 0; J < A; J++)
                    if (S = h[J], !(S === 0 && h[J + 1] !== 0) && S !== 10 && S !== 13 && (S < 32 || S > 127)) {
                      $ = 0;
                      break;
                    }
                  if ($ !== 2)
                    continue;
                  if (!d) {
                    (0, n.warn)("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
                    continue;
                  }
                  const j = new W(new e.Stream(h.slice()), d);
                  j._hexStringWarn = () => {
                  };
                  let G = 0;
                  for (; ; ) {
                    const J = j.getObj();
                    if (J === P.EOF) {
                      $ = 0;
                      break;
                    }
                    if (J instanceof P.Cmd) {
                      const oe = d[J.cmd];
                      if (oe) {
                        if (oe.variableArgs ? G <= oe.numArgs : G === oe.numArgs)
                          break;
                      } else {
                        $ = 0;
                        break;
                      }
                      G = 0;
                      continue;
                    }
                    G++;
                  }
                  if ($ === 2)
                    break;
                } else
                  $ = 0;
              S === -1 && ((0, n.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), v && ((0, n.warn)('... trying to recover by using the last "EI" occurrence.'), o.skip(-(o.pos - v))));
              let m = 4;
              return o.skip(-m), S = o.peekByte(), o.skip(m), (0, D.isWhiteSpace)(S) || m--, o.pos - m - y;
            }
            findDCTDecodeInlineStreamEnd(o) {
              const c = o.pos;
              let I = !1, s, r;
              for (; (s = o.getByte()) !== -1; )
                if (s === 255) {
                  switch (o.getByte()) {
                    case 0:
                      break;
                    case 255:
                      o.skip(-1);
                      break;
                    case 217:
                      I = !0;
                      break;
                    case 192:
                    case 193:
                    case 194:
                    case 195:
                    case 197:
                    case 198:
                    case 199:
                    case 201:
                    case 202:
                    case 203:
                    case 205:
                    case 206:
                    case 207:
                    case 196:
                    case 204:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 254:
                      r = o.getUint16(), r > 2 ? o.skip(r - 2) : o.skip(-2);
                      break;
                  }
                  if (I)
                    break;
                }
              const u = o.pos - c;
              return s === -1 ? ((0, n.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), o.skip(-u), this.findDefaultInlineStreamEnd(o)) : (this.inlineStreamSkipEI(o), u);
            }
            findASCII85DecodeInlineStreamEnd(o) {
              const s = o.pos;
              let r;
              for (; (r = o.getByte()) !== -1; )
                if (r === 126) {
                  const C = o.pos;
                  for (r = o.peekByte(); (0, D.isWhiteSpace)(r); )
                    o.skip(), r = o.peekByte();
                  if (r === 62) {
                    o.skip();
                    break;
                  }
                  if (o.pos > C) {
                    const d = o.peekBytes(2);
                    if (d[0] === 69 && d[1] === 73)
                      break;
                  }
                }
              const u = o.pos - s;
              return r === -1 ? ((0, n.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), o.skip(-u), this.findDefaultInlineStreamEnd(o)) : (this.inlineStreamSkipEI(o), u);
            }
            findASCIIHexDecodeInlineStreamEnd(o) {
              const I = o.pos;
              let s;
              for (; (s = o.getByte()) !== -1 && s !== 62; )
                ;
              const r = o.pos - I;
              return s === -1 ? ((0, n.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), o.skip(-r), this.findDefaultInlineStreamEnd(o)) : (this.inlineStreamSkipEI(o), r);
            }
            inlineStreamSkipEI(o) {
              let s = 0, r;
              for (; (r = o.getByte()) !== -1; )
                if (s === 0)
                  s = r === 69 ? 1 : 0;
                else if (s === 1)
                  s = r === 73 ? 2 : 0;
                else if (s === 2)
                  break;
            }
            makeInlineImage(o) {
              const c = this.lexer, I = c.stream, s = /* @__PURE__ */ Object.create(null);
              let r;
              for (; !(0, P.isCmd)(this.buf1, "ID") && this.buf1 !== P.EOF; ) {
                if (!(this.buf1 instanceof P.Name))
                  throw new n.FormatError("Dictionary key must be a name object");
                const v = this.buf1.name;
                if (this.shift(), this.buf1 === P.EOF)
                  break;
                s[v] = this.getObj(o);
              }
              c.beginInlineImagePos !== -1 && (r = I.pos - c.beginInlineImagePos);
              const u = this.xref.fetchIfRef(s.F || s.Filter);
              let C;
              if (u instanceof P.Name)
                C = u.name;
              else if (Array.isArray(u)) {
                const v = this.xref.fetchIfRef(u[0]);
                v instanceof P.Name && (C = v.name);
              }
              const d = I.pos;
              let y;
              switch (C) {
                case "DCT":
                case "DCTDecode":
                  y = this.findDCTDecodeInlineStreamEnd(I);
                  break;
                case "A85":
                case "ASCII85Decode":
                  y = this.findASCII85DecodeInlineStreamEnd(I);
                  break;
                case "AHx":
                case "ASCIIHexDecode":
                  y = this.findASCIIHexDecodeInlineStreamEnd(I);
                  break;
                default:
                  y = this.findDefaultInlineStreamEnd(I);
              }
              let _;
              if (y < p && r > 0) {
                const v = I.pos;
                I.pos = c.beginInlineImagePos, _ = O(I.getBytes(r + y)), I.pos = v;
                const m = this.imageCache[_];
                if (m !== void 0)
                  return this.buf2 = P.Cmd.get("EI"), this.shift(), m.reset(), m;
              }
              const $ = new P.Dict(this.xref);
              for (const v in s)
                $.set(v, s[v]);
              let S = I.makeSubStream(d, y, $);
              return o && (S = o.createStream(S, y)), S = this.filter(S, $, y), S.dict = $, _ !== void 0 && (S.cacheKey = `inline_img_${++this._imageId}`, this.imageCache[_] = S), this.buf2 = P.Cmd.get("EI"), this.shift(), S;
            }
            _findStreamLength(o, c) {
              const {
                stream: I
              } = this.lexer;
              I.pos = o;
              const s = 2048, r = c.length;
              for (; I.pos < I.end; ) {
                const u = I.peekBytes(s), C = u.length - r;
                if (C <= 0)
                  break;
                let d = 0;
                for (; d < C; ) {
                  let y = 0;
                  for (; y < r && u[d + y] === c[y]; )
                    y++;
                  if (y >= r)
                    return I.pos += d, I.pos - o;
                  d++;
                }
                I.pos += C;
              }
              return -1;
            }
            makeStream(o, c) {
              const I = this.lexer;
              let s = I.stream;
              I.skipToNextLine();
              const r = s.pos - 1;
              let u = o.get("Length");
              if (Number.isInteger(u) || ((0, n.info)(`Bad length "${u && u.toString()}" in stream.`), u = 0), s.pos = r + u, I.nextChar(), this.tryShift() && (0, P.isCmd)(this.buf2, "endstream"))
                this.shift();
              else {
                const C = new Uint8Array([101, 110, 100, 115, 116, 114, 101, 97, 109]);
                let d = this._findStreamLength(r, C);
                if (d < 0) {
                  for (let _ = 1; _ <= 1; _++) {
                    const $ = C.length - _, S = C.slice(0, $), v = this._findStreamLength(r, S);
                    if (v >= 0) {
                      const m = s.peekBytes($ + 1)[$];
                      if (!(0, D.isWhiteSpace)(m))
                        break;
                      (0, n.info)(`Found "${(0, n.bytesToString)(S)}" when searching for endstream command.`), d = v;
                      break;
                    }
                  }
                  if (d < 0)
                    throw new n.FormatError("Missing endstream command.");
                }
                u = d, I.nextChar(), this.shift(), this.shift();
              }
              return this.shift(), s = s.makeSubStream(r, u, o), c && (s = c.createStream(s, u)), s = this.filter(s, o, u), s.dict = o, s;
            }
            filter(o, c, I) {
              let s = c.get("F", "Filter"), r = c.get("DP", "DecodeParms");
              if (s instanceof P.Name)
                return Array.isArray(r) && (0, n.warn)("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(o, s.name, I, r);
              let u = I;
              if (Array.isArray(s)) {
                const C = s, d = r;
                for (let y = 0, _ = C.length; y < _; ++y) {
                  if (s = this.xref.fetchIfRef(C[y]), !(s instanceof P.Name))
                    throw new n.FormatError(`Bad filter name "${s}"`);
                  r = null, Array.isArray(d) && y in d && (r = this.xref.fetchIfRef(d[y])), o = this.makeFilter(o, s.name, u, r), u = null;
                }
              }
              return o;
            }
            makeFilter(o, c, I, s) {
              if (I === 0)
                return (0, n.warn)(`Empty "${c}" stream.`), new e.NullStream();
              try {
                switch (c) {
                  case "Fl":
                  case "FlateDecode":
                    return s ? new a.PredictorStream(new te.FlateStream(o, I), I, s) : new te.FlateStream(o, I);
                  case "LZW":
                  case "LZWDecode":
                    let r = 1;
                    return s ? (s.has("EarlyChange") && (r = s.get("EarlyChange")), new a.PredictorStream(new x.LZWStream(o, I, r), I, s)) : new x.LZWStream(o, I, r);
                  case "DCT":
                  case "DCTDecode":
                    return new F.JpegStream(o, I, s);
                  case "JPX":
                  case "JPXDecode":
                    return new f.JpxStream(o, I, s);
                  case "A85":
                  case "ASCII85Decode":
                    return new t.Ascii85Stream(o, I);
                  case "AHx":
                  case "ASCIIHexDecode":
                    return new l.AsciiHexStream(o, I);
                  case "CCF":
                  case "CCITTFaxDecode":
                    return new V.CCITTFaxStream(o, I, s);
                  case "RL":
                  case "RunLengthDecode":
                    return new N.RunLengthStream(o, I);
                  case "JBIG2Decode":
                    return new E.Jbig2Stream(o, I, s);
                }
                return (0, n.warn)(`Filter "${c}" is not supported.`), o;
              } catch (r) {
                if (r instanceof D.MissingDataException)
                  throw r;
                return (0, n.warn)(`Invalid stream: "${r}"`), new e.NullStream();
              }
            }
          }
          b.Parser = M;
          const R = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          function z(T) {
            return T >= 48 && T <= 57 ? T & 15 : T >= 65 && T <= 70 || T >= 97 && T <= 102 ? (T & 15) + 9 : -1;
          }
          class W {
            constructor(o, c = null) {
              this.stream = o, this.nextChar(), this.strBuf = [], this.knownCommands = c, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            peekChar() {
              return this.stream.peekByte();
            }
            getNumber() {
              let o = this.currentChar, c = !1, I = 0, s = 1;
              if (o === 45 ? (s = -1, o = this.nextChar(), o === 45 && (o = this.nextChar())) : o === 43 && (o = this.nextChar()), o === 10 || o === 13)
                do
                  o = this.nextChar();
                while (o === 10 || o === 13);
              if (o === 46 && (I = 10, o = this.nextChar()), o < 48 || o > 57) {
                const d = `Invalid number: ${String.fromCharCode(o)} (charCode ${o})`;
                if ((0, D.isWhiteSpace)(o) || o === -1)
                  return (0, n.info)(`Lexer.getNumber - "${d}".`), 0;
                throw new n.FormatError(d);
              }
              let r = o - 48, u = 0, C = 1;
              for (; (o = this.nextChar()) >= 0; )
                if (o >= 48 && o <= 57) {
                  const d = o - 48;
                  c ? u = u * 10 + d : (I !== 0 && (I *= 10), r = r * 10 + d);
                } else if (o === 46)
                  if (I === 0)
                    I = 1;
                  else
                    break;
                else if (o === 45)
                  (0, n.warn)("Badly formatted number: minus sign in the middle");
                else if (o === 69 || o === 101) {
                  if (o = this.peekChar(), o === 43 || o === 45)
                    C = o === 45 ? -1 : 1, this.nextChar();
                  else if (o < 48 || o > 57)
                    break;
                  c = !0;
                } else
                  break;
              return I !== 0 && (r /= I), c && (r *= 10 ** (C * u)), s * r;
            }
            getString() {
              let o = 1, c = !1;
              const I = this.strBuf;
              I.length = 0;
              let s = this.nextChar();
              for (; ; ) {
                let r = !1;
                switch (s | 0) {
                  case -1:
                    (0, n.warn)("Unterminated string"), c = !0;
                    break;
                  case 40:
                    ++o, I.push("(");
                    break;
                  case 41:
                    --o === 0 ? (this.nextChar(), c = !0) : I.push(")");
                    break;
                  case 92:
                    switch (s = this.nextChar(), s) {
                      case -1:
                        (0, n.warn)("Unterminated string"), c = !0;
                        break;
                      case 110:
                        I.push(`
`);
                        break;
                      case 114:
                        I.push("\r");
                        break;
                      case 116:
                        I.push("	");
                        break;
                      case 98:
                        I.push("\b");
                        break;
                      case 102:
                        I.push("\f");
                        break;
                      case 92:
                      case 40:
                      case 41:
                        I.push(String.fromCharCode(s));
                        break;
                      case 48:
                      case 49:
                      case 50:
                      case 51:
                      case 52:
                      case 53:
                      case 54:
                      case 55:
                        let u = s & 15;
                        s = this.nextChar(), r = !0, s >= 48 && s <= 55 && (u = (u << 3) + (s & 15), s = this.nextChar(), s >= 48 && s <= 55 && (r = !1, u = (u << 3) + (s & 15))), I.push(String.fromCharCode(u));
                        break;
                      case 13:
                        this.peekChar() === 10 && this.nextChar();
                        break;
                      case 10:
                        break;
                      default:
                        I.push(String.fromCharCode(s));
                        break;
                    }
                    break;
                  default:
                    I.push(String.fromCharCode(s));
                    break;
                }
                if (c)
                  break;
                r || (s = this.nextChar());
              }
              return I.join("");
            }
            getName() {
              let o, c;
              const I = this.strBuf;
              for (I.length = 0; (o = this.nextChar()) >= 0 && !R[o]; )
                if (o === 35) {
                  if (o = this.nextChar(), R[o]) {
                    (0, n.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), I.push("#");
                    break;
                  }
                  const s = z(o);
                  if (s !== -1) {
                    c = o, o = this.nextChar();
                    const r = z(o);
                    if (r === -1) {
                      if ((0, n.warn)(`Lexer_getName: Illegal digit (${String.fromCharCode(o)}) in hexadecimal number.`), I.push("#", String.fromCharCode(c)), R[o])
                        break;
                      I.push(String.fromCharCode(o));
                      continue;
                    }
                    I.push(String.fromCharCode(s << 4 | r));
                  } else
                    I.push("#", String.fromCharCode(o));
                } else
                  I.push(String.fromCharCode(o));
              return I.length > 127 && (0, n.warn)(`Name token is longer than allowed by the spec: ${I.length}`), P.Name.get(I.join(""));
            }
            _hexStringWarn(o) {
              if (this._hexStringNumWarn++ === 5) {
                (0, n.warn)("getHexString - ignoring additional invalid characters.");
                return;
              }
              this._hexStringNumWarn > 5 || (0, n.warn)(`getHexString - ignoring invalid character: ${o}`);
            }
            getHexString() {
              const o = this.strBuf;
              o.length = 0;
              let c = this.currentChar, I = !0, s, r;
              for (this._hexStringNumWarn = 0; ; )
                if (c < 0) {
                  (0, n.warn)("Unterminated hex string");
                  break;
                } else if (c === 62) {
                  this.nextChar();
                  break;
                } else if (R[c] === 1) {
                  c = this.nextChar();
                  continue;
                } else {
                  if (I) {
                    if (s = z(c), s === -1) {
                      this._hexStringWarn(c), c = this.nextChar();
                      continue;
                    }
                  } else {
                    if (r = z(c), r === -1) {
                      this._hexStringWarn(c), c = this.nextChar();
                      continue;
                    }
                    o.push(String.fromCharCode(s << 4 | r));
                  }
                  I = !I, c = this.nextChar();
                }
              return o.join("");
            }
            getObj() {
              let o = !1, c = this.currentChar;
              for (; ; ) {
                if (c < 0)
                  return P.EOF;
                if (o)
                  (c === 10 || c === 13) && (o = !1);
                else if (c === 37)
                  o = !0;
                else if (R[c] !== 1)
                  break;
                c = this.nextChar();
              }
              switch (c | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return this.getNumber();
                case 40:
                  return this.getString();
                case 47:
                  return this.getName();
                case 91:
                  return this.nextChar(), P.Cmd.get("[");
                case 93:
                  return this.nextChar(), P.Cmd.get("]");
                case 60:
                  return c = this.nextChar(), c === 60 ? (this.nextChar(), P.Cmd.get("<<")) : this.getHexString();
                case 62:
                  return c = this.nextChar(), c === 62 ? (this.nextChar(), P.Cmd.get(">>")) : P.Cmd.get(">");
                case 123:
                  return this.nextChar(), P.Cmd.get("{");
                case 125:
                  return this.nextChar(), P.Cmd.get("}");
                case 41:
                  throw this.nextChar(), new n.FormatError(`Illegal character: ${c}`);
              }
              let I = String.fromCharCode(c);
              if (c < 32 || c > 127) {
                const u = this.peekChar();
                if (u >= 32 && u <= 127)
                  return this.nextChar(), P.Cmd.get(I);
              }
              const s = this.knownCommands;
              let r = (s == null ? void 0 : s[I]) !== void 0;
              for (; (c = this.nextChar()) >= 0 && !R[c]; ) {
                const u = I + String.fromCharCode(c);
                if (r && s[u] === void 0)
                  break;
                if (I.length === 128)
                  throw new n.FormatError(`Command token too long: ${I.length}`);
                I = u, r = (s == null ? void 0 : s[I]) !== void 0;
              }
              return I === "true" ? !0 : I === "false" ? !1 : I === "null" ? null : (I === "BI" && (this.beginInlineImagePos = this.stream.pos), P.Cmd.get(I));
            }
            skipToNextLine() {
              let o = this.currentChar;
              for (; o >= 0; ) {
                if (o === 13) {
                  o = this.nextChar(), o === 10 && this.nextChar();
                  break;
                } else if (o === 10) {
                  this.nextChar();
                  break;
                }
                o = this.nextChar();
              }
            }
          }
          b.Lexer = W;
          class g {
            static create(o) {
              function c($, S, v = !1) {
                const m = $.get(S);
                if (Number.isInteger(m) && (v ? m >= 0 : m > 0))
                  return m;
                throw new Error(`The "${S}" parameter in the linearization dictionary is invalid.`);
              }
              function I($) {
                const S = $.get("H");
                let v;
                if (Array.isArray(S) && ((v = S.length) === 2 || v === 4)) {
                  for (let m = 0; m < v; m++) {
                    const h = S[m];
                    if (!(Number.isInteger(h) && h > 0))
                      throw new Error(`Hint (${m}) in the linearization dictionary is invalid.`);
                  }
                  return S;
                }
                throw new Error("Hint array in the linearization dictionary is invalid.");
              }
              const s = new M({
                lexer: new W(o),
                xref: null
              }), r = s.getObj(), u = s.getObj(), C = s.getObj(), d = s.getObj();
              let y, _;
              if (Number.isInteger(r) && Number.isInteger(u) && (0, P.isCmd)(C, "obj") && d instanceof P.Dict && typeof (y = d.get("Linearized")) == "number" && y > 0) {
                if ((_ = c(d, "L")) !== o.length)
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
              } else
                return null;
              return {
                length: _,
                hints: I(d),
                objectNumberFirst: c(d, "O"),
                endFirst: c(d, "E"),
                numPages: c(d, "N"),
                mainXRefEntriesOffset: c(d, "T"),
                pageFirst: d.has("P") ? c(d, "P", !0) : 0
              };
            }
          }
          b.Linearization = g;
        },
        /* 17 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Ascii85Stream = void 0;
          var n = ce(18), P = ce(3);
          class D extends n.DecodeStream {
            constructor(t, l) {
              l && (l *= 0.8), super(l), this.str = t, this.dict = t.dict, this.input = new Uint8Array(5);
            }
            readBlock() {
              const te = this.str;
              let E = te.getByte();
              for (; (0, P.isWhiteSpace)(E); )
                E = te.getByte();
              if (E === -1 || E === 126) {
                this.eof = !0;
                return;
              }
              const F = this.bufferLength;
              let f, x;
              if (E === 122) {
                for (f = this.ensureBuffer(F + 4), x = 0; x < 4; ++x)
                  f[F + x] = 0;
                this.bufferLength += 4;
              } else {
                const a = this.input;
                for (a[0] = E, x = 1; x < 5; ++x) {
                  for (E = te.getByte(); (0, P.isWhiteSpace)(E); )
                    E = te.getByte();
                  if (a[x] = E, E === -1 || E === 126)
                    break;
                }
                if (f = this.ensureBuffer(F + x - 1), this.bufferLength += x - 1, x < 5) {
                  for (; x < 5; ++x)
                    a[x] = 117;
                  this.eof = !0;
                }
                let N = 0;
                for (x = 0; x < 5; ++x)
                  N = N * 85 + (a[x] - 33);
                for (x = 3; x >= 0; --x)
                  f[F + x] = N & 255, N >>= 8;
              }
            }
          }
          b.Ascii85Stream = D;
        },
        /* 18 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.StreamsSequenceStream = b.DecodeStream = void 0;
          var n = ce(5), P = ce(8);
          const D = new Uint8Array(0);
          class e extends n.BaseStream {
            constructor(V) {
              if (super(), this._rawMinBufferLength = V || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = D, this.minBufferLength = 512, V)
                for (; this.minBufferLength < V; )
                  this.minBufferLength *= 2;
            }
            get isEmpty() {
              for (; !this.eof && this.bufferLength === 0; )
                this.readBlock();
              return this.bufferLength === 0;
            }
            ensureBuffer(V) {
              const te = this.buffer;
              if (V <= te.byteLength)
                return te;
              let E = this.minBufferLength;
              for (; E < V; )
                E *= 2;
              const F = new Uint8Array(E);
              return F.set(te), this.buffer = F;
            }
            getByte() {
              const V = this.pos;
              for (; this.bufferLength <= V; ) {
                if (this.eof)
                  return -1;
                this.readBlock();
              }
              return this.buffer[this.pos++];
            }
            getBytes(V) {
              const te = this.pos;
              let E;
              if (V) {
                for (this.ensureBuffer(te + V), E = te + V; !this.eof && this.bufferLength < E; )
                  this.readBlock();
                const F = this.bufferLength;
                E > F && (E = F);
              } else {
                for (; !this.eof; )
                  this.readBlock();
                E = this.bufferLength;
              }
              return this.pos = E, this.buffer.subarray(te, E);
            }
            reset() {
              this.pos = 0;
            }
            makeSubStream(V, te, E = null) {
              if (te === void 0)
                for (; !this.eof; )
                  this.readBlock();
              else {
                const F = V + te;
                for (; this.bufferLength <= F && !this.eof; )
                  this.readBlock();
              }
              return new P.Stream(this.buffer, V, te, E);
            }
            getBaseStreams() {
              return this.str ? this.str.getBaseStreams() : null;
            }
          }
          b.DecodeStream = e;
          class t extends e {
            constructor(V, te = null) {
              let E = 0;
              for (const F of V)
                E += F instanceof e ? F._rawMinBufferLength : F.length;
              super(E), this.streams = V, this._onError = te;
            }
            readBlock() {
              var a;
              const V = this.streams;
              if (V.length === 0) {
                this.eof = !0;
                return;
              }
              const te = V.shift();
              let E;
              try {
                E = te.getBytes();
              } catch (N) {
                if (this._onError) {
                  this._onError(N, (a = te.dict) == null ? void 0 : a.objId);
                  return;
                }
                throw N;
              }
              const F = this.bufferLength, f = F + E.length;
              this.ensureBuffer(f).set(E, F), this.bufferLength = f;
            }
            getBaseStreams() {
              const V = [];
              for (const te of this.streams) {
                const E = te.getBaseStreams();
                E && V.push(...E);
              }
              return V.length > 0 ? V : null;
            }
          }
          b.StreamsSequenceStream = t;
        },
        /* 19 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.AsciiHexStream = void 0;
          var n = ce(18);
          class P extends n.DecodeStream {
            constructor(e, t) {
              t && (t *= 0.5), super(t), this.str = e, this.dict = e.dict, this.firstDigit = -1;
            }
            readBlock() {
              const t = this.str.getBytes(8e3);
              if (!t.length) {
                this.eof = !0;
                return;
              }
              const l = t.length + 1 >> 1, V = this.ensureBuffer(this.bufferLength + l);
              let te = this.bufferLength, E = this.firstDigit;
              for (const F of t) {
                let f;
                if (F >= 48 && F <= 57)
                  f = F & 15;
                else if (F >= 65 && F <= 70 || F >= 97 && F <= 102)
                  f = (F & 15) + 9;
                else if (F === 62) {
                  this.eof = !0;
                  break;
                } else
                  continue;
                E < 0 ? E = f : (V[te++] = E << 4 | f, E = -1);
              }
              E >= 0 && this.eof && (V[te++] = E << 4, E = -1), this.firstDigit = E, this.bufferLength = te;
            }
          }
          b.AsciiHexStream = P;
        },
        /* 20 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.CCITTFaxStream = void 0;
          var n = ce(21), P = ce(18), D = ce(4);
          class e extends P.DecodeStream {
            constructor(l, V, te) {
              super(V), this.str = l, this.dict = l.dict, te instanceof D.Dict || (te = D.Dict.empty);
              const E = {
                next() {
                  return l.getByte();
                }
              };
              this.ccittFaxDecoder = new n.CCITTFaxDecoder(E, {
                K: te.get("K"),
                EndOfLine: te.get("EndOfLine"),
                EncodedByteAlign: te.get("EncodedByteAlign"),
                Columns: te.get("Columns"),
                Rows: te.get("Rows"),
                EndOfBlock: te.get("EndOfBlock"),
                BlackIs1: te.get("BlackIs1")
              });
            }
            readBlock() {
              for (; !this.eof; ) {
                const l = this.ccittFaxDecoder.readNextChar();
                if (l === -1) {
                  this.eof = !0;
                  return;
                }
                this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = l;
              }
            }
          }
          b.CCITTFaxStream = e;
        },
        /* 21 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.CCITTFaxDecoder = void 0;
          var n = ce(2);
          const P = -2, D = -1, e = 0, t = 1, l = 2, V = 3, te = 4, E = 5, F = 6, f = 7, x = 8, a = [[-1, -1], [-1, -1], [7, x], [7, f], [6, F], [6, F], [6, E], [6, E], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [4, e], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, t], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, te], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [3, V], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l], [1, l]], N = [[-1, -1], [12, P], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], p = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], O = [[-1, -1], [-1, -1], [12, P], [12, P], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], M = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], R = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
          class z {
            constructor(g, T = {}) {
              if (!g || typeof g.next != "function")
                throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
              this.source = g, this.eof = !1, this.encoding = T.K || 0, this.eoline = T.EndOfLine || !1, this.byteAlign = T.EncodedByteAlign || !1, this.columns = T.Columns || 1728, this.rows = T.Rows || 0, this.eoblock = T.EndOfBlock ?? !0, this.black = T.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
              let o;
              for (; (o = this._lookBits(12)) === 0; )
                this._eatBits(1);
              o === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
            }
            readNextChar() {
              if (this.eof)
                return -1;
              const g = this.refLine, T = this.codingLine, o = this.columns;
              let c, I, s, r;
              if (this.outputBits === 0) {
                if (this.rowsDone && (this.eof = !0), this.eof)
                  return -1;
                this.err = !1;
                let C, d, y;
                if (this.nextLine2D) {
                  for (r = 0; T[r] < o; ++r)
                    g[r] = T[r];
                  for (g[r++] = o, g[r] = o, T[0] = 0, this.codingPos = 0, c = 0, I = 0; T[this.codingPos] < o; )
                    switch (C = this._getTwoDimCode(), C) {
                      case e:
                        this._addPixels(g[c + 1], I), g[c + 1] < o && (c += 2);
                        break;
                      case t:
                        if (C = d = 0, I) {
                          do
                            C += y = this._getBlackCode();
                          while (y >= 64);
                          do
                            d += y = this._getWhiteCode();
                          while (y >= 64);
                        } else {
                          do
                            C += y = this._getWhiteCode();
                          while (y >= 64);
                          do
                            d += y = this._getBlackCode();
                          while (y >= 64);
                        }
                        for (this._addPixels(T[this.codingPos] + C, I), T[this.codingPos] < o && this._addPixels(T[this.codingPos] + d, I ^ 1); g[c] <= T[this.codingPos] && g[c] < o; )
                          c += 2;
                        break;
                      case f:
                        if (this._addPixels(g[c] + 3, I), I ^= 1, T[this.codingPos] < o)
                          for (++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case E:
                        if (this._addPixels(g[c] + 2, I), I ^= 1, T[this.codingPos] < o)
                          for (++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case V:
                        if (this._addPixels(g[c] + 1, I), I ^= 1, T[this.codingPos] < o)
                          for (++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case l:
                        if (this._addPixels(g[c], I), I ^= 1, T[this.codingPos] < o)
                          for (++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case x:
                        if (this._addPixelsNeg(g[c] - 3, I), I ^= 1, T[this.codingPos] < o)
                          for (c > 0 ? --c : ++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case F:
                        if (this._addPixelsNeg(g[c] - 2, I), I ^= 1, T[this.codingPos] < o)
                          for (c > 0 ? --c : ++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case te:
                        if (this._addPixelsNeg(g[c] - 1, I), I ^= 1, T[this.codingPos] < o)
                          for (c > 0 ? --c : ++c; g[c] <= T[this.codingPos] && g[c] < o; )
                            c += 2;
                        break;
                      case D:
                        this._addPixels(o, 0), this.eof = !0;
                        break;
                      default:
                        (0, n.info)("bad 2d code"), this._addPixels(o, 0), this.err = !0;
                    }
                } else
                  for (T[0] = 0, this.codingPos = 0, I = 0; T[this.codingPos] < o; ) {
                    if (C = 0, I)
                      do
                        C += y = this._getBlackCode();
                      while (y >= 64);
                    else
                      do
                        C += y = this._getWhiteCode();
                      while (y >= 64);
                    this._addPixels(T[this.codingPos] + C, I), I ^= 1;
                  }
                let _ = !1;
                if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
                  this.rowsDone = !0;
                else {
                  if (C = this._lookBits(12), this.eoline)
                    for (; C !== D && C !== 1; )
                      this._eatBits(1), C = this._lookBits(12);
                  else
                    for (; C === 0; )
                      this._eatBits(1), C = this._lookBits(12);
                  C === 1 ? (this._eatBits(12), _ = !0) : C === D && (this.eof = !0);
                }
                if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && _ && this.byteAlign) {
                  if (C = this._lookBits(12), C === 1) {
                    if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
                      for (r = 0; r < 4; ++r)
                        C = this._lookBits(12), C !== 1 && (0, n.info)("bad rtc code: " + C), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
                    this.eof = !0;
                  }
                } else if (this.err && this.eoline) {
                  for (; ; ) {
                    if (C = this._lookBits(13), C === D)
                      return this.eof = !0, -1;
                    if (C >> 1 === 1)
                      break;
                    this._eatBits(1);
                  }
                  this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(C & 1));
                }
                this.outputBits = T[0] > 0 ? T[this.codingPos = 0] : T[this.codingPos = 1], this.row++;
              }
              let u;
              if (this.outputBits >= 8)
                u = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && T[this.codingPos] < o && (this.codingPos++, this.outputBits = T[this.codingPos] - T[this.codingPos - 1]);
              else {
                s = 8, u = 0;
                do {
                  if (typeof this.outputBits != "number")
                    throw new n.FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
                  this.outputBits > s ? (u <<= s, this.codingPos & 1 || (u |= 255 >> 8 - s), this.outputBits -= s, s = 0) : (u <<= this.outputBits, this.codingPos & 1 || (u |= 255 >> 8 - this.outputBits), s -= this.outputBits, this.outputBits = 0, T[this.codingPos] < o ? (this.codingPos++, this.outputBits = T[this.codingPos] - T[this.codingPos - 1]) : s > 0 && (u <<= s, s = 0));
                } while (s);
              }
              return this.black && (u ^= 255), u;
            }
            _addPixels(g, T) {
              const o = this.codingLine;
              let c = this.codingPos;
              g > o[c] && (g > this.columns && ((0, n.info)("row is wrong length"), this.err = !0, g = this.columns), c & 1 ^ T && ++c, o[c] = g), this.codingPos = c;
            }
            _addPixelsNeg(g, T) {
              const o = this.codingLine;
              let c = this.codingPos;
              if (g > o[c])
                g > this.columns && ((0, n.info)("row is wrong length"), this.err = !0, g = this.columns), c & 1 ^ T && ++c, o[c] = g;
              else if (g < o[c]) {
                for (g < 0 && ((0, n.info)("invalid code"), this.err = !0, g = 0); c > 0 && g < o[c - 1]; )
                  --c;
                o[c] = g;
              }
              this.codingPos = c;
            }
            _findTableCode(g, T, o, c) {
              const I = c || 0;
              for (let s = g; s <= T; ++s) {
                let r = this._lookBits(s);
                if (r === D)
                  return [!0, 1, !1];
                if (s < T && (r <<= T - s), !I || r >= I) {
                  const u = o[r - I];
                  if (u[0] === s)
                    return this._eatBits(s), [!0, u[1], !0];
                }
              }
              return [!1, 0, !1];
            }
            _getTwoDimCode() {
              let g = 0, T;
              if (this.eoblock) {
                if (g = this._lookBits(7), T = a[g], (T == null ? void 0 : T[0]) > 0)
                  return this._eatBits(T[0]), T[1];
              } else {
                const o = this._findTableCode(1, 7, a);
                if (o[0] && o[2])
                  return o[1];
              }
              return (0, n.info)("Bad two dim code"), D;
            }
            _getWhiteCode() {
              let g = 0, T;
              if (this.eoblock) {
                if (g = this._lookBits(12), g === D)
                  return 1;
                if (T = g >> 5 ? p[g >> 3] : N[g], T[0] > 0)
                  return this._eatBits(T[0]), T[1];
              } else {
                let o = this._findTableCode(1, 9, p);
                if (o[0] || (o = this._findTableCode(11, 12, N), o[0]))
                  return o[1];
              }
              return (0, n.info)("bad white code"), this._eatBits(1), 1;
            }
            _getBlackCode() {
              let g, T;
              if (this.eoblock) {
                if (g = this._lookBits(13), g === D)
                  return 1;
                if (g >> 7 ? !(g >> 9) && g >> 7 ? T = M[(g >> 1) - 64] : T = R[g >> 7] : T = O[g], T[0] > 0)
                  return this._eatBits(T[0]), T[1];
              } else {
                let o = this._findTableCode(2, 6, R);
                if (o[0] || (o = this._findTableCode(7, 12, M, 64), o[0]) || (o = this._findTableCode(10, 13, O), o[0]))
                  return o[1];
              }
              return (0, n.info)("bad black code"), this._eatBits(1), 1;
            }
            _lookBits(g) {
              let T;
              for (; this.inputBits < g; ) {
                if ((T = this.source.next()) === -1)
                  return this.inputBits === 0 ? D : this.inputBuf << g - this.inputBits & 65535 >> 16 - g;
                this.inputBuf = this.inputBuf << 8 | T, this.inputBits += 8;
              }
              return this.inputBuf >> this.inputBits - g & 65535 >> 16 - g;
            }
            _eatBits(g) {
              (this.inputBits -= g) < 0 && (this.inputBits = 0);
            }
          }
          b.CCITTFaxDecoder = z;
        },
        /* 22 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.FlateStream = void 0;
          var n = ce(18), P = ce(2);
          const D = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), e = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), t = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), l = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], V = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
          class te extends n.DecodeStream {
            constructor(F, f) {
              super(f), this.str = F, this.dict = F.dict;
              const x = F.getByte(), a = F.getByte();
              if (x === -1 || a === -1)
                throw new P.FormatError(`Invalid header in flate stream: ${x}, ${a}`);
              if ((x & 15) !== 8)
                throw new P.FormatError(`Unknown compression method in flate stream: ${x}, ${a}`);
              if (((x << 8) + a) % 31 !== 0)
                throw new P.FormatError(`Bad FCHECK in flate stream: ${x}, ${a}`);
              if (a & 32)
                throw new P.FormatError(`FDICT bit set in flate stream: ${x}, ${a}`);
              this.codeSize = 0, this.codeBuf = 0;
            }
            getBits(F) {
              const f = this.str;
              let x = this.codeSize, a = this.codeBuf, N;
              for (; x < F; ) {
                if ((N = f.getByte()) === -1)
                  throw new P.FormatError("Bad encoding in flate stream");
                a |= N << x, x += 8;
              }
              return N = a & (1 << F) - 1, this.codeBuf = a >> F, this.codeSize = x -= F, N;
            }
            getCode(F) {
              const f = this.str, x = F[0], a = F[1];
              let N = this.codeSize, p = this.codeBuf, O;
              for (; N < a && (O = f.getByte()) !== -1; )
                p |= O << N, N += 8;
              const M = x[p & (1 << a) - 1], R = M >> 16, z = M & 65535;
              if (R < 1 || N < R)
                throw new P.FormatError("Bad encoding in flate stream");
              return this.codeBuf = p >> R, this.codeSize = N - R, z;
            }
            generateHuffmanTable(F) {
              const f = F.length;
              let x = 0, a;
              for (a = 0; a < f; ++a)
                F[a] > x && (x = F[a]);
              const N = 1 << x, p = new Int32Array(N);
              for (let O = 1, M = 0, R = 2; O <= x; ++O, M <<= 1, R <<= 1)
                for (let z = 0; z < f; ++z)
                  if (F[z] === O) {
                    let W = 0, g = M;
                    for (a = 0; a < O; ++a)
                      W = W << 1 | g & 1, g >>= 1;
                    for (a = W; a < N; a += R)
                      p[a] = O << 16 | z;
                    ++M;
                  }
              return [p, x];
            }
            readBlock() {
              let F, f;
              const x = this.str;
              let a = this.getBits(3);
              if (a & 1 && (this.eof = !0), a >>= 1, a === 0) {
                let R;
                if ((R = x.getByte()) === -1)
                  throw new P.FormatError("Bad block header in flate stream");
                let z = R;
                if ((R = x.getByte()) === -1)
                  throw new P.FormatError("Bad block header in flate stream");
                if (z |= R << 8, (R = x.getByte()) === -1)
                  throw new P.FormatError("Bad block header in flate stream");
                let W = R;
                if ((R = x.getByte()) === -1)
                  throw new P.FormatError("Bad block header in flate stream");
                if (W |= R << 8, W !== (~z & 65535) && (z !== 0 || W !== 0))
                  throw new P.FormatError("Bad uncompressed block length in flate stream");
                this.codeBuf = 0, this.codeSize = 0;
                const g = this.bufferLength, T = g + z;
                if (F = this.ensureBuffer(T), this.bufferLength = T, z === 0)
                  x.peekByte() === -1 && (this.eof = !0);
                else {
                  const o = x.getBytes(z);
                  F.set(o, g), o.length < z && (this.eof = !0);
                }
                return;
              }
              let N, p;
              if (a === 1)
                N = l, p = V;
              else if (a === 2) {
                const R = this.getBits(5) + 257, z = this.getBits(5) + 1, W = this.getBits(4) + 4, g = new Uint8Array(D.length);
                let T;
                for (T = 0; T < W; ++T)
                  g[D[T]] = this.getBits(3);
                const o = this.generateHuffmanTable(g);
                f = 0, T = 0;
                const c = R + z, I = new Uint8Array(c);
                let s, r, u;
                for (; T < c; ) {
                  const C = this.getCode(o);
                  if (C === 16)
                    s = 2, r = 3, u = f;
                  else if (C === 17)
                    s = 3, r = 3, u = f = 0;
                  else if (C === 18)
                    s = 7, r = 11, u = f = 0;
                  else {
                    I[T++] = f = C;
                    continue;
                  }
                  let d = this.getBits(s) + r;
                  for (; d-- > 0; )
                    I[T++] = u;
                }
                N = this.generateHuffmanTable(I.subarray(0, R)), p = this.generateHuffmanTable(I.subarray(R, c));
              } else
                throw new P.FormatError("Unknown block type in flate stream");
              F = this.buffer;
              let O = F ? F.length : 0, M = this.bufferLength;
              for (; ; ) {
                let R = this.getCode(N);
                if (R < 256) {
                  M + 1 >= O && (F = this.ensureBuffer(M + 1), O = F.length), F[M++] = R;
                  continue;
                }
                if (R === 256) {
                  this.bufferLength = M;
                  return;
                }
                R -= 257, R = e[R];
                let z = R >> 16;
                z > 0 && (z = this.getBits(z)), f = (R & 65535) + z, R = this.getCode(p), R = t[R], z = R >> 16, z > 0 && (z = this.getBits(z));
                const W = (R & 65535) + z;
                M + f >= O && (F = this.ensureBuffer(M + f), O = F.length);
                for (let g = 0; g < f; ++g, ++M)
                  F[M] = F[M - W];
              }
            }
          }
          b.FlateStream = te;
        },
        /* 23 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Jbig2Stream = void 0;
          var n = ce(5), P = ce(18), D = ce(4), e = ce(24), t = ce(2);
          class l extends P.DecodeStream {
            constructor(te, E, F) {
              super(E), this.stream = te, this.dict = te.dict, this.maybeLength = E, this.params = F;
            }
            get bytes() {
              return (0, t.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(te) {
            }
            readBlock() {
              if (this.eof)
                return;
              const te = new e.Jbig2Image(), E = [];
              if (this.params instanceof D.Dict) {
                const x = this.params.get("JBIG2Globals");
                if (x instanceof n.BaseStream) {
                  const a = x.getBytes();
                  E.push({
                    data: a,
                    start: 0,
                    end: a.length
                  });
                }
              }
              E.push({
                data: this.bytes,
                start: 0,
                end: this.bytes.length
              });
              const F = te.parseChunks(E), f = F.length;
              for (let x = 0; x < f; x++)
                F[x] ^= 255;
              this.buffer = F, this.bufferLength = f, this.eof = !0;
            }
          }
          b.Jbig2Stream = l;
        },
        /* 24 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Jbig2Image = void 0;
          var n = ce(2), P = ce(3), D = ce(25), e = ce(21);
          class t extends n.BaseException {
            constructor(Z) {
              super(`JBIG2 error: ${Z}`, "Jbig2Error");
            }
          }
          class l {
            getContexts(Z) {
              return Z in this ? this[Z] : this[Z] = new Int8Array(65536);
            }
          }
          class V {
            constructor(Z, w, k) {
              this.data = Z, this.start = w, this.end = k;
            }
            get decoder() {
              const Z = new D.ArithmeticDecoder(this.data, this.start, this.end);
              return (0, n.shadow)(this, "decoder", Z);
            }
            get contextCache() {
              const Z = new l();
              return (0, n.shadow)(this, "contextCache", Z);
            }
          }
          const te = 2 ** 31 - 1, E = -(2 ** 31);
          function F(K, Z, w) {
            const k = K.getContexts(Z);
            let X = 1;
            function H(U) {
              let ae = 0;
              for (let Q = 0; Q < U; Q++) {
                const L = w.readBit(k, X);
                X = X < 256 ? X << 1 | L : (X << 1 | L) & 511 | 256, ae = ae << 1 | L;
              }
              return ae >>> 0;
            }
            const Y = H(1), ie = H(1) ? H(1) ? H(1) ? H(1) ? H(1) ? H(32) + 4436 : H(12) + 340 : H(8) + 84 : H(6) + 20 : H(4) + 4 : H(2);
            let ne;
            return Y === 0 ? ne = ie : ie > 0 && (ne = -ie), ne >= E && ne <= te ? ne : null;
          }
          function f(K, Z, w) {
            const k = K.getContexts("IAID");
            let X = 1;
            for (let H = 0; H < w; H++) {
              const Y = Z.readBit(k, X);
              X = X << 1 | Y;
            }
            return w < 31 ? X & (1 << w) - 1 : X & 2147483647;
          }
          const x = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], a = [[{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: 2,
            y: -1
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -1,
            y: -2
          }, {
            x: 0,
            y: -2
          }, {
            x: 1,
            y: -2
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }], [{
            x: -3,
            y: -1
          }, {
            x: -2,
            y: -1
          }, {
            x: -1,
            y: -1
          }, {
            x: 0,
            y: -1
          }, {
            x: 1,
            y: -1
          }, {
            x: -4,
            y: 0
          }, {
            x: -3,
            y: 0
          }, {
            x: -2,
            y: 0
          }, {
            x: -1,
            y: 0
          }]], N = [{
            coding: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: -1,
              y: 1
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }, {
            coding: [{
              x: -1,
              y: -1
            }, {
              x: 0,
              y: -1
            }, {
              x: 1,
              y: -1
            }, {
              x: -1,
              y: 0
            }],
            reference: [{
              x: 0,
              y: -1
            }, {
              x: -1,
              y: 0
            }, {
              x: 0,
              y: 0
            }, {
              x: 1,
              y: 0
            }, {
              x: 0,
              y: 1
            }, {
              x: 1,
              y: 1
            }]
          }], p = [39717, 1941, 229, 405], O = [32, 8];
          function M(K, Z, w) {
            const k = w.decoder, X = w.contextCache.getContexts("GB"), H = [];
            let Y, ie, ne, U, ae, Q, L;
            const ee = 31735;
            for (ie = 0; ie < Z; ie++)
              for (ae = H[ie] = new Uint8Array(K), Q = ie < 1 ? ae : H[ie - 1], L = ie < 2 ? ae : H[ie - 2], Y = L[0] << 13 | L[1] << 12 | L[2] << 11 | Q[0] << 7 | Q[1] << 6 | Q[2] << 5 | Q[3] << 4, ne = 0; ne < K; ne++)
                ae[ne] = U = k.readBit(X, Y), Y = (Y & ee) << 1 | (ne + 3 < K ? L[ne + 3] << 11 : 0) | (ne + 4 < K ? Q[ne + 4] << 4 : 0) | U;
            return H;
          }
          function R(K, Z, w, k, X, H, Y, ie) {
            if (K) {
              const Qe = new A(ie.data, ie.start, ie.end);
              return q(Qe, Z, w, !1);
            }
            if (k === 0 && !H && !X && Y.length === 4 && Y[0].x === 3 && Y[0].y === -1 && Y[1].x === -3 && Y[1].y === -1 && Y[2].x === 2 && Y[2].y === -2 && Y[3].x === -2 && Y[3].y === -2)
              return M(Z, w, ie);
            const ne = !!H, U = a[k].concat(Y);
            U.sort(function(Qe, st) {
              return Qe.y - st.y || Qe.x - st.x;
            });
            const ae = U.length, Q = new Int8Array(ae), L = new Int8Array(ae), ee = [];
            let se = 0, le = 0, ue = 0, de = 0, ge, me;
            for (me = 0; me < ae; me++)
              Q[me] = U[me].x, L[me] = U[me].y, le = Math.min(le, U[me].x), ue = Math.max(ue, U[me].x), de = Math.min(de, U[me].y), me < ae - 1 && U[me].y === U[me + 1].y && U[me].x === U[me + 1].x - 1 ? se |= 1 << ae - 1 - me : ee.push(me);
            const pe = ee.length, xe = new Int8Array(pe), we = new Int8Array(pe), Ae = new Uint16Array(pe);
            for (ge = 0; ge < pe; ge++)
              me = ee[ge], xe[ge] = U[me].x, we[ge] = U[me].y, Ae[ge] = 1 << ae - 1 - me;
            const be = -le, he = -de, fe = Z - ue, Ce = p[k];
            let ye = new Uint8Array(Z);
            const Le = [], Be = ie.decoder, nt = ie.contextCache.getContexts("GB");
            let Oe = 0, Je, Ve, Pe, Ge = 0, dt, De;
            for (let Qe = 0; Qe < w; Qe++) {
              if (X) {
                const st = Be.readBit(nt, Ce);
                if (Oe ^= st, Oe) {
                  Le.push(ye);
                  continue;
                }
              }
              for (ye = new Uint8Array(ye), Le.push(ye), Je = 0; Je < Z; Je++) {
                if (ne && H[Qe][Je]) {
                  ye[Je] = 0;
                  continue;
                }
                if (Je >= be && Je < fe && Qe >= he)
                  for (Ge = Ge << 1 & se, me = 0; me < pe; me++)
                    Ve = Qe + we[me], Pe = Je + xe[me], dt = Le[Ve][Pe], dt && (dt = Ae[me], Ge |= dt);
                else
                  for (Ge = 0, De = ae - 1, me = 0; me < ae; me++, De--)
                    Pe = Je + Q[me], Pe >= 0 && Pe < Z && (Ve = Qe + L[me], Ve >= 0 && (dt = Le[Ve][Pe], dt && (Ge |= dt << De)));
                const st = Be.readBit(nt, Ge);
                ye[Je] = st;
              }
            }
            return Le;
          }
          function z(K, Z, w, k, X, H, Y, ie, ne) {
            let U = N[w].coding;
            w === 0 && (U = U.concat([ie[0]]));
            const ae = U.length, Q = new Int32Array(ae), L = new Int32Array(ae);
            let ee;
            for (ee = 0; ee < ae; ee++)
              Q[ee] = U[ee].x, L[ee] = U[ee].y;
            let se = N[w].reference;
            w === 0 && (se = se.concat([ie[1]]));
            const le = se.length, ue = new Int32Array(le), de = new Int32Array(le);
            for (ee = 0; ee < le; ee++)
              ue[ee] = se[ee].x, de[ee] = se[ee].y;
            const ge = k[0].length, me = k.length, pe = O[w], xe = [], we = ne.decoder, Ae = ne.contextCache.getContexts("GR");
            let be = 0;
            for (let he = 0; he < Z; he++) {
              if (Y) {
                const Ce = we.readBit(Ae, pe);
                if (be ^= Ce, be)
                  throw new t("prediction is not supported");
              }
              const fe = new Uint8Array(K);
              xe.push(fe);
              for (let Ce = 0; Ce < K; Ce++) {
                let ye, Le, Be = 0;
                for (ee = 0; ee < ae; ee++)
                  ye = he + L[ee], Le = Ce + Q[ee], ye < 0 || Le < 0 || Le >= K ? Be <<= 1 : Be = Be << 1 | xe[ye][Le];
                for (ee = 0; ee < le; ee++)
                  ye = he + de[ee] - H, Le = Ce + ue[ee] - X, ye < 0 || ye >= me || Le < 0 || Le >= ge ? Be <<= 1 : Be = Be << 1 | k[ye][Le];
                const nt = we.readBit(Ae, Be);
                fe[Ce] = nt;
              }
            }
            return xe;
          }
          function W(K, Z, w, k, X, H, Y, ie, ne, U, ae, Q) {
            if (K && Z)
              throw new t("symbol refinement with Huffman is not supported");
            const L = [];
            let ee = 0, se = (0, P.log2)(w.length + k);
            const le = ae.decoder, ue = ae.contextCache;
            let de, ge;
            for (K && (de = h(1), ge = [], se = Math.max(se, 1)); L.length < k; ) {
              const he = K ? H.tableDeltaHeight.decode(Q) : F(ue, "IADH", le);
              ee += he;
              let fe = 0, Ce = 0;
              const ye = K ? ge.length : 0;
              for (; ; ) {
                const Le = K ? H.tableDeltaWidth.decode(Q) : F(ue, "IADW", le);
                if (Le === null)
                  break;
                fe += Le, Ce += fe;
                let Be;
                if (Z) {
                  const nt = F(ue, "IAAI", le);
                  if (nt > 1)
                    Be = g(K, Z, fe, ee, 0, nt, 1, w.concat(L), se, 0, 0, 1, 0, H, ne, U, ae, 0, Q);
                  else {
                    const Oe = f(ue, le, se), Je = F(ue, "IARDX", le), Ve = F(ue, "IARDY", le), Pe = Oe < w.length ? w[Oe] : L[Oe - w.length];
                    Be = z(fe, ee, ne, Pe, Je, Ve, !1, U, ae);
                  }
                  L.push(Be);
                } else
                  K ? ge.push(fe) : (Be = R(!1, fe, ee, Y, !1, null, ie, ae), L.push(Be));
              }
              if (K && !Z) {
                const Le = H.tableBitmapSize.decode(Q);
                Q.byteAlign();
                let Be;
                if (Le === 0)
                  Be = oe(Q, Ce, ee);
                else {
                  const Oe = Q.end, Je = Q.position + Le;
                  Q.end = Je, Be = q(Q, Ce, ee, !1), Q.end = Oe, Q.position = Je;
                }
                const nt = ge.length;
                if (ye === nt - 1)
                  L.push(Be);
                else {
                  let Oe, Je, Ve = 0, Pe, Ge, dt;
                  for (Oe = ye; Oe < nt; Oe++) {
                    for (Ge = ge[Oe], Pe = Ve + Ge, dt = [], Je = 0; Je < ee; Je++)
                      dt.push(Be[Je].subarray(Ve, Pe));
                    L.push(dt), Ve = Pe;
                  }
                }
              }
            }
            const me = [], pe = [];
            let xe = !1, we, Ae;
            const be = w.length + k;
            for (; pe.length < be; ) {
              let he = K ? de.decode(Q) : F(ue, "IAEX", le);
              for (; he--; )
                pe.push(xe);
              xe = !xe;
            }
            for (we = 0, Ae = w.length; we < Ae; we++)
              pe[we] && me.push(w[we]);
            for (let he = 0; he < k; we++, he++)
              pe[we] && me.push(L[he]);
            return me;
          }
          function g(K, Z, w, k, X, H, Y, ie, ne, U, ae, Q, L, ee, se, le, ue, de, ge) {
            if (K && Z)
              throw new t("refinement with Huffman is not supported");
            const me = [];
            let pe, xe;
            for (pe = 0; pe < k; pe++) {
              if (xe = new Uint8Array(w), X)
                for (let fe = 0; fe < w; fe++)
                  xe[fe] = X;
              me.push(xe);
            }
            const we = ue.decoder, Ae = ue.contextCache;
            let be = K ? -ee.tableDeltaT.decode(ge) : -F(Ae, "IADT", we), he = 0;
            for (pe = 0; pe < H; ) {
              const fe = K ? ee.tableDeltaT.decode(ge) : F(Ae, "IADT", we);
              be += fe;
              const Ce = K ? ee.tableFirstS.decode(ge) : F(Ae, "IAFS", we);
              he += Ce;
              let ye = he;
              do {
                let Le = 0;
                Y > 1 && (Le = K ? ge.readBits(de) : F(Ae, "IAIT", we));
                const Be = Y * be + Le, nt = K ? ee.symbolIDTable.decode(ge) : f(Ae, we, ne), Oe = Z && (K ? ge.readBit() : F(Ae, "IARI", we));
                let Je = ie[nt], Ve = Je[0].length, Pe = Je.length;
                if (Oe) {
                  const Ot = F(Ae, "IARDW", we), ze = F(Ae, "IARDH", we), qe = F(Ae, "IARDX", we), Ue = F(Ae, "IARDY", we);
                  Ve += Ot, Pe += ze, Je = z(Ve, Pe, se, Je, (Ot >> 1) + qe, (ze >> 1) + Ue, !1, le, ue);
                }
                const Ge = Be - (Q & 1 ? 0 : Pe - 1), dt = ye - (Q & 2 ? Ve - 1 : 0);
                let De, Qe, st;
                if (U) {
                  for (De = 0; De < Pe; De++) {
                    if (xe = me[dt + De], !xe)
                      continue;
                    st = Je[De];
                    const Ot = Math.min(w - Ge, Ve);
                    switch (L) {
                      case 0:
                        for (Qe = 0; Qe < Ot; Qe++)
                          xe[Ge + Qe] |= st[Qe];
                        break;
                      case 2:
                        for (Qe = 0; Qe < Ot; Qe++)
                          xe[Ge + Qe] ^= st[Qe];
                        break;
                      default:
                        throw new t(`operator ${L} is not supported`);
                    }
                  }
                  ye += Pe - 1;
                } else {
                  for (Qe = 0; Qe < Pe; Qe++)
                    if (xe = me[Ge + Qe], !!xe)
                      switch (st = Je[Qe], L) {
                        case 0:
                          for (De = 0; De < Ve; De++)
                            xe[dt + De] |= st[De];
                          break;
                        case 2:
                          for (De = 0; De < Ve; De++)
                            xe[dt + De] ^= st[De];
                          break;
                        default:
                          throw new t(`operator ${L} is not supported`);
                      }
                  ye += Ve - 1;
                }
                pe++;
                const wt = K ? ee.tableDeltaS.decode(ge) : F(Ae, "IADS", we);
                if (wt === null)
                  break;
                ye += wt + ae;
              } while (!0);
            }
            return me;
          }
          function T(K, Z, w, k, X, H) {
            const Y = [];
            K || (Y.push({
              x: -Z,
              y: 0
            }), X === 0 && Y.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const ie = (k + 1) * Z, ne = R(K, ie, w, X, !1, null, Y, H), U = [];
            for (let ae = 0; ae <= k; ae++) {
              const Q = [], L = Z * ae, ee = L + Z;
              for (let se = 0; se < w; se++)
                Q.push(ne[se].subarray(L, ee));
              U.push(Q);
            }
            return U;
          }
          function o(K, Z, w, k, X, H, Y, ie, ne, U, ae, Q, L, ee, se) {
            if (Y)
              throw new t("skip is not supported");
            if (ie !== 0)
              throw new t(`operator "${ie}" is not supported in halftone region`);
            const ue = [];
            let de, ge, me;
            for (de = 0; de < X; de++) {
              if (me = new Uint8Array(k), H)
                for (ge = 0; ge < k; ge++)
                  me[ge] = H;
              ue.push(me);
            }
            const pe = Z.length, xe = Z[0], we = xe[0].length, Ae = xe.length, be = (0, P.log2)(pe), he = [];
            K || (he.push({
              x: w <= 1 ? 3 : 2,
              y: -1
            }), w === 0 && he.push({
              x: -3,
              y: -1
            }, {
              x: 2,
              y: -2
            }, {
              x: -2,
              y: -2
            }));
            const fe = [];
            let Ce, ye;
            for (K && (Ce = new A(se.data, se.start, se.end)), de = be - 1; de >= 0; de--)
              K ? ye = q(Ce, ne, U, !0) : ye = R(!1, ne, U, w, !1, null, he, se), fe[de] = ye;
            let Le, Be, nt, Oe, Je, Ve, Pe, Ge, dt;
            for (Le = 0; Le < U; Le++)
              for (Be = 0; Be < ne; Be++) {
                for (nt = 0, Oe = 0, ge = be - 1; ge >= 0; ge--)
                  nt ^= fe[ge][Le][Be], Oe |= nt << ge;
                if (Je = Z[Oe], Ve = ae + Le * ee + Be * L >> 8, Pe = Q + Le * L - Be * ee >> 8, Ve >= 0 && Ve + we <= k && Pe >= 0 && Pe + Ae <= X)
                  for (de = 0; de < Ae; de++)
                    for (dt = ue[Pe + de], Ge = Je[de], ge = 0; ge < we; ge++)
                      dt[Ve + ge] |= Ge[ge];
                else {
                  let De, Qe;
                  for (de = 0; de < Ae; de++)
                    if (Qe = Pe + de, !(Qe < 0 || Qe >= X))
                      for (dt = ue[Qe], Ge = Je[de], ge = 0; ge < we; ge++)
                        De = Ve + ge, De >= 0 && De < k && (dt[De] |= Ge[ge]);
                }
              }
            return ue;
          }
          function c(K, Z) {
            const w = {};
            w.number = (0, P.readUint32)(K, Z);
            const k = K[Z + 4], X = k & 63;
            if (!x[X])
              throw new t("invalid segment type: " + X);
            w.type = X, w.typeName = x[X], w.deferredNonRetain = !!(k & 128);
            const H = !!(k & 64), Y = K[Z + 5];
            let ie = Y >> 5 & 7;
            const ne = [Y & 31];
            let U = Z + 6;
            if (Y === 7) {
              ie = (0, P.readUint32)(K, U - 1) & 536870911, U += 3;
              let se = ie + 7 >> 3;
              for (ne[0] = K[U++]; --se > 0; )
                ne.push(K[U++]);
            } else if (Y === 5 || Y === 6)
              throw new t("invalid referred-to flags");
            w.retainBits = ne;
            let ae = 4;
            w.number <= 256 ? ae = 1 : w.number <= 65536 && (ae = 2);
            const Q = [];
            let L, ee;
            for (L = 0; L < ie; L++) {
              let se;
              ae === 1 ? se = K[U] : ae === 2 ? se = (0, P.readUint16)(K, U) : se = (0, P.readUint32)(K, U), Q.push(se), U += ae;
            }
            if (w.referredTo = Q, H ? (w.pageAssociation = (0, P.readUint32)(K, U), U += 4) : w.pageAssociation = K[U++], w.length = (0, P.readUint32)(K, U), U += 4, w.length === 4294967295)
              if (X === 38) {
                const se = s(K, U), ue = !!(K[U + r] & 1), de = 6, ge = new Uint8Array(de);
                for (ue || (ge[0] = 255, ge[1] = 172), ge[2] = se.height >>> 24 & 255, ge[3] = se.height >> 16 & 255, ge[4] = se.height >> 8 & 255, ge[5] = se.height & 255, L = U, ee = K.length; L < ee; L++) {
                  let me = 0;
                  for (; me < de && ge[me] === K[L + me]; )
                    me++;
                  if (me === de) {
                    w.length = L + de;
                    break;
                  }
                }
                if (w.length === 4294967295)
                  throw new t("segment end was not found");
              } else
                throw new t("invalid unknown segment length");
            return w.headerEnd = U, w;
          }
          function I(K, Z, w, k) {
            const X = [];
            let H = w;
            for (; H < k; ) {
              const Y = c(Z, H);
              H = Y.headerEnd;
              const ie = {
                header: Y,
                data: Z
              };
              if (K.randomAccess || (ie.start = H, H += Y.length, ie.end = H), X.push(ie), Y.type === 51)
                break;
            }
            if (K.randomAccess)
              for (let Y = 0, ie = X.length; Y < ie; Y++)
                X[Y].start = H, H += X[Y].header.length, X[Y].end = H;
            return X;
          }
          function s(K, Z) {
            return {
              width: (0, P.readUint32)(K, Z),
              height: (0, P.readUint32)(K, Z + 4),
              x: (0, P.readUint32)(K, Z + 8),
              y: (0, P.readUint32)(K, Z + 12),
              combinationOperator: K[Z + 16] & 7
            };
          }
          const r = 17;
          function u(K, Z) {
            const w = K.header, k = K.data, X = K.end;
            let H = K.start, Y, ie, ne, U;
            switch (w.type) {
              case 0:
                const Q = {}, L = (0, P.readUint16)(k, H);
                if (Q.huffman = !!(L & 1), Q.refinement = !!(L & 2), Q.huffmanDHSelector = L >> 2 & 3, Q.huffmanDWSelector = L >> 4 & 3, Q.bitmapSizeSelector = L >> 6 & 1, Q.aggregationInstancesSelector = L >> 7 & 1, Q.bitmapCodingContextUsed = !!(L & 256), Q.bitmapCodingContextRetained = !!(L & 512), Q.template = L >> 10 & 3, Q.refinementTemplate = L >> 12 & 1, H += 2, !Q.huffman) {
                  for (U = Q.template === 0 ? 4 : 1, ie = [], ne = 0; ne < U; ne++)
                    ie.push({
                      x: (0, P.readInt8)(k, H),
                      y: (0, P.readInt8)(k, H + 1)
                    }), H += 2;
                  Q.at = ie;
                }
                if (Q.refinement && !Q.refinementTemplate) {
                  for (ie = [], ne = 0; ne < 2; ne++)
                    ie.push({
                      x: (0, P.readInt8)(k, H),
                      y: (0, P.readInt8)(k, H + 1)
                    }), H += 2;
                  Q.refinementAt = ie;
                }
                Q.numberOfExportedSymbols = (0, P.readUint32)(k, H), H += 4, Q.numberOfNewSymbols = (0, P.readUint32)(k, H), H += 4, Y = [Q, w.number, w.referredTo, k, H, X];
                break;
              case 6:
              case 7:
                const ee = {};
                ee.info = s(k, H), H += r;
                const se = (0, P.readUint16)(k, H);
                if (H += 2, ee.huffman = !!(se & 1), ee.refinement = !!(se & 2), ee.logStripSize = se >> 2 & 3, ee.stripSize = 1 << ee.logStripSize, ee.referenceCorner = se >> 4 & 3, ee.transposed = !!(se & 64), ee.combinationOperator = se >> 7 & 3, ee.defaultPixelValue = se >> 9 & 1, ee.dsOffset = se << 17 >> 27, ee.refinementTemplate = se >> 15 & 1, ee.huffman) {
                  const Ae = (0, P.readUint16)(k, H);
                  H += 2, ee.huffmanFS = Ae & 3, ee.huffmanDS = Ae >> 2 & 3, ee.huffmanDT = Ae >> 4 & 3, ee.huffmanRefinementDW = Ae >> 6 & 3, ee.huffmanRefinementDH = Ae >> 8 & 3, ee.huffmanRefinementDX = Ae >> 10 & 3, ee.huffmanRefinementDY = Ae >> 12 & 3, ee.huffmanRefinementSizeSelector = !!(Ae & 16384);
                }
                if (ee.refinement && !ee.refinementTemplate) {
                  for (ie = [], ne = 0; ne < 2; ne++)
                    ie.push({
                      x: (0, P.readInt8)(k, H),
                      y: (0, P.readInt8)(k, H + 1)
                    }), H += 2;
                  ee.refinementAt = ie;
                }
                ee.numberOfSymbolInstances = (0, P.readUint32)(k, H), H += 4, Y = [ee, w.referredTo, k, H, X];
                break;
              case 16:
                const le = {}, ue = k[H++];
                le.mmr = !!(ue & 1), le.template = ue >> 1 & 3, le.patternWidth = k[H++], le.patternHeight = k[H++], le.maxPatternIndex = (0, P.readUint32)(k, H), H += 4, Y = [le, w.number, k, H, X];
                break;
              case 22:
              case 23:
                const de = {};
                de.info = s(k, H), H += r;
                const ge = k[H++];
                de.mmr = !!(ge & 1), de.template = ge >> 1 & 3, de.enableSkip = !!(ge & 8), de.combinationOperator = ge >> 4 & 7, de.defaultPixelValue = ge >> 7 & 1, de.gridWidth = (0, P.readUint32)(k, H), H += 4, de.gridHeight = (0, P.readUint32)(k, H), H += 4, de.gridOffsetX = (0, P.readUint32)(k, H) & 4294967295, H += 4, de.gridOffsetY = (0, P.readUint32)(k, H) & 4294967295, H += 4, de.gridVectorX = (0, P.readUint16)(k, H), H += 2, de.gridVectorY = (0, P.readUint16)(k, H), H += 2, Y = [de, w.referredTo, k, H, X];
                break;
              case 38:
              case 39:
                const me = {};
                me.info = s(k, H), H += r;
                const pe = k[H++];
                if (me.mmr = !!(pe & 1), me.template = pe >> 1 & 3, me.prediction = !!(pe & 8), !me.mmr) {
                  for (U = me.template === 0 ? 4 : 1, ie = [], ne = 0; ne < U; ne++)
                    ie.push({
                      x: (0, P.readInt8)(k, H),
                      y: (0, P.readInt8)(k, H + 1)
                    }), H += 2;
                  me.at = ie;
                }
                Y = [me, k, H, X];
                break;
              case 48:
                const xe = {
                  width: (0, P.readUint32)(k, H),
                  height: (0, P.readUint32)(k, H + 4),
                  resolutionX: (0, P.readUint32)(k, H + 8),
                  resolutionY: (0, P.readUint32)(k, H + 12)
                };
                xe.height === 4294967295 && delete xe.height;
                const we = k[H + 16];
                (0, P.readUint16)(k, H + 17), xe.lossless = !!(we & 1), xe.refinement = !!(we & 2), xe.defaultPixelValue = we >> 2 & 1, xe.combinationOperator = we >> 3 & 3, xe.requiresBuffer = !!(we & 32), xe.combinationOperatorOverride = !!(we & 64), Y = [xe];
                break;
              case 49:
                break;
              case 50:
                break;
              case 51:
                break;
              case 53:
                Y = [w.number, k, H, X];
                break;
              case 62:
                break;
              default:
                throw new t(`segment type ${w.typeName}(${w.type}) is not implemented`);
            }
            const ae = "on" + w.typeName;
            ae in Z && Z[ae].apply(Z, Y);
          }
          function C(K, Z) {
            for (let w = 0, k = K.length; w < k; w++)
              u(K[w], Z);
          }
          function d(K) {
            const Z = new y();
            for (let w = 0, k = K.length; w < k; w++) {
              const X = K[w], H = I({}, X.data, X.start, X.end);
              C(H, Z);
            }
            return Z.buffer;
          }
          class y {
            onPageInformation(Z) {
              this.currentPageInfo = Z;
              const w = Z.width + 7 >> 3, k = new Uint8ClampedArray(w * Z.height);
              Z.defaultPixelValue && k.fill(255), this.buffer = k;
            }
            drawBitmap(Z, w) {
              const k = this.currentPageInfo, X = Z.width, H = Z.height, Y = k.width + 7 >> 3, ie = k.combinationOperatorOverride ? Z.combinationOperator : k.combinationOperator, ne = this.buffer, U = 128 >> (Z.x & 7);
              let ae = Z.y * Y + (Z.x >> 3), Q, L, ee, se;
              switch (ie) {
                case 0:
                  for (Q = 0; Q < H; Q++) {
                    for (ee = U, se = ae, L = 0; L < X; L++)
                      w[Q][L] && (ne[se] |= ee), ee >>= 1, ee || (ee = 128, se++);
                    ae += Y;
                  }
                  break;
                case 2:
                  for (Q = 0; Q < H; Q++) {
                    for (ee = U, se = ae, L = 0; L < X; L++)
                      w[Q][L] && (ne[se] ^= ee), ee >>= 1, ee || (ee = 128, se++);
                    ae += Y;
                  }
                  break;
                default:
                  throw new t(`operator ${ie} is not supported`);
              }
            }
            onImmediateGenericRegion(Z, w, k, X) {
              const H = Z.info, Y = new V(w, k, X), ie = R(Z.mmr, H.width, H.height, Z.template, Z.prediction, null, Z.at, Y);
              this.drawBitmap(H, ie);
            }
            onImmediateLosslessGenericRegion() {
              this.onImmediateGenericRegion(...arguments);
            }
            onSymbolDictionary(Z, w, k, X, H, Y) {
              let ie, ne;
              Z.huffman && (ie = J(Z, k, this.customTables), ne = new A(X, H, Y));
              let U = this.symbols;
              U || (this.symbols = U = {});
              const ae = [];
              for (const L of k) {
                const ee = U[L];
                ee && ae.push(...ee);
              }
              const Q = new V(X, H, Y);
              U[w] = W(Z.huffman, Z.refinement, ae, Z.numberOfNewSymbols, Z.numberOfExportedSymbols, ie, Z.template, Z.at, Z.refinementTemplate, Z.refinementAt, Q, ne);
            }
            onImmediateTextRegion(Z, w, k, X, H) {
              const Y = Z.info;
              let ie, ne;
              const U = this.symbols, ae = [];
              for (const se of w) {
                const le = U[se];
                le && ae.push(...le);
              }
              const Q = (0, P.log2)(ae.length);
              Z.huffman && (ne = new A(k, X, H), ie = G(Z, w, this.customTables, ae.length, ne));
              const L = new V(k, X, H), ee = g(Z.huffman, Z.refinement, Y.width, Y.height, Z.defaultPixelValue, Z.numberOfSymbolInstances, Z.stripSize, ae, Q, Z.transposed, Z.dsOffset, Z.referenceCorner, Z.combinationOperator, ie, Z.refinementTemplate, Z.refinementAt, L, Z.logStripSize, ne);
              this.drawBitmap(Y, ee);
            }
            onImmediateLosslessTextRegion() {
              this.onImmediateTextRegion(...arguments);
            }
            onPatternDictionary(Z, w, k, X, H) {
              let Y = this.patterns;
              Y || (this.patterns = Y = {});
              const ie = new V(k, X, H);
              Y[w] = T(Z.mmr, Z.patternWidth, Z.patternHeight, Z.maxPatternIndex, Z.template, ie);
            }
            onImmediateHalftoneRegion(Z, w, k, X, H) {
              const Y = this.patterns[w[0]], ie = Z.info, ne = new V(k, X, H), U = o(Z.mmr, Y, Z.template, ie.width, ie.height, Z.defaultPixelValue, Z.enableSkip, Z.combinationOperator, Z.gridWidth, Z.gridHeight, Z.gridOffsetX, Z.gridOffsetY, Z.gridVectorX, Z.gridVectorY, ne);
              this.drawBitmap(ie, U);
            }
            onImmediateLosslessHalftoneRegion() {
              this.onImmediateHalftoneRegion(...arguments);
            }
            onTables(Z, w, k, X) {
              let H = this.customTables;
              H || (this.customTables = H = {}), H[Z] = v(w, k, X);
            }
          }
          class _ {
            constructor(Z) {
              Z.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = Z[0], this.rangeLength = 0, this.prefixCode = Z[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = Z[0], this.prefixLength = Z[1], this.rangeLength = Z[2], this.prefixCode = Z[3], this.isLowerRange = Z[4] === "lower");
            }
          }
          class $ {
            constructor(Z) {
              this.children = [], Z ? (this.isLeaf = !0, this.rangeLength = Z.rangeLength, this.rangeLow = Z.rangeLow, this.isLowerRange = Z.isLowerRange, this.isOOB = Z.isOOB) : this.isLeaf = !1;
            }
            buildTree(Z, w) {
              const k = Z.prefixCode >> w & 1;
              if (w <= 0)
                this.children[k] = new $(Z);
              else {
                let X = this.children[k];
                X || (this.children[k] = X = new $(null)), X.buildTree(Z, w - 1);
              }
            }
            decodeNode(Z) {
              if (this.isLeaf) {
                if (this.isOOB)
                  return null;
                const k = Z.readBits(this.rangeLength);
                return this.rangeLow + (this.isLowerRange ? -k : k);
              }
              const w = this.children[Z.readBit()];
              if (!w)
                throw new t("invalid Huffman data");
              return w.decodeNode(Z);
            }
          }
          class S {
            constructor(Z, w) {
              w || this.assignPrefixCodes(Z), this.rootNode = new $(null);
              for (let k = 0, X = Z.length; k < X; k++) {
                const H = Z[k];
                H.prefixLength > 0 && this.rootNode.buildTree(H, H.prefixLength - 1);
              }
            }
            decode(Z) {
              return this.rootNode.decodeNode(Z);
            }
            assignPrefixCodes(Z) {
              const w = Z.length;
              let k = 0;
              for (let ae = 0; ae < w; ae++)
                k = Math.max(k, Z[ae].prefixLength);
              const X = new Uint32Array(k + 1);
              for (let ae = 0; ae < w; ae++)
                X[Z[ae].prefixLength]++;
              let H = 1, Y = 0, ie, ne, U;
              for (X[0] = 0; H <= k; ) {
                for (Y = Y + X[H - 1] << 1, ie = Y, ne = 0; ne < w; )
                  U = Z[ne], U.prefixLength === H && (U.prefixCode = ie, ie++), ne++;
                H++;
              }
            }
          }
          function v(K, Z, w) {
            const k = K[Z], X = (0, P.readUint32)(K, Z + 1) & 4294967295, H = (0, P.readUint32)(K, Z + 5) & 4294967295, Y = new A(K, Z + 9, w), ie = (k >> 1 & 7) + 1, ne = (k >> 4 & 7) + 1, U = [];
            let ae, Q, L = X;
            do
              ae = Y.readBits(ie), Q = Y.readBits(ne), U.push(new _([L, ae, Q, 0])), L += 1 << Q;
            while (L < H);
            return ae = Y.readBits(ie), U.push(new _([X - 1, ae, 32, 0, "lower"])), ae = Y.readBits(ie), U.push(new _([H, ae, 32, 0])), k & 1 && (ae = Y.readBits(ie), U.push(new _([ae, 0]))), new S(U, !1);
          }
          const m = {};
          function h(K) {
            let Z = m[K];
            if (Z)
              return Z;
            let w;
            switch (K) {
              case 1:
                w = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
                break;
              case 2:
                w = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
                break;
              case 3:
                w = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
                break;
              case 4:
                w = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
                break;
              case 5:
                w = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
                break;
              case 6:
                w = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
                break;
              case 7:
                w = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
                break;
              case 8:
                w = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
                break;
              case 9:
                w = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
                break;
              case 10:
                w = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
                break;
              case 11:
                w = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 12:
                w = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
                break;
              case 13:
                w = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
                break;
              case 14:
                w = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
                break;
              case 15:
                w = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
                break;
              default:
                throw new t(`standard table B.${K} does not exist`);
            }
            for (let k = 0, X = w.length; k < X; k++)
              w[k] = new _(w[k]);
            return Z = new S(w, !0), m[K] = Z, Z;
          }
          class A {
            constructor(Z, w, k) {
              this.data = Z, this.start = w, this.end = k, this.position = w, this.shift = -1, this.currentByte = 0;
            }
            readBit() {
              if (this.shift < 0) {
                if (this.position >= this.end)
                  throw new t("end of data while reading bit");
                this.currentByte = this.data[this.position++], this.shift = 7;
              }
              const Z = this.currentByte >> this.shift & 1;
              return this.shift--, Z;
            }
            readBits(Z) {
              let w = 0, k;
              for (k = Z - 1; k >= 0; k--)
                w |= this.readBit() << k;
              return w;
            }
            byteAlign() {
              this.shift = -1;
            }
            next() {
              return this.position >= this.end ? -1 : this.data[this.position++];
            }
          }
          function j(K, Z, w) {
            let k = 0;
            for (let X = 0, H = Z.length; X < H; X++) {
              const Y = w[Z[X]];
              if (Y) {
                if (K === k)
                  return Y;
                k++;
              }
            }
            throw new t("can't find custom Huffman table");
          }
          function G(K, Z, w, k, X) {
            const H = [];
            for (let L = 0; L <= 34; L++) {
              const ee = X.readBits(4);
              H.push(new _([L, ee, 0, 0]));
            }
            const Y = new S(H, !1);
            H.length = 0;
            for (let L = 0; L < k; ) {
              const ee = Y.decode(X);
              if (ee >= 32) {
                let se, le, ue;
                switch (ee) {
                  case 32:
                    if (L === 0)
                      throw new t("no previous value in symbol ID table");
                    le = X.readBits(2) + 3, se = H[L - 1].prefixLength;
                    break;
                  case 33:
                    le = X.readBits(3) + 3, se = 0;
                    break;
                  case 34:
                    le = X.readBits(7) + 11, se = 0;
                    break;
                  default:
                    throw new t("invalid code length in symbol ID table");
                }
                for (ue = 0; ue < le; ue++)
                  H.push(new _([L, se, 0, 0])), L++;
              } else
                H.push(new _([L, ee, 0, 0])), L++;
            }
            X.byteAlign();
            const ie = new S(H, !1);
            let ne = 0, U, ae, Q;
            switch (K.huffmanFS) {
              case 0:
              case 1:
                U = h(K.huffmanFS + 6);
                break;
              case 3:
                U = j(ne, Z, w), ne++;
                break;
              default:
                throw new t("invalid Huffman FS selector");
            }
            switch (K.huffmanDS) {
              case 0:
              case 1:
              case 2:
                ae = h(K.huffmanDS + 8);
                break;
              case 3:
                ae = j(ne, Z, w), ne++;
                break;
              default:
                throw new t("invalid Huffman DS selector");
            }
            switch (K.huffmanDT) {
              case 0:
              case 1:
              case 2:
                Q = h(K.huffmanDT + 11);
                break;
              case 3:
                Q = j(ne, Z, w), ne++;
                break;
              default:
                throw new t("invalid Huffman DT selector");
            }
            if (K.refinement)
              throw new t("refinement with Huffman is not supported");
            return {
              symbolIDTable: ie,
              tableFirstS: U,
              tableDeltaS: ae,
              tableDeltaT: Q
            };
          }
          function J(K, Z, w) {
            let k = 0, X, H;
            switch (K.huffmanDHSelector) {
              case 0:
              case 1:
                X = h(K.huffmanDHSelector + 4);
                break;
              case 3:
                X = j(k, Z, w), k++;
                break;
              default:
                throw new t("invalid Huffman DH selector");
            }
            switch (K.huffmanDWSelector) {
              case 0:
              case 1:
                H = h(K.huffmanDWSelector + 2);
                break;
              case 3:
                H = j(k, Z, w), k++;
                break;
              default:
                throw new t("invalid Huffman DW selector");
            }
            let Y, ie;
            return K.bitmapSizeSelector ? (Y = j(k, Z, w), k++) : Y = h(1), K.aggregationInstancesSelector ? ie = j(k, Z, w) : ie = h(1), {
              tableDeltaHeight: X,
              tableDeltaWidth: H,
              tableBitmapSize: Y,
              tableAggregateInstances: ie
            };
          }
          function oe(K, Z, w) {
            const k = [];
            for (let X = 0; X < w; X++) {
              const H = new Uint8Array(Z);
              k.push(H);
              for (let Y = 0; Y < Z; Y++)
                H[Y] = K.readBit();
              K.byteAlign();
            }
            return k;
          }
          function q(K, Z, w, k) {
            const X = {
              K: -1,
              Columns: Z,
              Rows: w,
              BlackIs1: !0,
              EndOfBlock: k
            }, H = new e.CCITTFaxDecoder(K, X), Y = [];
            let ie, ne = !1;
            for (let U = 0; U < w; U++) {
              const ae = new Uint8Array(Z);
              Y.push(ae);
              let Q = -1;
              for (let L = 0; L < Z; L++)
                Q < 0 && (ie = H.readNextChar(), ie === -1 && (ie = 0, ne = !0), Q = 7), ae[L] = ie >> Q & 1, Q--;
            }
            if (k && !ne)
              for (let ae = 0; ae < 5 && H.readNextChar() !== -1; ae++)
                ;
            return Y;
          }
          class re {
            parseChunks(Z) {
              return d(Z);
            }
            parse(Z) {
              throw new Error("Not implemented: Jbig2Image.parse");
            }
          }
          b.Jbig2Image = re;
        },
        /* 25 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ArithmeticDecoder = void 0;
          const ce = [{
            qe: 22017,
            nmps: 1,
            nlps: 1,
            switchFlag: 1
          }, {
            qe: 13313,
            nmps: 2,
            nlps: 6,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 3,
            nlps: 9,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 4,
            nlps: 12,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 5,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 38,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 7,
            nlps: 6,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 8,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 9,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 10,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 11,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 12,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 13,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 29,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 15,
            nlps: 14,
            switchFlag: 1
          }, {
            qe: 21505,
            nmps: 16,
            nlps: 14,
            switchFlag: 0
          }, {
            qe: 20737,
            nmps: 17,
            nlps: 15,
            switchFlag: 0
          }, {
            qe: 18433,
            nmps: 18,
            nlps: 16,
            switchFlag: 0
          }, {
            qe: 14337,
            nmps: 19,
            nlps: 17,
            switchFlag: 0
          }, {
            qe: 13313,
            nmps: 20,
            nlps: 18,
            switchFlag: 0
          }, {
            qe: 12289,
            nmps: 21,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 10241,
            nmps: 22,
            nlps: 19,
            switchFlag: 0
          }, {
            qe: 9217,
            nmps: 23,
            nlps: 20,
            switchFlag: 0
          }, {
            qe: 8705,
            nmps: 24,
            nlps: 21,
            switchFlag: 0
          }, {
            qe: 7169,
            nmps: 25,
            nlps: 22,
            switchFlag: 0
          }, {
            qe: 6145,
            nmps: 26,
            nlps: 23,
            switchFlag: 0
          }, {
            qe: 5633,
            nmps: 27,
            nlps: 24,
            switchFlag: 0
          }, {
            qe: 5121,
            nmps: 28,
            nlps: 25,
            switchFlag: 0
          }, {
            qe: 4609,
            nmps: 29,
            nlps: 26,
            switchFlag: 0
          }, {
            qe: 4353,
            nmps: 30,
            nlps: 27,
            switchFlag: 0
          }, {
            qe: 2753,
            nmps: 31,
            nlps: 28,
            switchFlag: 0
          }, {
            qe: 2497,
            nmps: 32,
            nlps: 29,
            switchFlag: 0
          }, {
            qe: 2209,
            nmps: 33,
            nlps: 30,
            switchFlag: 0
          }, {
            qe: 1313,
            nmps: 34,
            nlps: 31,
            switchFlag: 0
          }, {
            qe: 1089,
            nmps: 35,
            nlps: 32,
            switchFlag: 0
          }, {
            qe: 673,
            nmps: 36,
            nlps: 33,
            switchFlag: 0
          }, {
            qe: 545,
            nmps: 37,
            nlps: 34,
            switchFlag: 0
          }, {
            qe: 321,
            nmps: 38,
            nlps: 35,
            switchFlag: 0
          }, {
            qe: 273,
            nmps: 39,
            nlps: 36,
            switchFlag: 0
          }, {
            qe: 133,
            nmps: 40,
            nlps: 37,
            switchFlag: 0
          }, {
            qe: 73,
            nmps: 41,
            nlps: 38,
            switchFlag: 0
          }, {
            qe: 37,
            nmps: 42,
            nlps: 39,
            switchFlag: 0
          }, {
            qe: 21,
            nmps: 43,
            nlps: 40,
            switchFlag: 0
          }, {
            qe: 9,
            nmps: 44,
            nlps: 41,
            switchFlag: 0
          }, {
            qe: 5,
            nmps: 45,
            nlps: 42,
            switchFlag: 0
          }, {
            qe: 1,
            nmps: 45,
            nlps: 43,
            switchFlag: 0
          }, {
            qe: 22017,
            nmps: 46,
            nlps: 46,
            switchFlag: 0
          }];
          class n {
            constructor(D, e, t) {
              this.data = D, this.bp = e, this.dataEnd = t, this.chigh = D[e], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
            }
            byteIn() {
              const D = this.data;
              let e = this.bp;
              D[e] === 255 ? D[e + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (e++, this.clow += D[e] << 9, this.ct = 7, this.bp = e) : (e++, this.clow += e < this.dataEnd ? D[e] << 8 : 65280, this.ct = 8, this.bp = e), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
            }
            readBit(D, e) {
              let t = D[e] >> 1, l = D[e] & 1;
              const V = ce[t], te = V.qe;
              let E, F = this.a - te;
              if (this.chigh < te)
                F < te ? (F = te, E = l, t = V.nmps) : (F = te, E = 1 ^ l, V.switchFlag === 1 && (l = E), t = V.nlps);
              else {
                if (this.chigh -= te, F & 32768)
                  return this.a = F, l;
                F < te ? (E = 1 ^ l, V.switchFlag === 1 && (l = E), t = V.nlps) : (E = l, t = V.nmps);
              }
              do
                this.ct === 0 && this.byteIn(), F <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
              while (!(F & 32768));
              return this.a = F, D[e] = t << 1 | l, E;
            }
          }
          b.ArithmeticDecoder = n;
        },
        /* 26 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.JpegStream = void 0;
          var n = ce(18), P = ce(4), D = ce(27), e = ce(2);
          class t extends n.DecodeStream {
            constructor(V, te, E) {
              let F;
              for (; (F = V.getByte()) !== -1; )
                if (F === 255) {
                  V.skip(-1);
                  break;
                }
              super(te), this.stream = V, this.dict = V.dict, this.maybeLength = te, this.params = E;
            }
            get bytes() {
              return (0, e.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(V) {
            }
            readBlock() {
              if (this.eof)
                return;
              const V = {
                decodeTransform: void 0,
                colorTransform: void 0
              }, te = this.dict.getArray("D", "Decode");
              if ((this.forceRGBA || this.forceRGB) && Array.isArray(te)) {
                const f = this.dict.get("BPC", "BitsPerComponent") || 8, x = te.length, a = new Int32Array(x);
                let N = !1;
                const p = (1 << f) - 1;
                for (let O = 0; O < x; O += 2)
                  a[O] = (te[O + 1] - te[O]) * 256 | 0, a[O + 1] = te[O] * p | 0, (a[O] !== 256 || a[O + 1] !== 0) && (N = !0);
                N && (V.decodeTransform = a);
              }
              if (this.params instanceof P.Dict) {
                const f = this.params.get("ColorTransform");
                Number.isInteger(f) && (V.colorTransform = f);
              }
              const E = new D.JpegImage(V);
              E.parse(this.bytes);
              const F = E.getData({
                width: this.drawWidth,
                height: this.drawHeight,
                forceRGBA: this.forceRGBA,
                forceRGB: this.forceRGB,
                isSourcePDF: !0
              });
              this.buffer = F, this.bufferLength = F.length, this.eof = !0;
            }
          }
          b.JpegStream = t;
        },
        /* 27 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.JpegImage = void 0;
          var n = ce(2), P = ce(28), D = ce(3);
          class e extends n.BaseException {
            constructor(c) {
              super(`JPEG error: ${c}`, "JpegError");
            }
          }
          class t extends n.BaseException {
            constructor(c, I) {
              super(c, "DNLMarkerError"), this.scanLines = I;
            }
          }
          class l extends n.BaseException {
            constructor(c) {
              super(c, "EOIMarkerError");
            }
          }
          const V = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), te = 4017, E = 799, F = 3406, f = 2276, x = 1567, a = 3784, N = 5793, p = 2896;
          function O(o, c) {
            let I = 0, s, r, u = 16;
            for (; u > 0 && !o[u - 1]; )
              u--;
            const C = [{
              children: [],
              index: 0
            }];
            let d = C[0], y;
            for (s = 0; s < u; s++) {
              for (r = 0; r < o[s]; r++) {
                for (d = C.pop(), d.children[d.index] = c[I]; d.index > 0; )
                  d = C.pop();
                for (d.index++, C.push(d); C.length <= s; )
                  C.push(y = {
                    children: [],
                    index: 0
                  }), d.children[d.index] = y.children, d = y;
                I++;
              }
              s + 1 < u && (C.push(y = {
                children: [],
                index: 0
              }), d.children[d.index] = y.children, d = y);
            }
            return C[0].children;
          }
          function M(o, c, I) {
            return 64 * ((o.blocksPerLine + 1) * c + I);
          }
          function R(o, c, I, s, r, u, C, d, y, _ = !1) {
            const $ = I.mcusPerLine, S = I.progressive, v = c;
            let m = 0, h = 0;
            function A() {
              if (h > 0)
                return h--, m >> h & 1;
              if (m = o[c++], m === 255) {
                const pe = o[c++];
                if (pe) {
                  if (pe === 220 && _) {
                    c += 2;
                    const xe = (0, D.readUint16)(o, c);
                    if (c += 2, xe > 0 && xe !== I.scanLines)
                      throw new t("Found DNL marker (0xFFDC) while parsing scan data", xe);
                  } else if (pe === 217) {
                    if (_) {
                      const xe = H * (I.precision === 8 ? 8 : 0);
                      if (xe > 0 && Math.round(I.scanLines / xe) >= 5)
                        throw new t("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", xe);
                    }
                    throw new l("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new e(`unexpected marker ${(m << 8 | pe).toString(16)}`);
                }
              }
              return h = 7, m >>> 7;
            }
            function j(pe) {
              let xe = pe;
              for (; ; ) {
                switch (xe = xe[A()], typeof xe) {
                  case "number":
                    return xe;
                  case "object":
                    continue;
                }
                throw new e("invalid huffman sequence");
              }
            }
            function G(pe) {
              let xe = 0;
              for (; pe > 0; )
                xe = xe << 1 | A(), pe--;
              return xe;
            }
            function J(pe) {
              if (pe === 1)
                return A() === 1 ? 1 : -1;
              const xe = G(pe);
              return xe >= 1 << pe - 1 ? xe : xe + (-1 << pe) + 1;
            }
            function oe(pe, xe) {
              const we = j(pe.huffmanTableDC), Ae = we === 0 ? 0 : J(we);
              pe.blockData[xe] = pe.pred += Ae;
              let be = 1;
              for (; be < 64; ) {
                const he = j(pe.huffmanTableAC), fe = he & 15, Ce = he >> 4;
                if (fe === 0) {
                  if (Ce < 15)
                    break;
                  be += 16;
                  continue;
                }
                be += Ce;
                const ye = V[be];
                pe.blockData[xe + ye] = J(fe), be++;
              }
            }
            function q(pe, xe) {
              const we = j(pe.huffmanTableDC), Ae = we === 0 ? 0 : J(we) << y;
              pe.blockData[xe] = pe.pred += Ae;
            }
            function re(pe, xe) {
              pe.blockData[xe] |= A() << y;
            }
            let K = 0;
            function Z(pe, xe) {
              if (K > 0) {
                K--;
                return;
              }
              let we = u;
              const Ae = C;
              for (; we <= Ae; ) {
                const be = j(pe.huffmanTableAC), he = be & 15, fe = be >> 4;
                if (he === 0) {
                  if (fe < 15) {
                    K = G(fe) + (1 << fe) - 1;
                    break;
                  }
                  we += 16;
                  continue;
                }
                we += fe;
                const Ce = V[we];
                pe.blockData[xe + Ce] = J(he) * (1 << y), we++;
              }
            }
            let w = 0, k;
            function X(pe, xe) {
              let we = u;
              const Ae = C;
              let be = 0, he, fe;
              for (; we <= Ae; ) {
                const Ce = xe + V[we], ye = pe.blockData[Ce] < 0 ? -1 : 1;
                switch (w) {
                  case 0:
                    if (fe = j(pe.huffmanTableAC), he = fe & 15, be = fe >> 4, he === 0)
                      be < 15 ? (K = G(be) + (1 << be), w = 4) : (be = 16, w = 1);
                    else {
                      if (he !== 1)
                        throw new e("invalid ACn encoding");
                      k = J(he), w = be ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    pe.blockData[Ce] ? pe.blockData[Ce] += ye * (A() << y) : (be--, be === 0 && (w = w === 2 ? 3 : 0));
                    break;
                  case 3:
                    pe.blockData[Ce] ? pe.blockData[Ce] += ye * (A() << y) : (pe.blockData[Ce] = k << y, w = 0);
                    break;
                  case 4:
                    pe.blockData[Ce] && (pe.blockData[Ce] += ye * (A() << y));
                    break;
                }
                we++;
              }
              w === 4 && (K--, K === 0 && (w = 0));
            }
            let H = 0;
            function Y(pe, xe, we, Ae, be) {
              const he = we / $ | 0, fe = we % $;
              H = he * pe.v + Ae;
              const Ce = fe * pe.h + be, ye = M(pe, H, Ce);
              xe(pe, ye);
            }
            function ie(pe, xe, we) {
              H = we / pe.blocksPerLine | 0;
              const Ae = we % pe.blocksPerLine, be = M(pe, H, Ae);
              xe(pe, be);
            }
            const ne = s.length;
            let U, ae, Q, L, ee, se;
            S ? u === 0 ? se = d === 0 ? q : re : se = d === 0 ? Z : X : se = oe;
            let le = 0, ue;
            const de = ne === 1 ? s[0].blocksPerLine * s[0].blocksPerColumn : $ * I.mcusPerColumn;
            let ge, me;
            for (; le <= de; ) {
              const pe = r ? Math.min(de - le, r) : de;
              if (pe > 0) {
                for (ae = 0; ae < ne; ae++)
                  s[ae].pred = 0;
                if (K = 0, ne === 1)
                  for (U = s[0], ee = 0; ee < pe; ee++)
                    ie(U, se, le), le++;
                else
                  for (ee = 0; ee < pe; ee++) {
                    for (ae = 0; ae < ne; ae++)
                      for (U = s[ae], ge = U.h, me = U.v, Q = 0; Q < me; Q++)
                        for (L = 0; L < ge; L++)
                          Y(U, se, le, Q, L);
                    le++;
                  }
              }
              if (h = 0, ue = g(o, c), !ue)
                break;
              if (ue.invalid) {
                const xe = pe > 0 ? "unexpected" : "excessive";
                (0, n.warn)(`decodeScan - ${xe} MCU data, current marker is: ${ue.invalid}`), c = ue.offset;
              }
              if (ue.marker >= 65488 && ue.marker <= 65495)
                c += 2;
              else
                break;
            }
            return c - v;
          }
          function z(o, c, I) {
            const s = o.quantizationTable, r = o.blockData;
            let u, C, d, y, _, $, S, v, m, h, A, j, G, J, oe, q, re;
            if (!s)
              throw new e("missing required Quantization Table.");
            for (let K = 0; K < 64; K += 8) {
              if (m = r[c + K], h = r[c + K + 1], A = r[c + K + 2], j = r[c + K + 3], G = r[c + K + 4], J = r[c + K + 5], oe = r[c + K + 6], q = r[c + K + 7], m *= s[K], !(h | A | j | G | J | oe | q)) {
                re = N * m + 512 >> 10, I[K] = re, I[K + 1] = re, I[K + 2] = re, I[K + 3] = re, I[K + 4] = re, I[K + 5] = re, I[K + 6] = re, I[K + 7] = re;
                continue;
              }
              h *= s[K + 1], A *= s[K + 2], j *= s[K + 3], G *= s[K + 4], J *= s[K + 5], oe *= s[K + 6], q *= s[K + 7], u = N * m + 128 >> 8, C = N * G + 128 >> 8, d = A, y = oe, _ = p * (h - q) + 128 >> 8, v = p * (h + q) + 128 >> 8, $ = j << 4, S = J << 4, u = u + C + 1 >> 1, C = u - C, re = d * a + y * x + 128 >> 8, d = d * x - y * a + 128 >> 8, y = re, _ = _ + S + 1 >> 1, S = _ - S, v = v + $ + 1 >> 1, $ = v - $, u = u + y + 1 >> 1, y = u - y, C = C + d + 1 >> 1, d = C - d, re = _ * f + v * F + 2048 >> 12, _ = _ * F - v * f + 2048 >> 12, v = re, re = $ * E + S * te + 2048 >> 12, $ = $ * te - S * E + 2048 >> 12, S = re, I[K] = u + v, I[K + 7] = u - v, I[K + 1] = C + S, I[K + 6] = C - S, I[K + 2] = d + $, I[K + 5] = d - $, I[K + 3] = y + _, I[K + 4] = y - _;
            }
            for (let K = 0; K < 8; ++K) {
              if (m = I[K], h = I[K + 8], A = I[K + 16], j = I[K + 24], G = I[K + 32], J = I[K + 40], oe = I[K + 48], q = I[K + 56], !(h | A | j | G | J | oe | q)) {
                re = N * m + 8192 >> 14, re < -2040 ? re = 0 : re >= 2024 ? re = 255 : re = re + 2056 >> 4, r[c + K] = re, r[c + K + 8] = re, r[c + K + 16] = re, r[c + K + 24] = re, r[c + K + 32] = re, r[c + K + 40] = re, r[c + K + 48] = re, r[c + K + 56] = re;
                continue;
              }
              u = N * m + 2048 >> 12, C = N * G + 2048 >> 12, d = A, y = oe, _ = p * (h - q) + 2048 >> 12, v = p * (h + q) + 2048 >> 12, $ = j, S = J, u = (u + C + 1 >> 1) + 4112, C = u - C, re = d * a + y * x + 2048 >> 12, d = d * x - y * a + 2048 >> 12, y = re, _ = _ + S + 1 >> 1, S = _ - S, v = v + $ + 1 >> 1, $ = v - $, u = u + y + 1 >> 1, y = u - y, C = C + d + 1 >> 1, d = C - d, re = _ * f + v * F + 2048 >> 12, _ = _ * F - v * f + 2048 >> 12, v = re, re = $ * E + S * te + 2048 >> 12, $ = $ * te - S * E + 2048 >> 12, S = re, m = u + v, q = u - v, h = C + S, oe = C - S, A = d + $, J = d - $, j = y + _, G = y - _, m < 16 ? m = 0 : m >= 4080 ? m = 255 : m >>= 4, h < 16 ? h = 0 : h >= 4080 ? h = 255 : h >>= 4, A < 16 ? A = 0 : A >= 4080 ? A = 255 : A >>= 4, j < 16 ? j = 0 : j >= 4080 ? j = 255 : j >>= 4, G < 16 ? G = 0 : G >= 4080 ? G = 255 : G >>= 4, J < 16 ? J = 0 : J >= 4080 ? J = 255 : J >>= 4, oe < 16 ? oe = 0 : oe >= 4080 ? oe = 255 : oe >>= 4, q < 16 ? q = 0 : q >= 4080 ? q = 255 : q >>= 4, r[c + K] = m, r[c + K + 8] = h, r[c + K + 16] = A, r[c + K + 24] = j, r[c + K + 32] = G, r[c + K + 40] = J, r[c + K + 48] = oe, r[c + K + 56] = q;
            }
          }
          function W(o, c) {
            const I = c.blocksPerLine, s = c.blocksPerColumn, r = new Int16Array(64);
            for (let u = 0; u < s; u++)
              for (let C = 0; C < I; C++) {
                const d = M(c, u, C);
                z(c, d, r);
              }
            return c.blockData;
          }
          function g(o, c, I = c) {
            const s = o.length - 1;
            let r = I < c ? I : c;
            if (c >= s)
              return null;
            const u = (0, D.readUint16)(o, c);
            if (u >= 65472 && u <= 65534)
              return {
                invalid: null,
                marker: u,
                offset: c
              };
            let C = (0, D.readUint16)(o, r);
            for (; !(C >= 65472 && C <= 65534); ) {
              if (++r >= s)
                return null;
              C = (0, D.readUint16)(o, r);
            }
            return {
              invalid: u.toString(16),
              marker: C,
              offset: r
            };
          }
          class T {
            constructor({
              decodeTransform: c = null,
              colorTransform: I = -1
            } = {}) {
              this._decodeTransform = c, this._colorTransform = I;
            }
            parse(c, {
              dnlScanLines: I = null
            } = {}) {
              function s() {
                const A = (0, D.readUint16)(c, u);
                u += 2;
                let j = u + A - 2;
                const G = g(c, j, u);
                G != null && G.invalid && ((0, n.warn)("readDataBlock - incorrect length, current marker is: " + G.invalid), j = G.offset);
                const J = c.subarray(u, j);
                return u += J.length, J;
              }
              function r(A) {
                const j = Math.ceil(A.samplesPerLine / 8 / A.maxH), G = Math.ceil(A.scanLines / 8 / A.maxV);
                for (const J of A.components) {
                  const oe = Math.ceil(Math.ceil(A.samplesPerLine / 8) * J.h / A.maxH), q = Math.ceil(Math.ceil(A.scanLines / 8) * J.v / A.maxV), re = j * J.h, Z = 64 * (G * J.v) * (re + 1);
                  J.blockData = new Int16Array(Z), J.blocksPerLine = oe, J.blocksPerColumn = q;
                }
                A.mcusPerLine = j, A.mcusPerColumn = G;
              }
              let u = 0, C = null, d = null, y, _, $ = 0;
              const S = [], v = [], m = [];
              let h = (0, D.readUint16)(c, u);
              if (u += 2, h !== 65496)
                throw new e("SOI not found");
              h = (0, D.readUint16)(c, u), u += 2;
              e:
                for (; h !== 65497; ) {
                  let A, j, G;
                  switch (h) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      const J = s();
                      h === 65504 && J[0] === 74 && J[1] === 70 && J[2] === 73 && J[3] === 70 && J[4] === 0 && (C = {
                        version: {
                          major: J[5],
                          minor: J[6]
                        },
                        densityUnits: J[7],
                        xDensity: J[8] << 8 | J[9],
                        yDensity: J[10] << 8 | J[11],
                        thumbWidth: J[12],
                        thumbHeight: J[13],
                        thumbData: J.subarray(14, 14 + 3 * J[12] * J[13])
                      }), h === 65518 && J[0] === 65 && J[1] === 100 && J[2] === 111 && J[3] === 98 && J[4] === 101 && (d = {
                        version: J[5] << 8 | J[6],
                        flags0: J[7] << 8 | J[8],
                        flags1: J[9] << 8 | J[10],
                        transformCode: J[11]
                      });
                      break;
                    case 65499:
                      const oe = (0, D.readUint16)(c, u);
                      u += 2;
                      const q = oe + u - 2;
                      let re;
                      for (; u < q; ) {
                        const L = c[u++], ee = new Uint16Array(64);
                        if (L >> 4)
                          if (L >> 4 === 1)
                            for (j = 0; j < 64; j++)
                              re = V[j], ee[re] = (0, D.readUint16)(c, u), u += 2;
                          else
                            throw new e("DQT - invalid table spec");
                        else
                          for (j = 0; j < 64; j++)
                            re = V[j], ee[re] = c[u++];
                        S[L & 15] = ee;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (y)
                        throw new e("Only single frame JPEGs supported");
                      u += 2, y = {}, y.extended = h === 65473, y.progressive = h === 65474, y.precision = c[u++];
                      const K = (0, D.readUint16)(c, u);
                      u += 2, y.scanLines = I || K, y.samplesPerLine = (0, D.readUint16)(c, u), u += 2, y.components = [], y.componentIds = {};
                      const Z = c[u++];
                      let w = 0, k = 0;
                      for (A = 0; A < Z; A++) {
                        const L = c[u], ee = c[u + 1] >> 4, se = c[u + 1] & 15;
                        w < ee && (w = ee), k < se && (k = se);
                        const le = c[u + 2];
                        G = y.components.push({
                          h: ee,
                          v: se,
                          quantizationId: le,
                          quantizationTable: null
                        }), y.componentIds[L] = G - 1, u += 3;
                      }
                      y.maxH = w, y.maxV = k, r(y);
                      break;
                    case 65476:
                      const X = (0, D.readUint16)(c, u);
                      for (u += 2, A = 2; A < X; ) {
                        const L = c[u++], ee = new Uint8Array(16);
                        let se = 0;
                        for (j = 0; j < 16; j++, u++)
                          se += ee[j] = c[u];
                        const le = new Uint8Array(se);
                        for (j = 0; j < se; j++, u++)
                          le[j] = c[u];
                        A += 17 + se, (L >> 4 ? v : m)[L & 15] = O(ee, le);
                      }
                      break;
                    case 65501:
                      u += 2, _ = (0, D.readUint16)(c, u), u += 2;
                      break;
                    case 65498:
                      const H = ++$ === 1 && !I;
                      u += 2;
                      const Y = c[u++], ie = [];
                      for (A = 0; A < Y; A++) {
                        const L = c[u++], ee = y.componentIds[L], se = y.components[ee];
                        se.index = L;
                        const le = c[u++];
                        se.huffmanTableDC = m[le >> 4], se.huffmanTableAC = v[le & 15], ie.push(se);
                      }
                      const ne = c[u++], U = c[u++], ae = c[u++];
                      try {
                        const L = R(c, u, y, ie, _, ne, U, ae >> 4, ae & 15, H);
                        u += L;
                      } catch (L) {
                        if (L instanceof t)
                          return (0, n.warn)(`${L.message} -- attempting to re-parse the JPEG image.`), this.parse(c, {
                            dnlScanLines: L.scanLines
                          });
                        if (L instanceof l) {
                          (0, n.warn)(`${L.message} -- ignoring the rest of the image data.`);
                          break e;
                        }
                        throw L;
                      }
                      break;
                    case 65500:
                      u += 4;
                      break;
                    case 65535:
                      c[u] !== 255 && u--;
                      break;
                    default:
                      const Q = g(c, u - 2, u - 3);
                      if (Q != null && Q.invalid) {
                        (0, n.warn)("JpegImage.parse - unexpected data, current marker is: " + Q.invalid), u = Q.offset;
                        break;
                      }
                      if (!Q || u >= c.length - 1) {
                        (0, n.warn)("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
                        break e;
                      }
                      throw new e("JpegImage.parse - unknown marker: " + h.toString(16));
                  }
                  h = (0, D.readUint16)(c, u), u += 2;
                }
              this.width = y.samplesPerLine, this.height = y.scanLines, this.jfif = C, this.adobe = d, this.components = [];
              for (const A of y.components) {
                const j = S[A.quantizationId];
                j && (A.quantizationTable = j), this.components.push({
                  index: A.index,
                  output: W(y, A),
                  scaleX: A.h / y.maxH,
                  scaleY: A.v / y.maxV,
                  blocksPerLine: A.blocksPerLine,
                  blocksPerColumn: A.blocksPerColumn
                });
              }
              this.numComponents = this.components.length;
            }
            _getLinearizedBlockData(c, I, s = !1) {
              const r = this.width / c, u = this.height / I;
              let C, d, y, _, $, S, v, m, h, A, j = 0, G;
              const J = this.components.length, oe = c * I * J, q = new Uint8ClampedArray(oe), re = new Uint32Array(c), K = 4294967288;
              let Z;
              for (v = 0; v < J; v++) {
                if (C = this.components[v], d = C.scaleX * r, y = C.scaleY * u, j = v, G = C.output, _ = C.blocksPerLine + 1 << 3, d !== Z) {
                  for ($ = 0; $ < c; $++)
                    m = 0 | $ * d, re[$] = (m & K) << 3 | m & 7;
                  Z = d;
                }
                for (S = 0; S < I; S++)
                  for (m = 0 | S * y, A = _ * (m & K) | (m & 7) << 3, $ = 0; $ < c; $++)
                    q[j] = G[A + re[$]], j += J;
              }
              let w = this._decodeTransform;
              if (!s && J === 4 && !w && (w = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), w)
                for (v = 0; v < oe; )
                  for (m = 0, h = 0; m < J; m++, v++, h += 2)
                    q[v] = (q[v] * w[h] >> 8) + w[h + 1];
              return q;
            }
            get _isColorConversionNeeded() {
              return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
            }
            _convertYccToRgb(c) {
              let I, s, r;
              for (let u = 0, C = c.length; u < C; u += 3)
                I = c[u], s = c[u + 1], r = c[u + 2], c[u] = I - 179.456 + 1.402 * r, c[u + 1] = I + 135.459 - 0.344 * s - 0.714 * r, c[u + 2] = I - 226.816 + 1.772 * s;
              return c;
            }
            _convertYccToRgba(c, I) {
              for (let s = 0, r = 0, u = c.length; s < u; s += 3, r += 4) {
                const C = c[s], d = c[s + 1], y = c[s + 2];
                I[r] = C - 179.456 + 1.402 * y, I[r + 1] = C + 135.459 - 0.344 * d - 0.714 * y, I[r + 2] = C - 226.816 + 1.772 * d, I[r + 3] = 255;
              }
              return I;
            }
            _convertYcckToRgb(c) {
              let I, s, r, u, C = 0;
              for (let d = 0, y = c.length; d < y; d += 4)
                I = c[d], s = c[d + 1], r = c[d + 2], u = c[d + 3], c[C++] = -122.67195406894 + s * (-660635669420364e-19 * s + 437130475926232e-18 * r - 54080610064599e-18 * I + 48449797120281e-17 * u - 0.154362151871126) + r * (-957964378445773e-18 * r + 817076911346625e-18 * I - 0.00477271405408747 * u + 1.53380253221734) + I * (961250184130688e-18 * I - 0.00266257332283933 * u + 0.48357088451265) + u * (-336197177618394e-18 * u + 0.484791561490776), c[C++] = 107.268039397724 + s * (219927104525741e-19 * s - 640992018297945e-18 * r + 659397001245577e-18 * I + 426105652938837e-18 * u - 0.176491792462875) + r * (-778269941513683e-18 * r + 0.00130872261408275 * I + 770482631801132e-18 * u - 0.151051492775562) + I * (0.00126935368114843 * I - 0.00265090189010898 * u + 0.25802910206845) + u * (-318913117588328e-18 * u - 0.213742400323665), c[C++] = -20.810012546947 + s * (-570115196973677e-18 * s - 263409051004589e-19 * r + 0.0020741088115012 * I - 0.00288260236853442 * u + 0.814272968359295) + r * (-153496057440975e-19 * r - 132689043961446e-18 * I + 560833691242812e-18 * u - 0.195152027534049) + I * (0.00174418132927582 * I - 0.00255243321439347 * u + 0.116935020465145) + u * (-343531996510555e-18 * u + 0.24165260232407);
              return c.subarray(0, C);
            }
            _convertYcckToRgba(c) {
              for (let I = 0, s = c.length; I < s; I += 4) {
                const r = c[I], u = c[I + 1], C = c[I + 2], d = c[I + 3];
                c[I] = -122.67195406894 + u * (-660635669420364e-19 * u + 437130475926232e-18 * C - 54080610064599e-18 * r + 48449797120281e-17 * d - 0.154362151871126) + C * (-957964378445773e-18 * C + 817076911346625e-18 * r - 0.00477271405408747 * d + 1.53380253221734) + r * (961250184130688e-18 * r - 0.00266257332283933 * d + 0.48357088451265) + d * (-336197177618394e-18 * d + 0.484791561490776), c[I + 1] = 107.268039397724 + u * (219927104525741e-19 * u - 640992018297945e-18 * C + 659397001245577e-18 * r + 426105652938837e-18 * d - 0.176491792462875) + C * (-778269941513683e-18 * C + 0.00130872261408275 * r + 770482631801132e-18 * d - 0.151051492775562) + r * (0.00126935368114843 * r - 0.00265090189010898 * d + 0.25802910206845) + d * (-318913117588328e-18 * d - 0.213742400323665), c[I + 2] = -20.810012546947 + u * (-570115196973677e-18 * u - 263409051004589e-19 * C + 0.0020741088115012 * r - 0.00288260236853442 * d + 0.814272968359295) + C * (-153496057440975e-19 * C - 132689043961446e-18 * r + 560833691242812e-18 * d - 0.195152027534049) + r * (0.00174418132927582 * r - 0.00255243321439347 * d + 0.116935020465145) + d * (-343531996510555e-18 * d + 0.24165260232407), c[I + 3] = 255;
              }
              return c;
            }
            _convertYcckToCmyk(c) {
              let I, s, r;
              for (let u = 0, C = c.length; u < C; u += 4)
                I = c[u], s = c[u + 1], r = c[u + 2], c[u] = 434.456 - I - 1.402 * r, c[u + 1] = 119.541 - I + 0.344 * s + 0.714 * r, c[u + 2] = 481.816 - I - 1.772 * s;
              return c;
            }
            _convertCmykToRgb(c) {
              let I, s, r, u, C = 0;
              for (let d = 0, y = c.length; d < y; d += 4)
                I = c[d], s = c[d + 1], r = c[d + 2], u = c[d + 3], c[C++] = 255 + I * (-6747147073602441e-20 * I + 8379262121013727e-19 * s + 2894718188643294e-19 * r + 0.003264231057537806 * u - 1.1185611867203937) + s * (26374107616089405e-21 * s - 8626949158638572e-20 * r - 2748769067499491e-19 * u - 0.02155688794978967) + r * (-3878099212869363e-20 * r - 3267808279485286e-19 * u + 0.0686742238595345) - u * (3361971776183937e-19 * u + 0.7430659151342254), c[C++] = 255 + I * (13596372813588848e-20 * I + 924537132573585e-18 * s + 10567359618683593e-20 * r + 4791864687436512e-19 * u - 0.3109689587515875) + s * (-23545346108370344e-20 * s + 2702845253534714e-19 * r + 0.0020200308977307156 * u - 0.7488052167015494) + r * (6834815998235662e-20 * r + 15168452363460973e-20 * u - 0.09751927774728933) - u * (3189131175883281e-19 * u + 0.7364883807733168), c[C++] = 255 + I * (13598650411385307e-21 * I + 12423956175490851e-20 * s + 4751985097583589e-19 * r - 36729317476630422e-22 * u - 0.05562186980264034) + s * (16141380598724676e-20 * s + 9692239130725186e-19 * r + 7782692450036253e-19 * u - 0.44015232367526463) + r * (5068882914068769e-22 * r + 0.0017778369011375071 * u - 0.7591454649749609) - u * (3435319965105553e-19 * u + 0.7063770186160144);
              return c.subarray(0, C);
            }
            _convertCmykToRgba(c) {
              for (let I = 0, s = c.length; I < s; I += 4) {
                const r = c[I], u = c[I + 1], C = c[I + 2], d = c[I + 3];
                c[I] = 255 + r * (-6747147073602441e-20 * r + 8379262121013727e-19 * u + 2894718188643294e-19 * C + 0.003264231057537806 * d - 1.1185611867203937) + u * (26374107616089405e-21 * u - 8626949158638572e-20 * C - 2748769067499491e-19 * d - 0.02155688794978967) + C * (-3878099212869363e-20 * C - 3267808279485286e-19 * d + 0.0686742238595345) - d * (3361971776183937e-19 * d + 0.7430659151342254), c[I + 1] = 255 + r * (13596372813588848e-20 * r + 924537132573585e-18 * u + 10567359618683593e-20 * C + 4791864687436512e-19 * d - 0.3109689587515875) + u * (-23545346108370344e-20 * u + 2702845253534714e-19 * C + 0.0020200308977307156 * d - 0.7488052167015494) + C * (6834815998235662e-20 * C + 15168452363460973e-20 * d - 0.09751927774728933) - d * (3189131175883281e-19 * d + 0.7364883807733168), c[I + 2] = 255 + r * (13598650411385307e-21 * r + 12423956175490851e-20 * u + 4751985097583589e-19 * C - 36729317476630422e-22 * d - 0.05562186980264034) + u * (16141380598724676e-20 * u + 9692239130725186e-19 * C + 7782692450036253e-19 * d - 0.44015232367526463) + C * (5068882914068769e-22 * C + 0.0017778369011375071 * d - 0.7591454649749609) - d * (3435319965105553e-19 * d + 0.7063770186160144), c[I + 3] = 255;
              }
              return c;
            }
            getData({
              width: c,
              height: I,
              forceRGBA: s = !1,
              forceRGB: r = !1,
              isSourcePDF: u = !1
            }) {
              if (this.numComponents > 4)
                throw new e("Unsupported color mode");
              const C = this._getLinearizedBlockData(c, I, u);
              if (this.numComponents === 1 && (s || r)) {
                const d = C.length * (s ? 4 : 3), y = new Uint8ClampedArray(d);
                let _ = 0;
                if (s)
                  (0, P.grayToRGBA)(C, new Uint32Array(y.buffer));
                else
                  for (const $ of C)
                    y[_++] = $, y[_++] = $, y[_++] = $;
                return y;
              } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
                if (s) {
                  const d = new Uint8ClampedArray(C.length / 3 * 4);
                  return this._convertYccToRgba(C, d);
                }
                return this._convertYccToRgb(C);
              } else if (this.numComponents === 4) {
                if (this._isColorConversionNeeded)
                  return s ? this._convertYcckToRgba(C) : r ? this._convertYcckToRgb(C) : this._convertYcckToCmyk(C);
                if (s)
                  return this._convertCmykToRgba(C);
                if (r)
                  return this._convertCmykToRgb(C);
              }
              return C;
            }
          }
          b.JpegImage = T;
        },
        /* 28 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.convertBlackAndWhiteToRGBA = D, b.convertToRGBA = P, b.grayToRGBA = t;
          var n = ce(2);
          function P(l) {
            switch (l.kind) {
              case n.ImageKind.GRAYSCALE_1BPP:
                return D(l);
              case n.ImageKind.RGB_24BPP:
                return e(l);
            }
            return null;
          }
          function D({
            src: l,
            srcPos: V = 0,
            dest: te,
            width: E,
            height: F,
            nonBlackColor: f = 4294967295,
            inverseDecode: x = !1
          }) {
            const a = n.FeatureTest.isLittleEndian ? 4278190080 : 255, [N, p] = x ? [f, a] : [a, f], O = E >> 3, M = E & 7, R = l.length;
            te = new Uint32Array(te.buffer);
            let z = 0;
            for (let W = 0; W < F; W++) {
              for (const T = V + O; V < T; V++) {
                const o = V < R ? l[V] : 255;
                te[z++] = o & 128 ? p : N, te[z++] = o & 64 ? p : N, te[z++] = o & 32 ? p : N, te[z++] = o & 16 ? p : N, te[z++] = o & 8 ? p : N, te[z++] = o & 4 ? p : N, te[z++] = o & 2 ? p : N, te[z++] = o & 1 ? p : N;
              }
              if (M === 0)
                continue;
              const g = V < R ? l[V++] : 255;
              for (let T = 0; T < M; T++)
                te[z++] = g & 1 << 7 - T ? p : N;
            }
            return {
              srcPos: V,
              destPos: z
            };
          }
          function e({
            src: l,
            srcPos: V = 0,
            dest: te,
            destPos: E = 0,
            width: F,
            height: f
          }) {
            let x = 0;
            const a = l.length >> 2, N = new Uint32Array(l.buffer, V, a);
            if (n.FeatureTest.isLittleEndian) {
              for (; x < a - 2; x += 3, E += 4) {
                const p = N[x], O = N[x + 1], M = N[x + 2];
                te[E] = p | 4278190080, te[E + 1] = p >>> 24 | O << 8 | 4278190080, te[E + 2] = O >>> 16 | M << 16 | 4278190080, te[E + 3] = M >>> 8 | 4278190080;
              }
              for (let p = x * 4, O = l.length; p < O; p += 3)
                te[E++] = l[p] | l[p + 1] << 8 | l[p + 2] << 16 | 4278190080;
            } else {
              for (; x < a - 2; x += 3, E += 4) {
                const p = N[x], O = N[x + 1], M = N[x + 2];
                te[E] = p | 255, te[E + 1] = p << 24 | O >>> 8 | 255, te[E + 2] = O << 16 | M >>> 16 | 255, te[E + 3] = M << 8 | 255;
              }
              for (let p = x * 4, O = l.length; p < O; p += 3)
                te[E++] = l[p] << 24 | l[p + 1] << 16 | l[p + 2] << 8 | 255;
            }
            return {
              srcPos: V,
              destPos: E
            };
          }
          function t(l, V) {
            if (n.FeatureTest.isLittleEndian)
              for (let te = 0, E = l.length; te < E; te++)
                V[te] = l[te] * 65793 | 4278190080;
            else
              for (let te = 0, E = l.length; te < E; te++)
                V[te] = l[te] * 16843008 | 255;
          }
        },
        /* 29 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.JpxStream = void 0;
          var n = ce(18), P = ce(30), D = ce(2);
          class e extends n.DecodeStream {
            constructor(l, V, te) {
              super(V), this.stream = l, this.dict = l.dict, this.maybeLength = V, this.params = te;
            }
            get bytes() {
              return (0, D.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
            }
            ensureBuffer(l) {
            }
            readBlock() {
              if (this.eof)
                return;
              const l = new P.JpxImage();
              l.parse(this.bytes);
              const V = l.width, te = l.height, E = l.componentsCount, F = l.tiles.length;
              if (F === 1)
                this.buffer = l.tiles[0].items;
              else {
                const f = new Uint8ClampedArray(V * te * E);
                for (let x = 0; x < F; x++) {
                  const a = l.tiles[x], N = a.width, p = a.height, O = a.left, M = a.top, R = a.items;
                  let z = 0, W = (V * M + O) * E;
                  const g = V * E, T = N * E;
                  for (let o = 0; o < p; o++) {
                    const c = R.subarray(z, z + T);
                    f.set(c, W), z += T, W += g;
                  }
                }
                this.buffer = f;
              }
              this.bufferLength = this.buffer.length, this.eof = !0;
            }
          }
          b.JpxStream = e;
        },
        /* 30 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.JpxImage = void 0;
          var n = ce(2), P = ce(3), D = ce(25);
          class e extends n.BaseException {
            constructor(S) {
              super(`JPX error: ${S}`, "JpxError");
            }
          }
          const t = {
            LL: 0,
            LH: 1,
            HL: 1,
            HH: 2
          };
          class l {
            constructor() {
              this.failOnCorruptedImage = !1;
            }
            parse(S) {
              if ((0, P.readUint16)(S, 0) === 65359) {
                this.parseCodestream(S, 0, S.length);
                return;
              }
              const m = S.length;
              let h = 0;
              for (; h < m; ) {
                let A = 8, j = (0, P.readUint32)(S, h);
                const G = (0, P.readUint32)(S, h + 4);
                if (h += A, j === 1 && (j = (0, P.readUint32)(S, h) * 4294967296 + (0, P.readUint32)(S, h + 4), h += 8, A += 8), j === 0 && (j = m - h + A), j < A)
                  throw new e("Invalid box field size");
                const J = j - A;
                let oe = !0;
                switch (G) {
                  case 1785737832:
                    oe = !1;
                    break;
                  case 1668246642:
                    const q = S[h];
                    if (q === 1) {
                      const K = (0, P.readUint32)(S, h + 3);
                      switch (K) {
                        case 16:
                        case 17:
                        case 18:
                          break;
                        default:
                          (0, n.warn)("Unknown colorspace " + K);
                          break;
                      }
                    } else
                      q === 2 && (0, n.info)("ICC profile not supported");
                    break;
                  case 1785737827:
                    this.parseCodestream(S, h, h + J);
                    break;
                  case 1783636e3:
                    (0, P.readUint32)(S, h) !== 218793738 && (0, n.warn)("Invalid JP2 signature");
                    break;
                  case 1783634458:
                  case 1718909296:
                  case 1920099697:
                  case 1919251232:
                  case 1768449138:
                    break;
                  default:
                    const re = String.fromCharCode(G >> 24 & 255, G >> 16 & 255, G >> 8 & 255, G & 255);
                    (0, n.warn)(`Unsupported header type ${G} (${re}).`);
                    break;
                }
                oe && (h += J);
              }
            }
            parseImageProperties(S) {
              let v = S.getByte();
              for (; v >= 0; ) {
                const m = v;
                if (v = S.getByte(), (m << 8 | v) === 65361) {
                  S.skip(4);
                  const A = S.getInt32() >>> 0, j = S.getInt32() >>> 0, G = S.getInt32() >>> 0, J = S.getInt32() >>> 0;
                  S.skip(16);
                  const oe = S.getUint16();
                  this.width = A - G, this.height = j - J, this.componentsCount = oe, this.bitsPerComponent = 8;
                  return;
                }
              }
              throw new e("No size marker found in JPX stream");
            }
            parseCodestream(S, v, m) {
              const h = {};
              let A = !1;
              try {
                let j = v;
                for (; j + 1 < m; ) {
                  const G = (0, P.readUint16)(S, j);
                  j += 2;
                  let J = 0, oe, q, re, K, Z, w;
                  switch (G) {
                    case 65359:
                      h.mainHeader = !0;
                      break;
                    case 65497:
                      break;
                    case 65361:
                      J = (0, P.readUint16)(S, j);
                      const k = {};
                      k.Xsiz = (0, P.readUint32)(S, j + 4), k.Ysiz = (0, P.readUint32)(S, j + 8), k.XOsiz = (0, P.readUint32)(S, j + 12), k.YOsiz = (0, P.readUint32)(S, j + 16), k.XTsiz = (0, P.readUint32)(S, j + 20), k.YTsiz = (0, P.readUint32)(S, j + 24), k.XTOsiz = (0, P.readUint32)(S, j + 28), k.YTOsiz = (0, P.readUint32)(S, j + 32);
                      const X = (0, P.readUint16)(S, j + 36);
                      k.Csiz = X;
                      const H = [];
                      oe = j + 38;
                      for (let ee = 0; ee < X; ee++) {
                        const se = {
                          precision: (S[oe] & 127) + 1,
                          isSigned: !!(S[oe] & 128),
                          XRsiz: S[oe + 1],
                          YRsiz: S[oe + 2]
                        };
                        oe += 3, V(se, k), H.push(se);
                      }
                      h.SIZ = k, h.components = H, te(h, H), h.QCC = [], h.COC = [];
                      break;
                    case 65372:
                      J = (0, P.readUint16)(S, j);
                      const Y = {};
                      switch (oe = j + 2, q = S[oe++], q & 31) {
                        case 0:
                          K = 8, Z = !0;
                          break;
                        case 1:
                          K = 16, Z = !1;
                          break;
                        case 2:
                          K = 16, Z = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + q);
                      }
                      for (Y.noQuantization = K === 8, Y.scalarExpounded = Z, Y.guardBits = q >> 5, re = []; oe < J + j; ) {
                        const ee = {};
                        K === 8 ? (ee.epsilon = S[oe++] >> 3, ee.mu = 0) : (ee.epsilon = S[oe] >> 3, ee.mu = (S[oe] & 7) << 8 | S[oe + 1], oe += 2), re.push(ee);
                      }
                      Y.SPqcds = re, h.mainHeader ? h.QCD = Y : (h.currentTile.QCD = Y, h.currentTile.QCC = []);
                      break;
                    case 65373:
                      J = (0, P.readUint16)(S, j);
                      const ie = {};
                      oe = j + 2;
                      let ne;
                      switch (h.SIZ.Csiz < 257 ? ne = S[oe++] : (ne = (0, P.readUint16)(S, oe), oe += 2), q = S[oe++], q & 31) {
                        case 0:
                          K = 8, Z = !0;
                          break;
                        case 1:
                          K = 16, Z = !1;
                          break;
                        case 2:
                          K = 16, Z = !0;
                          break;
                        default:
                          throw new Error("Invalid SQcd value " + q);
                      }
                      for (ie.noQuantization = K === 8, ie.scalarExpounded = Z, ie.guardBits = q >> 5, re = []; oe < J + j; ) {
                        const ee = {};
                        K === 8 ? (ee.epsilon = S[oe++] >> 3, ee.mu = 0) : (ee.epsilon = S[oe] >> 3, ee.mu = (S[oe] & 7) << 8 | S[oe + 1], oe += 2), re.push(ee);
                      }
                      ie.SPqcds = re, h.mainHeader ? h.QCC[ne] = ie : h.currentTile.QCC[ne] = ie;
                      break;
                    case 65362:
                      J = (0, P.readUint16)(S, j);
                      const U = {};
                      oe = j + 2;
                      const ae = S[oe++];
                      U.entropyCoderWithCustomPrecincts = !!(ae & 1), U.sopMarkerUsed = !!(ae & 2), U.ephMarkerUsed = !!(ae & 4), U.progressionOrder = S[oe++], U.layersCount = (0, P.readUint16)(S, oe), oe += 2, U.multipleComponentTransform = S[oe++], U.decompositionLevelsCount = S[oe++], U.xcb = (S[oe++] & 15) + 2, U.ycb = (S[oe++] & 15) + 2;
                      const Q = S[oe++];
                      if (U.selectiveArithmeticCodingBypass = !!(Q & 1), U.resetContextProbabilities = !!(Q & 2), U.terminationOnEachCodingPass = !!(Q & 4), U.verticallyStripe = !!(Q & 8), U.predictableTermination = !!(Q & 16), U.segmentationSymbolUsed = !!(Q & 32), U.reversibleTransformation = S[oe++], U.entropyCoderWithCustomPrecincts) {
                        const ee = [];
                        for (; oe < J + j; ) {
                          const se = S[oe++];
                          ee.push({
                            PPx: se & 15,
                            PPy: se >> 4
                          });
                        }
                        U.precinctsSizes = ee;
                      }
                      const L = [];
                      U.selectiveArithmeticCodingBypass && L.push("selectiveArithmeticCodingBypass"), U.terminationOnEachCodingPass && L.push("terminationOnEachCodingPass"), U.verticallyStripe && L.push("verticallyStripe"), U.predictableTermination && L.push("predictableTermination"), L.length > 0 && (A = !0, (0, n.warn)(`JPX: Unsupported COD options (${L.join(", ")}).`)), h.mainHeader ? h.COD = U : (h.currentTile.COD = U, h.currentTile.COC = []);
                      break;
                    case 65424:
                      J = (0, P.readUint16)(S, j), w = {}, w.index = (0, P.readUint16)(S, j + 2), w.length = (0, P.readUint32)(S, j + 4), w.dataEnd = w.length + j - 2, w.partIndex = S[j + 8], w.partsCount = S[j + 9], h.mainHeader = !1, w.partIndex === 0 && (w.COD = h.COD, w.COC = h.COC.slice(0), w.QCD = h.QCD, w.QCC = h.QCC.slice(0)), h.currentTile = w;
                      break;
                    case 65427:
                      w = h.currentTile, w.partIndex === 0 && (I(h, w.index), W(h)), J = w.dataEnd - j, g(h, S, j, J);
                      break;
                    case 65363:
                      (0, n.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");
                    case 65365:
                    case 65367:
                    case 65368:
                    case 65380:
                      J = (0, P.readUint16)(S, j);
                      break;
                    default:
                      throw new Error("Unknown codestream code: " + G.toString(16));
                  }
                  j += J;
                }
              } catch (j) {
                if (A || this.failOnCorruptedImage)
                  throw new e(j.message);
                (0, n.warn)(`JPX: Trying to recover from: "${j.message}".`);
              }
              this.tiles = c(h), this.width = h.SIZ.Xsiz - h.SIZ.XOsiz, this.height = h.SIZ.Ysiz - h.SIZ.YOsiz, this.componentsCount = h.SIZ.Csiz;
            }
          }
          b.JpxImage = l;
          function V($, S) {
            $.x0 = Math.ceil(S.XOsiz / $.XRsiz), $.x1 = Math.ceil(S.Xsiz / $.XRsiz), $.y0 = Math.ceil(S.YOsiz / $.YRsiz), $.y1 = Math.ceil(S.Ysiz / $.YRsiz), $.width = $.x1 - $.x0, $.height = $.y1 - $.y0;
          }
          function te($, S) {
            const v = $.SIZ, m = [];
            let h;
            const A = Math.ceil((v.Xsiz - v.XTOsiz) / v.XTsiz), j = Math.ceil((v.Ysiz - v.YTOsiz) / v.YTsiz);
            for (let J = 0; J < j; J++)
              for (let oe = 0; oe < A; oe++)
                h = {}, h.tx0 = Math.max(v.XTOsiz + oe * v.XTsiz, v.XOsiz), h.ty0 = Math.max(v.YTOsiz + J * v.YTsiz, v.YOsiz), h.tx1 = Math.min(v.XTOsiz + (oe + 1) * v.XTsiz, v.Xsiz), h.ty1 = Math.min(v.YTOsiz + (J + 1) * v.YTsiz, v.Ysiz), h.width = h.tx1 - h.tx0, h.height = h.ty1 - h.ty0, h.components = [], m.push(h);
            $.tiles = m;
            const G = v.Csiz;
            for (let J = 0, oe = G; J < oe; J++) {
              const q = S[J];
              for (let re = 0, K = m.length; re < K; re++) {
                const Z = {};
                h = m[re], Z.tcx0 = Math.ceil(h.tx0 / q.XRsiz), Z.tcy0 = Math.ceil(h.ty0 / q.YRsiz), Z.tcx1 = Math.ceil(h.tx1 / q.XRsiz), Z.tcy1 = Math.ceil(h.ty1 / q.YRsiz), Z.width = Z.tcx1 - Z.tcx0, Z.height = Z.tcy1 - Z.tcy0, h.components[J] = Z;
              }
            }
          }
          function E($, S, v) {
            const m = S.codingStyleParameters, h = {};
            return m.entropyCoderWithCustomPrecincts ? (h.PPx = m.precinctsSizes[v].PPx, h.PPy = m.precinctsSizes[v].PPy) : (h.PPx = 15, h.PPy = 15), h.xcb_ = v > 0 ? Math.min(m.xcb, h.PPx - 1) : Math.min(m.xcb, h.PPx), h.ycb_ = v > 0 ? Math.min(m.ycb, h.PPy - 1) : Math.min(m.ycb, h.PPy), h;
          }
          function F($, S, v) {
            const m = 1 << v.PPx, h = 1 << v.PPy, A = S.resLevel === 0, j = 1 << v.PPx + (A ? 0 : -1), G = 1 << v.PPy + (A ? 0 : -1), J = S.trx1 > S.trx0 ? Math.ceil(S.trx1 / m) - Math.floor(S.trx0 / m) : 0, oe = S.try1 > S.try0 ? Math.ceil(S.try1 / h) - Math.floor(S.try0 / h) : 0, q = J * oe;
            S.precinctParameters = {
              precinctWidth: m,
              precinctHeight: h,
              numprecinctswide: J,
              numprecinctshigh: oe,
              numprecincts: q,
              precinctWidthInSubband: j,
              precinctHeightInSubband: G
            };
          }
          function f($, S, v) {
            const m = v.xcb_, h = v.ycb_, A = 1 << m, j = 1 << h, G = S.tbx0 >> m, J = S.tby0 >> h, oe = S.tbx1 + A - 1 >> m, q = S.tby1 + j - 1 >> h, re = S.resolution.precinctParameters, K = [], Z = [];
            let w, k, X, H;
            for (k = J; k < q; k++)
              for (w = G; w < oe; w++) {
                X = {
                  cbx: w,
                  cby: k,
                  tbx0: A * w,
                  tby0: j * k,
                  tbx1: A * (w + 1),
                  tby1: j * (k + 1)
                }, X.tbx0_ = Math.max(S.tbx0, X.tbx0), X.tby0_ = Math.max(S.tby0, X.tby0), X.tbx1_ = Math.min(S.tbx1, X.tbx1), X.tby1_ = Math.min(S.tby1, X.tby1);
                const Y = Math.floor((X.tbx0_ - S.tbx0) / re.precinctWidthInSubband), ie = Math.floor((X.tby0_ - S.tby0) / re.precinctHeightInSubband);
                if (H = Y + ie * re.numprecinctswide, X.precinctNumber = H, X.subbandType = S.type, X.Lblock = 3, X.tbx1_ <= X.tbx0_ || X.tby1_ <= X.tby0_)
                  continue;
                K.push(X);
                let ne = Z[H];
                ne !== void 0 ? (w < ne.cbxMin ? ne.cbxMin = w : w > ne.cbxMax && (ne.cbxMax = w), k < ne.cbyMin ? ne.cbxMin = k : k > ne.cbyMax && (ne.cbyMax = k)) : Z[H] = ne = {
                  cbxMin: w,
                  cbyMin: k,
                  cbxMax: w,
                  cbyMax: k
                }, X.precinct = ne;
              }
            S.codeblockParameters = {
              codeblockWidth: m,
              codeblockHeight: h,
              numcodeblockwide: oe - G + 1,
              numcodeblockhigh: q - J + 1
            }, S.codeblocks = K, S.precincts = Z;
          }
          function x($, S, v) {
            const m = [], h = $.subbands;
            for (let A = 0, j = h.length; A < j; A++) {
              const J = h[A].codeblocks;
              for (let oe = 0, q = J.length; oe < q; oe++) {
                const re = J[oe];
                re.precinctNumber === S && m.push(re);
              }
            }
            return {
              layerNumber: v,
              codeblocks: m
            };
          }
          function a($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = m.codingStyleDefaultParameters.layersCount, A = S.Csiz;
            let j = 0;
            for (let re = 0; re < A; re++)
              j = Math.max(j, m.components[re].codingStyleParameters.decompositionLevelsCount);
            let G = 0, J = 0, oe = 0, q = 0;
            this.nextPacket = function() {
              for (; G < h; G++) {
                for (; J <= j; J++) {
                  for (; oe < A; oe++) {
                    const K = m.components[oe];
                    if (J > K.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const Z = K.resolutions[J], w = Z.precinctParameters.numprecincts;
                    for (; q < w; ) {
                      const k = x(Z, q, G);
                      return q++, k;
                    }
                    q = 0;
                  }
                  oe = 0;
                }
                J = 0;
              }
              throw new e("Out of packets");
            };
          }
          function N($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = m.codingStyleDefaultParameters.layersCount, A = S.Csiz;
            let j = 0;
            for (let re = 0; re < A; re++)
              j = Math.max(j, m.components[re].codingStyleParameters.decompositionLevelsCount);
            let G = 0, J = 0, oe = 0, q = 0;
            this.nextPacket = function() {
              for (; G <= j; G++) {
                for (; J < h; J++) {
                  for (; oe < A; oe++) {
                    const K = m.components[oe];
                    if (G > K.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const Z = K.resolutions[G], w = Z.precinctParameters.numprecincts;
                    for (; q < w; ) {
                      const k = x(Z, q, J);
                      return q++, k;
                    }
                    q = 0;
                  }
                  oe = 0;
                }
                J = 0;
              }
              throw new e("Out of packets");
            };
          }
          function p($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = m.codingStyleDefaultParameters.layersCount, A = S.Csiz;
            let j, G, J, oe, q = 0;
            for (J = 0; J < A; J++) {
              const K = m.components[J];
              q = Math.max(q, K.codingStyleParameters.decompositionLevelsCount);
            }
            const re = new Int32Array(q + 1);
            for (G = 0; G <= q; ++G) {
              let K = 0;
              for (J = 0; J < A; ++J) {
                const Z = m.components[J].resolutions;
                G < Z.length && (K = Math.max(K, Z[G].precinctParameters.numprecincts));
              }
              re[G] = K;
            }
            j = 0, G = 0, J = 0, oe = 0, this.nextPacket = function() {
              for (; G <= q; G++) {
                for (; oe < re[G]; oe++) {
                  for (; J < A; J++) {
                    const Z = m.components[J];
                    if (G > Z.codingStyleParameters.decompositionLevelsCount)
                      continue;
                    const w = Z.resolutions[G], k = w.precinctParameters.numprecincts;
                    if (!(oe >= k)) {
                      for (; j < h; ) {
                        const X = x(w, oe, j);
                        return j++, X;
                      }
                      j = 0;
                    }
                  }
                  J = 0;
                }
                oe = 0;
              }
              throw new e("Out of packets");
            };
          }
          function O($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = m.codingStyleDefaultParameters.layersCount, A = S.Csiz, j = z(m), G = j;
            let J = 0, oe = 0, q = 0, re = 0, K = 0;
            this.nextPacket = function() {
              for (; K < G.maxNumHigh; K++) {
                for (; re < G.maxNumWide; re++) {
                  for (; q < A; q++) {
                    const w = m.components[q], k = w.codingStyleParameters.decompositionLevelsCount;
                    for (; oe <= k; oe++) {
                      const X = w.resolutions[oe], H = j.components[q].resolutions[oe], Y = R(re, K, H, G, X);
                      if (Y !== null) {
                        for (; J < h; ) {
                          const ie = x(X, Y, J);
                          return J++, ie;
                        }
                        J = 0;
                      }
                    }
                    oe = 0;
                  }
                  q = 0;
                }
                re = 0;
              }
              throw new e("Out of packets");
            };
          }
          function M($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = m.codingStyleDefaultParameters.layersCount, A = S.Csiz, j = z(m);
            let G = 0, J = 0, oe = 0, q = 0, re = 0;
            this.nextPacket = function() {
              for (; oe < A; ++oe) {
                const Z = m.components[oe], w = j.components[oe], k = Z.codingStyleParameters.decompositionLevelsCount;
                for (; re < w.maxNumHigh; re++) {
                  for (; q < w.maxNumWide; q++) {
                    for (; J <= k; J++) {
                      const X = Z.resolutions[J], H = w.resolutions[J], Y = R(q, re, H, w, X);
                      if (Y !== null) {
                        for (; G < h; ) {
                          const ie = x(X, Y, G);
                          return G++, ie;
                        }
                        G = 0;
                      }
                    }
                    J = 0;
                  }
                  q = 0;
                }
                re = 0;
              }
              throw new e("Out of packets");
            };
          }
          function R($, S, v, m, h) {
            const A = $ * m.minWidth, j = S * m.minHeight;
            if (A % v.width !== 0 || j % v.height !== 0)
              return null;
            const G = j / v.width * h.precinctParameters.numprecinctswide;
            return A / v.height + G;
          }
          function z($) {
            const S = $.components.length;
            let v = Number.MAX_VALUE, m = Number.MAX_VALUE, h = 0, A = 0;
            const j = new Array(S);
            for (let G = 0; G < S; G++) {
              const J = $.components[G], oe = J.codingStyleParameters.decompositionLevelsCount, q = new Array(oe + 1);
              let re = Number.MAX_VALUE, K = Number.MAX_VALUE, Z = 0, w = 0, k = 1;
              for (let X = oe; X >= 0; --X) {
                const H = J.resolutions[X], Y = k * H.precinctParameters.precinctWidth, ie = k * H.precinctParameters.precinctHeight;
                re = Math.min(re, Y), K = Math.min(K, ie), Z = Math.max(Z, H.precinctParameters.numprecinctswide), w = Math.max(w, H.precinctParameters.numprecinctshigh), q[X] = {
                  width: Y,
                  height: ie
                }, k <<= 1;
              }
              v = Math.min(v, re), m = Math.min(m, K), h = Math.max(h, Z), A = Math.max(A, w), j[G] = {
                resolutions: q,
                minWidth: re,
                minHeight: K,
                maxNumWide: Z,
                maxNumHigh: w
              };
            }
            return {
              components: j,
              minWidth: v,
              minHeight: m,
              maxNumWide: h,
              maxNumHigh: A
            };
          }
          function W($) {
            const S = $.SIZ, v = $.currentTile.index, m = $.tiles[v], h = S.Csiz;
            for (let j = 0; j < h; j++) {
              const G = m.components[j], J = G.codingStyleParameters.decompositionLevelsCount, oe = [], q = [];
              for (let re = 0; re <= J; re++) {
                const K = E($, G, re), Z = {}, w = 1 << J - re;
                Z.trx0 = Math.ceil(G.tcx0 / w), Z.try0 = Math.ceil(G.tcy0 / w), Z.trx1 = Math.ceil(G.tcx1 / w), Z.try1 = Math.ceil(G.tcy1 / w), Z.resLevel = re, F($, Z, K), oe.push(Z);
                let k;
                if (re === 0)
                  k = {}, k.type = "LL", k.tbx0 = Math.ceil(G.tcx0 / w), k.tby0 = Math.ceil(G.tcy0 / w), k.tbx1 = Math.ceil(G.tcx1 / w), k.tby1 = Math.ceil(G.tcy1 / w), k.resolution = Z, f($, k, K), q.push(k), Z.subbands = [k];
                else {
                  const X = 1 << J - re + 1, H = [];
                  k = {}, k.type = "HL", k.tbx0 = Math.ceil(G.tcx0 / X - 0.5), k.tby0 = Math.ceil(G.tcy0 / X), k.tbx1 = Math.ceil(G.tcx1 / X - 0.5), k.tby1 = Math.ceil(G.tcy1 / X), k.resolution = Z, f($, k, K), q.push(k), H.push(k), k = {}, k.type = "LH", k.tbx0 = Math.ceil(G.tcx0 / X), k.tby0 = Math.ceil(G.tcy0 / X - 0.5), k.tbx1 = Math.ceil(G.tcx1 / X), k.tby1 = Math.ceil(G.tcy1 / X - 0.5), k.resolution = Z, f($, k, K), q.push(k), H.push(k), k = {}, k.type = "HH", k.tbx0 = Math.ceil(G.tcx0 / X - 0.5), k.tby0 = Math.ceil(G.tcy0 / X - 0.5), k.tbx1 = Math.ceil(G.tcx1 / X - 0.5), k.tby1 = Math.ceil(G.tcy1 / X - 0.5), k.resolution = Z, f($, k, K), q.push(k), H.push(k), Z.subbands = H;
                }
              }
              G.resolutions = oe, G.subbands = q;
            }
            const A = m.codingStyleDefaultParameters.progressionOrder;
            switch (A) {
              case 0:
                m.packetsIterator = new a($);
                break;
              case 1:
                m.packetsIterator = new N($);
                break;
              case 2:
                m.packetsIterator = new p($);
                break;
              case 3:
                m.packetsIterator = new O($);
                break;
              case 4:
                m.packetsIterator = new M($);
                break;
              default:
                throw new e(`Unsupported progression order ${A}`);
            }
          }
          function g($, S, v, m) {
            let h = 0, A, j = 0, G = !1;
            function J(Y) {
              for (; j < Y; ) {
                const ie = S[v + h];
                h++, G ? (A = A << 7 | ie, j += 7, G = !1) : (A = A << 8 | ie, j += 8), ie === 255 && (G = !0);
              }
              return j -= Y, A >>> j & (1 << Y) - 1;
            }
            function oe(Y) {
              return S[v + h - 1] === 255 && S[v + h] === Y ? (q(1), !0) : S[v + h] === 255 && S[v + h + 1] === Y ? (q(2), !0) : !1;
            }
            function q(Y) {
              h += Y;
            }
            function re() {
              j = 0, G && (h++, G = !1);
            }
            function K() {
              if (J(1) === 0)
                return 1;
              if (J(1) === 0)
                return 2;
              let Y = J(2);
              return Y < 3 ? Y + 3 : (Y = J(5), Y < 31 ? Y + 6 : (Y = J(7), Y + 37));
            }
            const Z = $.currentTile.index, w = $.tiles[Z], k = $.COD.sopMarkerUsed, X = $.COD.ephMarkerUsed, H = w.packetsIterator;
            for (; h < m; ) {
              re(), k && oe(145) && q(4);
              const Y = H.nextPacket();
              if (!J(1))
                continue;
              const ie = Y.layerNumber, ne = [];
              let U;
              for (let ae = 0, Q = Y.codeblocks.length; ae < Q; ae++) {
                U = Y.codeblocks[ae];
                let L = U.precinct;
                const ee = U.cbx - L.cbxMin, se = U.cby - L.cbyMin;
                let le = !1, ue = !1, de, ge;
                if (U.included !== void 0)
                  le = !!J(1);
                else {
                  L = U.precinct;
                  let Ae;
                  if (L.inclusionTree !== void 0)
                    Ae = L.inclusionTree;
                  else {
                    const be = L.cbxMax - L.cbxMin + 1, he = L.cbyMax - L.cbyMin + 1;
                    Ae = new r(be, he, ie), ge = new s(be, he), L.inclusionTree = Ae, L.zeroBitPlanesTree = ge;
                    for (let fe = 0; fe < ie; fe++)
                      if (J(1) !== 0)
                        throw new e("Invalid tag tree");
                  }
                  if (Ae.reset(ee, se, ie))
                    for (; ; )
                      if (J(1)) {
                        if (de = !Ae.nextLevel(), de) {
                          U.included = !0, le = ue = !0;
                          break;
                        }
                      } else {
                        Ae.incrementValue(ie);
                        break;
                      }
                }
                if (!le)
                  continue;
                if (ue) {
                  for (ge = L.zeroBitPlanesTree, ge.reset(ee, se); ; )
                    if (J(1)) {
                      if (de = !ge.nextLevel(), de)
                        break;
                    } else
                      ge.incrementValue();
                  U.zeroBitPlanes = ge.value;
                }
                const me = K();
                for (; J(1); )
                  U.Lblock++;
                const pe = (0, P.log2)(me), xe = (me < 1 << pe ? pe - 1 : pe) + U.Lblock, we = J(xe);
                ne.push({
                  codeblock: U,
                  codingpasses: me,
                  dataLength: we
                });
              }
              for (re(), X && oe(146); ne.length > 0; ) {
                const ae = ne.shift();
                U = ae.codeblock, U.data === void 0 && (U.data = []), U.data.push({
                  data: S,
                  start: v + h,
                  end: v + h + ae.dataLength,
                  codingpasses: ae.codingpasses
                }), h += ae.dataLength;
              }
            }
            return h;
          }
          function T($, S, v, m, h, A, j, G, J) {
            const oe = m.tbx0, q = m.tby0, re = m.tbx1 - m.tbx0, K = m.codeblocks, Z = m.type.charAt(0) === "H" ? 1 : 0, w = m.type.charAt(1) === "H" ? S : 0;
            for (let k = 0, X = K.length; k < X; ++k) {
              const H = K[k], Y = H.tbx1_ - H.tbx0_, ie = H.tby1_ - H.tby0_;
              if (Y === 0 || ie === 0 || H.data === void 0)
                continue;
              const ne = new u(Y, ie, H.subbandType, H.zeroBitPlanes, A);
              let U = 2;
              const ae = H.data;
              let Q = 0, L = 0, ee, se, le;
              for (ee = 0, se = ae.length; ee < se; ee++)
                le = ae[ee], Q += le.end - le.start, L += le.codingpasses;
              const ue = new Uint8Array(Q);
              let de = 0;
              for (ee = 0, se = ae.length; ee < se; ee++) {
                le = ae[ee];
                const ye = le.data.subarray(le.start, le.end);
                ue.set(ye, de), de += ye.length;
              }
              const ge = new D.ArithmeticDecoder(ue, 0, Q);
              for (ne.setDecoder(ge), ee = 0; ee < L; ee++) {
                switch (U) {
                  case 0:
                    ne.runSignificancePropagationPass();
                    break;
                  case 1:
                    ne.runMagnitudeRefinementPass();
                    break;
                  case 2:
                    ne.runCleanupPass(), G && ne.checkSegmentationSymbol();
                    break;
                }
                J && ne.reset(), U = (U + 1) % 3;
              }
              let me = H.tbx0_ - oe + (H.tby0_ - q) * re;
              const pe = ne.coefficentsSign, xe = ne.coefficentsMagnitude, we = ne.bitsDecoded, Ae = j ? 0 : 0.5;
              let be, he, fe;
              de = 0;
              const Ce = m.type !== "LL";
              for (ee = 0; ee < ie; ee++) {
                const Le = 2 * (me / re | 0) * (S - re) + Z + w;
                for (be = 0; be < Y; be++) {
                  if (he = xe[de], he !== 0) {
                    he = (he + Ae) * h, pe[de] !== 0 && (he = -he), fe = we[de];
                    const Be = Ce ? Le + (me << 1) : me;
                    $[Be] = j && fe >= A ? he : he * (1 << A - fe);
                  }
                  me++, de++;
                }
                me += re - Y;
              }
            }
          }
          function o($, S, v) {
            const m = S.components[v], h = m.codingStyleParameters, A = m.quantizationParameters, j = h.decompositionLevelsCount, G = A.SPqcds, J = A.scalarExpounded, oe = A.guardBits, q = h.segmentationSymbolUsed, re = h.resetContextProbabilities, K = $.components[v].precision, Z = h.reversibleTransformation, w = Z ? new y() : new d(), k = [];
            let X = 0;
            for (let Y = 0; Y <= j; Y++) {
              const ie = m.resolutions[Y], ne = ie.trx1 - ie.trx0, U = ie.try1 - ie.try0, ae = new Float32Array(ne * U);
              for (let Q = 0, L = ie.subbands.length; Q < L; Q++) {
                let ee, se;
                J ? (ee = G[X].mu, se = G[X].epsilon, X++) : (ee = G[0].mu, se = G[0].epsilon + (Y > 0 ? 1 - Y : 0));
                const le = ie.subbands[Q], ue = t[le.type], de = Z ? 1 : 2 ** (K + ue - se) * (1 + ee / 2048), ge = oe + se - 1;
                T(ae, ne, U, le, de, ge, Z, q, re);
              }
              k.push({
                width: ne,
                height: U,
                items: ae
              });
            }
            const H = w.calculate(k, m.tcx0, m.tcy0);
            return {
              left: m.tcx0,
              top: m.tcy0,
              width: H.width,
              height: H.height,
              items: H.items
            };
          }
          function c($) {
            const S = $.SIZ, v = $.components, m = S.Csiz, h = [];
            for (let A = 0, j = $.tiles.length; A < j; A++) {
              const G = $.tiles[A], J = [];
              for (let ne = 0; ne < m; ne++)
                J[ne] = o($, G, ne);
              const oe = J[0], q = new Uint8ClampedArray(oe.items.length * m), re = {
                left: oe.left,
                top: oe.top,
                width: oe.width,
                height: oe.height,
                items: q
              };
              let K, Z, w = 0, k, X, H, Y, ie;
              if (G.codingStyleDefaultParameters.multipleComponentTransform) {
                const ne = m === 4, U = J[0].items, ae = J[1].items, Q = J[2].items, L = ne ? J[3].items : null;
                K = v[0].precision - 8, Z = (128 << K) + 0.5;
                const ee = G.components[0], se = m - 3;
                if (X = U.length, ee.codingStyleParameters.reversibleTransformation)
                  for (k = 0; k < X; k++, w += se) {
                    H = U[k] + Z, Y = ae[k], ie = Q[k];
                    const le = H - (ie + Y >> 2);
                    q[w++] = le + ie >> K, q[w++] = le >> K, q[w++] = le + Y >> K;
                  }
                else
                  for (k = 0; k < X; k++, w += se)
                    H = U[k] + Z, Y = ae[k], ie = Q[k], q[w++] = H + 1.402 * ie >> K, q[w++] = H - 0.34413 * Y - 0.71414 * ie >> K, q[w++] = H + 1.772 * Y >> K;
                if (ne)
                  for (k = 0, w = 3; k < X; k++, w += 4)
                    q[w] = L[k] + Z >> K;
              } else
                for (let ne = 0; ne < m; ne++) {
                  const U = J[ne].items;
                  for (K = v[ne].precision - 8, Z = (128 << K) + 0.5, w = ne, k = 0, X = U.length; k < X; k++)
                    q[w] = U[k] + Z >> K, w += m;
                }
              h.push(re);
            }
            return h;
          }
          function I($, S) {
            const m = $.SIZ.Csiz, h = $.tiles[S];
            for (let A = 0; A < m; A++) {
              const j = h.components[A], G = $.currentTile.QCC[A] !== void 0 ? $.currentTile.QCC[A] : $.currentTile.QCD;
              j.quantizationParameters = G;
              const J = $.currentTile.COC[A] !== void 0 ? $.currentTile.COC[A] : $.currentTile.COD;
              j.codingStyleParameters = J;
            }
            h.codingStyleDefaultParameters = $.currentTile.COD;
          }
          class s {
            constructor(S, v) {
              const m = (0, P.log2)(Math.max(S, v)) + 1;
              this.levels = [];
              for (let h = 0; h < m; h++) {
                const A = {
                  width: S,
                  height: v,
                  items: []
                };
                this.levels.push(A), S = Math.ceil(S / 2), v = Math.ceil(v / 2);
              }
            }
            reset(S, v) {
              let m = 0, h = 0, A;
              for (; m < this.levels.length; ) {
                A = this.levels[m];
                const j = S + v * A.width;
                if (A.items[j] !== void 0) {
                  h = A.items[j];
                  break;
                }
                A.index = j, S >>= 1, v >>= 1, m++;
              }
              m--, A = this.levels[m], A.items[A.index] = h, this.currentLevel = m, delete this.value;
            }
            incrementValue() {
              const S = this.levels[this.currentLevel];
              S.items[S.index]++;
            }
            nextLevel() {
              let S = this.currentLevel, v = this.levels[S];
              const m = v.items[v.index];
              return S--, S < 0 ? (this.value = m, !1) : (this.currentLevel = S, v = this.levels[S], v.items[v.index] = m, !0);
            }
          }
          class r {
            constructor(S, v, m) {
              const h = (0, P.log2)(Math.max(S, v)) + 1;
              this.levels = [];
              for (let A = 0; A < h; A++) {
                const j = new Uint8Array(S * v);
                for (let J = 0, oe = j.length; J < oe; J++)
                  j[J] = m;
                const G = {
                  width: S,
                  height: v,
                  items: j
                };
                this.levels.push(G), S = Math.ceil(S / 2), v = Math.ceil(v / 2);
              }
            }
            reset(S, v, m) {
              let h = 0;
              for (; h < this.levels.length; ) {
                const A = this.levels[h], j = S + v * A.width;
                A.index = j;
                const G = A.items[j];
                if (G === 255)
                  break;
                if (G > m)
                  return this.currentLevel = h, this.propagateValues(), !1;
                S >>= 1, v >>= 1, h++;
              }
              return this.currentLevel = h - 1, !0;
            }
            incrementValue(S) {
              const v = this.levels[this.currentLevel];
              v.items[v.index] = S + 1, this.propagateValues();
            }
            propagateValues() {
              let S = this.currentLevel, v = this.levels[S];
              const m = v.items[v.index];
              for (; --S >= 0; )
                v = this.levels[S], v.items[v.index] = m;
            }
            nextLevel() {
              let S = this.currentLevel, v = this.levels[S];
              const m = v.items[v.index];
              return v.items[v.index] = 255, S--, S < 0 ? !1 : (this.currentLevel = S, v = this.levels[S], v.items[v.index] = m, !0);
            }
          }
          const _ = class _ {
            constructor(S, v, m, h, A) {
              this.width = S, this.height = v;
              let j;
              m === "HH" ? j = _.HHContextLabel : m === "HL" ? j = _.HLContextLabel : j = _.LLAndLHContextsLabel, this.contextLabelTable = j;
              const G = S * v;
              this.neighborsSignificance = new Uint8Array(G), this.coefficentsSign = new Uint8Array(G);
              let J;
              A > 14 ? J = new Uint32Array(G) : A > 6 ? J = new Uint16Array(G) : J = new Uint8Array(G), this.coefficentsMagnitude = J, this.processingFlags = new Uint8Array(G);
              const oe = new Uint8Array(G);
              if (h !== 0)
                for (let q = 0; q < G; q++)
                  oe[q] = h;
              this.bitsDecoded = oe, this.reset();
            }
            setDecoder(S) {
              this.decoder = S;
            }
            reset() {
              this.contexts = new Int8Array(19), this.contexts[0] = 8, this.contexts[_.UNIFORM_CONTEXT] = 92, this.contexts[_.RUNLENGTH_CONTEXT] = 6;
            }
            setNeighborsSignificance(S, v, m) {
              const h = this.neighborsSignificance, A = this.width, j = this.height, G = v > 0, J = v + 1 < A;
              let oe;
              S > 0 && (oe = m - A, G && (h[oe - 1] += 16), J && (h[oe + 1] += 16), h[oe] += 4), S + 1 < j && (oe = m + A, G && (h[oe - 1] += 16), J && (h[oe + 1] += 16), h[oe] += 4), G && (h[m - 1] += 1), J && (h[m + 1] += 1), h[m] |= 128;
            }
            runSignificancePropagationPass() {
              const S = this.decoder, v = this.width, m = this.height, h = this.coefficentsMagnitude, A = this.coefficentsSign, j = this.neighborsSignificance, G = this.processingFlags, J = this.contexts, oe = this.contextLabelTable, q = this.bitsDecoded, re = -2, K = 1, Z = 2;
              for (let w = 0; w < m; w += 4)
                for (let k = 0; k < v; k++) {
                  let X = w * v + k;
                  for (let H = 0; H < 4; H++, X += v) {
                    const Y = w + H;
                    if (Y >= m)
                      break;
                    if (G[X] &= re, h[X] || !j[X])
                      continue;
                    const ie = oe[j[X]];
                    if (S.readBit(J, ie)) {
                      const U = this.decodeSignBit(Y, k, X);
                      A[X] = U, h[X] = 1, this.setNeighborsSignificance(Y, k, X), G[X] |= Z;
                    }
                    q[X]++, G[X] |= K;
                  }
                }
            }
            decodeSignBit(S, v, m) {
              const h = this.width, A = this.height, j = this.coefficentsMagnitude, G = this.coefficentsSign;
              let J, oe, q, re, K, Z;
              re = v > 0 && j[m - 1] !== 0, v + 1 < h && j[m + 1] !== 0 ? (q = G[m + 1], re ? (oe = G[m - 1], J = 1 - q - oe) : J = 1 - q - q) : re ? (oe = G[m - 1], J = 1 - oe - oe) : J = 0;
              const w = 3 * J;
              return re = S > 0 && j[m - h] !== 0, S + 1 < A && j[m + h] !== 0 ? (q = G[m + h], re ? (oe = G[m - h], J = 1 - q - oe + w) : J = 1 - q - q + w) : re ? (oe = G[m - h], J = 1 - oe - oe + w) : J = w, J >= 0 ? (K = 9 + J, Z = this.decoder.readBit(this.contexts, K)) : (K = 9 - J, Z = this.decoder.readBit(this.contexts, K) ^ 1), Z;
            }
            runMagnitudeRefinementPass() {
              const S = this.decoder, v = this.width, m = this.height, h = this.coefficentsMagnitude, A = this.neighborsSignificance, j = this.contexts, G = this.bitsDecoded, J = this.processingFlags, oe = 1, q = 2, re = v * m, K = v * 4;
              for (let Z = 0, w; Z < re; Z = w) {
                w = Math.min(re, Z + K);
                for (let k = 0; k < v; k++)
                  for (let X = Z + k; X < w; X += v) {
                    if (!h[X] || J[X] & oe)
                      continue;
                    let H = 16;
                    J[X] & q && (J[X] ^= q, H = (A[X] & 127) === 0 ? 15 : 14);
                    const Y = S.readBit(j, H);
                    h[X] = h[X] << 1 | Y, G[X]++, J[X] |= oe;
                  }
              }
            }
            runCleanupPass() {
              const S = this.decoder, v = this.width, m = this.height, h = this.neighborsSignificance, A = this.coefficentsMagnitude, j = this.coefficentsSign, G = this.contexts, J = this.contextLabelTable, oe = this.bitsDecoded, q = this.processingFlags, re = 1, K = 2, Z = v, w = v * 2, k = v * 3;
              let X;
              for (let H = 0; H < m; H = X) {
                X = Math.min(H + 4, m);
                const Y = H * v, ie = H + 3 < m;
                for (let ne = 0; ne < v; ne++) {
                  const U = Y + ne, ae = ie && q[U] === 0 && q[U + Z] === 0 && q[U + w] === 0 && q[U + k] === 0 && h[U] === 0 && h[U + Z] === 0 && h[U + w] === 0 && h[U + k] === 0;
                  let Q = 0, L = U, ee = H, se;
                  if (ae) {
                    if (!S.readBit(G, _.RUNLENGTH_CONTEXT)) {
                      oe[U]++, oe[U + Z]++, oe[U + w]++, oe[U + k]++;
                      continue;
                    }
                    Q = S.readBit(G, _.UNIFORM_CONTEXT) << 1 | S.readBit(G, _.UNIFORM_CONTEXT), Q !== 0 && (ee = H + Q, L += Q * v), se = this.decodeSignBit(ee, ne, L), j[L] = se, A[L] = 1, this.setNeighborsSignificance(ee, ne, L), q[L] |= K, L = U;
                    for (let ue = H; ue <= ee; ue++, L += v)
                      oe[L]++;
                    Q++;
                  }
                  for (ee = H + Q; ee < X; ee++, L += v) {
                    if (A[L] || q[L] & re)
                      continue;
                    const le = J[h[L]];
                    S.readBit(G, le) === 1 && (se = this.decodeSignBit(ee, ne, L), j[L] = se, A[L] = 1, this.setNeighborsSignificance(ee, ne, L), q[L] |= K), oe[L]++;
                  }
                }
              }
            }
            checkSegmentationSymbol() {
              const S = this.decoder, v = this.contexts;
              if ((S.readBit(v, _.UNIFORM_CONTEXT) << 3 | S.readBit(v, _.UNIFORM_CONTEXT) << 2 | S.readBit(v, _.UNIFORM_CONTEXT) << 1 | S.readBit(v, _.UNIFORM_CONTEXT)) !== 10)
                throw new e("Invalid segmentation symbol");
            }
          };
          Ut(_, "UNIFORM_CONTEXT", 17), Ut(_, "RUNLENGTH_CONTEXT", 18), Ut(_, "LLAndLHContextsLabel", new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8])), Ut(_, "HLContextLabel", new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8])), Ut(_, "HHContextLabel", new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]));
          let u = _;
          class C {
            constructor() {
              this.constructor === C && (0, n.unreachable)("Cannot initialize Transform.");
            }
            calculate(S, v, m) {
              let h = S[0];
              for (let A = 1, j = S.length; A < j; A++)
                h = this.iterate(h, S[A], v, m);
              return h;
            }
            extend(S, v, m) {
              let h = v - 1, A = v + 1, j = v + m - 2, G = v + m;
              S[h--] = S[A++], S[G++] = S[j--], S[h--] = S[A++], S[G++] = S[j--], S[h--] = S[A++], S[G++] = S[j--], S[h] = S[A], S[G] = S[j];
            }
            filter(S, v, m) {
              (0, n.unreachable)("Abstract method `filter` called");
            }
            iterate(S, v, m, h) {
              const A = S.width, j = S.height;
              let G = S.items;
              const J = v.width, oe = v.height, q = v.items;
              let re, K, Z, w, k, X;
              for (Z = 0, re = 0; re < j; re++)
                for (w = re * 2 * J, K = 0; K < A; K++, Z++, w += 2)
                  q[w] = G[Z];
              G = S.items = null;
              const H = 4, Y = new Float32Array(J + 2 * H);
              if (J === 1) {
                if (m & 1)
                  for (X = 0, Z = 0; X < oe; X++, Z += J)
                    q[Z] *= 0.5;
              } else
                for (X = 0, Z = 0; X < oe; X++, Z += J)
                  Y.set(q.subarray(Z, Z + J), H), this.extend(Y, H, J), this.filter(Y, H, J), q.set(Y.subarray(H, H + J), Z);
              let ie = 16;
              const ne = [];
              for (re = 0; re < ie; re++)
                ne.push(new Float32Array(oe + 2 * H));
              let U, ae = 0;
              if (S = H + oe, oe === 1) {
                if (h & 1)
                  for (k = 0; k < J; k++)
                    q[k] *= 0.5;
              } else
                for (k = 0; k < J; k++) {
                  if (ae === 0) {
                    for (ie = Math.min(J - k, ie), Z = k, w = H; w < S; Z += J, w++)
                      for (U = 0; U < ie; U++)
                        ne[U][w] = q[Z + U];
                    ae = ie;
                  }
                  ae--;
                  const Q = ne[ae];
                  if (this.extend(Q, H, oe), this.filter(Q, H, oe), ae === 0)
                    for (Z = k - ie + 1, w = H; w < S; Z += J, w++)
                      for (U = 0; U < ie; U++)
                        q[Z + U] = ne[U][w];
                }
              return {
                width: J,
                height: oe,
                items: q
              };
            }
          }
          class d extends C {
            filter(S, v, m) {
              const h = m >> 1;
              v |= 0;
              let A, j, G, J;
              const oe = -1.586134342059924, q = -0.052980118572961, re = 0.882911075530934, K = 0.443506852043971, Z = 1.230174104914001, w = 1 / Z;
              for (A = v - 3, j = h + 4; j--; A += 2)
                S[A] *= w;
              for (A = v - 2, G = K * S[A - 1], j = h + 3; j-- && (J = K * S[A + 1], S[A] = Z * S[A] - G - J, j--); A += 2)
                A += 2, G = K * S[A + 1], S[A] = Z * S[A] - G - J;
              for (A = v - 1, G = re * S[A - 1], j = h + 2; j-- && (J = re * S[A + 1], S[A] -= G + J, j--); A += 2)
                A += 2, G = re * S[A + 1], S[A] -= G + J;
              for (A = v, G = q * S[A - 1], j = h + 1; j-- && (J = q * S[A + 1], S[A] -= G + J, j--); A += 2)
                A += 2, G = q * S[A + 1], S[A] -= G + J;
              if (h !== 0)
                for (A = v + 1, G = oe * S[A - 1], j = h; j-- && (J = oe * S[A + 1], S[A] -= G + J, j--); A += 2)
                  A += 2, G = oe * S[A + 1], S[A] -= G + J;
            }
          }
          class y extends C {
            filter(S, v, m) {
              const h = m >> 1;
              v |= 0;
              let A, j;
              for (A = v, j = h + 1; j--; A += 2)
                S[A] -= S[A - 1] + S[A + 1] + 2 >> 2;
              for (A = v + 1, j = h; j--; A += 2)
                S[A] += S[A - 1] + S[A + 1] >> 1;
            }
          }
        },
        /* 31 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.LZWStream = void 0;
          var n = ce(18);
          class P extends n.DecodeStream {
            constructor(e, t, l) {
              super(t), this.str = e, this.dict = e.dict, this.cachedData = 0, this.bitsCached = 0;
              const V = 4096, te = {
                earlyChange: l,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(V),
                dictionaryLengths: new Uint16Array(V),
                dictionaryPrevCodes: new Uint16Array(V),
                currentSequence: new Uint8Array(V),
                currentSequenceLength: 0
              };
              for (let E = 0; E < 256; ++E)
                te.dictionaryValues[E] = E, te.dictionaryLengths[E] = 1;
              this.lzwState = te;
            }
            readBits(e) {
              let t = this.bitsCached, l = this.cachedData;
              for (; t < e; ) {
                const V = this.str.getByte();
                if (V === -1)
                  return this.eof = !0, null;
                l = l << 8 | V, t += 8;
              }
              return this.bitsCached = t -= e, this.cachedData = l, this.lastCode = null, l >>> t & (1 << e) - 1;
            }
            readBlock() {
              let l = 1024, V, te, E;
              const F = this.lzwState;
              if (!F)
                return;
              const f = F.earlyChange;
              let x = F.nextCode;
              const a = F.dictionaryValues, N = F.dictionaryLengths, p = F.dictionaryPrevCodes;
              let O = F.codeLength, M = F.prevCode;
              const R = F.currentSequence;
              let z = F.currentSequenceLength, W = 0, g = this.bufferLength, T = this.ensureBuffer(this.bufferLength + l);
              for (V = 0; V < 512; V++) {
                const o = this.readBits(O), c = z > 0;
                if (o < 256)
                  R[0] = o, z = 1;
                else if (o >= 258)
                  if (o < x)
                    for (z = N[o], te = z - 1, E = o; te >= 0; te--)
                      R[te] = a[E], E = p[E];
                  else
                    R[z++] = R[0];
                else if (o === 256) {
                  O = 9, x = 258, z = 0;
                  continue;
                } else {
                  this.eof = !0, delete this.lzwState;
                  break;
                }
                if (c && (p[x] = M, N[x] = N[M] + 1, a[x] = R[0], x++, O = x + f & x + f - 1 ? O : Math.min(Math.log(x + f) / 0.6931471805599453 + 1, 12) | 0), M = o, W += z, l < W) {
                  do
                    l += 512;
                  while (l < W);
                  T = this.ensureBuffer(this.bufferLength + l);
                }
                for (te = 0; te < z; te++)
                  T[g++] = R[te];
              }
              F.nextCode = x, F.codeLength = O, F.prevCode = M, F.currentSequenceLength = z, this.bufferLength = g;
            }
          }
          b.LZWStream = P;
        },
        /* 32 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PredictorStream = void 0;
          var n = ce(18), P = ce(4), D = ce(2);
          class e extends n.DecodeStream {
            constructor(l, V, te) {
              if (super(V), !(te instanceof P.Dict))
                return l;
              const E = this.predictor = te.get("Predictor") || 1;
              if (E <= 1)
                return l;
              if (E !== 2 && (E < 10 || E > 15))
                throw new D.FormatError(`Unsupported predictor: ${E}`);
              this.readBlock = E === 2 ? this.readBlockTiff : this.readBlockPng, this.str = l, this.dict = l.dict;
              const F = this.colors = te.get("Colors") || 1, f = this.bits = te.get("BPC", "BitsPerComponent") || 8, x = this.columns = te.get("Columns") || 1;
              return this.pixBytes = F * f + 7 >> 3, this.rowBytes = x * F * f + 7 >> 3, this;
            }
            readBlockTiff() {
              const l = this.rowBytes, V = this.bufferLength, te = this.ensureBuffer(V + l), E = this.bits, F = this.colors, f = this.str.getBytes(l);
              if (this.eof = !f.length, this.eof)
                return;
              let x = 0, a = 0, N = 0, p = 0, O = V, M;
              if (E === 1 && F === 1)
                for (M = 0; M < l; ++M) {
                  let R = f[M] ^ x;
                  R ^= R >> 1, R ^= R >> 2, R ^= R >> 4, x = (R & 1) << 7, te[O++] = R;
                }
              else if (E === 8) {
                for (M = 0; M < F; ++M)
                  te[O++] = f[M];
                for (; M < l; ++M)
                  te[O] = te[O - F] + f[M], O++;
              } else if (E === 16) {
                const R = F * 2;
                for (M = 0; M < R; ++M)
                  te[O++] = f[M];
                for (; M < l; M += 2) {
                  const z = ((f[M] & 255) << 8) + (f[M + 1] & 255) + ((te[O - R] & 255) << 8) + (te[O - R + 1] & 255);
                  te[O++] = z >> 8 & 255, te[O++] = z & 255;
                }
              } else {
                const R = new Uint8Array(F + 1), z = (1 << E) - 1;
                let W = 0, g = V;
                const T = this.columns;
                for (M = 0; M < T; ++M)
                  for (let o = 0; o < F; ++o)
                    N < E && (x = x << 8 | f[W++] & 255, N += 8), R[o] = R[o] + (x >> N - E) & z, N -= E, a = a << E | R[o], p += E, p >= 8 && (te[g++] = a >> p - 8 & 255, p -= 8);
                p > 0 && (te[g++] = (a << 8 - p) + (x & (1 << 8 - p) - 1));
              }
              this.bufferLength += l;
            }
            readBlockPng() {
              const l = this.rowBytes, V = this.pixBytes, te = this.str.getByte(), E = this.str.getBytes(l);
              if (this.eof = !E.length, this.eof)
                return;
              const F = this.bufferLength, f = this.ensureBuffer(F + l);
              let x = f.subarray(F - l, F);
              x.length === 0 && (x = new Uint8Array(l));
              let a, N = F, p, O;
              switch (te) {
                case 0:
                  for (a = 0; a < l; ++a)
                    f[N++] = E[a];
                  break;
                case 1:
                  for (a = 0; a < V; ++a)
                    f[N++] = E[a];
                  for (; a < l; ++a)
                    f[N] = f[N - V] + E[a] & 255, N++;
                  break;
                case 2:
                  for (a = 0; a < l; ++a)
                    f[N++] = x[a] + E[a] & 255;
                  break;
                case 3:
                  for (a = 0; a < V; ++a)
                    f[N++] = (x[a] >> 1) + E[a];
                  for (; a < l; ++a)
                    f[N] = (x[a] + f[N - V] >> 1) + E[a] & 255, N++;
                  break;
                case 4:
                  for (a = 0; a < V; ++a)
                    p = x[a], O = E[a], f[N++] = p + O;
                  for (; a < l; ++a) {
                    p = x[a];
                    const M = x[a - V], R = f[N - V], z = R + p - M;
                    let W = z - R;
                    W < 0 && (W = -W);
                    let g = z - p;
                    g < 0 && (g = -g);
                    let T = z - M;
                    T < 0 && (T = -T), O = E[a], W <= g && W <= T ? f[N++] = R + O : g <= T ? f[N++] = p + O : f[N++] = M + O;
                  }
                  break;
                default:
                  throw new D.FormatError(`Unsupported predictor: ${te}`);
              }
              this.bufferLength += l;
            }
          }
          b.PredictorStream = e;
        },
        /* 33 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.RunLengthStream = void 0;
          var n = ce(18);
          class P extends n.DecodeStream {
            constructor(e, t) {
              super(t), this.str = e, this.dict = e.dict;
            }
            readBlock() {
              const e = this.str.getBytes(2);
              if (!e || e.length < 2 || e[0] === 128) {
                this.eof = !0;
                return;
              }
              let t, l = this.bufferLength, V = e[0];
              if (V < 128) {
                if (t = this.ensureBuffer(l + V + 1), t[l++] = e[1], V > 0) {
                  const te = this.str.getBytes(V);
                  t.set(te, l), l += V;
                }
              } else {
                V = 257 - V;
                const te = e[1];
                t = this.ensureBuffer(l + V + 1);
                for (let E = 0; E < V; E++)
                  t[l++] = te;
              }
              this.bufferLength = l;
            }
          }
          b.RunLengthStream = P;
        },
        /* 34 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Font = b.ErrorFont = void 0;
          var n = ce(2), P = ce(35), D = ce(38), e = ce(40), t = ce(39), l = ce(37), V = ce(41), te = ce(42), E = ce(43), F = ce(44), f = ce(45), x = ce(46), a = ce(14), N = ce(47), p = ce(3), O = ce(8), M = ce(48);
          const R = [[57344, 63743], [1048576, 1114109]], z = 1e3, W = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], g = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
          function T(U) {
            if (!U.fontMatrix || U.fontMatrix[0] === n.FONT_IDENTITY_MATRIX[0])
              return;
            const ae = 1e-3 / U.fontMatrix[0], Q = U.widths;
            for (const L in Q)
              Q[L] *= ae;
            U.defaultWidth *= ae;
          }
          function o(U, ae, Q) {
            if (U.isInternalFont || U.hasIncludedToUnicodeMap || U.hasEncoding || U.toUnicode instanceof te.IdentityToUnicodeMap || !ae || Q.length === 0 || U.defaultEncoding === l.WinAnsiEncoding)
              return;
            for (const le of Q)
              if (!oe(le))
                return;
            const L = l.WinAnsiEncoding, ee = [], se = (0, t.getGlyphsUnicode)();
            for (const le in L) {
              const ue = L[le];
              if (ue === "")
                continue;
              const de = se[ue];
              de !== void 0 && (ee[le] = String.fromCharCode(de));
            }
            ee.length > 0 && U.toUnicode.amend(ee);
          }
          function c(U, ae) {
            if (U.isInternalFont || U.hasIncludedToUnicodeMap || ae === U.defaultEncoding || U.toUnicode instanceof te.IdentityToUnicodeMap)
              return;
            const Q = [], L = (0, t.getGlyphsUnicode)();
            for (const ee in ae) {
              if (U.hasEncoding && (U.baseEncodingName || U.differences[ee] !== void 0))
                continue;
              const se = ae[ee], le = (0, e.getUnicodeForGlyph)(se, L);
              le !== -1 && (Q[ee] = String.fromCharCode(le));
            }
            Q.length > 0 && U.toUnicode.amend(Q);
          }
          function I(U) {
            if (!U.fallbackToUnicode || U.toUnicode instanceof te.IdentityToUnicodeMap)
              return;
            const ae = [];
            for (const Q in U.fallbackToUnicode)
              U.toUnicode.has(Q) || (ae[Q] = U.fallbackToUnicode[Q]);
            ae.length > 0 && U.toUnicode.amend(ae);
          }
          class s {
            constructor(ae, Q, L, ee, se, le, ue, de, ge) {
              this.originalCharCode = ae, this.fontChar = Q, this.unicode = L, this.accent = ee, this.width = se, this.vmetric = le, this.operatorListId = ue, this.isSpace = de, this.isInFont = ge;
            }
            get category() {
              return (0, n.shadow)(this, "category", (0, e.getCharUnicodeCategory)(this.unicode), !0);
            }
          }
          function r(U, ae) {
            return (U << 8) + ae;
          }
          function u(U, ae, Q) {
            U[ae + 1] = Q, U[ae] = Q >>> 8;
          }
          function C(U, ae) {
            const Q = (U << 8) + ae;
            return Q & 32768 ? Q - 65536 : Q;
          }
          function d(U, ae, Q, L) {
            return (U << 24) + (ae << 16) + (Q << 8) + L;
          }
          function y(U) {
            return String.fromCharCode(U >> 8 & 255, U & 255);
          }
          function _(U) {
            return U > 32767 ? U = 32767 : U < -32768 && (U = -32768), String.fromCharCode(U >> 8 & 255, U & 255);
          }
          function $(U) {
            const ae = U.peekBytes(4);
            return (0, p.readUint32)(ae, 0) === 65536 || (0, n.bytesToString)(ae) === "true";
          }
          function S(U) {
            const ae = U.peekBytes(4);
            return (0, n.bytesToString)(ae) === "ttcf";
          }
          function v(U) {
            const ae = U.peekBytes(4);
            return (0, n.bytesToString)(ae) === "OTTO";
          }
          function m(U) {
            const ae = U.peekBytes(2);
            return ae[0] === 37 && ae[1] === 33 || ae[0] === 128 && ae[1] === 1;
          }
          function h(U) {
            const ae = U.peekBytes(4);
            return ae[0] >= 1 && ae[3] >= 1 && ae[3] <= 4;
          }
          function A(U, {
            type: ae,
            subtype: Q,
            composite: L
          }) {
            let ee, se;
            return $(U) || S(U) ? ee = L ? "CIDFontType2" : "TrueType" : v(U) ? ee = L ? "CIDFontType2" : "OpenType" : m(U) ? L ? ee = "CIDFontType0" : ee = ae === "MMType1" ? "MMType1" : "Type1" : h(U) ? L ? (ee = "CIDFontType0", se = "CIDFontType0C") : (ee = ae === "MMType1" ? "MMType1" : "Type1", se = "Type1C") : ((0, n.warn)("getFontFileType: Unable to detect correct font file Type/Subtype."), ee = ae, se = Q), [ee, se];
          }
          function j(U, ae) {
            for (const Q in ae)
              U[+Q] = ae[Q];
          }
          function G(U, ae, Q) {
            const L = [];
            let ee;
            for (let se = 0, le = U.length; se < le; se++)
              ee = (0, e.getUnicodeForGlyph)(U[se], ae), ee !== -1 && (L[se] = ee);
            for (const se in Q)
              ee = (0, e.getUnicodeForGlyph)(Q[se], ae), ee !== -1 && (L[+se] = ee);
            return L;
          }
          function J(U) {
            return U.platform === 1 && U.encoding === 0 && U.language === 0;
          }
          function oe(U) {
            return U.platform === 3 && U.encoding === 1 && U.language === 1033;
          }
          function q(U, ae, Q = !1) {
            switch (ae.length) {
              case 1:
                return ae.charCodeAt(0);
              case 2:
                return ae.charCodeAt(0) << 8 | ae.charCodeAt(1);
            }
            const L = `Unsupported CID string (charCode ${U}): "${ae}".`;
            if (Q)
              throw new n.FormatError(L);
            return (0, n.warn)(L), ae;
          }
          function re(U, ae, Q, L) {
            const ee = /* @__PURE__ */ Object.create(null), se = /* @__PURE__ */ new Map(), le = [], ue = /* @__PURE__ */ new Set();
            let de = 0, me = R[de][0], pe = R[de][1];
            const xe = (we) => R[0][0] <= we && we <= R[0][1] || R[1][0] <= we && we <= R[1][1];
            for (let we in U) {
              we |= 0;
              let Ae = U[we];
              if (!ae(Ae))
                continue;
              if (me > pe) {
                if (de++, de >= R.length) {
                  (0, n.warn)("Ran out of space in font private use area.");
                  break;
                }
                me = R[de][0], pe = R[de][1];
              }
              const be = me++;
              Ae === 0 && (Ae = Q);
              let he = L.get(we);
              typeof he == "string" && (he = he.codePointAt(0)), he && !xe(he) && !ue.has(Ae) && (se.set(he, Ae), ue.add(Ae)), ee[be] = Ae, le[we] = be;
            }
            return {
              toFontChar: le,
              charCodeToGlyphId: ee,
              toUnicodeExtraMap: se,
              nextAvailableFontCharCode: me
            };
          }
          function K(U, ae, Q) {
            const L = [];
            for (const le in U)
              U[le] >= Q || L.push({
                fontCharCode: le | 0,
                glyphId: U[le]
              });
            if (ae)
              for (const [le, ue] of ae)
                ue >= Q || L.push({
                  fontCharCode: le,
                  glyphId: ue
                });
            L.length === 0 && L.push({
              fontCharCode: 0,
              glyphId: 0
            }), L.sort(function(ue, de) {
              return ue.fontCharCode - de.fontCharCode;
            });
            const ee = [], se = L.length;
            for (let le = 0; le < se; ) {
              const ue = L[le].fontCharCode, de = [L[le].glyphId];
              ++le;
              let ge = ue;
              for (; le < se && ge + 1 === L[le].fontCharCode && (de.push(L[le].glyphId), ++ge, ++le, ge !== 65535); )
                ;
              ee.push([ue, ge, de]);
            }
            return ee;
          }
          function Z(U, ae, Q) {
            const L = K(U, ae, Q), ee = L.at(-1)[1] > 65535 ? 2 : 1;
            let se = "\0\0" + y(ee) + "\0\0" + (0, n.string32)(4 + ee * 8), le, ue, de, ge;
            for (le = L.length - 1; le >= 0 && !(L[le][0] <= 65535); --le)
              ;
            const me = le + 1;
            L[le][0] < 65535 && L[le][1] === 65535 && (L[le][1] = 65534);
            const pe = L[le][1] < 65535 ? 1 : 0, xe = me + pe, we = N.OpenTypeFileBuilder.getSearchParams(xe, 2);
            let Ae = "", be = "", he = "", fe = "", Ce = "", ye = 0, Le, Be, nt, Oe;
            for (le = 0, ue = me; le < ue; le++) {
              Le = L[le], Be = Le[0], nt = Le[1], Ae += y(Be), be += y(nt), Oe = Le[2];
              let Ge = !0;
              for (de = 1, ge = Oe.length; de < ge; ++de)
                if (Oe[de] !== Oe[de - 1] + 1) {
                  Ge = !1;
                  break;
                }
              if (Ge) {
                const dt = Oe[0];
                he += y(dt - Be & 65535), fe += y(0);
              } else {
                const dt = (xe - le) * 2 + ye * 2;
                for (ye += nt - Be + 1, he += y(0), fe += y(dt), de = 0, ge = Oe.length; de < ge; ++de)
                  Ce += y(Oe[de]);
              }
            }
            pe > 0 && (be += "ÿÿ", Ae += "ÿÿ", he += "\0", fe += "\0\0");
            const Je = "\0\0" + y(2 * xe) + y(we.range) + y(we.entry) + y(we.rangeShift) + be + "\0\0" + Ae + he + fe + Ce;
            let Ve = "", Pe = "";
            if (ee > 1) {
              for (se += `\0\0
` + (0, n.string32)(4 + ee * 8 + 4 + Je.length), Ve = "", le = 0, ue = L.length; le < ue; le++) {
                Le = L[le], Be = Le[0], Oe = Le[2];
                let Ge = Oe[0];
                for (de = 1, ge = Oe.length; de < ge; ++de)
                  Oe[de] !== Oe[de - 1] + 1 && (nt = Le[0] + de - 1, Ve += (0, n.string32)(Be) + (0, n.string32)(nt) + (0, n.string32)(Ge), Be = nt + 1, Ge = Oe[de]);
                Ve += (0, n.string32)(Be) + (0, n.string32)(Le[1]) + (0, n.string32)(Ge);
              }
              Pe = "\0\f\0\0" + (0, n.string32)(Ve.length + 16) + "\0\0\0\0" + (0, n.string32)(Ve.length / 12);
            }
            return se + "\0" + y(Je.length + 4) + Je + Pe + Ve;
          }
          function w(U, ae) {
            ae.pos = (ae.start || 0) + U.offset;
            const Q = ae.getUint16();
            ae.skip(60);
            const L = ae.getUint16();
            if (Q < 4 && L & 768)
              return !1;
            const ee = ae.getUint16(), se = ae.getUint16();
            return ee > se || (ae.skip(6), ae.getUint16() === 0) ? !1 : (U.data[8] = U.data[9] = 0, !0);
          }
          function k(U, ae, Q) {
            Q || (Q = {
              unitsPerEm: 0,
              yMax: 0,
              yMin: 0,
              ascent: 0,
              descent: 0
            });
            let L = 0, ee = 0, se = 0, le = 0, ue = null, de = 0, ge = -1;
            if (ae) {
              for (let fe in ae)
                if (fe |= 0, (ue > fe || !ue) && (ue = fe), de < fe && (de = fe), ge = (0, e.getUnicodeRangeFor)(fe, ge), ge < 32)
                  L |= 1 << ge;
                else if (ge < 64)
                  ee |= 1 << ge - 32;
                else if (ge < 96)
                  se |= 1 << ge - 64;
                else if (ge < 123)
                  le |= 1 << ge - 96;
                else
                  throw new n.FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
              de > 65535 && (de = 65535);
            } else
              ue = 0, de = 255;
            const me = U.bbox || [0, 0, 0, 0], pe = Q.unitsPerEm || 1 / (U.fontMatrix || n.FONT_IDENTITY_MATRIX)[0], xe = U.ascentScaled ? 1 : pe / z, we = Q.ascent || Math.round(xe * (U.ascent || me[3]));
            let Ae = Q.descent || Math.round(xe * (U.descent || me[1]));
            Ae > 0 && U.descent > 0 && me[1] < 0 && (Ae = -Ae);
            const be = Q.yMax || we, he = -Q.yMin || -Ae;
            return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(U.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + (0, n.string32)(L) + (0, n.string32)(ee) + (0, n.string32)(se) + (0, n.string32)(le) + "*21*" + y(U.italicAngle ? 1 : 0) + y(ue || U.firstChar) + y(de || U.lastChar) + y(we) + y(Ae) + "\0d" + y(be) + y(he) + "\0\0\0\0\0\0\0\0" + y(U.xHeight) + y(U.capHeight) + y(0) + y(ue || U.firstChar) + "\0";
          }
          function X(U) {
            const ae = Math.floor(U.italicAngle * 65536);
            return "\0\0\0" + (0, n.string32)(ae) + "\0\0\0\0" + (0, n.string32)(U.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
          }
          function H(U) {
            return U.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
          }
          function Y(U, ae) {
            ae || (ae = [[], []]);
            const Q = [ae[0][0] || "Original licence", ae[0][1] || U, ae[0][2] || "Unknown", ae[0][3] || "uniqueID", ae[0][4] || U, ae[0][5] || "Version 0.11", ae[0][6] || H(U), ae[0][7] || "Unknown", ae[0][8] || "Unknown", ae[0][9] || "Unknown"], L = [];
            let ee, se, le, ue, de;
            for (ee = 0, se = Q.length; ee < se; ee++) {
              de = ae[1][ee] || Q[ee];
              const he = [];
              for (le = 0, ue = de.length; le < ue; le++)
                he.push(y(de.charCodeAt(le)));
              L.push(he.join(""));
            }
            const ge = [Q, L], me = ["\0", "\0"], pe = ["\0\0", "\0"], xe = ["\0\0", "	"], we = Q.length * me.length;
            let Ae = "\0\0" + y(we) + y(we * 12 + 6), be = 0;
            for (ee = 0, se = me.length; ee < se; ee++) {
              const he = ge[ee];
              for (le = 0, ue = he.length; le < ue; le++) {
                de = he[le];
                const fe = me[ee] + pe[ee] + xe[ee] + y(le) + y(de.length) + y(be);
                Ae += fe, be += de.length;
              }
            }
            return Ae += Q.join("") + L.join(""), Ae;
          }
          class ie {
            constructor(ae, Q, L) {
              var ge;
              this.name = ae, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = L.loadedName, this.isType3Font = L.isType3Font, this.missingFile = !1, this.cssFontInfo = L.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
              let ee = !!(L.flags & D.FontFlags.Serif);
              if (!ee && !L.isSimulatedFlags) {
                const me = ae.replaceAll(/[,_]/g, "-").split("-")[0], pe = (0, V.getSerifFonts)();
                for (const xe of me.split("+"))
                  if (pe[xe]) {
                    ee = !0;
                    break;
                  }
              }
              this.isSerifFont = ee, this.isSymbolicFont = !!(L.flags & D.FontFlags.Symbolic), this.isMonospace = !!(L.flags & D.FontFlags.FixedPitch);
              let {
                type: se,
                subtype: le
              } = L;
              this.type = se, this.subtype = le, this.systemFontInfo = L.systemFontInfo;
              const ue = ae.match(/^InvalidPDFjsFont_(.*)_\d+$/);
              if (this.isInvalidPDFjsFont = !!ue, this.isInvalidPDFjsFont ? this.fallbackName = ue[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", (ge = this.systemFontInfo) != null && ge.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = L.differences, this.widths = L.widths, this.defaultWidth = L.defaultWidth, this.composite = L.composite, this.cMap = L.cMap, this.capHeight = L.capHeight / z, this.ascent = L.ascent / z, this.descent = L.descent / z, this.lineHeight = this.ascent - this.descent, this.fontMatrix = L.fontMatrix, this.bbox = L.bbox, this.defaultEncoding = L.defaultEncoding, this.toUnicode = L.toUnicode, this.toFontChar = [], L.type === "Type3") {
                for (let me = 0; me < 256; me++)
                  this.toFontChar[me] = this.differences[me] || L.defaultEncoding[me];
                return;
              }
              if (this.cidEncoding = L.cidEncoding || "", this.vertical = !!L.vertical, this.vertical && (this.vmetrics = L.vmetrics, this.defaultVMetrics = L.defaultVMetrics), !Q || Q.isEmpty) {
                Q && (0, n.warn)('Font file is empty in "' + ae + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(L);
                return;
              }
              [se, le] = A(Q, L), (se !== this.type || le !== this.subtype) && (0, n.info)(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${se}/${le}.`);
              let de;
              try {
                switch (se) {
                  case "MMType1":
                    (0, n.info)("MMType1 font (" + ae + "), falling back to Type1.");
                  case "Type1":
                  case "CIDFontType0":
                    this.mimetype = "font/opentype";
                    const me = le === "Type1C" || le === "CIDFontType0C" ? new E.CFFFont(Q, L) : new M.Type1Font(ae, Q, L);
                    T(L), de = this.convert(ae, me, L);
                    break;
                  case "OpenType":
                  case "TrueType":
                  case "CIDFontType2":
                    this.mimetype = "font/opentype", de = this.checkAndRepair(ae, Q, L), this.isOpenType && (T(L), se = "OpenType");
                    break;
                  default:
                    throw new n.FormatError(`Font ${se} is not supported`);
                }
              } catch (me) {
                (0, n.warn)(me), this.fallbackToSystemFont(L);
                return;
              }
              I(L), this.data = de, this.type = se, this.subtype = le, this.fontMatrix = L.fontMatrix, this.widths = L.widths, this.defaultWidth = L.defaultWidth, this.toUnicode = L.toUnicode, this.seacMap = L.seacMap;
            }
            get renderer() {
              const ae = F.FontRendererFactory.create(this, D.SEAC_ANALYSIS_ENABLED);
              return (0, n.shadow)(this, "renderer", ae);
            }
            exportData(ae = !1) {
              const Q = ae ? [...W, ...g] : W, L = /* @__PURE__ */ Object.create(null);
              let ee, se;
              for (ee of Q)
                se = this[ee], se !== void 0 && (L[ee] = se);
              return L;
            }
            fallbackToSystemFont(ae) {
              this.missingFile = !0;
              const {
                name: Q,
                type: L
              } = this;
              let ee = (0, D.normalizeFontName)(Q);
              const se = (0, V.getStdFontMap)(), le = (0, V.getNonStdFontMap)(), ue = !!se[ee], de = !!(le[ee] && se[le[ee]]);
              ee = se[ee] || le[ee] || ee;
              const me = (0, f.getFontBasicMetrics)()[ee];
              me && (isNaN(this.ascent) && (this.ascent = me.ascent / z), isNaN(this.descent) && (this.descent = me.descent / z), isNaN(this.capHeight) && (this.capHeight = me.capHeight / z)), this.bold = /bold/gi.test(ee), this.italic = /oblique|italic/gi.test(ee), this.black = /Black/g.test(Q);
              const pe = /Narrow/g.test(Q);
              if (this.remeasure = (!ue || pe) && Object.keys(this.widths).length > 0, (ue || de) && L === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
                const xe = ae.cidToGidMap, we = [];
                if (j(we, (0, V.getGlyphMapForStandardFonts)()), /Arial-?Black/i.test(Q) ? j(we, (0, V.getSupplementalGlyphMapForArialBlack)()) : /Calibri/i.test(Q) && j(we, (0, V.getSupplementalGlyphMapForCalibri)()), xe) {
                  for (const Ae in we) {
                    const be = we[Ae];
                    xe[be] !== void 0 && (we[+Ae] = xe[be]);
                  }
                  xe.length !== this.toUnicode.length && ae.hasIncludedToUnicodeMap && this.toUnicode instanceof te.IdentityToUnicodeMap && this.toUnicode.forEach(function(Ae, be) {
                    const he = we[Ae];
                    xe[he] === void 0 && (we[+Ae] = be);
                  });
                }
                this.toUnicode instanceof te.IdentityToUnicodeMap || this.toUnicode.forEach(function(Ae, be) {
                  we[+Ae] = be;
                }), this.toFontChar = we, this.toUnicode = new te.ToUnicodeMap(we);
              } else if (/Symbol/i.test(ee))
                this.toFontChar = G(l.SymbolSetEncoding, (0, t.getGlyphsUnicode)(), this.differences);
              else if (/Dingbats/i.test(ee))
                this.toFontChar = G(l.ZapfDingbatsEncoding, (0, t.getDingbatsGlyphsUnicode)(), this.differences);
              else if (ue) {
                const xe = G(this.defaultEncoding, (0, t.getGlyphsUnicode)(), this.differences);
                L === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof te.IdentityToUnicodeMap) && this.toUnicode.forEach(function(we, Ae) {
                  xe[+we] = Ae;
                }), this.toFontChar = xe;
              } else {
                const xe = (0, t.getGlyphsUnicode)(), we = [];
                this.toUnicode.forEach((Ae, be) => {
                  if (!this.composite) {
                    const he = this.differences[Ae] || this.defaultEncoding[Ae], fe = (0, e.getUnicodeForGlyph)(he, xe);
                    fe !== -1 && (be = fe);
                  }
                  we[+Ae] = be;
                }), this.composite && this.toUnicode instanceof te.IdentityToUnicodeMap && /Tahoma|Verdana/i.test(Q) && j(we, (0, V.getGlyphMapForStandardFonts)()), this.toFontChar = we;
              }
              I(ae), this.loadedName = ee.split("-")[0];
            }
            checkAndRepair(ae, Q, L) {
              var ht, Rt, _t;
              const ee = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
              function se(Ie, Fe) {
                const Me = /* @__PURE__ */ Object.create(null);
                Me["OS/2"] = null, Me.cmap = null, Me.head = null, Me.hhea = null, Me.hmtx = null, Me.maxp = null, Me.name = null, Me.post = null;
                for (let Ne = 0; Ne < Fe; Ne++) {
                  const je = le(Ie);
                  ee.includes(je.tag) && je.length !== 0 && (Me[je.tag] = je);
                }
                return Me;
              }
              function le(Ie) {
                const Fe = Ie.getString(4), Me = Ie.getInt32() >>> 0, Ne = Ie.getInt32() >>> 0, je = Ie.getInt32() >>> 0, et = Ie.pos;
                Ie.pos = Ie.start || 0, Ie.skip(Ne);
                const $e = Ie.getBytes(je);
                return Ie.pos = et, Fe === "head" && ($e[8] = $e[9] = $e[10] = $e[11] = 0, $e[17] |= 32), {
                  tag: Fe,
                  checksum: Me,
                  length: je,
                  offset: Ne,
                  data: $e
                };
              }
              function ue(Ie) {
                return {
                  version: Ie.getString(4),
                  numTables: Ie.getUint16(),
                  searchRange: Ie.getUint16(),
                  entrySelector: Ie.getUint16(),
                  rangeShift: Ie.getUint16()
                };
              }
              function de(Ie) {
                const Fe = Ie.getString(4);
                (0, n.assert)(Fe === "ttcf", "Must be a TrueType Collection font.");
                const Me = Ie.getUint16(), Ne = Ie.getUint16(), je = Ie.getInt32() >>> 0, et = [];
                for (let Ee = 0; Ee < je; Ee++)
                  et.push(Ie.getInt32() >>> 0);
                const $e = {
                  ttcTag: Fe,
                  majorVersion: Me,
                  minorVersion: Ne,
                  numFonts: je,
                  offsetTable: et
                };
                switch (Me) {
                  case 1:
                    return $e;
                  case 2:
                    return $e.dsigTag = Ie.getInt32() >>> 0, $e.dsigLength = Ie.getInt32() >>> 0, $e.dsigOffset = Ie.getInt32() >>> 0, $e;
                }
                throw new n.FormatError(`Invalid TrueType Collection majorVersion: ${Me}.`);
              }
              function ge(Ie, Fe) {
                var $e;
                const {
                  numFonts: Me,
                  offsetTable: Ne
                } = de(Ie), je = Fe.split("+");
                let et;
                for (let Ee = 0; Ee < Me; Ee++) {
                  Ie.pos = (Ie.start || 0) + Ne[Ee];
                  const He = ue(Ie), rt = se(Ie, He.numTables);
                  if (!rt.name)
                    throw new n.FormatError('TrueType Collection font must contain a "name" table.');
                  const [mt] = he(rt.name);
                  for (let tt = 0, at = mt.length; tt < at; tt++)
                    for (let ft = 0, We = mt[tt].length; ft < We; ft++) {
                      const ot = ($e = mt[tt][ft]) == null ? void 0 : $e.replaceAll(/\s/g, "");
                      if (ot) {
                        if (ot === Fe)
                          return {
                            header: He,
                            tables: rt
                          };
                        if (!(je.length < 2))
                          for (const Xe of je)
                            ot === Xe && (et = {
                              name: Xe,
                              header: He,
                              tables: rt
                            });
                      }
                    }
                }
                if (et)
                  return (0, n.warn)(`TrueType Collection does not contain "${Fe}" font, falling back to "${et.name}" font instead.`), {
                    header: et.header,
                    tables: et.tables
                  };
                throw new n.FormatError(`TrueType Collection does not contain "${Fe}" font.`);
              }
              function me(Ie, Fe, Me, Ne) {
                if (!Ie)
                  return (0, n.warn)("No cmap table available."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                let je, et = (Fe.start || 0) + Ie.offset;
                Fe.pos = et, Fe.skip(2);
                const $e = Fe.getUint16();
                let Ee, He = !1;
                for (let We = 0; We < $e; We++) {
                  const ot = Fe.getUint16(), Xe = Fe.getUint16(), ut = Fe.getInt32() >>> 0;
                  let pt = !1;
                  if (!((Ee == null ? void 0 : Ee.platformId) === ot && (Ee == null ? void 0 : Ee.encodingId) === Xe)) {
                    if (ot === 0 && (Xe === 0 || Xe === 1 || Xe === 3))
                      pt = !0;
                    else if (ot === 1 && Xe === 0)
                      pt = !0;
                    else if (ot === 3 && Xe === 1 && (Ne || !Ee))
                      pt = !0, Me || (He = !0);
                    else if (Me && ot === 3 && Xe === 0) {
                      pt = !0;
                      let $t = !0;
                      if (We < $e - 1) {
                        const ct = Fe.peekBytes(2);
                        r(ct[0], ct[1]) < ot && ($t = !1);
                      }
                      $t && (He = !0);
                    }
                    if (pt && (Ee = {
                      platformId: ot,
                      encodingId: Xe,
                      offset: ut
                    }), He)
                      break;
                  }
                }
                if (Ee && (Fe.pos = et + Ee.offset), !Ee || Fe.peekByte() === -1)
                  return (0, n.warn)("Could not find a preferred cmap table."), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                const rt = Fe.getUint16();
                let mt = !1;
                const tt = [];
                let at, ft;
                if (rt === 0) {
                  for (Fe.skip(4), at = 0; at < 256; at++) {
                    const We = Fe.getByte();
                    We && tt.push({
                      charCode: at,
                      glyphId: We
                    });
                  }
                  mt = !0;
                } else if (rt === 2) {
                  Fe.skip(4);
                  const We = [];
                  let ot = 0;
                  for (let ut = 0; ut < 256; ut++) {
                    const pt = Fe.getUint16() >> 3;
                    We.push(pt), ot = Math.max(pt, ot);
                  }
                  const Xe = [];
                  for (let ut = 0; ut <= ot; ut++)
                    Xe.push({
                      firstCode: Fe.getUint16(),
                      entryCount: Fe.getUint16(),
                      idDelta: C(Fe.getByte(), Fe.getByte()),
                      idRangePos: Fe.pos + Fe.getUint16()
                    });
                  for (let ut = 0; ut < 256; ut++)
                    if (We[ut] === 0)
                      Fe.pos = Xe[0].idRangePos + 2 * ut, ft = Fe.getUint16(), tt.push({
                        charCode: ut,
                        glyphId: ft
                      });
                    else {
                      const pt = Xe[We[ut]];
                      for (at = 0; at < pt.entryCount; at++) {
                        const $t = (ut << 8) + at + pt.firstCode;
                        Fe.pos = pt.idRangePos + 2 * at, ft = Fe.getUint16(), ft !== 0 && (ft = (ft + pt.idDelta) % 65536), tt.push({
                          charCode: $t,
                          glyphId: ft
                        });
                      }
                    }
                } else if (rt === 4) {
                  Fe.skip(4);
                  const We = Fe.getUint16() >> 1;
                  Fe.skip(6);
                  const ot = [];
                  let Xe;
                  for (Xe = 0; Xe < We; Xe++)
                    ot.push({
                      end: Fe.getUint16()
                    });
                  for (Fe.skip(2), Xe = 0; Xe < We; Xe++)
                    ot[Xe].start = Fe.getUint16();
                  for (Xe = 0; Xe < We; Xe++)
                    ot[Xe].delta = Fe.getUint16();
                  let ut = 0, pt;
                  for (Xe = 0; Xe < We; Xe++) {
                    je = ot[Xe];
                    const ct = Fe.getUint16();
                    if (!ct) {
                      je.offsetIndex = -1;
                      continue;
                    }
                    pt = (ct >> 1) - (We - Xe), je.offsetIndex = pt, ut = Math.max(ut, pt + je.end - je.start + 1);
                  }
                  const $t = [];
                  for (at = 0; at < ut; at++)
                    $t.push(Fe.getUint16());
                  for (Xe = 0; Xe < We; Xe++) {
                    je = ot[Xe], et = je.start;
                    const ct = je.end, lt = je.delta;
                    for (pt = je.offsetIndex, at = et; at <= ct; at++)
                      at !== 65535 && (ft = pt < 0 ? at : $t[pt + at - et], ft = ft + lt & 65535, tt.push({
                        charCode: at,
                        glyphId: ft
                      }));
                  }
                } else if (rt === 6) {
                  Fe.skip(4);
                  const We = Fe.getUint16(), ot = Fe.getUint16();
                  for (at = 0; at < ot; at++) {
                    ft = Fe.getUint16();
                    const Xe = We + at;
                    tt.push({
                      charCode: Xe,
                      glyphId: ft
                    });
                  }
                } else if (rt === 12) {
                  Fe.skip(10);
                  const We = Fe.getInt32() >>> 0;
                  for (at = 0; at < We; at++) {
                    const ot = Fe.getInt32() >>> 0, Xe = Fe.getInt32() >>> 0;
                    let ut = Fe.getInt32() >>> 0;
                    for (let pt = ot; pt <= Xe; pt++)
                      tt.push({
                        charCode: pt,
                        glyphId: ut++
                      });
                  }
                } else
                  return (0, n.warn)("cmap table has unsupported format: " + rt), {
                    platformId: -1,
                    encodingId: -1,
                    mappings: [],
                    hasShortCmap: !1
                  };
                tt.sort(function(We, ot) {
                  return We.charCode - ot.charCode;
                });
                for (let We = 1; We < tt.length; We++)
                  tt[We - 1].charCode === tt[We].charCode && (tt.splice(We, 1), We--);
                return {
                  platformId: Ee.platformId,
                  encodingId: Ee.encodingId,
                  mappings: tt,
                  hasShortCmap: mt
                };
              }
              function pe(Ie, Fe, Me, Ne, je, et) {
                if (!Fe) {
                  Me && (Me.data = null);
                  return;
                }
                Ie.pos = (Ie.start || 0) + Fe.offset, Ie.pos += 4, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2, Ie.pos += 2;
                const $e = Ie.getUint16();
                Ie.pos += 8, Ie.pos += 2;
                let Ee = Ie.getUint16();
                $e !== 0 && (r(Ne.data[44], Ne.data[45]) & 2 || (Fe.data[22] = 0, Fe.data[23] = 0)), Ee > je && ((0, n.info)(`The numOfMetrics (${Ee}) should not be greater than the numGlyphs (${je}).`), Ee = je, Fe.data[34] = (Ee & 65280) >> 8, Fe.data[35] = Ee & 255);
                const rt = je - Ee - (Me.length - Ee * 4 >> 1);
                if (rt > 0) {
                  const mt = new Uint8Array(Me.length + rt * 2);
                  mt.set(Me.data), et && (mt[Me.length] = Me.data[2], mt[Me.length + 1] = Me.data[3]), Me.data = mt;
                }
              }
              function xe(Ie, Fe, Me, Ne, je, et) {
                const $e = {
                  length: 0,
                  sizeOfInstructions: 0
                };
                if (Fe < 0 || Fe >= Ie.length || Me > Ie.length || Me - Fe <= 12)
                  return $e;
                const Ee = Ie.subarray(Fe, Me), He = C(Ee[2], Ee[3]), rt = C(Ee[4], Ee[5]), mt = C(Ee[6], Ee[7]), tt = C(Ee[8], Ee[9]);
                He > mt && (u(Ee, 2, mt), u(Ee, 6, He)), rt > tt && (u(Ee, 4, tt), u(Ee, 8, rt));
                const at = C(Ee[0], Ee[1]);
                if (at < 0)
                  return at < -1 || (Ne.set(Ee, je), $e.length = Ee.length), $e;
                let ft, We = 10, ot = 0;
                for (ft = 0; ft < at; ft++)
                  ot = (Ee[We] << 8 | Ee[We + 1]) + 1, We += 2;
                const Xe = We, ut = Ee[We] << 8 | Ee[We + 1];
                $e.sizeOfInstructions = ut, We += 2 + ut;
                const pt = We;
                let $t = 0;
                for (ft = 0; ft < ot; ft++) {
                  const lt = Ee[We++];
                  lt & 192 && (Ee[We - 1] = lt & 63);
                  let vt = 2;
                  lt & 2 ? vt = 1 : lt & 16 && (vt = 0);
                  let Nt = 2;
                  lt & 4 ? Nt = 1 : lt & 32 && (Nt = 0);
                  const qt = vt + Nt;
                  if ($t += qt, lt & 8) {
                    const en = Ee[We++];
                    en === 0 && (Ee[We - 1] ^= 8), ft += en, $t += en * qt;
                  }
                }
                if ($t === 0)
                  return $e;
                let ct = We + $t;
                return ct > Ee.length ? $e : !et && ut > 0 ? (Ne.set(Ee.subarray(0, Xe), je), Ne.set([0, 0], je + Xe), Ne.set(Ee.subarray(pt, ct), je + Xe + 2), ct -= ut, Ee.length - ct > 3 && (ct = ct + 3 & -4), $e.length = ct, $e) : Ee.length - ct > 3 ? (ct = ct + 3 & -4, Ne.set(Ee.subarray(0, ct), je), $e.length = ct, $e) : (Ne.set(Ee, je), $e.length = Ee.length, $e);
              }
              function we(Ie, Fe, Me) {
                const Ne = Ie.data, je = d(Ne[0], Ne[1], Ne[2], Ne[3]);
                je >> 16 !== 1 && ((0, n.info)("Attempting to fix invalid version in head table: " + je), Ne[0] = 0, Ne[1] = 1, Ne[2] = 0, Ne[3] = 0);
                const et = r(Ne[50], Ne[51]);
                if (et < 0 || et > 1) {
                  (0, n.info)("Attempting to fix invalid indexToLocFormat in head table: " + et);
                  const $e = Fe + 1;
                  if (Me === $e << 1)
                    Ne[50] = 0, Ne[51] = 0;
                  else if (Me === $e << 2)
                    Ne[50] = 0, Ne[51] = 1;
                  else
                    throw new n.FormatError("Could not fix indexToLocFormat: " + et);
                }
              }
              function Ae(Ie, Fe, Me, Ne, je, et, $e) {
                let Ee, He, rt;
                Ne ? (Ee = 4, He = function(vt, Nt) {
                  return vt[Nt] << 24 | vt[Nt + 1] << 16 | vt[Nt + 2] << 8 | vt[Nt + 3];
                }, rt = function(vt, Nt, qt) {
                  vt[Nt] = qt >>> 24 & 255, vt[Nt + 1] = qt >> 16 & 255, vt[Nt + 2] = qt >> 8 & 255, vt[Nt + 3] = qt & 255;
                }) : (Ee = 2, He = function(vt, Nt) {
                  return vt[Nt] << 9 | vt[Nt + 1] << 1;
                }, rt = function(vt, Nt, qt) {
                  vt[Nt] = qt >> 9 & 255, vt[Nt + 1] = qt >> 1 & 255;
                });
                const mt = et ? Me + 1 : Me, tt = Ee * (1 + mt), at = new Uint8Array(tt);
                at.set(Ie.data.subarray(0, tt)), Ie.data = at;
                const ft = Fe.data, We = ft.length, ot = new Uint8Array(We);
                let Xe, ut;
                const pt = [];
                for (Xe = 0, ut = 0; Xe < Me + 1; Xe++, ut += Ee) {
                  let lt = He(at, ut);
                  lt > We && (lt = We), pt.push({
                    index: Xe,
                    offset: lt,
                    endOffset: 0
                  });
                }
                for (pt.sort((lt, vt) => lt.offset - vt.offset), Xe = 0; Xe < Me; Xe++)
                  pt[Xe].endOffset = pt[Xe + 1].offset;
                for (pt.sort((lt, vt) => lt.index - vt.index), Xe = 0; Xe < Me; Xe++) {
                  const {
                    offset: lt,
                    endOffset: vt
                  } = pt[Xe];
                  if (lt !== 0 || vt !== 0)
                    break;
                  const Nt = pt[Xe + 1].offset;
                  if (Nt !== 0) {
                    pt[Xe].endOffset = Nt;
                    break;
                  }
                }
                const $t = /* @__PURE__ */ Object.create(null);
                let ct = 0;
                for (rt(at, 0, ct), Xe = 0, ut = Ee; Xe < Me; Xe++, ut += Ee) {
                  const lt = xe(ft, pt[Xe].offset, pt[Xe].endOffset, ot, ct, je), vt = lt.length;
                  vt === 0 && ($t[Xe] = !0), lt.sizeOfInstructions > $e && ($e = lt.sizeOfInstructions), ct += vt, rt(at, ut, ct);
                }
                if (ct === 0) {
                  const lt = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
                  for (Xe = 0, ut = Ee; Xe < mt; Xe++, ut += Ee)
                    rt(at, ut, lt.length);
                  Fe.data = lt;
                } else if (et) {
                  const lt = He(at, Ee);
                  ot.length > lt + ct ? Fe.data = ot.subarray(0, lt + ct) : (Fe.data = new Uint8Array(lt + ct), Fe.data.set(ot.subarray(0, ct))), Fe.data.set(ot.subarray(0, lt), ct), rt(Ie.data, at.length - Ee, ct + lt);
                } else
                  Fe.data = ot.subarray(0, ct);
                return {
                  missingGlyphs: $t,
                  maxSizeOfInstructions: $e
                };
              }
              function be(Ie, Fe, Me) {
                const Ne = (Q.start || 0) + Ie.offset;
                Q.pos = Ne;
                const je = Ie.length, et = Ne + je, $e = Q.getInt32();
                Q.skip(28);
                let Ee, He = !0, rt;
                switch ($e) {
                  case 65536:
                    Ee = D.MacStandardGlyphOrdering;
                    break;
                  case 131072:
                    const mt = Q.getUint16();
                    if (mt !== Me) {
                      He = !1;
                      break;
                    }
                    const tt = [];
                    for (rt = 0; rt < mt; ++rt) {
                      const We = Q.getUint16();
                      if (We >= 32768) {
                        He = !1;
                        break;
                      }
                      tt.push(We);
                    }
                    if (!He)
                      break;
                    const at = [], ft = [];
                    for (; Q.pos < et; ) {
                      const We = Q.getByte();
                      for (ft.length = We, rt = 0; rt < We; ++rt)
                        ft[rt] = String.fromCharCode(Q.getByte());
                      at.push(ft.join(""));
                    }
                    for (Ee = [], rt = 0; rt < mt; ++rt) {
                      const We = tt[rt];
                      if (We < 258) {
                        Ee.push(D.MacStandardGlyphOrdering[We]);
                        continue;
                      }
                      Ee.push(at[We - 258]);
                    }
                    break;
                  case 196608:
                    break;
                  default:
                    (0, n.warn)("Unknown/unsupported post table version " + $e), He = !1, Fe.defaultEncoding && (Ee = Fe.defaultEncoding);
                    break;
                }
                return Fe.glyphNames = Ee, He;
              }
              function he(Ie) {
                const Fe = (Q.start || 0) + Ie.offset;
                Q.pos = Fe;
                const Me = [[], []], Ne = [], je = Ie.length, et = Fe + je;
                if (Q.getUint16() !== 0 || je < 6)
                  return [Me, Ne];
                const He = Q.getUint16(), rt = Q.getUint16(), mt = 12;
                let tt, at;
                for (tt = 0; tt < He && Q.pos + mt <= et; tt++) {
                  const ft = {
                    platform: Q.getUint16(),
                    encoding: Q.getUint16(),
                    language: Q.getUint16(),
                    name: Q.getUint16(),
                    length: Q.getUint16(),
                    offset: Q.getUint16()
                  };
                  (J(ft) || oe(ft)) && Ne.push(ft);
                }
                for (tt = 0, at = Ne.length; tt < at; tt++) {
                  const ft = Ne[tt];
                  if (ft.length <= 0)
                    continue;
                  const We = Fe + rt + ft.offset;
                  if (We + ft.length > et)
                    continue;
                  Q.pos = We;
                  const ot = ft.name;
                  if (ft.encoding) {
                    let Xe = "";
                    for (let ut = 0, pt = ft.length; ut < pt; ut += 2)
                      Xe += String.fromCharCode(Q.getUint16());
                    Me[1][ot] = Xe;
                  } else
                    Me[0][ot] = Q.getString(ft.length);
                }
                return [Me, Ne];
              }
              const fe = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
              function Ce(Ie, Fe) {
                let Me = Ie.data, Ne = 0, je, et, $e, Ee, He, rt = 0, mt = 0;
                const tt = [], at = [], ft = [];
                let We = Fe.tooComplexToFollowFunctions, ot = !1, Xe = 0, ut = 0;
                for (let $t = Me.length; Ne < $t; ) {
                  const ct = Me[Ne++];
                  if (ct === 64)
                    if (et = Me[Ne++], ot || ut)
                      Ne += et;
                    else
                      for (je = 0; je < et; je++)
                        tt.push(Me[Ne++]);
                  else if (ct === 65)
                    if (et = Me[Ne++], ot || ut)
                      Ne += et * 2;
                    else
                      for (je = 0; je < et; je++)
                        $e = Me[Ne++], tt.push($e << 8 | Me[Ne++]);
                  else if ((ct & 248) === 176)
                    if (et = ct - 176 + 1, ot || ut)
                      Ne += et;
                    else
                      for (je = 0; je < et; je++)
                        tt.push(Me[Ne++]);
                  else if ((ct & 248) === 184)
                    if (et = ct - 184 + 1, ot || ut)
                      Ne += et * 2;
                    else
                      for (je = 0; je < et; je++)
                        $e = Me[Ne++], tt.push($e << 8 | Me[Ne++]);
                  else if (ct === 43 && !We) {
                    if (!ot && !ut) {
                      if (Ee = tt.at(-1), isNaN(Ee))
                        (0, n.info)("TT: CALL empty stack (or invalid entry).");
                      else if (Fe.functionsUsed[Ee] = !0, Ee in Fe.functionsStackDeltas) {
                        const lt = tt.length + Fe.functionsStackDeltas[Ee];
                        if (lt < 0) {
                          (0, n.warn)("TT: CALL invalid functions stack delta."), Fe.hintsValid = !1;
                          return;
                        }
                        tt.length = lt;
                      } else if (Ee in Fe.functionsDefined && !ft.includes(Ee)) {
                        if (at.push({
                          data: Me,
                          i: Ne,
                          stackTop: tt.length - 1
                        }), ft.push(Ee), He = Fe.functionsDefined[Ee], !He) {
                          (0, n.warn)("TT: CALL non-existent function"), Fe.hintsValid = !1;
                          return;
                        }
                        Me = He.data, Ne = He.i;
                      }
                    }
                  } else if (ct === 44 && !We)
                    (ot || ut) && ((0, n.warn)("TT: nested FDEFs not allowed"), We = !0), ot = !0, mt = Ne, Ee = tt.pop(), Fe.functionsDefined[Ee] = {
                      data: Me,
                      i: Ne
                    };
                  else if (ct === 45)
                    if (ot)
                      ot = !1, rt = Ne;
                    else {
                      if (He = at.pop(), !He) {
                        (0, n.warn)("TT: ENDF bad stack"), Fe.hintsValid = !1;
                        return;
                      }
                      Ee = ft.pop(), Me = He.data, Ne = He.i, Fe.functionsStackDeltas[Ee] = tt.length - He.stackTop;
                    }
                  else if (ct === 137)
                    (ot || ut) && ((0, n.warn)("TT: nested IDEFs not allowed"), We = !0), ot = !0, mt = Ne;
                  else if (ct === 88)
                    ++Xe;
                  else if (ct === 27)
                    ut = Xe;
                  else if (ct === 89)
                    ut === Xe && (ut = 0), --Xe;
                  else if (ct === 28 && !ot && !ut) {
                    const lt = tt.at(-1);
                    lt > 0 && (Ne += lt - 1);
                  }
                  if (!ot && !ut) {
                    let lt = 0;
                    for (ct <= 142 ? lt = fe[ct] : ct >= 192 && ct <= 223 ? lt = -1 : ct >= 224 && (lt = -2), ct >= 113 && ct <= 117 && (et = tt.pop(), isNaN(et) || (lt = -et * 2)); lt < 0 && tt.length > 0; )
                      tt.pop(), lt++;
                    for (; lt > 0; )
                      tt.push(NaN), lt--;
                  }
                }
                Fe.tooComplexToFollowFunctions = We;
                const pt = [Me];
                Ne > Me.length && pt.push(new Uint8Array(Ne - Me.length)), mt > rt && ((0, n.warn)("TT: complementing a missing function tail"), pt.push(new Uint8Array([34, 45]))), Le(Ie, pt);
              }
              function ye(Ie, Fe) {
                if (!Ie.tooComplexToFollowFunctions) {
                  if (Ie.functionsDefined.length > Fe) {
                    (0, n.warn)("TT: more functions defined than expected"), Ie.hintsValid = !1;
                    return;
                  }
                  for (let Me = 0, Ne = Ie.functionsUsed.length; Me < Ne; Me++) {
                    if (Me > Fe) {
                      (0, n.warn)("TT: invalid function id: " + Me), Ie.hintsValid = !1;
                      return;
                    }
                    if (Ie.functionsUsed[Me] && !Ie.functionsDefined[Me]) {
                      (0, n.warn)("TT: undefined function: " + Me), Ie.hintsValid = !1;
                      return;
                    }
                  }
                }
              }
              function Le(Ie, Fe) {
                if (Fe.length > 1) {
                  let Me = 0, Ne, je;
                  for (Ne = 0, je = Fe.length; Ne < je; Ne++)
                    Me += Fe[Ne].length;
                  Me = Me + 3 & -4;
                  const et = new Uint8Array(Me);
                  let $e = 0;
                  for (Ne = 0, je = Fe.length; Ne < je; Ne++)
                    et.set(Fe[Ne], $e), $e += Fe[Ne].length;
                  Ie.data = et, Ie.length = Me;
                }
              }
              function Be(Ie, Fe, Me, Ne) {
                const je = {
                  functionsDefined: [],
                  functionsUsed: [],
                  functionsStackDeltas: [],
                  tooComplexToFollowFunctions: !1,
                  hintsValid: !0
                };
                if (Ie && Ce(Ie, je), Fe && Ce(Fe, je), Ie && ye(je, Ne), Me && Me.length & 1) {
                  const et = new Uint8Array(Me.length + 1);
                  et.set(Me.data), Me.data = et;
                }
                return je.hintsValid;
              }
              Q = new O.Stream(new Uint8Array(Q.getBytes()));
              let nt, Oe;
              if (S(Q)) {
                const Ie = ge(Q, this.name);
                nt = Ie.header, Oe = Ie.tables;
              } else
                nt = ue(Q), Oe = se(Q, nt.numTables);
              let Je, Ve;
              const Pe = !Oe["CFF "];
              if (Pe) {
                if (!Oe.loca)
                  throw new n.FormatError('Required "loca" table is not found');
                Oe.glyf || ((0, n.warn)('Required "glyf" table is not found -- trying to recover.'), Oe.glyf = {
                  tag: "glyf",
                  data: new Uint8Array(0)
                }), this.isOpenType = !1;
              } else {
                const Ie = L.composite && (((ht = L.cidToGidMap) == null ? void 0 : ht.length) > 0 || !(L.cMap instanceof a.IdentityCMap));
                if (nt.version === "OTTO" && !Ie || !Oe.head || !Oe.hhea || !Oe.maxp || !Oe.post)
                  return Ve = new O.Stream(Oe["CFF "].data), Je = new E.CFFFont(Ve, L), T(L), this.convert(ae, Je, L);
                delete Oe.glyf, delete Oe.loca, delete Oe.fpgm, delete Oe.prep, delete Oe["cvt "], this.isOpenType = !0;
              }
              if (!Oe.maxp)
                throw new n.FormatError('Required "maxp" table is not found');
              Q.pos = (Q.start || 0) + Oe.maxp.offset;
              const Ge = Q.getInt32(), dt = Q.getUint16();
              if (((Rt = L.scaleFactors) == null ? void 0 : Rt.length) === dt && Pe) {
                const {
                  scaleFactors: Ie
                } = L, Fe = r(Oe.head.data[50], Oe.head.data[51]), Me = new x.GlyfTable({
                  glyfTable: Oe.glyf.data,
                  isGlyphLocationsLong: Fe,
                  locaTable: Oe.loca.data,
                  numGlyphs: dt
                });
                Me.scale(Ie);
                const {
                  glyf: Ne,
                  loca: je,
                  isLocationLong: et
                } = Me.write();
                Oe.glyf.data = Ne, Oe.loca.data = je, et !== !!Fe && (Oe.head.data[50] = 0, Oe.head.data[51] = et ? 1 : 0);
                const $e = Oe.hmtx.data;
                for (let Ee = 0; Ee < dt; Ee++) {
                  const He = 4 * Ee, rt = Math.round(Ie[Ee] * r($e[He], $e[He + 1]));
                  $e[He] = rt >> 8 & 255, $e[He + 1] = rt & 255;
                  const mt = Math.round(Ie[Ee] * C($e[He + 2], $e[He + 3]));
                  u($e, He + 2, mt);
                }
              }
              let De = dt + 1, Qe = !0;
              De > 65535 && (Qe = !1, De = dt, (0, n.warn)("Not enough space in glyfs to duplicate first glyph."));
              let st = 0, wt = 0;
              Ge >= 65536 && Oe.maxp.length >= 22 && (Q.pos += 8, Q.getUint16() > 2 && (Oe.maxp.data[14] = 0, Oe.maxp.data[15] = 2), Q.pos += 4, st = Q.getUint16(), Q.pos += 4, wt = Q.getUint16()), Oe.maxp.data[4] = De >> 8, Oe.maxp.data[5] = De & 255;
              const Ot = Be(Oe.fpgm, Oe.prep, Oe["cvt "], st);
              if (Ot || (delete Oe.fpgm, delete Oe.prep, delete Oe["cvt "]), pe(Q, Oe.hhea, Oe.hmtx, Oe.head, De, Qe), !Oe.head)
                throw new n.FormatError('Required "head" table is not found');
              we(Oe.head, dt, Pe ? Oe.loca.length : 0);
              let ze = /* @__PURE__ */ Object.create(null);
              if (Pe) {
                const Ie = r(Oe.head.data[50], Oe.head.data[51]), Fe = Ae(Oe.loca, Oe.glyf, dt, Ie, Ot, Qe, wt);
                ze = Fe.missingGlyphs, Ge >= 65536 && Oe.maxp.length >= 22 && (Oe.maxp.data[26] = Fe.maxSizeOfInstructions >> 8, Oe.maxp.data[27] = Fe.maxSizeOfInstructions & 255);
              }
              if (!Oe.hhea)
                throw new n.FormatError('Required "hhea" table is not found');
              Oe.hhea.data[10] === 0 && Oe.hhea.data[11] === 0 && (Oe.hhea.data[10] = 255, Oe.hhea.data[11] = 255);
              const qe = {
                unitsPerEm: r(Oe.head.data[18], Oe.head.data[19]),
                yMax: C(Oe.head.data[42], Oe.head.data[43]),
                yMin: C(Oe.head.data[38], Oe.head.data[39]),
                ascent: C(Oe.hhea.data[4], Oe.hhea.data[5]),
                descent: C(Oe.hhea.data[6], Oe.hhea.data[7]),
                lineGap: C(Oe.hhea.data[8], Oe.hhea.data[9])
              };
              this.ascent = qe.ascent / qe.unitsPerEm, this.descent = qe.descent / qe.unitsPerEm, this.lineGap = qe.lineGap / qe.unitsPerEm, (_t = this.cssFontInfo) != null && _t.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, Oe.post && be(Oe.post, L, dt), Oe.post = {
                tag: "post",
                data: X(L)
              };
              const Ue = [];
              function bt(Ie) {
                return !ze[Ie];
              }
              if (L.composite) {
                const Ie = L.cidToGidMap || [], Fe = Ie.length === 0;
                L.cMap.forEach(function(Me, Ne) {
                  if (typeof Ne == "string" && (Ne = q(Me, Ne, !0)), Ne > 65535)
                    throw new n.FormatError("Max size of CID is 65,535");
                  let je = -1;
                  Fe ? je = Ne : Ie[Ne] !== void 0 && (je = Ie[Ne]), je >= 0 && je < dt && bt(je) && (Ue[Me] = je);
                });
              } else {
                const Ie = me(Oe.cmap, Q, this.isSymbolicFont, L.hasEncoding), Fe = Ie.platformId, Me = Ie.encodingId, Ne = Ie.mappings;
                let je = [], et = !1;
                if (L.hasEncoding && (L.baseEncodingName === "MacRomanEncoding" || L.baseEncodingName === "WinAnsiEncoding") && (je = (0, l.getEncoding)(L.baseEncodingName)), L.hasEncoding && !this.isSymbolicFont && (Fe === 3 && Me === 1 || Fe === 1 && Me === 0)) {
                  const $e = (0, t.getGlyphsUnicode)();
                  for (let Ee = 0; Ee < 256; Ee++) {
                    let He;
                    if (this.differences[Ee] !== void 0 ? He = this.differences[Ee] : je.length && je[Ee] !== "" ? He = je[Ee] : He = l.StandardEncoding[Ee], !He)
                      continue;
                    const rt = (0, D.recoverGlyphName)(He, $e);
                    let mt;
                    if (Fe === 3 && Me === 1 ? mt = $e[rt] : Fe === 1 && Me === 0 && (mt = l.MacRomanEncoding.indexOf(rt)), mt === void 0) {
                      if (!L.glyphNames && L.hasIncludedToUnicodeMap && !(this.toUnicode instanceof te.IdentityToUnicodeMap)) {
                        const tt = this.toUnicode.get(Ee);
                        tt && (mt = tt.codePointAt(0));
                      }
                      if (mt === void 0)
                        continue;
                    }
                    for (const tt of Ne)
                      if (tt.charCode === mt) {
                        Ue[Ee] = tt.glyphId;
                        break;
                      }
                  }
                } else if (Fe === 0) {
                  for (const $e of Ne)
                    Ue[$e.charCode] = $e.glyphId;
                  et = !0;
                } else
                  for (const $e of Ne) {
                    let Ee = $e.charCode;
                    Fe === 3 && Ee >= 61440 && Ee <= 61695 && (Ee &= 255), Ue[Ee] = $e.glyphId;
                  }
                if (L.glyphNames && (je.length || this.differences.length))
                  for (let $e = 0; $e < 256; ++$e) {
                    if (!et && Ue[$e] !== void 0)
                      continue;
                    const Ee = this.differences[$e] || je[$e];
                    if (!Ee)
                      continue;
                    const He = L.glyphNames.indexOf(Ee);
                    He > 0 && bt(He) && (Ue[$e] = He);
                  }
              }
              Ue.length === 0 && (Ue[0] = 0);
              let It = De - 1;
              if (Qe || (It = 0), !L.cssFontInfo) {
                const Ie = re(Ue, bt, It, this.toUnicode);
                this.toFontChar = Ie.toFontChar, Oe.cmap = {
                  tag: "cmap",
                  data: Z(Ie.charCodeToGlyphId, Ie.toUnicodeExtraMap, De)
                }, (!Oe["OS/2"] || !w(Oe["OS/2"], Q)) && (Oe["OS/2"] = {
                  tag: "OS/2",
                  data: k(L, Ie.charCodeToGlyphId, qe)
                });
              }
              if (!Pe)
                try {
                  Ve = new O.Stream(Oe["CFF "].data), Je = new P.CFFParser(Ve, L, D.SEAC_ANALYSIS_ENABLED).parse(), Je.duplicateFirstGlyph();
                  const Fe = new P.CFFCompiler(Je);
                  Oe["CFF "].data = Fe.compile();
                } catch {
                  (0, n.warn)("Failed to compile font " + L.loadedName);
                }
              if (!Oe.name)
                Oe.name = {
                  tag: "name",
                  data: Y(this.name)
                };
              else {
                const [Ie, Fe] = he(Oe.name);
                Oe.name.data = Y(ae, Ie), this.psName = Ie[0][6] || null, L.composite || o(L, this.isSymbolicFont, Fe);
              }
              const kt = new N.OpenTypeFileBuilder(nt.version);
              for (const Ie in Oe)
                kt.addTable(Ie, Oe[Ie].data);
              return kt.toArray();
            }
            convert(ae, Q, L) {
              L.fixedPitch = !1, L.builtInEncoding && c(L, L.builtInEncoding);
              let ee = 1;
              Q instanceof E.CFFFont && (ee = Q.numGlyphs - 1);
              const se = Q.getGlyphMapping(L);
              let le = null, ue = se, de = null;
              L.cssFontInfo || (le = re(se, Q.hasGlyphId.bind(Q), ee, this.toUnicode), this.toFontChar = le.toFontChar, ue = le.charCodeToGlyphId, de = le.toUnicodeExtraMap);
              const ge = Q.numGlyphs;
              function me(be, he) {
                let fe = null;
                for (const Ce in be)
                  he === be[Ce] && (fe || (fe = [])).push(Ce | 0);
                return fe;
              }
              function pe(be, he) {
                for (const fe in be)
                  if (he === be[fe])
                    return fe | 0;
                return le.charCodeToGlyphId[le.nextAvailableFontCharCode] = he, le.nextAvailableFontCharCode++;
              }
              const xe = Q.seacs;
              if (le && D.SEAC_ANALYSIS_ENABLED && (xe != null && xe.length)) {
                const be = L.fontMatrix || n.FONT_IDENTITY_MATRIX, he = Q.getCharset(), fe = /* @__PURE__ */ Object.create(null);
                for (let Ce in xe) {
                  Ce |= 0;
                  const ye = xe[Ce], Le = l.StandardEncoding[ye[2]], Be = l.StandardEncoding[ye[3]], nt = he.indexOf(Le), Oe = he.indexOf(Be);
                  if (nt < 0 || Oe < 0)
                    continue;
                  const Je = {
                    x: ye[0] * be[0] + ye[1] * be[2] + be[4],
                    y: ye[0] * be[1] + ye[1] * be[3] + be[5]
                  }, Ve = me(se, Ce);
                  if (Ve)
                    for (const Pe of Ve) {
                      const Ge = le.charCodeToGlyphId, dt = pe(Ge, nt), De = pe(Ge, Oe);
                      fe[Pe] = {
                        baseFontCharCode: dt,
                        accentFontCharCode: De,
                        accentOffset: Je
                      };
                    }
                }
                L.seacMap = fe;
              }
              const we = 1 / (L.fontMatrix || n.FONT_IDENTITY_MATRIX)[0], Ae = new N.OpenTypeFileBuilder("OTTO");
              return Ae.addTable("CFF ", Q.data), Ae.addTable("OS/2", k(L, ue)), Ae.addTable("cmap", Z(ue, de, ge)), Ae.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + _(we) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + _(L.descent) + "ÿ" + _(L.ascent) + y(L.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), Ae.addTable("hhea", "\0\0\0" + _(L.ascent) + _(L.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + _(L.capHeight) + _(Math.tan(L.italicAngle) * L.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + y(ge)), Ae.addTable("hmtx", function() {
                const he = Q.charstrings, fe = Q.cff ? Q.cff.widths : null;
                let Ce = "\0\0\0\0";
                for (let ye = 1, Le = ge; ye < Le; ye++) {
                  let Be = 0;
                  if (he) {
                    const nt = he[ye - 1];
                    Be = "width" in nt ? nt.width : 0;
                  } else
                    fe && (Be = Math.ceil(fe[ye] || 0));
                  Ce += y(Be) + y(0);
                }
                return Ce;
              }()), Ae.addTable("maxp", "\0\0P\0" + y(ge)), Ae.addTable("name", Y(ae)), Ae.addTable("post", X(L)), Ae.toArray();
            }
            get spaceWidth() {
              const ae = ["space", "minus", "one", "i", "I"];
              let Q;
              for (const L of ae) {
                if (L in this.widths) {
                  Q = this.widths[L];
                  break;
                }
                const se = (0, t.getGlyphsUnicode)()[L];
                let le = 0;
                if (this.composite && this.cMap.contains(se) && (le = this.cMap.lookup(se), typeof le == "string" && (le = q(se, le))), !le && this.toUnicode && (le = this.toUnicode.charCodeOf(se)), le <= 0 && (le = se), Q = this.widths[le], Q)
                  break;
              }
              return (0, n.shadow)(this, "spaceWidth", Q || this.defaultWidth);
            }
            _charToGlyph(ae, Q = !1) {
              var we, Ae, be;
              let L = this._glyphCache[ae];
              if ((L == null ? void 0 : L.isSpace) === Q)
                return L;
              let ee, se, le, ue = ae;
              (we = this.cMap) != null && we.contains(ae) && (ue = this.cMap.lookup(ae), typeof ue == "string" && (ue = q(ae, ue))), se = this.widths[ue], typeof se != "number" && (se = this.defaultWidth);
              const de = (Ae = this.vmetrics) == null ? void 0 : Ae[ue];
              let ge = this.toUnicode.get(ae) || ae;
              typeof ge == "number" && (ge = String.fromCharCode(ge));
              let me = this.toFontChar[ae] !== void 0;
              if (ee = this.toFontChar[ae] || ae, this.missingFile) {
                const he = this.differences[ae] || this.defaultEncoding[ae];
                (he === ".notdef" || he === "") && this.type === "Type1" && (ee = 32), ee = (0, e.mapSpecialUnicodeValues)(ee);
              }
              this.isType3Font && (le = ee);
              let pe = null;
              if ((be = this.seacMap) != null && be[ae]) {
                me = !0;
                const he = this.seacMap[ae];
                ee = he.baseFontCharCode, pe = {
                  fontChar: String.fromCodePoint(he.accentFontCharCode),
                  offset: he.accentOffset
                };
              }
              let xe = "";
              return typeof ee == "number" && (ee <= 1114111 ? xe = String.fromCodePoint(ee) : (0, n.warn)(`charToGlyph - invalid fontCharCode: ${ee}`)), L = new s(ae, xe, ge, pe, se, de, le, Q, me), this._glyphCache[ae] = L;
            }
            charsToGlyphs(ae) {
              let Q = this._charsCache[ae];
              if (Q)
                return Q;
              if (Q = [], this.cMap) {
                const L = /* @__PURE__ */ Object.create(null), ee = ae.length;
                let se = 0;
                for (; se < ee; ) {
                  this.cMap.readCharCode(ae, se, L);
                  const {
                    charcode: le,
                    length: ue
                  } = L;
                  se += ue;
                  const de = this._charToGlyph(le, ue === 1 && ae.charCodeAt(se - 1) === 32);
                  Q.push(de);
                }
              } else
                for (let L = 0, ee = ae.length; L < ee; ++L) {
                  const se = ae.charCodeAt(L), le = this._charToGlyph(se, se === 32);
                  Q.push(le);
                }
              return this._charsCache[ae] = Q;
            }
            getCharPositions(ae) {
              const Q = [];
              if (this.cMap) {
                const L = /* @__PURE__ */ Object.create(null);
                let ee = 0;
                for (; ee < ae.length; ) {
                  this.cMap.readCharCode(ae, ee, L);
                  const se = L.length;
                  Q.push([ee, ee + se]), ee += se;
                }
              } else
                for (let L = 0, ee = ae.length; L < ee; ++L)
                  Q.push([L, L + 1]);
              return Q;
            }
            get glyphCacheValues() {
              return Object.values(this._glyphCache);
            }
            encodeString(ae) {
              const Q = [], L = [], ee = () => Q.length % 2 === 1, se = this.toUnicode instanceof te.IdentityToUnicodeMap ? (le) => this.toUnicode.charCodeOf(le) : (le) => this.toUnicode.charCodeOf(String.fromCodePoint(le));
              for (let le = 0, ue = ae.length; le < ue; le++) {
                const de = ae.codePointAt(le);
                if (de > 55295 && (de < 57344 || de > 65533) && le++, this.toUnicode) {
                  const ge = se(de);
                  if (ge !== -1) {
                    ee() && (Q.push(L.join("")), L.length = 0);
                    const me = this.cMap ? this.cMap.getCharCodeLength(ge) : 1;
                    for (let pe = me - 1; pe >= 0; pe--)
                      L.push(String.fromCharCode(ge >> 8 * pe & 255));
                    continue;
                  }
                }
                ee() || (Q.push(L.join("")), L.length = 0), L.push(String.fromCodePoint(de));
              }
              return Q.push(L.join("")), Q;
            }
          }
          b.Font = ie;
          class ne {
            constructor(ae) {
              this.error = ae, this.loadedName = "g_font_error", this.missingFile = !0;
            }
            charsToGlyphs() {
              return [];
            }
            encodeString(ae) {
              return [ae];
            }
            exportData(ae = !1) {
              return {
                error: this.error
              };
            }
          }
          b.ErrorFont = ne;
        },
        /* 35 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.CFFTopDict = b.CFFStrings = b.CFFStandardStrings = b.CFFPrivateDict = b.CFFParser = b.CFFIndex = b.CFFHeader = b.CFFFDSelect = b.CFFCompiler = b.CFFCharset = b.CFF = void 0;
          var n = ce(2), P = ce(36), D = ce(37);
          const e = 10, t = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
          b.CFFStandardStrings = t;
          const l = 391, V = [null, {
            id: "hstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, null, {
            id: "vstem",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "vmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "rlineto",
            min: 2,
            resetStack: !0
          }, {
            id: "hlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "vlineto",
            min: 1,
            resetStack: !0
          }, {
            id: "rrcurveto",
            min: 6,
            resetStack: !0
          }, null, {
            id: "callsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "return",
            min: 0,
            undefStack: !0
          }, null, null, {
            id: "endchar",
            min: 0,
            stackClearing: !0
          }, null, null, null, {
            id: "hstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "hintmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "cntrmask",
            min: 0,
            stackClearing: !0
          }, {
            id: "rmoveto",
            min: 2,
            stackClearing: !0
          }, {
            id: "hmoveto",
            min: 1,
            stackClearing: !0
          }, {
            id: "vstemhm",
            min: 2,
            stackClearing: !0,
            stem: !0
          }, {
            id: "rcurveline",
            min: 8,
            resetStack: !0
          }, {
            id: "rlinecurve",
            min: 8,
            resetStack: !0
          }, {
            id: "vvcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hhcurveto",
            min: 4,
            resetStack: !0
          }, null, {
            id: "callgsubr",
            min: 1,
            undefStack: !0
          }, {
            id: "vhcurveto",
            min: 4,
            resetStack: !0
          }, {
            id: "hvcurveto",
            min: 4,
            resetStack: !0
          }], te = [null, null, null, {
            id: "and",
            min: 2,
            stackDelta: -1
          }, {
            id: "or",
            min: 2,
            stackDelta: -1
          }, {
            id: "not",
            min: 1,
            stackDelta: 0
          }, null, null, null, {
            id: "abs",
            min: 1,
            stackDelta: 0
          }, {
            id: "add",
            min: 2,
            stackDelta: -1,
            stackFn(I, s) {
              I[s - 2] = I[s - 2] + I[s - 1];
            }
          }, {
            id: "sub",
            min: 2,
            stackDelta: -1,
            stackFn(I, s) {
              I[s - 2] = I[s - 2] - I[s - 1];
            }
          }, {
            id: "div",
            min: 2,
            stackDelta: -1,
            stackFn(I, s) {
              I[s - 2] = I[s - 2] / I[s - 1];
            }
          }, null, {
            id: "neg",
            min: 1,
            stackDelta: 0,
            stackFn(I, s) {
              I[s - 1] = -I[s - 1];
            }
          }, {
            id: "eq",
            min: 2,
            stackDelta: -1
          }, null, null, {
            id: "drop",
            min: 1,
            stackDelta: -1
          }, null, {
            id: "put",
            min: 2,
            stackDelta: -2
          }, {
            id: "get",
            min: 1,
            stackDelta: 0
          }, {
            id: "ifelse",
            min: 4,
            stackDelta: -3
          }, {
            id: "random",
            min: 0,
            stackDelta: 1
          }, {
            id: "mul",
            min: 2,
            stackDelta: -1,
            stackFn(I, s) {
              I[s - 2] = I[s - 2] * I[s - 1];
            }
          }, null, {
            id: "sqrt",
            min: 1,
            stackDelta: 0
          }, {
            id: "dup",
            min: 1,
            stackDelta: 1
          }, {
            id: "exch",
            min: 2,
            stackDelta: 0
          }, {
            id: "index",
            min: 2,
            stackDelta: 0
          }, {
            id: "roll",
            min: 3,
            stackDelta: -2
          }, null, null, null, {
            id: "hflex",
            min: 7,
            resetStack: !0
          }, {
            id: "flex",
            min: 13,
            resetStack: !0
          }, {
            id: "hflex1",
            min: 9,
            resetStack: !0
          }, {
            id: "flex1",
            min: 11,
            resetStack: !0
          }];
          class E {
            constructor(s, r, u) {
              this.bytes = s.getBytes(), this.properties = r, this.seacAnalysisEnabled = !!u;
            }
            parse() {
              const s = this.properties, r = new F();
              this.cff = r;
              const u = this.parseHeader(), C = this.parseIndex(u.endPos), d = this.parseIndex(C.endPos), y = this.parseIndex(d.endPos), _ = this.parseIndex(y.endPos), $ = this.parseDict(d.obj.get(0)), S = this.createDict(O, $, r.strings);
              r.header = u.obj, r.names = this.parseNameIndex(C.obj), r.strings = this.parseStringIndex(y.obj), r.topDict = S, r.globalSubrIndex = _.obj, this.parsePrivateDict(r.topDict), r.isCIDFont = S.hasName("ROS");
              const v = S.getByName("CharStrings"), m = this.parseIndex(v).obj, h = S.getByName("FontMatrix");
              h && (s.fontMatrix = h);
              const A = S.getByName("FontBBox");
              A && (s.ascent = Math.max(A[3], A[1]), s.descent = Math.min(A[1], A[3]), s.ascentScaled = !0);
              let j, G;
              if (r.isCIDFont) {
                const oe = this.parseIndex(S.getByName("FDArray")).obj;
                for (let q = 0, re = oe.count; q < re; ++q) {
                  const K = oe.get(q), Z = this.createDict(O, this.parseDict(K), r.strings);
                  this.parsePrivateDict(Z), r.fdArray.push(Z);
                }
                G = null, j = this.parseCharsets(S.getByName("charset"), m.count, r.strings, !0), r.fdSelect = this.parseFDSelect(S.getByName("FDSelect"), m.count);
              } else
                j = this.parseCharsets(S.getByName("charset"), m.count, r.strings, !1), G = this.parseEncoding(S.getByName("Encoding"), s, r.strings, j.charset);
              r.charset = j, r.encoding = G;
              const J = this.parseCharStrings({
                charStrings: m,
                localSubrIndex: S.privateDict.subrsIndex,
                globalSubrIndex: _.obj,
                fdSelect: r.fdSelect,
                fdArray: r.fdArray,
                privateDict: S.privateDict
              });
              return r.charStrings = J.charStrings, r.seacs = J.seacs, r.widths = J.widths, r;
            }
            parseHeader() {
              let s = this.bytes;
              const r = s.length;
              let u = 0;
              for (; u < r && s[u] !== 1; )
                ++u;
              if (u >= r)
                throw new n.FormatError("Invalid CFF header");
              u !== 0 && ((0, n.info)("cff data is shifted"), s = s.subarray(u), this.bytes = s);
              const C = s[0], d = s[1], y = s[2], _ = s[3];
              return {
                obj: new f(C, d, y, _),
                endPos: y
              };
            }
            parseDict(s) {
              let r = 0;
              function u() {
                let $ = s[r++];
                return $ === 30 ? C() : $ === 28 ? ($ = s[r++], $ = ($ << 24 | s[r++] << 16) >> 16, $) : $ === 29 ? ($ = s[r++], $ = $ << 8 | s[r++], $ = $ << 8 | s[r++], $ = $ << 8 | s[r++], $) : $ >= 32 && $ <= 246 ? $ - 139 : $ >= 247 && $ <= 250 ? ($ - 247) * 256 + s[r++] + 108 : $ >= 251 && $ <= 254 ? -(($ - 251) * 256) - s[r++] - 108 : ((0, n.warn)('CFFParser_parseDict: "' + $ + '" is a reserved command.'), NaN);
              }
              function C() {
                let $ = "";
                const v = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], m = s.length;
                for (; r < m; ) {
                  const h = s[r++], A = h >> 4, j = h & 15;
                  if (A === 15 || ($ += v[A], j === 15))
                    break;
                  $ += v[j];
                }
                return parseFloat($);
              }
              let d = [];
              const y = [];
              r = 0;
              const _ = s.length;
              for (; r < _; ) {
                let $ = s[r];
                $ <= 21 ? ($ === 12 && ($ = $ << 8 | s[++r]), y.push([$, d]), d = [], ++r) : d.push(u());
              }
              return y;
            }
            parseIndex(s) {
              const r = new a(), u = this.bytes, C = u[s++] << 8 | u[s++], d = [];
              let y = s, _, $;
              if (C !== 0) {
                const S = u[s++], v = s + (C + 1) * S - 1;
                for (_ = 0, $ = C + 1; _ < $; ++_) {
                  let m = 0;
                  for (let h = 0; h < S; ++h)
                    m <<= 8, m += u[s++];
                  d.push(v + m);
                }
                y = d[C];
              }
              for (_ = 0, $ = d.length - 1; _ < $; ++_) {
                const S = d[_], v = d[_ + 1];
                r.add(u.subarray(S, v));
              }
              return {
                obj: r,
                endPos: y
              };
            }
            parseNameIndex(s) {
              const r = [];
              for (let u = 0, C = s.count; u < C; ++u) {
                const d = s.get(u);
                r.push((0, n.bytesToString)(d));
              }
              return r;
            }
            parseStringIndex(s) {
              const r = new x();
              for (let u = 0, C = s.count; u < C; ++u) {
                const d = s.get(u);
                r.add((0, n.bytesToString)(d));
              }
              return r;
            }
            createDict(s, r, u) {
              const C = new s(u);
              for (const [d, y] of r)
                C.setByKey(d, y);
              return C;
            }
            parseCharString(s, r, u, C) {
              if (!r || s.callDepth > e)
                return !1;
              let d = s.stackSize;
              const y = s.stack;
              let _ = r.length;
              for (let $ = 0; $ < _; ) {
                const S = r[$++];
                let v = null;
                if (S === 12) {
                  const m = r[$++];
                  m === 0 ? (r[$ - 2] = 139, r[$ - 1] = 22, d = 0) : v = te[m];
                } else if (S === 28)
                  y[d] = (r[$] << 24 | r[$ + 1] << 16) >> 16, $ += 2, d++;
                else if (S === 14) {
                  if (d >= 4 && (d -= 4, this.seacAnalysisEnabled))
                    return s.seac = y.slice(d, d + 4), !1;
                  v = V[S];
                } else if (S >= 32 && S <= 246)
                  y[d] = S - 139, d++;
                else if (S >= 247 && S <= 254)
                  y[d] = S < 251 ? (S - 247 << 8) + r[$] + 108 : -(S - 251 << 8) - r[$] - 108, $++, d++;
                else if (S === 255)
                  y[d] = (r[$] << 24 | r[$ + 1] << 16 | r[$ + 2] << 8 | r[$ + 3]) / 65536, $ += 4, d++;
                else if (S === 19 || S === 20) {
                  if (s.hints += d >> 1, s.hints === 0) {
                    r.copyWithin($ - 1, $, -1), $ -= 1, _ -= 1;
                    continue;
                  }
                  $ += s.hints + 7 >> 3, d %= 2, v = V[S];
                } else if (S === 10 || S === 29) {
                  const m = S === 10 ? u : C;
                  if (!m)
                    return v = V[S], (0, n.warn)("Missing subrsIndex for " + v.id), !1;
                  let h = 32768;
                  m.count < 1240 ? h = 107 : m.count < 33900 && (h = 1131);
                  const A = y[--d] + h;
                  if (A < 0 || A >= m.count || isNaN(A))
                    return v = V[S], (0, n.warn)("Out of bounds subrIndex for " + v.id), !1;
                  if (s.stackSize = d, s.callDepth++, !this.parseCharString(s, m.get(A), u, C))
                    return !1;
                  s.callDepth--, d = s.stackSize;
                  continue;
                } else {
                  if (S === 11)
                    return s.stackSize = d, !0;
                  if (S === 0 && $ === r.length)
                    r[$ - 1] = 14, v = V[14];
                  else if (S === 9) {
                    r.copyWithin($ - 1, $, -1), $ -= 1, _ -= 1;
                    continue;
                  } else
                    v = V[S];
                }
                if (v) {
                  if (v.stem && (s.hints += d >> 1, S === 3 || S === 23 ? s.hasVStems = !0 : s.hasVStems && (S === 1 || S === 18) && ((0, n.warn)("CFF stem hints are in wrong order"), r[$ - 1] = S === 1 ? 3 : 23)), "min" in v && !s.undefStack && d < v.min)
                    return (0, n.warn)("Not enough parameters for " + v.id + "; actual: " + d + ", expected: " + v.min), d === 0 ? (r[$ - 1] = 14, !0) : !1;
                  s.firstStackClearing && v.stackClearing && (s.firstStackClearing = !1, d -= v.min, d >= 2 && v.stem ? d %= 2 : d > 1 && (0, n.warn)("Found too many parameters for stack-clearing command"), d > 0 && (s.width = y[d - 1])), "stackDelta" in v ? ("stackFn" in v && v.stackFn(y, d), d += v.stackDelta) : v.stackClearing ? d = 0 : v.resetStack ? (d = 0, s.undefStack = !1) : v.undefStack && (d = 0, s.undefStack = !0, s.firstStackClearing = !1);
                }
              }
              return _ < r.length && r.fill(14, _), s.stackSize = d, !0;
            }
            parseCharStrings({
              charStrings: s,
              localSubrIndex: r,
              globalSubrIndex: u,
              fdSelect: C,
              fdArray: d,
              privateDict: y
            }) {
              const _ = [], $ = [], S = s.count;
              for (let v = 0; v < S; v++) {
                const m = s.get(v), h = {
                  callDepth: 0,
                  stackSize: 0,
                  stack: [],
                  undefStack: !0,
                  hints: 0,
                  firstStackClearing: !0,
                  seac: null,
                  width: null,
                  hasVStems: !1
                };
                let A = !0, j = null, G = y;
                if (C && d.length) {
                  const J = C.getFDIndex(v);
                  J === -1 && ((0, n.warn)("Glyph index is not in fd select."), A = !1), J >= d.length && ((0, n.warn)("Invalid fd index for glyph index."), A = !1), A && (G = d[J].privateDict, j = G.subrsIndex);
                } else
                  r && (j = r);
                if (A && (A = this.parseCharString(h, m, j, u)), h.width !== null) {
                  const J = G.getByName("nominalWidthX");
                  $[v] = J + h.width;
                } else {
                  const J = G.getByName("defaultWidthX");
                  $[v] = J;
                }
                h.seac !== null && (_[v] = h.seac), A || s.set(v, new Uint8Array([14]));
              }
              return {
                charStrings: s,
                seacs: _,
                widths: $
              };
            }
            emptyPrivateDictionary(s) {
              const r = this.createDict(R, [], s.strings);
              s.setByKey(18, [0, 0]), s.privateDict = r;
            }
            parsePrivateDict(s) {
              if (!s.hasName("Private")) {
                this.emptyPrivateDictionary(s);
                return;
              }
              const r = s.getByName("Private");
              if (!Array.isArray(r) || r.length !== 2) {
                s.removeByName("Private");
                return;
              }
              const u = r[0], C = r[1];
              if (u === 0 || C >= this.bytes.length) {
                this.emptyPrivateDictionary(s);
                return;
              }
              const d = C + u, y = this.bytes.subarray(C, d), _ = this.parseDict(y), $ = this.createDict(R, _, s.strings);
              if (s.privateDict = $, $.getByName("ExpansionFactor") === 0 && $.setByName("ExpansionFactor", 0.06), !$.getByName("Subrs"))
                return;
              const S = $.getByName("Subrs"), v = C + S;
              if (S === 0 || v >= this.bytes.length) {
                this.emptyPrivateDictionary(s);
                return;
              }
              const m = this.parseIndex(v);
              $.subrsIndex = m.obj;
            }
            parseCharsets(s, r, u, C) {
              if (s === 0)
                return new W(!0, z.ISO_ADOBE, P.ISOAdobeCharset);
              if (s === 1)
                return new W(!0, z.EXPERT, P.ExpertCharset);
              if (s === 2)
                return new W(!0, z.EXPERT_SUBSET, P.ExpertSubsetCharset);
              const d = this.bytes, y = s, _ = d[s++], $ = [C ? 0 : ".notdef"];
              let S, v, m;
              switch (r -= 1, _) {
                case 0:
                  for (m = 0; m < r; m++)
                    S = d[s++] << 8 | d[s++], $.push(C ? S : u.get(S));
                  break;
                case 1:
                  for (; $.length <= r; )
                    for (S = d[s++] << 8 | d[s++], v = d[s++], m = 0; m <= v; m++)
                      $.push(C ? S++ : u.get(S++));
                  break;
                case 2:
                  for (; $.length <= r; )
                    for (S = d[s++] << 8 | d[s++], v = d[s++] << 8 | d[s++], m = 0; m <= v; m++)
                      $.push(C ? S++ : u.get(S++));
                  break;
                default:
                  throw new n.FormatError("Unknown charset format");
              }
              const h = s, A = d.subarray(y, h);
              return new W(!1, _, $, A);
            }
            parseEncoding(s, r, u, C) {
              const d = /* @__PURE__ */ Object.create(null), y = this.bytes;
              let _ = !1, $, S, v, m = null;
              function h() {
                const A = y[s++];
                for (S = 0; S < A; S++) {
                  const j = y[s++], G = (y[s++] << 8) + (y[s++] & 255);
                  d[j] = C.indexOf(u.get(G));
                }
              }
              if (s === 0 || s === 1) {
                _ = !0, $ = s;
                const A = s ? D.ExpertEncoding : D.StandardEncoding;
                for (S = 0, v = C.length; S < v; S++) {
                  const j = A.indexOf(C[S]);
                  j !== -1 && (d[j] = S);
                }
              } else {
                const A = s;
                switch ($ = y[s++], $ & 127) {
                  case 0:
                    const G = y[s++];
                    for (S = 1; S <= G; S++)
                      d[y[s++]] = S;
                    break;
                  case 1:
                    const J = y[s++];
                    let oe = 1;
                    for (S = 0; S < J; S++) {
                      const q = y[s++], re = y[s++];
                      for (let K = q; K <= q + re; K++)
                        d[K] = oe++;
                    }
                    break;
                  default:
                    throw new n.FormatError(`Unknown encoding format: ${$} in CFF`);
                }
                const j = s;
                $ & 128 && (y[A] &= 127, h()), m = y.subarray(A, j);
              }
              return $ &= 127, new g(_, $, d, m);
            }
            parseFDSelect(s, r) {
              const u = this.bytes, C = u[s++], d = [];
              let y;
              switch (C) {
                case 0:
                  for (y = 0; y < r; ++y) {
                    const $ = u[s++];
                    d.push($);
                  }
                  break;
                case 3:
                  const _ = u[s++] << 8 | u[s++];
                  for (y = 0; y < _; ++y) {
                    let $ = u[s++] << 8 | u[s++];
                    y === 0 && $ !== 0 && ((0, n.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), $ = 0);
                    const S = u[s++], v = u[s] << 8 | u[s + 1];
                    for (let m = $; m < v; ++m)
                      d.push(S);
                  }
                  s += 2;
                  break;
                default:
                  throw new n.FormatError(`parseFDSelect: Unknown format "${C}".`);
              }
              if (d.length !== r)
                throw new n.FormatError("parseFDSelect: Invalid font data.");
              return new T(C, d);
            }
          }
          b.CFFParser = E;
          class F {
            constructor() {
              this.header = null, this.names = [], this.topDict = null, this.strings = new x(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
            }
            duplicateFirstGlyph() {
              if (this.charStrings.count >= 65535) {
                (0, n.warn)("Not enough space in charstrings to duplicate first glyph.");
                return;
              }
              const s = this.charStrings.get(0);
              this.charStrings.add(s), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
            }
            hasGlyphId(s) {
              return s < 0 || s >= this.charStrings.count ? !1 : this.charStrings.get(s).length > 0;
            }
          }
          b.CFF = F;
          class f {
            constructor(s, r, u, C) {
              this.major = s, this.minor = r, this.hdrSize = u, this.offSize = C;
            }
          }
          b.CFFHeader = f;
          class x {
            constructor() {
              this.strings = [];
            }
            get(s) {
              return s >= 0 && s <= l - 1 ? t[s] : s - l <= this.strings.length ? this.strings[s - l] : t[0];
            }
            getSID(s) {
              let r = t.indexOf(s);
              return r !== -1 ? r : (r = this.strings.indexOf(s), r !== -1 ? r + l : -1);
            }
            add(s) {
              this.strings.push(s);
            }
            get count() {
              return this.strings.length;
            }
          }
          b.CFFStrings = x;
          class a {
            constructor() {
              this.objects = [], this.length = 0;
            }
            add(s) {
              this.length += s.length, this.objects.push(s);
            }
            set(s, r) {
              this.length += r.length - this.objects[s].length, this.objects[s] = r;
            }
            get(s) {
              return this.objects[s];
            }
            get count() {
              return this.objects.length;
            }
          }
          b.CFFIndex = a;
          class N {
            constructor(s, r) {
              this.keyToNameMap = s.keyToNameMap, this.nameToKeyMap = s.nameToKeyMap, this.defaults = s.defaults, this.types = s.types, this.opcodes = s.opcodes, this.order = s.order, this.strings = r, this.values = /* @__PURE__ */ Object.create(null);
            }
            setByKey(s, r) {
              if (!(s in this.keyToNameMap))
                return !1;
              if (r.length === 0)
                return !0;
              for (const C of r)
                if (isNaN(C))
                  return (0, n.warn)(`Invalid CFFDict value: "${r}" for key "${s}".`), !0;
              const u = this.types[s];
              return (u === "num" || u === "sid" || u === "offset") && (r = r[0]), this.values[s] = r, !0;
            }
            setByName(s, r) {
              if (!(s in this.nameToKeyMap))
                throw new n.FormatError(`Invalid dictionary name "${s}"`);
              this.values[this.nameToKeyMap[s]] = r;
            }
            hasName(s) {
              return this.nameToKeyMap[s] in this.values;
            }
            getByName(s) {
              if (!(s in this.nameToKeyMap))
                throw new n.FormatError(`Invalid dictionary name ${s}"`);
              const r = this.nameToKeyMap[s];
              return r in this.values ? this.values[r] : this.defaults[r];
            }
            removeByName(s) {
              delete this.values[this.nameToKeyMap[s]];
            }
            static createTables(s) {
              const r = {
                keyToNameMap: {},
                nameToKeyMap: {},
                defaults: {},
                types: {},
                opcodes: {},
                order: []
              };
              for (const u of s) {
                const C = Array.isArray(u[0]) ? (u[0][0] << 8) + u[0][1] : u[0];
                r.keyToNameMap[C] = u[1], r.nameToKeyMap[u[1]] = C, r.types[C] = u[2], r.defaults[C] = u[3], r.opcodes[C] = Array.isArray(u[0]) ? u[0] : [u[0]], r.order.push(C);
              }
              return r;
            }
          }
          const p = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
          class O extends N {
            static get tables() {
              return (0, n.shadow)(this, "tables", this.createTables(p));
            }
            constructor(s) {
              super(O.tables, s), this.privateDict = null;
            }
          }
          b.CFFTopDict = O;
          const M = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
          class R extends N {
            static get tables() {
              return (0, n.shadow)(this, "tables", this.createTables(M));
            }
            constructor(s) {
              super(R.tables, s), this.subrsIndex = null;
            }
          }
          b.CFFPrivateDict = R;
          const z = {
            ISO_ADOBE: 0,
            EXPERT: 1,
            EXPERT_SUBSET: 2
          };
          class W {
            constructor(s, r, u, C) {
              this.predefined = s, this.format = r, this.charset = u, this.raw = C;
            }
          }
          b.CFFCharset = W;
          class g {
            constructor(s, r, u, C) {
              this.predefined = s, this.format = r, this.encoding = u, this.raw = C;
            }
          }
          class T {
            constructor(s, r) {
              this.format = s, this.fdSelect = r;
            }
            getFDIndex(s) {
              return s < 0 || s >= this.fdSelect.length ? -1 : this.fdSelect[s];
            }
          }
          b.CFFFDSelect = T;
          class o {
            constructor() {
              this.offsets = /* @__PURE__ */ Object.create(null);
            }
            isTracking(s) {
              return s in this.offsets;
            }
            track(s, r) {
              if (s in this.offsets)
                throw new n.FormatError(`Already tracking location of ${s}`);
              this.offsets[s] = r;
            }
            offset(s) {
              for (const r in this.offsets)
                this.offsets[r] += s;
            }
            setEntryLocation(s, r, u) {
              if (!(s in this.offsets))
                throw new n.FormatError(`Not tracking location of ${s}`);
              const C = u.data, d = this.offsets[s], y = 5;
              for (let _ = 0, $ = r.length; _ < $; ++_) {
                const S = _ * y + d, v = S + 1, m = S + 2, h = S + 3, A = S + 4;
                if (C[S] !== 29 || C[v] !== 0 || C[m] !== 0 || C[h] !== 0 || C[A] !== 0)
                  throw new n.FormatError("writing to an offset that is not empty");
                const j = r[_];
                C[S] = 29, C[v] = j >> 24 & 255, C[m] = j >> 16 & 255, C[h] = j >> 8 & 255, C[A] = j & 255;
              }
            }
          }
          class c {
            constructor(s) {
              this.cff = s;
            }
            compile() {
              const s = this.cff, r = {
                data: [],
                length: 0,
                add(h) {
                  try {
                    this.data.push(...h);
                  } catch {
                    this.data = this.data.concat(h);
                  }
                  this.length = this.data.length;
                }
              }, u = this.compileHeader(s.header);
              r.add(u);
              const C = this.compileNameIndex(s.names);
              if (r.add(C), s.isCIDFont && s.topDict.hasName("FontMatrix")) {
                const h = s.topDict.getByName("FontMatrix");
                s.topDict.removeByName("FontMatrix");
                for (const A of s.fdArray) {
                  let j = h.slice(0);
                  A.hasName("FontMatrix") && (j = n.Util.transform(j, A.getByName("FontMatrix"))), A.setByName("FontMatrix", j);
                }
              }
              const d = s.topDict.getByName("XUID");
              (d == null ? void 0 : d.length) > 16 && s.topDict.removeByName("XUID"), s.topDict.setByName("charset", 0);
              let y = this.compileTopDicts([s.topDict], r.length, s.isCIDFont);
              r.add(y.output);
              const _ = y.trackers[0], $ = this.compileStringIndex(s.strings.strings);
              r.add($);
              const S = this.compileIndex(s.globalSubrIndex);
              if (r.add(S), s.encoding && s.topDict.hasName("Encoding"))
                if (s.encoding.predefined)
                  _.setEntryLocation("Encoding", [s.encoding.format], r);
                else {
                  const h = this.compileEncoding(s.encoding);
                  _.setEntryLocation("Encoding", [r.length], r), r.add(h);
                }
              const v = this.compileCharset(s.charset, s.charStrings.count, s.strings, s.isCIDFont);
              _.setEntryLocation("charset", [r.length], r), r.add(v);
              const m = this.compileCharStrings(s.charStrings);
              if (_.setEntryLocation("CharStrings", [r.length], r), r.add(m), s.isCIDFont) {
                _.setEntryLocation("FDSelect", [r.length], r);
                const h = this.compileFDSelect(s.fdSelect);
                r.add(h), y = this.compileTopDicts(s.fdArray, r.length, !0), _.setEntryLocation("FDArray", [r.length], r), r.add(y.output);
                const A = y.trackers;
                this.compilePrivateDicts(s.fdArray, A, r);
              }
              return this.compilePrivateDicts([s.topDict], [_], r), r.add([0]), r.data;
            }
            encodeNumber(s) {
              return Number.isInteger(s) ? this.encodeInteger(s) : this.encodeFloat(s);
            }
            static get EncodeFloatRegExp() {
              return (0, n.shadow)(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
            }
            encodeFloat(s) {
              let r = s.toString();
              const u = c.EncodeFloatRegExp.exec(r);
              if (u) {
                const $ = parseFloat("1e" + ((u[2] ? +u[2] : 0) + u[1].length));
                r = (Math.round(s * $) / $).toString();
              }
              let C = "", d, y;
              for (d = 0, y = r.length; d < y; ++d) {
                const $ = r[d];
                $ === "e" ? C += r[++d] === "-" ? "c" : "b" : $ === "." ? C += "a" : $ === "-" ? C += "e" : C += $;
              }
              C += C.length & 1 ? "f" : "ff";
              const _ = [30];
              for (d = 0, y = C.length; d < y; d += 2)
                _.push(parseInt(C.substring(d, d + 2), 16));
              return _;
            }
            encodeInteger(s) {
              let r;
              return s >= -107 && s <= 107 ? r = [s + 139] : s >= 108 && s <= 1131 ? (s -= 108, r = [(s >> 8) + 247, s & 255]) : s >= -1131 && s <= -108 ? (s = -s - 108, r = [(s >> 8) + 251, s & 255]) : s >= -32768 && s <= 32767 ? r = [28, s >> 8 & 255, s & 255] : r = [29, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255], r;
            }
            compileHeader(s) {
              return [s.major, s.minor, 4, s.offSize];
            }
            compileNameIndex(s) {
              const r = new a();
              for (const u of s) {
                const C = Math.min(u.length, 127);
                let d = new Array(C);
                for (let y = 0; y < C; y++) {
                  let _ = u[y];
                  (_ < "!" || _ > "~" || _ === "[" || _ === "]" || _ === "(" || _ === ")" || _ === "{" || _ === "}" || _ === "<" || _ === ">" || _ === "/" || _ === "%") && (_ = "_"), d[y] = _;
                }
                d = d.join(""), d === "" && (d = "Bad_Font_Name"), r.add((0, n.stringToBytes)(d));
              }
              return this.compileIndex(r);
            }
            compileTopDicts(s, r, u) {
              const C = [];
              let d = new a();
              for (const y of s) {
                u && (y.removeByName("CIDFontVersion"), y.removeByName("CIDFontRevision"), y.removeByName("CIDFontType"), y.removeByName("CIDCount"), y.removeByName("UIDBase"));
                const _ = new o(), $ = this.compileDict(y, _);
                C.push(_), d.add($), _.offset(r);
              }
              return d = this.compileIndex(d, C), {
                trackers: C,
                output: d
              };
            }
            compilePrivateDicts(s, r, u) {
              for (let C = 0, d = s.length; C < d; ++C) {
                const y = s[C], _ = y.privateDict;
                if (!_ || !y.hasName("Private"))
                  throw new n.FormatError("There must be a private dictionary.");
                const $ = new o(), S = this.compileDict(_, $);
                let v = u.length;
                if ($.offset(v), S.length || (v = 0), r[C].setEntryLocation("Private", [S.length, v], u), u.add(S), _.subrsIndex && _.hasName("Subrs")) {
                  const m = this.compileIndex(_.subrsIndex);
                  $.setEntryLocation("Subrs", [S.length], u), u.add(m);
                }
              }
            }
            compileDict(s, r) {
              const u = [];
              for (const C of s.order) {
                if (!(C in s.values))
                  continue;
                let d = s.values[C], y = s.types[C];
                if (Array.isArray(y) || (y = [y]), Array.isArray(d) || (d = [d]), d.length !== 0) {
                  for (let _ = 0, $ = y.length; _ < $; ++_) {
                    const S = y[_], v = d[_];
                    switch (S) {
                      case "num":
                      case "sid":
                        u.push(...this.encodeNumber(v));
                        break;
                      case "offset":
                        const m = s.keyToNameMap[C];
                        r.isTracking(m) || r.track(m, u.length), u.push(29, 0, 0, 0, 0);
                        break;
                      case "array":
                      case "delta":
                        u.push(...this.encodeNumber(v));
                        for (let h = 1, A = d.length; h < A; ++h)
                          u.push(...this.encodeNumber(d[h]));
                        break;
                      default:
                        throw new n.FormatError(`Unknown data type of ${S}`);
                    }
                  }
                  u.push(...s.opcodes[C]);
                }
              }
              return u;
            }
            compileStringIndex(s) {
              const r = new a();
              for (const u of s)
                r.add((0, n.stringToBytes)(u));
              return this.compileIndex(r);
            }
            compileCharStrings(s) {
              const r = new a();
              for (let u = 0; u < s.count; u++) {
                const C = s.get(u);
                if (C.length === 0) {
                  r.add(new Uint8Array([139, 14]));
                  continue;
                }
                r.add(C);
              }
              return this.compileIndex(r);
            }
            compileCharset(s, r, u, C) {
              let d;
              const y = r - 1;
              if (C)
                d = new Uint8Array([2, 0, 0, y >> 8 & 255, y & 255]);
              else {
                const _ = 1 + y * 2;
                d = new Uint8Array(_), d[0] = 0;
                let $ = 0;
                const S = s.charset.length;
                let v = !1;
                for (let m = 1; m < d.length; m += 2) {
                  let h = 0;
                  if ($ < S) {
                    const A = s.charset[$++];
                    h = u.getSID(A), h === -1 && (h = 0, v || (v = !0, (0, n.warn)(`Couldn't find ${A} in CFF strings`)));
                  }
                  d[m] = h >> 8 & 255, d[m + 1] = h & 255;
                }
              }
              return this.compileTypedArray(d);
            }
            compileEncoding(s) {
              return this.compileTypedArray(s.raw);
            }
            compileFDSelect(s) {
              const r = s.format;
              let u, C;
              switch (r) {
                case 0:
                  for (u = new Uint8Array(1 + s.fdSelect.length), u[0] = r, C = 0; C < s.fdSelect.length; C++)
                    u[C + 1] = s.fdSelect[C];
                  break;
                case 3:
                  const d = 0;
                  let y = s.fdSelect[0];
                  const _ = [r, 0, 0, d >> 8 & 255, d & 255, y];
                  for (C = 1; C < s.fdSelect.length; C++) {
                    const S = s.fdSelect[C];
                    S !== y && (_.push(C >> 8 & 255, C & 255, S), y = S);
                  }
                  const $ = (_.length - 3) / 3;
                  _[1] = $ >> 8 & 255, _[2] = $ & 255, _.push(C >> 8 & 255, C & 255), u = new Uint8Array(_);
                  break;
              }
              return this.compileTypedArray(u);
            }
            compileTypedArray(s) {
              return Array.from(s);
            }
            compileIndex(s, r = []) {
              const u = s.objects, C = u.length;
              if (C === 0)
                return [0, 0];
              const d = [C >> 8 & 255, C & 255];
              let y = 1, _;
              for (_ = 0; _ < C; ++_)
                y += u[_].length;
              let $;
              y < 256 ? $ = 1 : y < 65536 ? $ = 2 : y < 16777216 ? $ = 3 : $ = 4, d.push($);
              let S = 1;
              for (_ = 0; _ < C + 1; _++)
                $ === 1 ? d.push(S & 255) : $ === 2 ? d.push(S >> 8 & 255, S & 255) : $ === 3 ? d.push(S >> 16 & 255, S >> 8 & 255, S & 255) : d.push(S >>> 24 & 255, S >> 16 & 255, S >> 8 & 255, S & 255), u[_] && (S += u[_].length);
              for (_ = 0; _ < C; _++)
                r[_] && r[_].offset(d.length), d.push(...u[_]);
              return d;
            }
          }
          b.CFFCompiler = c;
        },
        /* 36 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ISOAdobeCharset = b.ExpertSubsetCharset = b.ExpertCharset = void 0;
          const ce = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
          b.ISOAdobeCharset = ce;
          const n = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          b.ExpertCharset = n;
          const P = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
          b.ExpertSubsetCharset = P;
        },
        /* 37 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ZapfDingbatsEncoding = b.WinAnsiEncoding = b.SymbolSetEncoding = b.StandardEncoding = b.MacRomanEncoding = b.ExpertEncoding = void 0, b.getEncoding = V;
          const ce = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
          b.ExpertEncoding = ce;
          const n = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], P = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
          b.MacRomanEncoding = P;
          const D = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
          b.StandardEncoding = D;
          const e = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
          b.WinAnsiEncoding = e;
          const t = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
          b.SymbolSetEncoding = t;
          const l = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
          b.ZapfDingbatsEncoding = l;
          function V(te) {
            switch (te) {
              case "WinAnsiEncoding":
                return e;
              case "StandardEncoding":
                return D;
              case "MacRomanEncoding":
                return P;
              case "SymbolSetEncoding":
                return t;
              case "ZapfDingbatsEncoding":
                return l;
              case "ExpertEncoding":
                return ce;
              case "MacExpertEncoding":
                return n;
              default:
                return null;
            }
          }
        },
        /* 38 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.SEAC_ANALYSIS_ENABLED = b.MacStandardGlyphOrdering = b.FontFlags = void 0, b.normalizeFontName = F, b.recoverGlyphName = te, b.type1FontGlyphMapping = E;
          var n = ce(37), P = ce(39), D = ce(40), e = ce(2);
          const t = !0;
          b.SEAC_ANALYSIS_ENABLED = t;
          const l = {
            FixedPitch: 1,
            Serif: 2,
            Symbolic: 4,
            Script: 8,
            Nonsymbolic: 32,
            Italic: 64,
            AllCap: 65536,
            SmallCap: 131072,
            ForceBold: 262144
          };
          b.FontFlags = l;
          const V = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
          b.MacStandardGlyphOrdering = V;
          function te(f, x) {
            if (x[f] !== void 0)
              return f;
            const a = (0, D.getUnicodeForGlyph)(f, x);
            if (a !== -1) {
              for (const N in x)
                if (x[N] === a)
                  return N;
            }
            return (0, e.info)("Unable to recover a standard glyph name for: " + f), f;
          }
          function E(f, x, a) {
            const N = /* @__PURE__ */ Object.create(null);
            let p, O, M;
            const R = !!(f.flags & l.Symbolic);
            if (f.isInternalFont)
              for (M = x, O = 0; O < M.length; O++)
                p = a.indexOf(M[O]), N[O] = p >= 0 ? p : 0;
            else if (f.baseEncodingName)
              for (M = (0, n.getEncoding)(f.baseEncodingName), O = 0; O < M.length; O++)
                p = a.indexOf(M[O]), N[O] = p >= 0 ? p : 0;
            else if (R)
              for (O in x)
                N[O] = x[O];
            else
              for (M = n.StandardEncoding, O = 0; O < M.length; O++)
                p = a.indexOf(M[O]), N[O] = p >= 0 ? p : 0;
            const z = f.differences;
            let W;
            if (z)
              for (O in z) {
                const g = z[O];
                if (p = a.indexOf(g), p === -1) {
                  W || (W = (0, P.getGlyphsUnicode)());
                  const T = te(g, W);
                  T !== g && (p = a.indexOf(T));
                }
                N[O] = p >= 0 ? p : 0;
              }
            return N;
          }
          function F(f) {
            return f.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
          }
        },
        /* 39 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.getGlyphsUnicode = b.getDingbatsGlyphsUnicode = void 0;
          var n = ce(3);
          const P = (0, n.getLookupTableFactory)(function(e) {
            e.A = 65, e.AE = 198, e.AEacute = 508, e.AEmacron = 482, e.AEsmall = 63462, e.Aacute = 193, e.Aacutesmall = 63457, e.Abreve = 258, e.Abreveacute = 7854, e.Abrevecyrillic = 1232, e.Abrevedotbelow = 7862, e.Abrevegrave = 7856, e.Abrevehookabove = 7858, e.Abrevetilde = 7860, e.Acaron = 461, e.Acircle = 9398, e.Acircumflex = 194, e.Acircumflexacute = 7844, e.Acircumflexdotbelow = 7852, e.Acircumflexgrave = 7846, e.Acircumflexhookabove = 7848, e.Acircumflexsmall = 63458, e.Acircumflextilde = 7850, e.Acute = 63177, e.Acutesmall = 63412, e.Acyrillic = 1040, e.Adblgrave = 512, e.Adieresis = 196, e.Adieresiscyrillic = 1234, e.Adieresismacron = 478, e.Adieresissmall = 63460, e.Adotbelow = 7840, e.Adotmacron = 480, e.Agrave = 192, e.Agravesmall = 63456, e.Ahookabove = 7842, e.Aiecyrillic = 1236, e.Ainvertedbreve = 514, e.Alpha = 913, e.Alphatonos = 902, e.Amacron = 256, e.Amonospace = 65313, e.Aogonek = 260, e.Aring = 197, e.Aringacute = 506, e.Aringbelow = 7680, e.Aringsmall = 63461, e.Asmall = 63329, e.Atilde = 195, e.Atildesmall = 63459, e.Aybarmenian = 1329, e.B = 66, e.Bcircle = 9399, e.Bdotaccent = 7682, e.Bdotbelow = 7684, e.Becyrillic = 1041, e.Benarmenian = 1330, e.Beta = 914, e.Bhook = 385, e.Blinebelow = 7686, e.Bmonospace = 65314, e.Brevesmall = 63220, e.Bsmall = 63330, e.Btopbar = 386, e.C = 67, e.Caarmenian = 1342, e.Cacute = 262, e.Caron = 63178, e.Caronsmall = 63221, e.Ccaron = 268, e.Ccedilla = 199, e.Ccedillaacute = 7688, e.Ccedillasmall = 63463, e.Ccircle = 9400, e.Ccircumflex = 264, e.Cdot = 266, e.Cdotaccent = 266, e.Cedillasmall = 63416, e.Chaarmenian = 1353, e.Cheabkhasiancyrillic = 1212, e.Checyrillic = 1063, e.Chedescenderabkhasiancyrillic = 1214, e.Chedescendercyrillic = 1206, e.Chedieresiscyrillic = 1268, e.Cheharmenian = 1347, e.Chekhakassiancyrillic = 1227, e.Cheverticalstrokecyrillic = 1208, e.Chi = 935, e.Chook = 391, e.Circumflexsmall = 63222, e.Cmonospace = 65315, e.Coarmenian = 1361, e.Csmall = 63331, e.D = 68, e.DZ = 497, e.DZcaron = 452, e.Daarmenian = 1332, e.Dafrican = 393, e.Dcaron = 270, e.Dcedilla = 7696, e.Dcircle = 9401, e.Dcircumflexbelow = 7698, e.Dcroat = 272, e.Ddotaccent = 7690, e.Ddotbelow = 7692, e.Decyrillic = 1044, e.Deicoptic = 1006, e.Delta = 8710, e.Deltagreek = 916, e.Dhook = 394, e.Dieresis = 63179, e.DieresisAcute = 63180, e.DieresisGrave = 63181, e.Dieresissmall = 63400, e.Digammagreek = 988, e.Djecyrillic = 1026, e.Dlinebelow = 7694, e.Dmonospace = 65316, e.Dotaccentsmall = 63223, e.Dslash = 272, e.Dsmall = 63332, e.Dtopbar = 395, e.Dz = 498, e.Dzcaron = 453, e.Dzeabkhasiancyrillic = 1248, e.Dzecyrillic = 1029, e.Dzhecyrillic = 1039, e.E = 69, e.Eacute = 201, e.Eacutesmall = 63465, e.Ebreve = 276, e.Ecaron = 282, e.Ecedillabreve = 7708, e.Echarmenian = 1333, e.Ecircle = 9402, e.Ecircumflex = 202, e.Ecircumflexacute = 7870, e.Ecircumflexbelow = 7704, e.Ecircumflexdotbelow = 7878, e.Ecircumflexgrave = 7872, e.Ecircumflexhookabove = 7874, e.Ecircumflexsmall = 63466, e.Ecircumflextilde = 7876, e.Ecyrillic = 1028, e.Edblgrave = 516, e.Edieresis = 203, e.Edieresissmall = 63467, e.Edot = 278, e.Edotaccent = 278, e.Edotbelow = 7864, e.Efcyrillic = 1060, e.Egrave = 200, e.Egravesmall = 63464, e.Eharmenian = 1335, e.Ehookabove = 7866, e.Eightroman = 8551, e.Einvertedbreve = 518, e.Eiotifiedcyrillic = 1124, e.Elcyrillic = 1051, e.Elevenroman = 8554, e.Emacron = 274, e.Emacronacute = 7702, e.Emacrongrave = 7700, e.Emcyrillic = 1052, e.Emonospace = 65317, e.Encyrillic = 1053, e.Endescendercyrillic = 1186, e.Eng = 330, e.Enghecyrillic = 1188, e.Enhookcyrillic = 1223, e.Eogonek = 280, e.Eopen = 400, e.Epsilon = 917, e.Epsilontonos = 904, e.Ercyrillic = 1056, e.Ereversed = 398, e.Ereversedcyrillic = 1069, e.Escyrillic = 1057, e.Esdescendercyrillic = 1194, e.Esh = 425, e.Esmall = 63333, e.Eta = 919, e.Etarmenian = 1336, e.Etatonos = 905, e.Eth = 208, e.Ethsmall = 63472, e.Etilde = 7868, e.Etildebelow = 7706, e.Euro = 8364, e.Ezh = 439, e.Ezhcaron = 494, e.Ezhreversed = 440, e.F = 70, e.Fcircle = 9403, e.Fdotaccent = 7710, e.Feharmenian = 1366, e.Feicoptic = 996, e.Fhook = 401, e.Fitacyrillic = 1138, e.Fiveroman = 8548, e.Fmonospace = 65318, e.Fourroman = 8547, e.Fsmall = 63334, e.G = 71, e.GBsquare = 13191, e.Gacute = 500, e.Gamma = 915, e.Gammaafrican = 404, e.Gangiacoptic = 1002, e.Gbreve = 286, e.Gcaron = 486, e.Gcedilla = 290, e.Gcircle = 9404, e.Gcircumflex = 284, e.Gcommaaccent = 290, e.Gdot = 288, e.Gdotaccent = 288, e.Gecyrillic = 1043, e.Ghadarmenian = 1346, e.Ghemiddlehookcyrillic = 1172, e.Ghestrokecyrillic = 1170, e.Gheupturncyrillic = 1168, e.Ghook = 403, e.Gimarmenian = 1331, e.Gjecyrillic = 1027, e.Gmacron = 7712, e.Gmonospace = 65319, e.Grave = 63182, e.Gravesmall = 63328, e.Gsmall = 63335, e.Gsmallhook = 667, e.Gstroke = 484, e.H = 72, e.H18533 = 9679, e.H18543 = 9642, e.H18551 = 9643, e.H22073 = 9633, e.HPsquare = 13259, e.Haabkhasiancyrillic = 1192, e.Hadescendercyrillic = 1202, e.Hardsigncyrillic = 1066, e.Hbar = 294, e.Hbrevebelow = 7722, e.Hcedilla = 7720, e.Hcircle = 9405, e.Hcircumflex = 292, e.Hdieresis = 7718, e.Hdotaccent = 7714, e.Hdotbelow = 7716, e.Hmonospace = 65320, e.Hoarmenian = 1344, e.Horicoptic = 1e3, e.Hsmall = 63336, e.Hungarumlaut = 63183, e.Hungarumlautsmall = 63224, e.Hzsquare = 13200, e.I = 73, e.IAcyrillic = 1071, e.IJ = 306, e.IUcyrillic = 1070, e.Iacute = 205, e.Iacutesmall = 63469, e.Ibreve = 300, e.Icaron = 463, e.Icircle = 9406, e.Icircumflex = 206, e.Icircumflexsmall = 63470, e.Icyrillic = 1030, e.Idblgrave = 520, e.Idieresis = 207, e.Idieresisacute = 7726, e.Idieresiscyrillic = 1252, e.Idieresissmall = 63471, e.Idot = 304, e.Idotaccent = 304, e.Idotbelow = 7882, e.Iebrevecyrillic = 1238, e.Iecyrillic = 1045, e.Ifraktur = 8465, e.Igrave = 204, e.Igravesmall = 63468, e.Ihookabove = 7880, e.Iicyrillic = 1048, e.Iinvertedbreve = 522, e.Iishortcyrillic = 1049, e.Imacron = 298, e.Imacroncyrillic = 1250, e.Imonospace = 65321, e.Iniarmenian = 1339, e.Iocyrillic = 1025, e.Iogonek = 302, e.Iota = 921, e.Iotaafrican = 406, e.Iotadieresis = 938, e.Iotatonos = 906, e.Ismall = 63337, e.Istroke = 407, e.Itilde = 296, e.Itildebelow = 7724, e.Izhitsacyrillic = 1140, e.Izhitsadblgravecyrillic = 1142, e.J = 74, e.Jaarmenian = 1345, e.Jcircle = 9407, e.Jcircumflex = 308, e.Jecyrillic = 1032, e.Jheharmenian = 1355, e.Jmonospace = 65322, e.Jsmall = 63338, e.K = 75, e.KBsquare = 13189, e.KKsquare = 13261, e.Kabashkircyrillic = 1184, e.Kacute = 7728, e.Kacyrillic = 1050, e.Kadescendercyrillic = 1178, e.Kahookcyrillic = 1219, e.Kappa = 922, e.Kastrokecyrillic = 1182, e.Kaverticalstrokecyrillic = 1180, e.Kcaron = 488, e.Kcedilla = 310, e.Kcircle = 9408, e.Kcommaaccent = 310, e.Kdotbelow = 7730, e.Keharmenian = 1364, e.Kenarmenian = 1343, e.Khacyrillic = 1061, e.Kheicoptic = 998, e.Khook = 408, e.Kjecyrillic = 1036, e.Klinebelow = 7732, e.Kmonospace = 65323, e.Koppacyrillic = 1152, e.Koppagreek = 990, e.Ksicyrillic = 1134, e.Ksmall = 63339, e.L = 76, e.LJ = 455, e.LL = 63167, e.Lacute = 313, e.Lambda = 923, e.Lcaron = 317, e.Lcedilla = 315, e.Lcircle = 9409, e.Lcircumflexbelow = 7740, e.Lcommaaccent = 315, e.Ldot = 319, e.Ldotaccent = 319, e.Ldotbelow = 7734, e.Ldotbelowmacron = 7736, e.Liwnarmenian = 1340, e.Lj = 456, e.Ljecyrillic = 1033, e.Llinebelow = 7738, e.Lmonospace = 65324, e.Lslash = 321, e.Lslashsmall = 63225, e.Lsmall = 63340, e.M = 77, e.MBsquare = 13190, e.Macron = 63184, e.Macronsmall = 63407, e.Macute = 7742, e.Mcircle = 9410, e.Mdotaccent = 7744, e.Mdotbelow = 7746, e.Menarmenian = 1348, e.Mmonospace = 65325, e.Msmall = 63341, e.Mturned = 412, e.Mu = 924, e.N = 78, e.NJ = 458, e.Nacute = 323, e.Ncaron = 327, e.Ncedilla = 325, e.Ncircle = 9411, e.Ncircumflexbelow = 7754, e.Ncommaaccent = 325, e.Ndotaccent = 7748, e.Ndotbelow = 7750, e.Nhookleft = 413, e.Nineroman = 8552, e.Nj = 459, e.Njecyrillic = 1034, e.Nlinebelow = 7752, e.Nmonospace = 65326, e.Nowarmenian = 1350, e.Nsmall = 63342, e.Ntilde = 209, e.Ntildesmall = 63473, e.Nu = 925, e.O = 79, e.OE = 338, e.OEsmall = 63226, e.Oacute = 211, e.Oacutesmall = 63475, e.Obarredcyrillic = 1256, e.Obarreddieresiscyrillic = 1258, e.Obreve = 334, e.Ocaron = 465, e.Ocenteredtilde = 415, e.Ocircle = 9412, e.Ocircumflex = 212, e.Ocircumflexacute = 7888, e.Ocircumflexdotbelow = 7896, e.Ocircumflexgrave = 7890, e.Ocircumflexhookabove = 7892, e.Ocircumflexsmall = 63476, e.Ocircumflextilde = 7894, e.Ocyrillic = 1054, e.Odblacute = 336, e.Odblgrave = 524, e.Odieresis = 214, e.Odieresiscyrillic = 1254, e.Odieresissmall = 63478, e.Odotbelow = 7884, e.Ogoneksmall = 63227, e.Ograve = 210, e.Ogravesmall = 63474, e.Oharmenian = 1365, e.Ohm = 8486, e.Ohookabove = 7886, e.Ohorn = 416, e.Ohornacute = 7898, e.Ohorndotbelow = 7906, e.Ohorngrave = 7900, e.Ohornhookabove = 7902, e.Ohorntilde = 7904, e.Ohungarumlaut = 336, e.Oi = 418, e.Oinvertedbreve = 526, e.Omacron = 332, e.Omacronacute = 7762, e.Omacrongrave = 7760, e.Omega = 8486, e.Omegacyrillic = 1120, e.Omegagreek = 937, e.Omegaroundcyrillic = 1146, e.Omegatitlocyrillic = 1148, e.Omegatonos = 911, e.Omicron = 927, e.Omicrontonos = 908, e.Omonospace = 65327, e.Oneroman = 8544, e.Oogonek = 490, e.Oogonekmacron = 492, e.Oopen = 390, e.Oslash = 216, e.Oslashacute = 510, e.Oslashsmall = 63480, e.Osmall = 63343, e.Ostrokeacute = 510, e.Otcyrillic = 1150, e.Otilde = 213, e.Otildeacute = 7756, e.Otildedieresis = 7758, e.Otildesmall = 63477, e.P = 80, e.Pacute = 7764, e.Pcircle = 9413, e.Pdotaccent = 7766, e.Pecyrillic = 1055, e.Peharmenian = 1354, e.Pemiddlehookcyrillic = 1190, e.Phi = 934, e.Phook = 420, e.Pi = 928, e.Piwrarmenian = 1363, e.Pmonospace = 65328, e.Psi = 936, e.Psicyrillic = 1136, e.Psmall = 63344, e.Q = 81, e.Qcircle = 9414, e.Qmonospace = 65329, e.Qsmall = 63345, e.R = 82, e.Raarmenian = 1356, e.Racute = 340, e.Rcaron = 344, e.Rcedilla = 342, e.Rcircle = 9415, e.Rcommaaccent = 342, e.Rdblgrave = 528, e.Rdotaccent = 7768, e.Rdotbelow = 7770, e.Rdotbelowmacron = 7772, e.Reharmenian = 1360, e.Rfraktur = 8476, e.Rho = 929, e.Ringsmall = 63228, e.Rinvertedbreve = 530, e.Rlinebelow = 7774, e.Rmonospace = 65330, e.Rsmall = 63346, e.Rsmallinverted = 641, e.Rsmallinvertedsuperior = 694, e.S = 83, e.SF010000 = 9484, e.SF020000 = 9492, e.SF030000 = 9488, e.SF040000 = 9496, e.SF050000 = 9532, e.SF060000 = 9516, e.SF070000 = 9524, e.SF080000 = 9500, e.SF090000 = 9508, e.SF100000 = 9472, e.SF110000 = 9474, e.SF190000 = 9569, e.SF200000 = 9570, e.SF210000 = 9558, e.SF220000 = 9557, e.SF230000 = 9571, e.SF240000 = 9553, e.SF250000 = 9559, e.SF260000 = 9565, e.SF270000 = 9564, e.SF280000 = 9563, e.SF360000 = 9566, e.SF370000 = 9567, e.SF380000 = 9562, e.SF390000 = 9556, e.SF400000 = 9577, e.SF410000 = 9574, e.SF420000 = 9568, e.SF430000 = 9552, e.SF440000 = 9580, e.SF450000 = 9575, e.SF460000 = 9576, e.SF470000 = 9572, e.SF480000 = 9573, e.SF490000 = 9561, e.SF500000 = 9560, e.SF510000 = 9554, e.SF520000 = 9555, e.SF530000 = 9579, e.SF540000 = 9578, e.Sacute = 346, e.Sacutedotaccent = 7780, e.Sampigreek = 992, e.Scaron = 352, e.Scarondotaccent = 7782, e.Scaronsmall = 63229, e.Scedilla = 350, e.Schwa = 399, e.Schwacyrillic = 1240, e.Schwadieresiscyrillic = 1242, e.Scircle = 9416, e.Scircumflex = 348, e.Scommaaccent = 536, e.Sdotaccent = 7776, e.Sdotbelow = 7778, e.Sdotbelowdotaccent = 7784, e.Seharmenian = 1357, e.Sevenroman = 8550, e.Shaarmenian = 1351, e.Shacyrillic = 1064, e.Shchacyrillic = 1065, e.Sheicoptic = 994, e.Shhacyrillic = 1210, e.Shimacoptic = 1004, e.Sigma = 931, e.Sixroman = 8549, e.Smonospace = 65331, e.Softsigncyrillic = 1068, e.Ssmall = 63347, e.Stigmagreek = 986, e.T = 84, e.Tau = 932, e.Tbar = 358, e.Tcaron = 356, e.Tcedilla = 354, e.Tcircle = 9417, e.Tcircumflexbelow = 7792, e.Tcommaaccent = 354, e.Tdotaccent = 7786, e.Tdotbelow = 7788, e.Tecyrillic = 1058, e.Tedescendercyrillic = 1196, e.Tenroman = 8553, e.Tetsecyrillic = 1204, e.Theta = 920, e.Thook = 428, e.Thorn = 222, e.Thornsmall = 63486, e.Threeroman = 8546, e.Tildesmall = 63230, e.Tiwnarmenian = 1359, e.Tlinebelow = 7790, e.Tmonospace = 65332, e.Toarmenian = 1337, e.Tonefive = 444, e.Tonesix = 388, e.Tonetwo = 423, e.Tretroflexhook = 430, e.Tsecyrillic = 1062, e.Tshecyrillic = 1035, e.Tsmall = 63348, e.Twelveroman = 8555, e.Tworoman = 8545, e.U = 85, e.Uacute = 218, e.Uacutesmall = 63482, e.Ubreve = 364, e.Ucaron = 467, e.Ucircle = 9418, e.Ucircumflex = 219, e.Ucircumflexbelow = 7798, e.Ucircumflexsmall = 63483, e.Ucyrillic = 1059, e.Udblacute = 368, e.Udblgrave = 532, e.Udieresis = 220, e.Udieresisacute = 471, e.Udieresisbelow = 7794, e.Udieresiscaron = 473, e.Udieresiscyrillic = 1264, e.Udieresisgrave = 475, e.Udieresismacron = 469, e.Udieresissmall = 63484, e.Udotbelow = 7908, e.Ugrave = 217, e.Ugravesmall = 63481, e.Uhookabove = 7910, e.Uhorn = 431, e.Uhornacute = 7912, e.Uhorndotbelow = 7920, e.Uhorngrave = 7914, e.Uhornhookabove = 7916, e.Uhorntilde = 7918, e.Uhungarumlaut = 368, e.Uhungarumlautcyrillic = 1266, e.Uinvertedbreve = 534, e.Ukcyrillic = 1144, e.Umacron = 362, e.Umacroncyrillic = 1262, e.Umacrondieresis = 7802, e.Umonospace = 65333, e.Uogonek = 370, e.Upsilon = 933, e.Upsilon1 = 978, e.Upsilonacutehooksymbolgreek = 979, e.Upsilonafrican = 433, e.Upsilondieresis = 939, e.Upsilondieresishooksymbolgreek = 980, e.Upsilonhooksymbol = 978, e.Upsilontonos = 910, e.Uring = 366, e.Ushortcyrillic = 1038, e.Usmall = 63349, e.Ustraightcyrillic = 1198, e.Ustraightstrokecyrillic = 1200, e.Utilde = 360, e.Utildeacute = 7800, e.Utildebelow = 7796, e.V = 86, e.Vcircle = 9419, e.Vdotbelow = 7806, e.Vecyrillic = 1042, e.Vewarmenian = 1358, e.Vhook = 434, e.Vmonospace = 65334, e.Voarmenian = 1352, e.Vsmall = 63350, e.Vtilde = 7804, e.W = 87, e.Wacute = 7810, e.Wcircle = 9420, e.Wcircumflex = 372, e.Wdieresis = 7812, e.Wdotaccent = 7814, e.Wdotbelow = 7816, e.Wgrave = 7808, e.Wmonospace = 65335, e.Wsmall = 63351, e.X = 88, e.Xcircle = 9421, e.Xdieresis = 7820, e.Xdotaccent = 7818, e.Xeharmenian = 1341, e.Xi = 926, e.Xmonospace = 65336, e.Xsmall = 63352, e.Y = 89, e.Yacute = 221, e.Yacutesmall = 63485, e.Yatcyrillic = 1122, e.Ycircle = 9422, e.Ycircumflex = 374, e.Ydieresis = 376, e.Ydieresissmall = 63487, e.Ydotaccent = 7822, e.Ydotbelow = 7924, e.Yericyrillic = 1067, e.Yerudieresiscyrillic = 1272, e.Ygrave = 7922, e.Yhook = 435, e.Yhookabove = 7926, e.Yiarmenian = 1349, e.Yicyrillic = 1031, e.Yiwnarmenian = 1362, e.Ymonospace = 65337, e.Ysmall = 63353, e.Ytilde = 7928, e.Yusbigcyrillic = 1130, e.Yusbigiotifiedcyrillic = 1132, e.Yuslittlecyrillic = 1126, e.Yuslittleiotifiedcyrillic = 1128, e.Z = 90, e.Zaarmenian = 1334, e.Zacute = 377, e.Zcaron = 381, e.Zcaronsmall = 63231, e.Zcircle = 9423, e.Zcircumflex = 7824, e.Zdot = 379, e.Zdotaccent = 379, e.Zdotbelow = 7826, e.Zecyrillic = 1047, e.Zedescendercyrillic = 1176, e.Zedieresiscyrillic = 1246, e.Zeta = 918, e.Zhearmenian = 1338, e.Zhebrevecyrillic = 1217, e.Zhecyrillic = 1046, e.Zhedescendercyrillic = 1174, e.Zhedieresiscyrillic = 1244, e.Zlinebelow = 7828, e.Zmonospace = 65338, e.Zsmall = 63354, e.Zstroke = 437, e.a = 97, e.aabengali = 2438, e.aacute = 225, e.aadeva = 2310, e.aagujarati = 2694, e.aagurmukhi = 2566, e.aamatragurmukhi = 2622, e.aarusquare = 13059, e.aavowelsignbengali = 2494, e.aavowelsigndeva = 2366, e.aavowelsigngujarati = 2750, e.abbreviationmarkarmenian = 1375, e.abbreviationsigndeva = 2416, e.abengali = 2437, e.abopomofo = 12570, e.abreve = 259, e.abreveacute = 7855, e.abrevecyrillic = 1233, e.abrevedotbelow = 7863, e.abrevegrave = 7857, e.abrevehookabove = 7859, e.abrevetilde = 7861, e.acaron = 462, e.acircle = 9424, e.acircumflex = 226, e.acircumflexacute = 7845, e.acircumflexdotbelow = 7853, e.acircumflexgrave = 7847, e.acircumflexhookabove = 7849, e.acircumflextilde = 7851, e.acute = 180, e.acutebelowcmb = 791, e.acutecmb = 769, e.acutecomb = 769, e.acutedeva = 2388, e.acutelowmod = 719, e.acutetonecmb = 833, e.acyrillic = 1072, e.adblgrave = 513, e.addakgurmukhi = 2673, e.adeva = 2309, e.adieresis = 228, e.adieresiscyrillic = 1235, e.adieresismacron = 479, e.adotbelow = 7841, e.adotmacron = 481, e.ae = 230, e.aeacute = 509, e.aekorean = 12624, e.aemacron = 483, e.afii00208 = 8213, e.afii08941 = 8356, e.afii10017 = 1040, e.afii10018 = 1041, e.afii10019 = 1042, e.afii10020 = 1043, e.afii10021 = 1044, e.afii10022 = 1045, e.afii10023 = 1025, e.afii10024 = 1046, e.afii10025 = 1047, e.afii10026 = 1048, e.afii10027 = 1049, e.afii10028 = 1050, e.afii10029 = 1051, e.afii10030 = 1052, e.afii10031 = 1053, e.afii10032 = 1054, e.afii10033 = 1055, e.afii10034 = 1056, e.afii10035 = 1057, e.afii10036 = 1058, e.afii10037 = 1059, e.afii10038 = 1060, e.afii10039 = 1061, e.afii10040 = 1062, e.afii10041 = 1063, e.afii10042 = 1064, e.afii10043 = 1065, e.afii10044 = 1066, e.afii10045 = 1067, e.afii10046 = 1068, e.afii10047 = 1069, e.afii10048 = 1070, e.afii10049 = 1071, e.afii10050 = 1168, e.afii10051 = 1026, e.afii10052 = 1027, e.afii10053 = 1028, e.afii10054 = 1029, e.afii10055 = 1030, e.afii10056 = 1031, e.afii10057 = 1032, e.afii10058 = 1033, e.afii10059 = 1034, e.afii10060 = 1035, e.afii10061 = 1036, e.afii10062 = 1038, e.afii10063 = 63172, e.afii10064 = 63173, e.afii10065 = 1072, e.afii10066 = 1073, e.afii10067 = 1074, e.afii10068 = 1075, e.afii10069 = 1076, e.afii10070 = 1077, e.afii10071 = 1105, e.afii10072 = 1078, e.afii10073 = 1079, e.afii10074 = 1080, e.afii10075 = 1081, e.afii10076 = 1082, e.afii10077 = 1083, e.afii10078 = 1084, e.afii10079 = 1085, e.afii10080 = 1086, e.afii10081 = 1087, e.afii10082 = 1088, e.afii10083 = 1089, e.afii10084 = 1090, e.afii10085 = 1091, e.afii10086 = 1092, e.afii10087 = 1093, e.afii10088 = 1094, e.afii10089 = 1095, e.afii10090 = 1096, e.afii10091 = 1097, e.afii10092 = 1098, e.afii10093 = 1099, e.afii10094 = 1100, e.afii10095 = 1101, e.afii10096 = 1102, e.afii10097 = 1103, e.afii10098 = 1169, e.afii10099 = 1106, e.afii10100 = 1107, e.afii10101 = 1108, e.afii10102 = 1109, e.afii10103 = 1110, e.afii10104 = 1111, e.afii10105 = 1112, e.afii10106 = 1113, e.afii10107 = 1114, e.afii10108 = 1115, e.afii10109 = 1116, e.afii10110 = 1118, e.afii10145 = 1039, e.afii10146 = 1122, e.afii10147 = 1138, e.afii10148 = 1140, e.afii10192 = 63174, e.afii10193 = 1119, e.afii10194 = 1123, e.afii10195 = 1139, e.afii10196 = 1141, e.afii10831 = 63175, e.afii10832 = 63176, e.afii10846 = 1241, e.afii299 = 8206, e.afii300 = 8207, e.afii301 = 8205, e.afii57381 = 1642, e.afii57388 = 1548, e.afii57392 = 1632, e.afii57393 = 1633, e.afii57394 = 1634, e.afii57395 = 1635, e.afii57396 = 1636, e.afii57397 = 1637, e.afii57398 = 1638, e.afii57399 = 1639, e.afii57400 = 1640, e.afii57401 = 1641, e.afii57403 = 1563, e.afii57407 = 1567, e.afii57409 = 1569, e.afii57410 = 1570, e.afii57411 = 1571, e.afii57412 = 1572, e.afii57413 = 1573, e.afii57414 = 1574, e.afii57415 = 1575, e.afii57416 = 1576, e.afii57417 = 1577, e.afii57418 = 1578, e.afii57419 = 1579, e.afii57420 = 1580, e.afii57421 = 1581, e.afii57422 = 1582, e.afii57423 = 1583, e.afii57424 = 1584, e.afii57425 = 1585, e.afii57426 = 1586, e.afii57427 = 1587, e.afii57428 = 1588, e.afii57429 = 1589, e.afii57430 = 1590, e.afii57431 = 1591, e.afii57432 = 1592, e.afii57433 = 1593, e.afii57434 = 1594, e.afii57440 = 1600, e.afii57441 = 1601, e.afii57442 = 1602, e.afii57443 = 1603, e.afii57444 = 1604, e.afii57445 = 1605, e.afii57446 = 1606, e.afii57448 = 1608, e.afii57449 = 1609, e.afii57450 = 1610, e.afii57451 = 1611, e.afii57452 = 1612, e.afii57453 = 1613, e.afii57454 = 1614, e.afii57455 = 1615, e.afii57456 = 1616, e.afii57457 = 1617, e.afii57458 = 1618, e.afii57470 = 1607, e.afii57505 = 1700, e.afii57506 = 1662, e.afii57507 = 1670, e.afii57508 = 1688, e.afii57509 = 1711, e.afii57511 = 1657, e.afii57512 = 1672, e.afii57513 = 1681, e.afii57514 = 1722, e.afii57519 = 1746, e.afii57534 = 1749, e.afii57636 = 8362, e.afii57645 = 1470, e.afii57658 = 1475, e.afii57664 = 1488, e.afii57665 = 1489, e.afii57666 = 1490, e.afii57667 = 1491, e.afii57668 = 1492, e.afii57669 = 1493, e.afii57670 = 1494, e.afii57671 = 1495, e.afii57672 = 1496, e.afii57673 = 1497, e.afii57674 = 1498, e.afii57675 = 1499, e.afii57676 = 1500, e.afii57677 = 1501, e.afii57678 = 1502, e.afii57679 = 1503, e.afii57680 = 1504, e.afii57681 = 1505, e.afii57682 = 1506, e.afii57683 = 1507, e.afii57684 = 1508, e.afii57685 = 1509, e.afii57686 = 1510, e.afii57687 = 1511, e.afii57688 = 1512, e.afii57689 = 1513, e.afii57690 = 1514, e.afii57694 = 64298, e.afii57695 = 64299, e.afii57700 = 64331, e.afii57705 = 64287, e.afii57716 = 1520, e.afii57717 = 1521, e.afii57718 = 1522, e.afii57723 = 64309, e.afii57793 = 1460, e.afii57794 = 1461, e.afii57795 = 1462, e.afii57796 = 1467, e.afii57797 = 1464, e.afii57798 = 1463, e.afii57799 = 1456, e.afii57800 = 1458, e.afii57801 = 1457, e.afii57802 = 1459, e.afii57803 = 1474, e.afii57804 = 1473, e.afii57806 = 1465, e.afii57807 = 1468, e.afii57839 = 1469, e.afii57841 = 1471, e.afii57842 = 1472, e.afii57929 = 700, e.afii61248 = 8453, e.afii61289 = 8467, e.afii61352 = 8470, e.afii61573 = 8236, e.afii61574 = 8237, e.afii61575 = 8238, e.afii61664 = 8204, e.afii63167 = 1645, e.afii64937 = 701, e.agrave = 224, e.agujarati = 2693, e.agurmukhi = 2565, e.ahiragana = 12354, e.ahookabove = 7843, e.aibengali = 2448, e.aibopomofo = 12574, e.aideva = 2320, e.aiecyrillic = 1237, e.aigujarati = 2704, e.aigurmukhi = 2576, e.aimatragurmukhi = 2632, e.ainarabic = 1593, e.ainfinalarabic = 65226, e.aininitialarabic = 65227, e.ainmedialarabic = 65228, e.ainvertedbreve = 515, e.aivowelsignbengali = 2504, e.aivowelsigndeva = 2376, e.aivowelsigngujarati = 2760, e.akatakana = 12450, e.akatakanahalfwidth = 65393, e.akorean = 12623, e.alef = 1488, e.alefarabic = 1575, e.alefdageshhebrew = 64304, e.aleffinalarabic = 65166, e.alefhamzaabovearabic = 1571, e.alefhamzaabovefinalarabic = 65156, e.alefhamzabelowarabic = 1573, e.alefhamzabelowfinalarabic = 65160, e.alefhebrew = 1488, e.aleflamedhebrew = 64335, e.alefmaddaabovearabic = 1570, e.alefmaddaabovefinalarabic = 65154, e.alefmaksuraarabic = 1609, e.alefmaksurafinalarabic = 65264, e.alefmaksurainitialarabic = 65267, e.alefmaksuramedialarabic = 65268, e.alefpatahhebrew = 64302, e.alefqamatshebrew = 64303, e.aleph = 8501, e.allequal = 8780, e.alpha = 945, e.alphatonos = 940, e.amacron = 257, e.amonospace = 65345, e.ampersand = 38, e.ampersandmonospace = 65286, e.ampersandsmall = 63270, e.amsquare = 13250, e.anbopomofo = 12578, e.angbopomofo = 12580, e.angbracketleft = 12296, e.angbracketright = 12297, e.angkhankhuthai = 3674, e.angle = 8736, e.anglebracketleft = 12296, e.anglebracketleftvertical = 65087, e.anglebracketright = 12297, e.anglebracketrightvertical = 65088, e.angleleft = 9001, e.angleright = 9002, e.angstrom = 8491, e.anoteleia = 903, e.anudattadeva = 2386, e.anusvarabengali = 2434, e.anusvaradeva = 2306, e.anusvaragujarati = 2690, e.aogonek = 261, e.apaatosquare = 13056, e.aparen = 9372, e.apostrophearmenian = 1370, e.apostrophemod = 700, e.apple = 63743, e.approaches = 8784, e.approxequal = 8776, e.approxequalorimage = 8786, e.approximatelyequal = 8773, e.araeaekorean = 12686, e.araeakorean = 12685, e.arc = 8978, e.arighthalfring = 7834, e.aring = 229, e.aringacute = 507, e.aringbelow = 7681, e.arrowboth = 8596, e.arrowdashdown = 8675, e.arrowdashleft = 8672, e.arrowdashright = 8674, e.arrowdashup = 8673, e.arrowdblboth = 8660, e.arrowdbldown = 8659, e.arrowdblleft = 8656, e.arrowdblright = 8658, e.arrowdblup = 8657, e.arrowdown = 8595, e.arrowdownleft = 8601, e.arrowdownright = 8600, e.arrowdownwhite = 8681, e.arrowheaddownmod = 709, e.arrowheadleftmod = 706, e.arrowheadrightmod = 707, e.arrowheadupmod = 708, e.arrowhorizex = 63719, e.arrowleft = 8592, e.arrowleftdbl = 8656, e.arrowleftdblstroke = 8653, e.arrowleftoverright = 8646, e.arrowleftwhite = 8678, e.arrowright = 8594, e.arrowrightdblstroke = 8655, e.arrowrightheavy = 10142, e.arrowrightoverleft = 8644, e.arrowrightwhite = 8680, e.arrowtableft = 8676, e.arrowtabright = 8677, e.arrowup = 8593, e.arrowupdn = 8597, e.arrowupdnbse = 8616, e.arrowupdownbase = 8616, e.arrowupleft = 8598, e.arrowupleftofdown = 8645, e.arrowupright = 8599, e.arrowupwhite = 8679, e.arrowvertex = 63718, e.asciicircum = 94, e.asciicircummonospace = 65342, e.asciitilde = 126, e.asciitildemonospace = 65374, e.ascript = 593, e.ascriptturned = 594, e.asmallhiragana = 12353, e.asmallkatakana = 12449, e.asmallkatakanahalfwidth = 65383, e.asterisk = 42, e.asteriskaltonearabic = 1645, e.asteriskarabic = 1645, e.asteriskmath = 8727, e.asteriskmonospace = 65290, e.asterisksmall = 65121, e.asterism = 8258, e.asuperior = 63209, e.asymptoticallyequal = 8771, e.at = 64, e.atilde = 227, e.atmonospace = 65312, e.atsmall = 65131, e.aturned = 592, e.aubengali = 2452, e.aubopomofo = 12576, e.audeva = 2324, e.augujarati = 2708, e.augurmukhi = 2580, e.aulengthmarkbengali = 2519, e.aumatragurmukhi = 2636, e.auvowelsignbengali = 2508, e.auvowelsigndeva = 2380, e.auvowelsigngujarati = 2764, e.avagrahadeva = 2365, e.aybarmenian = 1377, e.ayin = 1506, e.ayinaltonehebrew = 64288, e.ayinhebrew = 1506, e.b = 98, e.babengali = 2476, e.backslash = 92, e.backslashmonospace = 65340, e.badeva = 2348, e.bagujarati = 2732, e.bagurmukhi = 2604, e.bahiragana = 12400, e.bahtthai = 3647, e.bakatakana = 12496, e.bar = 124, e.barmonospace = 65372, e.bbopomofo = 12549, e.bcircle = 9425, e.bdotaccent = 7683, e.bdotbelow = 7685, e.beamedsixteenthnotes = 9836, e.because = 8757, e.becyrillic = 1073, e.beharabic = 1576, e.behfinalarabic = 65168, e.behinitialarabic = 65169, e.behiragana = 12409, e.behmedialarabic = 65170, e.behmeeminitialarabic = 64671, e.behmeemisolatedarabic = 64520, e.behnoonfinalarabic = 64621, e.bekatakana = 12505, e.benarmenian = 1378, e.bet = 1489, e.beta = 946, e.betasymbolgreek = 976, e.betdagesh = 64305, e.betdageshhebrew = 64305, e.bethebrew = 1489, e.betrafehebrew = 64332, e.bhabengali = 2477, e.bhadeva = 2349, e.bhagujarati = 2733, e.bhagurmukhi = 2605, e.bhook = 595, e.bihiragana = 12403, e.bikatakana = 12499, e.bilabialclick = 664, e.bindigurmukhi = 2562, e.birusquare = 13105, e.blackcircle = 9679, e.blackdiamond = 9670, e.blackdownpointingtriangle = 9660, e.blackleftpointingpointer = 9668, e.blackleftpointingtriangle = 9664, e.blacklenticularbracketleft = 12304, e.blacklenticularbracketleftvertical = 65083, e.blacklenticularbracketright = 12305, e.blacklenticularbracketrightvertical = 65084, e.blacklowerlefttriangle = 9699, e.blacklowerrighttriangle = 9698, e.blackrectangle = 9644, e.blackrightpointingpointer = 9658, e.blackrightpointingtriangle = 9654, e.blacksmallsquare = 9642, e.blacksmilingface = 9787, e.blacksquare = 9632, e.blackstar = 9733, e.blackupperlefttriangle = 9700, e.blackupperrighttriangle = 9701, e.blackuppointingsmalltriangle = 9652, e.blackuppointingtriangle = 9650, e.blank = 9251, e.blinebelow = 7687, e.block = 9608, e.bmonospace = 65346, e.bobaimaithai = 3610, e.bohiragana = 12412, e.bokatakana = 12508, e.bparen = 9373, e.bqsquare = 13251, e.braceex = 63732, e.braceleft = 123, e.braceleftbt = 63731, e.braceleftmid = 63730, e.braceleftmonospace = 65371, e.braceleftsmall = 65115, e.bracelefttp = 63729, e.braceleftvertical = 65079, e.braceright = 125, e.bracerightbt = 63742, e.bracerightmid = 63741, e.bracerightmonospace = 65373, e.bracerightsmall = 65116, e.bracerighttp = 63740, e.bracerightvertical = 65080, e.bracketleft = 91, e.bracketleftbt = 63728, e.bracketleftex = 63727, e.bracketleftmonospace = 65339, e.bracketlefttp = 63726, e.bracketright = 93, e.bracketrightbt = 63739, e.bracketrightex = 63738, e.bracketrightmonospace = 65341, e.bracketrighttp = 63737, e.breve = 728, e.brevebelowcmb = 814, e.brevecmb = 774, e.breveinvertedbelowcmb = 815, e.breveinvertedcmb = 785, e.breveinverteddoublecmb = 865, e.bridgebelowcmb = 810, e.bridgeinvertedbelowcmb = 826, e.brokenbar = 166, e.bstroke = 384, e.bsuperior = 63210, e.btopbar = 387, e.buhiragana = 12406, e.bukatakana = 12502, e.bullet = 8226, e.bulletinverse = 9688, e.bulletoperator = 8729, e.bullseye = 9678, e.c = 99, e.caarmenian = 1390, e.cabengali = 2458, e.cacute = 263, e.cadeva = 2330, e.cagujarati = 2714, e.cagurmukhi = 2586, e.calsquare = 13192, e.candrabindubengali = 2433, e.candrabinducmb = 784, e.candrabindudeva = 2305, e.candrabindugujarati = 2689, e.capslock = 8682, e.careof = 8453, e.caron = 711, e.caronbelowcmb = 812, e.caroncmb = 780, e.carriagereturn = 8629, e.cbopomofo = 12568, e.ccaron = 269, e.ccedilla = 231, e.ccedillaacute = 7689, e.ccircle = 9426, e.ccircumflex = 265, e.ccurl = 597, e.cdot = 267, e.cdotaccent = 267, e.cdsquare = 13253, e.cedilla = 184, e.cedillacmb = 807, e.cent = 162, e.centigrade = 8451, e.centinferior = 63199, e.centmonospace = 65504, e.centoldstyle = 63394, e.centsuperior = 63200, e.chaarmenian = 1401, e.chabengali = 2459, e.chadeva = 2331, e.chagujarati = 2715, e.chagurmukhi = 2587, e.chbopomofo = 12564, e.cheabkhasiancyrillic = 1213, e.checkmark = 10003, e.checyrillic = 1095, e.chedescenderabkhasiancyrillic = 1215, e.chedescendercyrillic = 1207, e.chedieresiscyrillic = 1269, e.cheharmenian = 1395, e.chekhakassiancyrillic = 1228, e.cheverticalstrokecyrillic = 1209, e.chi = 967, e.chieuchacirclekorean = 12919, e.chieuchaparenkorean = 12823, e.chieuchcirclekorean = 12905, e.chieuchkorean = 12618, e.chieuchparenkorean = 12809, e.chochangthai = 3594, e.chochanthai = 3592, e.chochingthai = 3593, e.chochoethai = 3596, e.chook = 392, e.cieucacirclekorean = 12918, e.cieucaparenkorean = 12822, e.cieuccirclekorean = 12904, e.cieuckorean = 12616, e.cieucparenkorean = 12808, e.cieucuparenkorean = 12828, e.circle = 9675, e.circlecopyrt = 169, e.circlemultiply = 8855, e.circleot = 8857, e.circleplus = 8853, e.circlepostalmark = 12342, e.circlewithlefthalfblack = 9680, e.circlewithrighthalfblack = 9681, e.circumflex = 710, e.circumflexbelowcmb = 813, e.circumflexcmb = 770, e.clear = 8999, e.clickalveolar = 450, e.clickdental = 448, e.clicklateral = 449, e.clickretroflex = 451, e.club = 9827, e.clubsuitblack = 9827, e.clubsuitwhite = 9831, e.cmcubedsquare = 13220, e.cmonospace = 65347, e.cmsquaredsquare = 13216, e.coarmenian = 1409, e.colon = 58, e.colonmonetary = 8353, e.colonmonospace = 65306, e.colonsign = 8353, e.colonsmall = 65109, e.colontriangularhalfmod = 721, e.colontriangularmod = 720, e.comma = 44, e.commaabovecmb = 787, e.commaaboverightcmb = 789, e.commaaccent = 63171, e.commaarabic = 1548, e.commaarmenian = 1373, e.commainferior = 63201, e.commamonospace = 65292, e.commareversedabovecmb = 788, e.commareversedmod = 701, e.commasmall = 65104, e.commasuperior = 63202, e.commaturnedabovecmb = 786, e.commaturnedmod = 699, e.compass = 9788, e.congruent = 8773, e.contourintegral = 8750, e.control = 8963, e.controlACK = 6, e.controlBEL = 7, e.controlBS = 8, e.controlCAN = 24, e.controlCR = 13, e.controlDC1 = 17, e.controlDC2 = 18, e.controlDC3 = 19, e.controlDC4 = 20, e.controlDEL = 127, e.controlDLE = 16, e.controlEM = 25, e.controlENQ = 5, e.controlEOT = 4, e.controlESC = 27, e.controlETB = 23, e.controlETX = 3, e.controlFF = 12, e.controlFS = 28, e.controlGS = 29, e.controlHT = 9, e.controlLF = 10, e.controlNAK = 21, e.controlNULL = 0, e.controlRS = 30, e.controlSI = 15, e.controlSO = 14, e.controlSOT = 2, e.controlSTX = 1, e.controlSUB = 26, e.controlSYN = 22, e.controlUS = 31, e.controlVT = 11, e.copyright = 169, e.copyrightsans = 63721, e.copyrightserif = 63193, e.cornerbracketleft = 12300, e.cornerbracketlefthalfwidth = 65378, e.cornerbracketleftvertical = 65089, e.cornerbracketright = 12301, e.cornerbracketrighthalfwidth = 65379, e.cornerbracketrightvertical = 65090, e.corporationsquare = 13183, e.cosquare = 13255, e.coverkgsquare = 13254, e.cparen = 9374, e.cruzeiro = 8354, e.cstretched = 663, e.curlyand = 8911, e.curlyor = 8910, e.currency = 164, e.cyrBreve = 63185, e.cyrFlex = 63186, e.cyrbreve = 63188, e.cyrflex = 63189, e.d = 100, e.daarmenian = 1380, e.dabengali = 2470, e.dadarabic = 1590, e.dadeva = 2342, e.dadfinalarabic = 65214, e.dadinitialarabic = 65215, e.dadmedialarabic = 65216, e.dagesh = 1468, e.dageshhebrew = 1468, e.dagger = 8224, e.daggerdbl = 8225, e.dagujarati = 2726, e.dagurmukhi = 2598, e.dahiragana = 12384, e.dakatakana = 12480, e.dalarabic = 1583, e.dalet = 1491, e.daletdagesh = 64307, e.daletdageshhebrew = 64307, e.dalethebrew = 1491, e.dalfinalarabic = 65194, e.dammaarabic = 1615, e.dammalowarabic = 1615, e.dammatanaltonearabic = 1612, e.dammatanarabic = 1612, e.danda = 2404, e.dargahebrew = 1447, e.dargalefthebrew = 1447, e.dasiapneumatacyrilliccmb = 1157, e.dblGrave = 63187, e.dblanglebracketleft = 12298, e.dblanglebracketleftvertical = 65085, e.dblanglebracketright = 12299, e.dblanglebracketrightvertical = 65086, e.dblarchinvertedbelowcmb = 811, e.dblarrowleft = 8660, e.dblarrowright = 8658, e.dbldanda = 2405, e.dblgrave = 63190, e.dblgravecmb = 783, e.dblintegral = 8748, e.dbllowline = 8215, e.dbllowlinecmb = 819, e.dbloverlinecmb = 831, e.dblprimemod = 698, e.dblverticalbar = 8214, e.dblverticallineabovecmb = 782, e.dbopomofo = 12553, e.dbsquare = 13256, e.dcaron = 271, e.dcedilla = 7697, e.dcircle = 9427, e.dcircumflexbelow = 7699, e.dcroat = 273, e.ddabengali = 2465, e.ddadeva = 2337, e.ddagujarati = 2721, e.ddagurmukhi = 2593, e.ddalarabic = 1672, e.ddalfinalarabic = 64393, e.dddhadeva = 2396, e.ddhabengali = 2466, e.ddhadeva = 2338, e.ddhagujarati = 2722, e.ddhagurmukhi = 2594, e.ddotaccent = 7691, e.ddotbelow = 7693, e.decimalseparatorarabic = 1643, e.decimalseparatorpersian = 1643, e.decyrillic = 1076, e.degree = 176, e.dehihebrew = 1453, e.dehiragana = 12391, e.deicoptic = 1007, e.dekatakana = 12487, e.deleteleft = 9003, e.deleteright = 8998, e.delta = 948, e.deltaturned = 397, e.denominatorminusonenumeratorbengali = 2552, e.dezh = 676, e.dhabengali = 2471, e.dhadeva = 2343, e.dhagujarati = 2727, e.dhagurmukhi = 2599, e.dhook = 599, e.dialytikatonos = 901, e.dialytikatonoscmb = 836, e.diamond = 9830, e.diamondsuitwhite = 9826, e.dieresis = 168, e.dieresisacute = 63191, e.dieresisbelowcmb = 804, e.dieresiscmb = 776, e.dieresisgrave = 63192, e.dieresistonos = 901, e.dihiragana = 12386, e.dikatakana = 12482, e.dittomark = 12291, e.divide = 247, e.divides = 8739, e.divisionslash = 8725, e.djecyrillic = 1106, e.dkshade = 9619, e.dlinebelow = 7695, e.dlsquare = 13207, e.dmacron = 273, e.dmonospace = 65348, e.dnblock = 9604, e.dochadathai = 3598, e.dodekthai = 3604, e.dohiragana = 12393, e.dokatakana = 12489, e.dollar = 36, e.dollarinferior = 63203, e.dollarmonospace = 65284, e.dollaroldstyle = 63268, e.dollarsmall = 65129, e.dollarsuperior = 63204, e.dong = 8363, e.dorusquare = 13094, e.dotaccent = 729, e.dotaccentcmb = 775, e.dotbelowcmb = 803, e.dotbelowcomb = 803, e.dotkatakana = 12539, e.dotlessi = 305, e.dotlessj = 63166, e.dotlessjstrokehook = 644, e.dotmath = 8901, e.dottedcircle = 9676, e.doubleyodpatah = 64287, e.doubleyodpatahhebrew = 64287, e.downtackbelowcmb = 798, e.downtackmod = 725, e.dparen = 9375, e.dsuperior = 63211, e.dtail = 598, e.dtopbar = 396, e.duhiragana = 12389, e.dukatakana = 12485, e.dz = 499, e.dzaltone = 675, e.dzcaron = 454, e.dzcurl = 677, e.dzeabkhasiancyrillic = 1249, e.dzecyrillic = 1109, e.dzhecyrillic = 1119, e.e = 101, e.eacute = 233, e.earth = 9793, e.ebengali = 2447, e.ebopomofo = 12572, e.ebreve = 277, e.ecandradeva = 2317, e.ecandragujarati = 2701, e.ecandravowelsigndeva = 2373, e.ecandravowelsigngujarati = 2757, e.ecaron = 283, e.ecedillabreve = 7709, e.echarmenian = 1381, e.echyiwnarmenian = 1415, e.ecircle = 9428, e.ecircumflex = 234, e.ecircumflexacute = 7871, e.ecircumflexbelow = 7705, e.ecircumflexdotbelow = 7879, e.ecircumflexgrave = 7873, e.ecircumflexhookabove = 7875, e.ecircumflextilde = 7877, e.ecyrillic = 1108, e.edblgrave = 517, e.edeva = 2319, e.edieresis = 235, e.edot = 279, e.edotaccent = 279, e.edotbelow = 7865, e.eegurmukhi = 2575, e.eematragurmukhi = 2631, e.efcyrillic = 1092, e.egrave = 232, e.egujarati = 2703, e.eharmenian = 1383, e.ehbopomofo = 12573, e.ehiragana = 12360, e.ehookabove = 7867, e.eibopomofo = 12575, e.eight = 56, e.eightarabic = 1640, e.eightbengali = 2542, e.eightcircle = 9319, e.eightcircleinversesansserif = 10129, e.eightdeva = 2414, e.eighteencircle = 9329, e.eighteenparen = 9349, e.eighteenperiod = 9369, e.eightgujarati = 2798, e.eightgurmukhi = 2670, e.eighthackarabic = 1640, e.eighthangzhou = 12328, e.eighthnotebeamed = 9835, e.eightideographicparen = 12839, e.eightinferior = 8328, e.eightmonospace = 65304, e.eightoldstyle = 63288, e.eightparen = 9339, e.eightperiod = 9359, e.eightpersian = 1784, e.eightroman = 8567, e.eightsuperior = 8312, e.eightthai = 3672, e.einvertedbreve = 519, e.eiotifiedcyrillic = 1125, e.ekatakana = 12456, e.ekatakanahalfwidth = 65396, e.ekonkargurmukhi = 2676, e.ekorean = 12628, e.elcyrillic = 1083, e.element = 8712, e.elevencircle = 9322, e.elevenparen = 9342, e.elevenperiod = 9362, e.elevenroman = 8570, e.ellipsis = 8230, e.ellipsisvertical = 8942, e.emacron = 275, e.emacronacute = 7703, e.emacrongrave = 7701, e.emcyrillic = 1084, e.emdash = 8212, e.emdashvertical = 65073, e.emonospace = 65349, e.emphasismarkarmenian = 1371, e.emptyset = 8709, e.enbopomofo = 12579, e.encyrillic = 1085, e.endash = 8211, e.endashvertical = 65074, e.endescendercyrillic = 1187, e.eng = 331, e.engbopomofo = 12581, e.enghecyrillic = 1189, e.enhookcyrillic = 1224, e.enspace = 8194, e.eogonek = 281, e.eokorean = 12627, e.eopen = 603, e.eopenclosed = 666, e.eopenreversed = 604, e.eopenreversedclosed = 606, e.eopenreversedhook = 605, e.eparen = 9376, e.epsilon = 949, e.epsilontonos = 941, e.equal = 61, e.equalmonospace = 65309, e.equalsmall = 65126, e.equalsuperior = 8316, e.equivalence = 8801, e.erbopomofo = 12582, e.ercyrillic = 1088, e.ereversed = 600, e.ereversedcyrillic = 1101, e.escyrillic = 1089, e.esdescendercyrillic = 1195, e.esh = 643, e.eshcurl = 646, e.eshortdeva = 2318, e.eshortvowelsigndeva = 2374, e.eshreversedloop = 426, e.eshsquatreversed = 645, e.esmallhiragana = 12359, e.esmallkatakana = 12455, e.esmallkatakanahalfwidth = 65386, e.estimated = 8494, e.esuperior = 63212, e.eta = 951, e.etarmenian = 1384, e.etatonos = 942, e.eth = 240, e.etilde = 7869, e.etildebelow = 7707, e.etnahtafoukhhebrew = 1425, e.etnahtafoukhlefthebrew = 1425, e.etnahtahebrew = 1425, e.etnahtalefthebrew = 1425, e.eturned = 477, e.eukorean = 12641, e.euro = 8364, e.evowelsignbengali = 2503, e.evowelsigndeva = 2375, e.evowelsigngujarati = 2759, e.exclam = 33, e.exclamarmenian = 1372, e.exclamdbl = 8252, e.exclamdown = 161, e.exclamdownsmall = 63393, e.exclammonospace = 65281, e.exclamsmall = 63265, e.existential = 8707, e.ezh = 658, e.ezhcaron = 495, e.ezhcurl = 659, e.ezhreversed = 441, e.ezhtail = 442, e.f = 102, e.fadeva = 2398, e.fagurmukhi = 2654, e.fahrenheit = 8457, e.fathaarabic = 1614, e.fathalowarabic = 1614, e.fathatanarabic = 1611, e.fbopomofo = 12552, e.fcircle = 9429, e.fdotaccent = 7711, e.feharabic = 1601, e.feharmenian = 1414, e.fehfinalarabic = 65234, e.fehinitialarabic = 65235, e.fehmedialarabic = 65236, e.feicoptic = 997, e.female = 9792, e.ff = 64256, e.f_f = 64256, e.ffi = 64259, e.f_f_i = 64259, e.ffl = 64260, e.f_f_l = 64260, e.fi = 64257, e.f_i = 64257, e.fifteencircle = 9326, e.fifteenparen = 9346, e.fifteenperiod = 9366, e.figuredash = 8210, e.filledbox = 9632, e.filledrect = 9644, e.finalkaf = 1498, e.finalkafdagesh = 64314, e.finalkafdageshhebrew = 64314, e.finalkafhebrew = 1498, e.finalmem = 1501, e.finalmemhebrew = 1501, e.finalnun = 1503, e.finalnunhebrew = 1503, e.finalpe = 1507, e.finalpehebrew = 1507, e.finaltsadi = 1509, e.finaltsadihebrew = 1509, e.firsttonechinese = 713, e.fisheye = 9673, e.fitacyrillic = 1139, e.five = 53, e.fivearabic = 1637, e.fivebengali = 2539, e.fivecircle = 9316, e.fivecircleinversesansserif = 10126, e.fivedeva = 2411, e.fiveeighths = 8541, e.fivegujarati = 2795, e.fivegurmukhi = 2667, e.fivehackarabic = 1637, e.fivehangzhou = 12325, e.fiveideographicparen = 12836, e.fiveinferior = 8325, e.fivemonospace = 65301, e.fiveoldstyle = 63285, e.fiveparen = 9336, e.fiveperiod = 9356, e.fivepersian = 1781, e.fiveroman = 8564, e.fivesuperior = 8309, e.fivethai = 3669, e.fl = 64258, e.f_l = 64258, e.florin = 402, e.fmonospace = 65350, e.fmsquare = 13209, e.fofanthai = 3615, e.fofathai = 3613, e.fongmanthai = 3663, e.forall = 8704, e.four = 52, e.fourarabic = 1636, e.fourbengali = 2538, e.fourcircle = 9315, e.fourcircleinversesansserif = 10125, e.fourdeva = 2410, e.fourgujarati = 2794, e.fourgurmukhi = 2666, e.fourhackarabic = 1636, e.fourhangzhou = 12324, e.fourideographicparen = 12835, e.fourinferior = 8324, e.fourmonospace = 65300, e.fournumeratorbengali = 2551, e.fouroldstyle = 63284, e.fourparen = 9335, e.fourperiod = 9355, e.fourpersian = 1780, e.fourroman = 8563, e.foursuperior = 8308, e.fourteencircle = 9325, e.fourteenparen = 9345, e.fourteenperiod = 9365, e.fourthai = 3668, e.fourthtonechinese = 715, e.fparen = 9377, e.fraction = 8260, e.franc = 8355, e.g = 103, e.gabengali = 2455, e.gacute = 501, e.gadeva = 2327, e.gafarabic = 1711, e.gaffinalarabic = 64403, e.gafinitialarabic = 64404, e.gafmedialarabic = 64405, e.gagujarati = 2711, e.gagurmukhi = 2583, e.gahiragana = 12364, e.gakatakana = 12460, e.gamma = 947, e.gammalatinsmall = 611, e.gammasuperior = 736, e.gangiacoptic = 1003, e.gbopomofo = 12557, e.gbreve = 287, e.gcaron = 487, e.gcedilla = 291, e.gcircle = 9430, e.gcircumflex = 285, e.gcommaaccent = 291, e.gdot = 289, e.gdotaccent = 289, e.gecyrillic = 1075, e.gehiragana = 12370, e.gekatakana = 12466, e.geometricallyequal = 8785, e.gereshaccenthebrew = 1436, e.gereshhebrew = 1523, e.gereshmuqdamhebrew = 1437, e.germandbls = 223, e.gershayimaccenthebrew = 1438, e.gershayimhebrew = 1524, e.getamark = 12307, e.ghabengali = 2456, e.ghadarmenian = 1394, e.ghadeva = 2328, e.ghagujarati = 2712, e.ghagurmukhi = 2584, e.ghainarabic = 1594, e.ghainfinalarabic = 65230, e.ghaininitialarabic = 65231, e.ghainmedialarabic = 65232, e.ghemiddlehookcyrillic = 1173, e.ghestrokecyrillic = 1171, e.gheupturncyrillic = 1169, e.ghhadeva = 2394, e.ghhagurmukhi = 2650, e.ghook = 608, e.ghzsquare = 13203, e.gihiragana = 12366, e.gikatakana = 12462, e.gimarmenian = 1379, e.gimel = 1490, e.gimeldagesh = 64306, e.gimeldageshhebrew = 64306, e.gimelhebrew = 1490, e.gjecyrillic = 1107, e.glottalinvertedstroke = 446, e.glottalstop = 660, e.glottalstopinverted = 662, e.glottalstopmod = 704, e.glottalstopreversed = 661, e.glottalstopreversedmod = 705, e.glottalstopreversedsuperior = 740, e.glottalstopstroke = 673, e.glottalstopstrokereversed = 674, e.gmacron = 7713, e.gmonospace = 65351, e.gohiragana = 12372, e.gokatakana = 12468, e.gparen = 9378, e.gpasquare = 13228, e.gradient = 8711, e.grave = 96, e.gravebelowcmb = 790, e.gravecmb = 768, e.gravecomb = 768, e.gravedeva = 2387, e.gravelowmod = 718, e.gravemonospace = 65344, e.gravetonecmb = 832, e.greater = 62, e.greaterequal = 8805, e.greaterequalorless = 8923, e.greatermonospace = 65310, e.greaterorequivalent = 8819, e.greaterorless = 8823, e.greateroverequal = 8807, e.greatersmall = 65125, e.gscript = 609, e.gstroke = 485, e.guhiragana = 12368, e.guillemotleft = 171, e.guillemotright = 187, e.guilsinglleft = 8249, e.guilsinglright = 8250, e.gukatakana = 12464, e.guramusquare = 13080, e.gysquare = 13257, e.h = 104, e.haabkhasiancyrillic = 1193, e.haaltonearabic = 1729, e.habengali = 2489, e.hadescendercyrillic = 1203, e.hadeva = 2361, e.hagujarati = 2745, e.hagurmukhi = 2617, e.haharabic = 1581, e.hahfinalarabic = 65186, e.hahinitialarabic = 65187, e.hahiragana = 12399, e.hahmedialarabic = 65188, e.haitusquare = 13098, e.hakatakana = 12495, e.hakatakanahalfwidth = 65418, e.halantgurmukhi = 2637, e.hamzaarabic = 1569, e.hamzalowarabic = 1569, e.hangulfiller = 12644, e.hardsigncyrillic = 1098, e.harpoonleftbarbup = 8636, e.harpoonrightbarbup = 8640, e.hasquare = 13258, e.hatafpatah = 1458, e.hatafpatah16 = 1458, e.hatafpatah23 = 1458, e.hatafpatah2f = 1458, e.hatafpatahhebrew = 1458, e.hatafpatahnarrowhebrew = 1458, e.hatafpatahquarterhebrew = 1458, e.hatafpatahwidehebrew = 1458, e.hatafqamats = 1459, e.hatafqamats1b = 1459, e.hatafqamats28 = 1459, e.hatafqamats34 = 1459, e.hatafqamatshebrew = 1459, e.hatafqamatsnarrowhebrew = 1459, e.hatafqamatsquarterhebrew = 1459, e.hatafqamatswidehebrew = 1459, e.hatafsegol = 1457, e.hatafsegol17 = 1457, e.hatafsegol24 = 1457, e.hatafsegol30 = 1457, e.hatafsegolhebrew = 1457, e.hatafsegolnarrowhebrew = 1457, e.hatafsegolquarterhebrew = 1457, e.hatafsegolwidehebrew = 1457, e.hbar = 295, e.hbopomofo = 12559, e.hbrevebelow = 7723, e.hcedilla = 7721, e.hcircle = 9431, e.hcircumflex = 293, e.hdieresis = 7719, e.hdotaccent = 7715, e.hdotbelow = 7717, e.he = 1492, e.heart = 9829, e.heartsuitblack = 9829, e.heartsuitwhite = 9825, e.hedagesh = 64308, e.hedageshhebrew = 64308, e.hehaltonearabic = 1729, e.heharabic = 1607, e.hehebrew = 1492, e.hehfinalaltonearabic = 64423, e.hehfinalalttwoarabic = 65258, e.hehfinalarabic = 65258, e.hehhamzaabovefinalarabic = 64421, e.hehhamzaaboveisolatedarabic = 64420, e.hehinitialaltonearabic = 64424, e.hehinitialarabic = 65259, e.hehiragana = 12408, e.hehmedialaltonearabic = 64425, e.hehmedialarabic = 65260, e.heiseierasquare = 13179, e.hekatakana = 12504, e.hekatakanahalfwidth = 65421, e.hekutaarusquare = 13110, e.henghook = 615, e.herutusquare = 13113, e.het = 1495, e.hethebrew = 1495, e.hhook = 614, e.hhooksuperior = 689, e.hieuhacirclekorean = 12923, e.hieuhaparenkorean = 12827, e.hieuhcirclekorean = 12909, e.hieuhkorean = 12622, e.hieuhparenkorean = 12813, e.hihiragana = 12402, e.hikatakana = 12498, e.hikatakanahalfwidth = 65419, e.hiriq = 1460, e.hiriq14 = 1460, e.hiriq21 = 1460, e.hiriq2d = 1460, e.hiriqhebrew = 1460, e.hiriqnarrowhebrew = 1460, e.hiriqquarterhebrew = 1460, e.hiriqwidehebrew = 1460, e.hlinebelow = 7830, e.hmonospace = 65352, e.hoarmenian = 1392, e.hohipthai = 3627, e.hohiragana = 12411, e.hokatakana = 12507, e.hokatakanahalfwidth = 65422, e.holam = 1465, e.holam19 = 1465, e.holam26 = 1465, e.holam32 = 1465, e.holamhebrew = 1465, e.holamnarrowhebrew = 1465, e.holamquarterhebrew = 1465, e.holamwidehebrew = 1465, e.honokhukthai = 3630, e.hookabovecomb = 777, e.hookcmb = 777, e.hookpalatalizedbelowcmb = 801, e.hookretroflexbelowcmb = 802, e.hoonsquare = 13122, e.horicoptic = 1001, e.horizontalbar = 8213, e.horncmb = 795, e.hotsprings = 9832, e.house = 8962, e.hparen = 9379, e.hsuperior = 688, e.hturned = 613, e.huhiragana = 12405, e.huiitosquare = 13107, e.hukatakana = 12501, e.hukatakanahalfwidth = 65420, e.hungarumlaut = 733, e.hungarumlautcmb = 779, e.hv = 405, e.hyphen = 45, e.hypheninferior = 63205, e.hyphenmonospace = 65293, e.hyphensmall = 65123, e.hyphensuperior = 63206, e.hyphentwo = 8208, e.i = 105, e.iacute = 237, e.iacyrillic = 1103, e.ibengali = 2439, e.ibopomofo = 12583, e.ibreve = 301, e.icaron = 464, e.icircle = 9432, e.icircumflex = 238, e.icyrillic = 1110, e.idblgrave = 521, e.ideographearthcircle = 12943, e.ideographfirecircle = 12939, e.ideographicallianceparen = 12863, e.ideographiccallparen = 12858, e.ideographiccentrecircle = 12965, e.ideographicclose = 12294, e.ideographiccomma = 12289, e.ideographiccommaleft = 65380, e.ideographiccongratulationparen = 12855, e.ideographiccorrectcircle = 12963, e.ideographicearthparen = 12847, e.ideographicenterpriseparen = 12861, e.ideographicexcellentcircle = 12957, e.ideographicfestivalparen = 12864, e.ideographicfinancialcircle = 12950, e.ideographicfinancialparen = 12854, e.ideographicfireparen = 12843, e.ideographichaveparen = 12850, e.ideographichighcircle = 12964, e.ideographiciterationmark = 12293, e.ideographiclaborcircle = 12952, e.ideographiclaborparen = 12856, e.ideographicleftcircle = 12967, e.ideographiclowcircle = 12966, e.ideographicmedicinecircle = 12969, e.ideographicmetalparen = 12846, e.ideographicmoonparen = 12842, e.ideographicnameparen = 12852, e.ideographicperiod = 12290, e.ideographicprintcircle = 12958, e.ideographicreachparen = 12867, e.ideographicrepresentparen = 12857, e.ideographicresourceparen = 12862, e.ideographicrightcircle = 12968, e.ideographicsecretcircle = 12953, e.ideographicselfparen = 12866, e.ideographicsocietyparen = 12851, e.ideographicspace = 12288, e.ideographicspecialparen = 12853, e.ideographicstockparen = 12849, e.ideographicstudyparen = 12859, e.ideographicsunparen = 12848, e.ideographicsuperviseparen = 12860, e.ideographicwaterparen = 12844, e.ideographicwoodparen = 12845, e.ideographiczero = 12295, e.ideographmetalcircle = 12942, e.ideographmooncircle = 12938, e.ideographnamecircle = 12948, e.ideographsuncircle = 12944, e.ideographwatercircle = 12940, e.ideographwoodcircle = 12941, e.ideva = 2311, e.idieresis = 239, e.idieresisacute = 7727, e.idieresiscyrillic = 1253, e.idotbelow = 7883, e.iebrevecyrillic = 1239, e.iecyrillic = 1077, e.ieungacirclekorean = 12917, e.ieungaparenkorean = 12821, e.ieungcirclekorean = 12903, e.ieungkorean = 12615, e.ieungparenkorean = 12807, e.igrave = 236, e.igujarati = 2695, e.igurmukhi = 2567, e.ihiragana = 12356, e.ihookabove = 7881, e.iibengali = 2440, e.iicyrillic = 1080, e.iideva = 2312, e.iigujarati = 2696, e.iigurmukhi = 2568, e.iimatragurmukhi = 2624, e.iinvertedbreve = 523, e.iishortcyrillic = 1081, e.iivowelsignbengali = 2496, e.iivowelsigndeva = 2368, e.iivowelsigngujarati = 2752, e.ij = 307, e.ikatakana = 12452, e.ikatakanahalfwidth = 65394, e.ikorean = 12643, e.ilde = 732, e.iluyhebrew = 1452, e.imacron = 299, e.imacroncyrillic = 1251, e.imageorapproximatelyequal = 8787, e.imatragurmukhi = 2623, e.imonospace = 65353, e.increment = 8710, e.infinity = 8734, e.iniarmenian = 1387, e.integral = 8747, e.integralbottom = 8993, e.integralbt = 8993, e.integralex = 63733, e.integraltop = 8992, e.integraltp = 8992, e.intersection = 8745, e.intisquare = 13061, e.invbullet = 9688, e.invcircle = 9689, e.invsmileface = 9787, e.iocyrillic = 1105, e.iogonek = 303, e.iota = 953, e.iotadieresis = 970, e.iotadieresistonos = 912, e.iotalatin = 617, e.iotatonos = 943, e.iparen = 9380, e.irigurmukhi = 2674, e.ismallhiragana = 12355, e.ismallkatakana = 12451, e.ismallkatakanahalfwidth = 65384, e.issharbengali = 2554, e.istroke = 616, e.isuperior = 63213, e.iterationhiragana = 12445, e.iterationkatakana = 12541, e.itilde = 297, e.itildebelow = 7725, e.iubopomofo = 12585, e.iucyrillic = 1102, e.ivowelsignbengali = 2495, e.ivowelsigndeva = 2367, e.ivowelsigngujarati = 2751, e.izhitsacyrillic = 1141, e.izhitsadblgravecyrillic = 1143, e.j = 106, e.jaarmenian = 1393, e.jabengali = 2460, e.jadeva = 2332, e.jagujarati = 2716, e.jagurmukhi = 2588, e.jbopomofo = 12560, e.jcaron = 496, e.jcircle = 9433, e.jcircumflex = 309, e.jcrossedtail = 669, e.jdotlessstroke = 607, e.jecyrillic = 1112, e.jeemarabic = 1580, e.jeemfinalarabic = 65182, e.jeeminitialarabic = 65183, e.jeemmedialarabic = 65184, e.jeharabic = 1688, e.jehfinalarabic = 64395, e.jhabengali = 2461, e.jhadeva = 2333, e.jhagujarati = 2717, e.jhagurmukhi = 2589, e.jheharmenian = 1403, e.jis = 12292, e.jmonospace = 65354, e.jparen = 9381, e.jsuperior = 690, e.k = 107, e.kabashkircyrillic = 1185, e.kabengali = 2453, e.kacute = 7729, e.kacyrillic = 1082, e.kadescendercyrillic = 1179, e.kadeva = 2325, e.kaf = 1499, e.kafarabic = 1603, e.kafdagesh = 64315, e.kafdageshhebrew = 64315, e.kaffinalarabic = 65242, e.kafhebrew = 1499, e.kafinitialarabic = 65243, e.kafmedialarabic = 65244, e.kafrafehebrew = 64333, e.kagujarati = 2709, e.kagurmukhi = 2581, e.kahiragana = 12363, e.kahookcyrillic = 1220, e.kakatakana = 12459, e.kakatakanahalfwidth = 65398, e.kappa = 954, e.kappasymbolgreek = 1008, e.kapyeounmieumkorean = 12657, e.kapyeounphieuphkorean = 12676, e.kapyeounpieupkorean = 12664, e.kapyeounssangpieupkorean = 12665, e.karoriisquare = 13069, e.kashidaautoarabic = 1600, e.kashidaautonosidebearingarabic = 1600, e.kasmallkatakana = 12533, e.kasquare = 13188, e.kasraarabic = 1616, e.kasratanarabic = 1613, e.kastrokecyrillic = 1183, e.katahiraprolongmarkhalfwidth = 65392, e.kaverticalstrokecyrillic = 1181, e.kbopomofo = 12558, e.kcalsquare = 13193, e.kcaron = 489, e.kcedilla = 311, e.kcircle = 9434, e.kcommaaccent = 311, e.kdotbelow = 7731, e.keharmenian = 1412, e.kehiragana = 12369, e.kekatakana = 12465, e.kekatakanahalfwidth = 65401, e.kenarmenian = 1391, e.kesmallkatakana = 12534, e.kgreenlandic = 312, e.khabengali = 2454, e.khacyrillic = 1093, e.khadeva = 2326, e.khagujarati = 2710, e.khagurmukhi = 2582, e.khaharabic = 1582, e.khahfinalarabic = 65190, e.khahinitialarabic = 65191, e.khahmedialarabic = 65192, e.kheicoptic = 999, e.khhadeva = 2393, e.khhagurmukhi = 2649, e.khieukhacirclekorean = 12920, e.khieukhaparenkorean = 12824, e.khieukhcirclekorean = 12906, e.khieukhkorean = 12619, e.khieukhparenkorean = 12810, e.khokhaithai = 3586, e.khokhonthai = 3589, e.khokhuatthai = 3587, e.khokhwaithai = 3588, e.khomutthai = 3675, e.khook = 409, e.khorakhangthai = 3590, e.khzsquare = 13201, e.kihiragana = 12365, e.kikatakana = 12461, e.kikatakanahalfwidth = 65399, e.kiroguramusquare = 13077, e.kiromeetorusquare = 13078, e.kirosquare = 13076, e.kiyeokacirclekorean = 12910, e.kiyeokaparenkorean = 12814, e.kiyeokcirclekorean = 12896, e.kiyeokkorean = 12593, e.kiyeokparenkorean = 12800, e.kiyeoksioskorean = 12595, e.kjecyrillic = 1116, e.klinebelow = 7733, e.klsquare = 13208, e.kmcubedsquare = 13222, e.kmonospace = 65355, e.kmsquaredsquare = 13218, e.kohiragana = 12371, e.kohmsquare = 13248, e.kokaithai = 3585, e.kokatakana = 12467, e.kokatakanahalfwidth = 65402, e.kooposquare = 13086, e.koppacyrillic = 1153, e.koreanstandardsymbol = 12927, e.koroniscmb = 835, e.kparen = 9382, e.kpasquare = 13226, e.ksicyrillic = 1135, e.ktsquare = 13263, e.kturned = 670, e.kuhiragana = 12367, e.kukatakana = 12463, e.kukatakanahalfwidth = 65400, e.kvsquare = 13240, e.kwsquare = 13246, e.l = 108, e.labengali = 2482, e.lacute = 314, e.ladeva = 2354, e.lagujarati = 2738, e.lagurmukhi = 2610, e.lakkhangyaothai = 3653, e.lamaleffinalarabic = 65276, e.lamalefhamzaabovefinalarabic = 65272, e.lamalefhamzaaboveisolatedarabic = 65271, e.lamalefhamzabelowfinalarabic = 65274, e.lamalefhamzabelowisolatedarabic = 65273, e.lamalefisolatedarabic = 65275, e.lamalefmaddaabovefinalarabic = 65270, e.lamalefmaddaaboveisolatedarabic = 65269, e.lamarabic = 1604, e.lambda = 955, e.lambdastroke = 411, e.lamed = 1500, e.lameddagesh = 64316, e.lameddageshhebrew = 64316, e.lamedhebrew = 1500, e.lamfinalarabic = 65246, e.lamhahinitialarabic = 64714, e.laminitialarabic = 65247, e.lamjeeminitialarabic = 64713, e.lamkhahinitialarabic = 64715, e.lamlamhehisolatedarabic = 65010, e.lammedialarabic = 65248, e.lammeemhahinitialarabic = 64904, e.lammeeminitialarabic = 64716, e.largecircle = 9711, e.lbar = 410, e.lbelt = 620, e.lbopomofo = 12556, e.lcaron = 318, e.lcedilla = 316, e.lcircle = 9435, e.lcircumflexbelow = 7741, e.lcommaaccent = 316, e.ldot = 320, e.ldotaccent = 320, e.ldotbelow = 7735, e.ldotbelowmacron = 7737, e.leftangleabovecmb = 794, e.lefttackbelowcmb = 792, e.less = 60, e.lessequal = 8804, e.lessequalorgreater = 8922, e.lessmonospace = 65308, e.lessorequivalent = 8818, e.lessorgreater = 8822, e.lessoverequal = 8806, e.lesssmall = 65124, e.lezh = 622, e.lfblock = 9612, e.lhookretroflex = 621, e.lira = 8356, e.liwnarmenian = 1388, e.lj = 457, e.ljecyrillic = 1113, e.ll = 63168, e.lladeva = 2355, e.llagujarati = 2739, e.llinebelow = 7739, e.llladeva = 2356, e.llvocalicbengali = 2529, e.llvocalicdeva = 2401, e.llvocalicvowelsignbengali = 2531, e.llvocalicvowelsigndeva = 2403, e.lmiddletilde = 619, e.lmonospace = 65356, e.lmsquare = 13264, e.lochulathai = 3628, e.logicaland = 8743, e.logicalnot = 172, e.logicalnotreversed = 8976, e.logicalor = 8744, e.lolingthai = 3621, e.longs = 383, e.lowlinecenterline = 65102, e.lowlinecmb = 818, e.lowlinedashed = 65101, e.lozenge = 9674, e.lparen = 9383, e.lslash = 322, e.lsquare = 8467, e.lsuperior = 63214, e.ltshade = 9617, e.luthai = 3622, e.lvocalicbengali = 2444, e.lvocalicdeva = 2316, e.lvocalicvowelsignbengali = 2530, e.lvocalicvowelsigndeva = 2402, e.lxsquare = 13267, e.m = 109, e.mabengali = 2478, e.macron = 175, e.macronbelowcmb = 817, e.macroncmb = 772, e.macronlowmod = 717, e.macronmonospace = 65507, e.macute = 7743, e.madeva = 2350, e.magujarati = 2734, e.magurmukhi = 2606, e.mahapakhhebrew = 1444, e.mahapakhlefthebrew = 1444, e.mahiragana = 12414, e.maichattawalowleftthai = 63637, e.maichattawalowrightthai = 63636, e.maichattawathai = 3659, e.maichattawaupperleftthai = 63635, e.maieklowleftthai = 63628, e.maieklowrightthai = 63627, e.maiekthai = 3656, e.maiekupperleftthai = 63626, e.maihanakatleftthai = 63620, e.maihanakatthai = 3633, e.maitaikhuleftthai = 63625, e.maitaikhuthai = 3655, e.maitholowleftthai = 63631, e.maitholowrightthai = 63630, e.maithothai = 3657, e.maithoupperleftthai = 63629, e.maitrilowleftthai = 63634, e.maitrilowrightthai = 63633, e.maitrithai = 3658, e.maitriupperleftthai = 63632, e.maiyamokthai = 3654, e.makatakana = 12510, e.makatakanahalfwidth = 65423, e.male = 9794, e.mansyonsquare = 13127, e.maqafhebrew = 1470, e.mars = 9794, e.masoracirclehebrew = 1455, e.masquare = 13187, e.mbopomofo = 12551, e.mbsquare = 13268, e.mcircle = 9436, e.mcubedsquare = 13221, e.mdotaccent = 7745, e.mdotbelow = 7747, e.meemarabic = 1605, e.meemfinalarabic = 65250, e.meeminitialarabic = 65251, e.meemmedialarabic = 65252, e.meemmeeminitialarabic = 64721, e.meemmeemisolatedarabic = 64584, e.meetorusquare = 13133, e.mehiragana = 12417, e.meizierasquare = 13182, e.mekatakana = 12513, e.mekatakanahalfwidth = 65426, e.mem = 1502, e.memdagesh = 64318, e.memdageshhebrew = 64318, e.memhebrew = 1502, e.menarmenian = 1396, e.merkhahebrew = 1445, e.merkhakefulahebrew = 1446, e.merkhakefulalefthebrew = 1446, e.merkhalefthebrew = 1445, e.mhook = 625, e.mhzsquare = 13202, e.middledotkatakanahalfwidth = 65381, e.middot = 183, e.mieumacirclekorean = 12914, e.mieumaparenkorean = 12818, e.mieumcirclekorean = 12900, e.mieumkorean = 12609, e.mieumpansioskorean = 12656, e.mieumparenkorean = 12804, e.mieumpieupkorean = 12654, e.mieumsioskorean = 12655, e.mihiragana = 12415, e.mikatakana = 12511, e.mikatakanahalfwidth = 65424, e.minus = 8722, e.minusbelowcmb = 800, e.minuscircle = 8854, e.minusmod = 727, e.minusplus = 8723, e.minute = 8242, e.miribaarusquare = 13130, e.mirisquare = 13129, e.mlonglegturned = 624, e.mlsquare = 13206, e.mmcubedsquare = 13219, e.mmonospace = 65357, e.mmsquaredsquare = 13215, e.mohiragana = 12418, e.mohmsquare = 13249, e.mokatakana = 12514, e.mokatakanahalfwidth = 65427, e.molsquare = 13270, e.momathai = 3617, e.moverssquare = 13223, e.moverssquaredsquare = 13224, e.mparen = 9384, e.mpasquare = 13227, e.mssquare = 13235, e.msuperior = 63215, e.mturned = 623, e.mu = 181, e.mu1 = 181, e.muasquare = 13186, e.muchgreater = 8811, e.muchless = 8810, e.mufsquare = 13196, e.mugreek = 956, e.mugsquare = 13197, e.muhiragana = 12416, e.mukatakana = 12512, e.mukatakanahalfwidth = 65425, e.mulsquare = 13205, e.multiply = 215, e.mumsquare = 13211, e.munahhebrew = 1443, e.munahlefthebrew = 1443, e.musicalnote = 9834, e.musicalnotedbl = 9835, e.musicflatsign = 9837, e.musicsharpsign = 9839, e.mussquare = 13234, e.muvsquare = 13238, e.muwsquare = 13244, e.mvmegasquare = 13241, e.mvsquare = 13239, e.mwmegasquare = 13247, e.mwsquare = 13245, e.n = 110, e.nabengali = 2472, e.nabla = 8711, e.nacute = 324, e.nadeva = 2344, e.nagujarati = 2728, e.nagurmukhi = 2600, e.nahiragana = 12394, e.nakatakana = 12490, e.nakatakanahalfwidth = 65413, e.napostrophe = 329, e.nasquare = 13185, e.nbopomofo = 12555, e.nbspace = 160, e.ncaron = 328, e.ncedilla = 326, e.ncircle = 9437, e.ncircumflexbelow = 7755, e.ncommaaccent = 326, e.ndotaccent = 7749, e.ndotbelow = 7751, e.nehiragana = 12397, e.nekatakana = 12493, e.nekatakanahalfwidth = 65416, e.newsheqelsign = 8362, e.nfsquare = 13195, e.ngabengali = 2457, e.ngadeva = 2329, e.ngagujarati = 2713, e.ngagurmukhi = 2585, e.ngonguthai = 3591, e.nhiragana = 12435, e.nhookleft = 626, e.nhookretroflex = 627, e.nieunacirclekorean = 12911, e.nieunaparenkorean = 12815, e.nieuncieuckorean = 12597, e.nieuncirclekorean = 12897, e.nieunhieuhkorean = 12598, e.nieunkorean = 12596, e.nieunpansioskorean = 12648, e.nieunparenkorean = 12801, e.nieunsioskorean = 12647, e.nieuntikeutkorean = 12646, e.nihiragana = 12395, e.nikatakana = 12491, e.nikatakanahalfwidth = 65414, e.nikhahitleftthai = 63641, e.nikhahitthai = 3661, e.nine = 57, e.ninearabic = 1641, e.ninebengali = 2543, e.ninecircle = 9320, e.ninecircleinversesansserif = 10130, e.ninedeva = 2415, e.ninegujarati = 2799, e.ninegurmukhi = 2671, e.ninehackarabic = 1641, e.ninehangzhou = 12329, e.nineideographicparen = 12840, e.nineinferior = 8329, e.ninemonospace = 65305, e.nineoldstyle = 63289, e.nineparen = 9340, e.nineperiod = 9360, e.ninepersian = 1785, e.nineroman = 8568, e.ninesuperior = 8313, e.nineteencircle = 9330, e.nineteenparen = 9350, e.nineteenperiod = 9370, e.ninethai = 3673, e.nj = 460, e.njecyrillic = 1114, e.nkatakana = 12531, e.nkatakanahalfwidth = 65437, e.nlegrightlong = 414, e.nlinebelow = 7753, e.nmonospace = 65358, e.nmsquare = 13210, e.nnabengali = 2467, e.nnadeva = 2339, e.nnagujarati = 2723, e.nnagurmukhi = 2595, e.nnnadeva = 2345, e.nohiragana = 12398, e.nokatakana = 12494, e.nokatakanahalfwidth = 65417, e.nonbreakingspace = 160, e.nonenthai = 3603, e.nonuthai = 3609, e.noonarabic = 1606, e.noonfinalarabic = 65254, e.noonghunnaarabic = 1722, e.noonghunnafinalarabic = 64415, e.nooninitialarabic = 65255, e.noonjeeminitialarabic = 64722, e.noonjeemisolatedarabic = 64587, e.noonmedialarabic = 65256, e.noonmeeminitialarabic = 64725, e.noonmeemisolatedarabic = 64590, e.noonnoonfinalarabic = 64653, e.notcontains = 8716, e.notelement = 8713, e.notelementof = 8713, e.notequal = 8800, e.notgreater = 8815, e.notgreaternorequal = 8817, e.notgreaternorless = 8825, e.notidentical = 8802, e.notless = 8814, e.notlessnorequal = 8816, e.notparallel = 8742, e.notprecedes = 8832, e.notsubset = 8836, e.notsucceeds = 8833, e.notsuperset = 8837, e.nowarmenian = 1398, e.nparen = 9385, e.nssquare = 13233, e.nsuperior = 8319, e.ntilde = 241, e.nu = 957, e.nuhiragana = 12396, e.nukatakana = 12492, e.nukatakanahalfwidth = 65415, e.nuktabengali = 2492, e.nuktadeva = 2364, e.nuktagujarati = 2748, e.nuktagurmukhi = 2620, e.numbersign = 35, e.numbersignmonospace = 65283, e.numbersignsmall = 65119, e.numeralsigngreek = 884, e.numeralsignlowergreek = 885, e.numero = 8470, e.nun = 1504, e.nundagesh = 64320, e.nundageshhebrew = 64320, e.nunhebrew = 1504, e.nvsquare = 13237, e.nwsquare = 13243, e.nyabengali = 2462, e.nyadeva = 2334, e.nyagujarati = 2718, e.nyagurmukhi = 2590, e.o = 111, e.oacute = 243, e.oangthai = 3629, e.obarred = 629, e.obarredcyrillic = 1257, e.obarreddieresiscyrillic = 1259, e.obengali = 2451, e.obopomofo = 12571, e.obreve = 335, e.ocandradeva = 2321, e.ocandragujarati = 2705, e.ocandravowelsigndeva = 2377, e.ocandravowelsigngujarati = 2761, e.ocaron = 466, e.ocircle = 9438, e.ocircumflex = 244, e.ocircumflexacute = 7889, e.ocircumflexdotbelow = 7897, e.ocircumflexgrave = 7891, e.ocircumflexhookabove = 7893, e.ocircumflextilde = 7895, e.ocyrillic = 1086, e.odblacute = 337, e.odblgrave = 525, e.odeva = 2323, e.odieresis = 246, e.odieresiscyrillic = 1255, e.odotbelow = 7885, e.oe = 339, e.oekorean = 12634, e.ogonek = 731, e.ogonekcmb = 808, e.ograve = 242, e.ogujarati = 2707, e.oharmenian = 1413, e.ohiragana = 12362, e.ohookabove = 7887, e.ohorn = 417, e.ohornacute = 7899, e.ohorndotbelow = 7907, e.ohorngrave = 7901, e.ohornhookabove = 7903, e.ohorntilde = 7905, e.ohungarumlaut = 337, e.oi = 419, e.oinvertedbreve = 527, e.okatakana = 12458, e.okatakanahalfwidth = 65397, e.okorean = 12631, e.olehebrew = 1451, e.omacron = 333, e.omacronacute = 7763, e.omacrongrave = 7761, e.omdeva = 2384, e.omega = 969, e.omega1 = 982, e.omegacyrillic = 1121, e.omegalatinclosed = 631, e.omegaroundcyrillic = 1147, e.omegatitlocyrillic = 1149, e.omegatonos = 974, e.omgujarati = 2768, e.omicron = 959, e.omicrontonos = 972, e.omonospace = 65359, e.one = 49, e.onearabic = 1633, e.onebengali = 2535, e.onecircle = 9312, e.onecircleinversesansserif = 10122, e.onedeva = 2407, e.onedotenleader = 8228, e.oneeighth = 8539, e.onefitted = 63196, e.onegujarati = 2791, e.onegurmukhi = 2663, e.onehackarabic = 1633, e.onehalf = 189, e.onehangzhou = 12321, e.oneideographicparen = 12832, e.oneinferior = 8321, e.onemonospace = 65297, e.onenumeratorbengali = 2548, e.oneoldstyle = 63281, e.oneparen = 9332, e.oneperiod = 9352, e.onepersian = 1777, e.onequarter = 188, e.oneroman = 8560, e.onesuperior = 185, e.onethai = 3665, e.onethird = 8531, e.oogonek = 491, e.oogonekmacron = 493, e.oogurmukhi = 2579, e.oomatragurmukhi = 2635, e.oopen = 596, e.oparen = 9386, e.openbullet = 9702, e.option = 8997, e.ordfeminine = 170, e.ordmasculine = 186, e.orthogonal = 8735, e.oshortdeva = 2322, e.oshortvowelsigndeva = 2378, e.oslash = 248, e.oslashacute = 511, e.osmallhiragana = 12361, e.osmallkatakana = 12457, e.osmallkatakanahalfwidth = 65387, e.ostrokeacute = 511, e.osuperior = 63216, e.otcyrillic = 1151, e.otilde = 245, e.otildeacute = 7757, e.otildedieresis = 7759, e.oubopomofo = 12577, e.overline = 8254, e.overlinecenterline = 65098, e.overlinecmb = 773, e.overlinedashed = 65097, e.overlinedblwavy = 65100, e.overlinewavy = 65099, e.overscore = 175, e.ovowelsignbengali = 2507, e.ovowelsigndeva = 2379, e.ovowelsigngujarati = 2763, e.p = 112, e.paampssquare = 13184, e.paasentosquare = 13099, e.pabengali = 2474, e.pacute = 7765, e.padeva = 2346, e.pagedown = 8671, e.pageup = 8670, e.pagujarati = 2730, e.pagurmukhi = 2602, e.pahiragana = 12401, e.paiyannoithai = 3631, e.pakatakana = 12497, e.palatalizationcyrilliccmb = 1156, e.palochkacyrillic = 1216, e.pansioskorean = 12671, e.paragraph = 182, e.parallel = 8741, e.parenleft = 40, e.parenleftaltonearabic = 64830, e.parenleftbt = 63725, e.parenleftex = 63724, e.parenleftinferior = 8333, e.parenleftmonospace = 65288, e.parenleftsmall = 65113, e.parenleftsuperior = 8317, e.parenlefttp = 63723, e.parenleftvertical = 65077, e.parenright = 41, e.parenrightaltonearabic = 64831, e.parenrightbt = 63736, e.parenrightex = 63735, e.parenrightinferior = 8334, e.parenrightmonospace = 65289, e.parenrightsmall = 65114, e.parenrightsuperior = 8318, e.parenrighttp = 63734, e.parenrightvertical = 65078, e.partialdiff = 8706, e.paseqhebrew = 1472, e.pashtahebrew = 1433, e.pasquare = 13225, e.patah = 1463, e.patah11 = 1463, e.patah1d = 1463, e.patah2a = 1463, e.patahhebrew = 1463, e.patahnarrowhebrew = 1463, e.patahquarterhebrew = 1463, e.patahwidehebrew = 1463, e.pazerhebrew = 1441, e.pbopomofo = 12550, e.pcircle = 9439, e.pdotaccent = 7767, e.pe = 1508, e.pecyrillic = 1087, e.pedagesh = 64324, e.pedageshhebrew = 64324, e.peezisquare = 13115, e.pefinaldageshhebrew = 64323, e.peharabic = 1662, e.peharmenian = 1402, e.pehebrew = 1508, e.pehfinalarabic = 64343, e.pehinitialarabic = 64344, e.pehiragana = 12410, e.pehmedialarabic = 64345, e.pekatakana = 12506, e.pemiddlehookcyrillic = 1191, e.perafehebrew = 64334, e.percent = 37, e.percentarabic = 1642, e.percentmonospace = 65285, e.percentsmall = 65130, e.period = 46, e.periodarmenian = 1417, e.periodcentered = 183, e.periodhalfwidth = 65377, e.periodinferior = 63207, e.periodmonospace = 65294, e.periodsmall = 65106, e.periodsuperior = 63208, e.perispomenigreekcmb = 834, e.perpendicular = 8869, e.perthousand = 8240, e.peseta = 8359, e.pfsquare = 13194, e.phabengali = 2475, e.phadeva = 2347, e.phagujarati = 2731, e.phagurmukhi = 2603, e.phi = 966, e.phi1 = 981, e.phieuphacirclekorean = 12922, e.phieuphaparenkorean = 12826, e.phieuphcirclekorean = 12908, e.phieuphkorean = 12621, e.phieuphparenkorean = 12812, e.philatin = 632, e.phinthuthai = 3642, e.phisymbolgreek = 981, e.phook = 421, e.phophanthai = 3614, e.phophungthai = 3612, e.phosamphaothai = 3616, e.pi = 960, e.pieupacirclekorean = 12915, e.pieupaparenkorean = 12819, e.pieupcieuckorean = 12662, e.pieupcirclekorean = 12901, e.pieupkiyeokkorean = 12658, e.pieupkorean = 12610, e.pieupparenkorean = 12805, e.pieupsioskiyeokkorean = 12660, e.pieupsioskorean = 12612, e.pieupsiostikeutkorean = 12661, e.pieupthieuthkorean = 12663, e.pieuptikeutkorean = 12659, e.pihiragana = 12404, e.pikatakana = 12500, e.pisymbolgreek = 982, e.piwrarmenian = 1411, e.planckover2pi = 8463, e.planckover2pi1 = 8463, e.plus = 43, e.plusbelowcmb = 799, e.pluscircle = 8853, e.plusminus = 177, e.plusmod = 726, e.plusmonospace = 65291, e.plussmall = 65122, e.plussuperior = 8314, e.pmonospace = 65360, e.pmsquare = 13272, e.pohiragana = 12413, e.pointingindexdownwhite = 9759, e.pointingindexleftwhite = 9756, e.pointingindexrightwhite = 9758, e.pointingindexupwhite = 9757, e.pokatakana = 12509, e.poplathai = 3611, e.postalmark = 12306, e.postalmarkface = 12320, e.pparen = 9387, e.precedes = 8826, e.prescription = 8478, e.primemod = 697, e.primereversed = 8245, e.product = 8719, e.projective = 8965, e.prolongedkana = 12540, e.propellor = 8984, e.propersubset = 8834, e.propersuperset = 8835, e.proportion = 8759, e.proportional = 8733, e.psi = 968, e.psicyrillic = 1137, e.psilipneumatacyrilliccmb = 1158, e.pssquare = 13232, e.puhiragana = 12407, e.pukatakana = 12503, e.pvsquare = 13236, e.pwsquare = 13242, e.q = 113, e.qadeva = 2392, e.qadmahebrew = 1448, e.qafarabic = 1602, e.qaffinalarabic = 65238, e.qafinitialarabic = 65239, e.qafmedialarabic = 65240, e.qamats = 1464, e.qamats10 = 1464, e.qamats1a = 1464, e.qamats1c = 1464, e.qamats27 = 1464, e.qamats29 = 1464, e.qamats33 = 1464, e.qamatsde = 1464, e.qamatshebrew = 1464, e.qamatsnarrowhebrew = 1464, e.qamatsqatanhebrew = 1464, e.qamatsqatannarrowhebrew = 1464, e.qamatsqatanquarterhebrew = 1464, e.qamatsqatanwidehebrew = 1464, e.qamatsquarterhebrew = 1464, e.qamatswidehebrew = 1464, e.qarneyparahebrew = 1439, e.qbopomofo = 12561, e.qcircle = 9440, e.qhook = 672, e.qmonospace = 65361, e.qof = 1511, e.qofdagesh = 64327, e.qofdageshhebrew = 64327, e.qofhebrew = 1511, e.qparen = 9388, e.quarternote = 9833, e.qubuts = 1467, e.qubuts18 = 1467, e.qubuts25 = 1467, e.qubuts31 = 1467, e.qubutshebrew = 1467, e.qubutsnarrowhebrew = 1467, e.qubutsquarterhebrew = 1467, e.qubutswidehebrew = 1467, e.question = 63, e.questionarabic = 1567, e.questionarmenian = 1374, e.questiondown = 191, e.questiondownsmall = 63423, e.questiongreek = 894, e.questionmonospace = 65311, e.questionsmall = 63295, e.quotedbl = 34, e.quotedblbase = 8222, e.quotedblleft = 8220, e.quotedblmonospace = 65282, e.quotedblprime = 12318, e.quotedblprimereversed = 12317, e.quotedblright = 8221, e.quoteleft = 8216, e.quoteleftreversed = 8219, e.quotereversed = 8219, e.quoteright = 8217, e.quoterightn = 329, e.quotesinglbase = 8218, e.quotesingle = 39, e.quotesinglemonospace = 65287, e.r = 114, e.raarmenian = 1404, e.rabengali = 2480, e.racute = 341, e.radeva = 2352, e.radical = 8730, e.radicalex = 63717, e.radoverssquare = 13230, e.radoverssquaredsquare = 13231, e.radsquare = 13229, e.rafe = 1471, e.rafehebrew = 1471, e.ragujarati = 2736, e.ragurmukhi = 2608, e.rahiragana = 12425, e.rakatakana = 12521, e.rakatakanahalfwidth = 65431, e.ralowerdiagonalbengali = 2545, e.ramiddlediagonalbengali = 2544, e.ramshorn = 612, e.ratio = 8758, e.rbopomofo = 12566, e.rcaron = 345, e.rcedilla = 343, e.rcircle = 9441, e.rcommaaccent = 343, e.rdblgrave = 529, e.rdotaccent = 7769, e.rdotbelow = 7771, e.rdotbelowmacron = 7773, e.referencemark = 8251, e.reflexsubset = 8838, e.reflexsuperset = 8839, e.registered = 174, e.registersans = 63720, e.registerserif = 63194, e.reharabic = 1585, e.reharmenian = 1408, e.rehfinalarabic = 65198, e.rehiragana = 12428, e.rekatakana = 12524, e.rekatakanahalfwidth = 65434, e.resh = 1512, e.reshdageshhebrew = 64328, e.reshhebrew = 1512, e.reversedtilde = 8765, e.reviahebrew = 1431, e.reviamugrashhebrew = 1431, e.revlogicalnot = 8976, e.rfishhook = 638, e.rfishhookreversed = 639, e.rhabengali = 2525, e.rhadeva = 2397, e.rho = 961, e.rhook = 637, e.rhookturned = 635, e.rhookturnedsuperior = 693, e.rhosymbolgreek = 1009, e.rhotichookmod = 734, e.rieulacirclekorean = 12913, e.rieulaparenkorean = 12817, e.rieulcirclekorean = 12899, e.rieulhieuhkorean = 12608, e.rieulkiyeokkorean = 12602, e.rieulkiyeoksioskorean = 12649, e.rieulkorean = 12601, e.rieulmieumkorean = 12603, e.rieulpansioskorean = 12652, e.rieulparenkorean = 12803, e.rieulphieuphkorean = 12607, e.rieulpieupkorean = 12604, e.rieulpieupsioskorean = 12651, e.rieulsioskorean = 12605, e.rieulthieuthkorean = 12606, e.rieultikeutkorean = 12650, e.rieulyeorinhieuhkorean = 12653, e.rightangle = 8735, e.righttackbelowcmb = 793, e.righttriangle = 8895, e.rihiragana = 12426, e.rikatakana = 12522, e.rikatakanahalfwidth = 65432, e.ring = 730, e.ringbelowcmb = 805, e.ringcmb = 778, e.ringhalfleft = 703, e.ringhalfleftarmenian = 1369, e.ringhalfleftbelowcmb = 796, e.ringhalfleftcentered = 723, e.ringhalfright = 702, e.ringhalfrightbelowcmb = 825, e.ringhalfrightcentered = 722, e.rinvertedbreve = 531, e.rittorusquare = 13137, e.rlinebelow = 7775, e.rlongleg = 636, e.rlonglegturned = 634, e.rmonospace = 65362, e.rohiragana = 12429, e.rokatakana = 12525, e.rokatakanahalfwidth = 65435, e.roruathai = 3619, e.rparen = 9389, e.rrabengali = 2524, e.rradeva = 2353, e.rragurmukhi = 2652, e.rreharabic = 1681, e.rrehfinalarabic = 64397, e.rrvocalicbengali = 2528, e.rrvocalicdeva = 2400, e.rrvocalicgujarati = 2784, e.rrvocalicvowelsignbengali = 2500, e.rrvocalicvowelsigndeva = 2372, e.rrvocalicvowelsigngujarati = 2756, e.rsuperior = 63217, e.rtblock = 9616, e.rturned = 633, e.rturnedsuperior = 692, e.ruhiragana = 12427, e.rukatakana = 12523, e.rukatakanahalfwidth = 65433, e.rupeemarkbengali = 2546, e.rupeesignbengali = 2547, e.rupiah = 63197, e.ruthai = 3620, e.rvocalicbengali = 2443, e.rvocalicdeva = 2315, e.rvocalicgujarati = 2699, e.rvocalicvowelsignbengali = 2499, e.rvocalicvowelsigndeva = 2371, e.rvocalicvowelsigngujarati = 2755, e.s = 115, e.sabengali = 2488, e.sacute = 347, e.sacutedotaccent = 7781, e.sadarabic = 1589, e.sadeva = 2360, e.sadfinalarabic = 65210, e.sadinitialarabic = 65211, e.sadmedialarabic = 65212, e.sagujarati = 2744, e.sagurmukhi = 2616, e.sahiragana = 12373, e.sakatakana = 12469, e.sakatakanahalfwidth = 65403, e.sallallahoualayhewasallamarabic = 65018, e.samekh = 1505, e.samekhdagesh = 64321, e.samekhdageshhebrew = 64321, e.samekhhebrew = 1505, e.saraaathai = 3634, e.saraaethai = 3649, e.saraaimaimalaithai = 3652, e.saraaimaimuanthai = 3651, e.saraamthai = 3635, e.saraathai = 3632, e.saraethai = 3648, e.saraiileftthai = 63622, e.saraiithai = 3637, e.saraileftthai = 63621, e.saraithai = 3636, e.saraothai = 3650, e.saraueeleftthai = 63624, e.saraueethai = 3639, e.saraueleftthai = 63623, e.sarauethai = 3638, e.sarauthai = 3640, e.sarauuthai = 3641, e.sbopomofo = 12569, e.scaron = 353, e.scarondotaccent = 7783, e.scedilla = 351, e.schwa = 601, e.schwacyrillic = 1241, e.schwadieresiscyrillic = 1243, e.schwahook = 602, e.scircle = 9442, e.scircumflex = 349, e.scommaaccent = 537, e.sdotaccent = 7777, e.sdotbelow = 7779, e.sdotbelowdotaccent = 7785, e.seagullbelowcmb = 828, e.second = 8243, e.secondtonechinese = 714, e.section = 167, e.seenarabic = 1587, e.seenfinalarabic = 65202, e.seeninitialarabic = 65203, e.seenmedialarabic = 65204, e.segol = 1462, e.segol13 = 1462, e.segol1f = 1462, e.segol2c = 1462, e.segolhebrew = 1462, e.segolnarrowhebrew = 1462, e.segolquarterhebrew = 1462, e.segoltahebrew = 1426, e.segolwidehebrew = 1462, e.seharmenian = 1405, e.sehiragana = 12379, e.sekatakana = 12475, e.sekatakanahalfwidth = 65406, e.semicolon = 59, e.semicolonarabic = 1563, e.semicolonmonospace = 65307, e.semicolonsmall = 65108, e.semivoicedmarkkana = 12444, e.semivoicedmarkkanahalfwidth = 65439, e.sentisquare = 13090, e.sentosquare = 13091, e.seven = 55, e.sevenarabic = 1639, e.sevenbengali = 2541, e.sevencircle = 9318, e.sevencircleinversesansserif = 10128, e.sevendeva = 2413, e.seveneighths = 8542, e.sevengujarati = 2797, e.sevengurmukhi = 2669, e.sevenhackarabic = 1639, e.sevenhangzhou = 12327, e.sevenideographicparen = 12838, e.seveninferior = 8327, e.sevenmonospace = 65303, e.sevenoldstyle = 63287, e.sevenparen = 9338, e.sevenperiod = 9358, e.sevenpersian = 1783, e.sevenroman = 8566, e.sevensuperior = 8311, e.seventeencircle = 9328, e.seventeenparen = 9348, e.seventeenperiod = 9368, e.seventhai = 3671, e.sfthyphen = 173, e.shaarmenian = 1399, e.shabengali = 2486, e.shacyrillic = 1096, e.shaddaarabic = 1617, e.shaddadammaarabic = 64609, e.shaddadammatanarabic = 64606, e.shaddafathaarabic = 64608, e.shaddakasraarabic = 64610, e.shaddakasratanarabic = 64607, e.shade = 9618, e.shadedark = 9619, e.shadelight = 9617, e.shademedium = 9618, e.shadeva = 2358, e.shagujarati = 2742, e.shagurmukhi = 2614, e.shalshelethebrew = 1427, e.shbopomofo = 12565, e.shchacyrillic = 1097, e.sheenarabic = 1588, e.sheenfinalarabic = 65206, e.sheeninitialarabic = 65207, e.sheenmedialarabic = 65208, e.sheicoptic = 995, e.sheqel = 8362, e.sheqelhebrew = 8362, e.sheva = 1456, e.sheva115 = 1456, e.sheva15 = 1456, e.sheva22 = 1456, e.sheva2e = 1456, e.shevahebrew = 1456, e.shevanarrowhebrew = 1456, e.shevaquarterhebrew = 1456, e.shevawidehebrew = 1456, e.shhacyrillic = 1211, e.shimacoptic = 1005, e.shin = 1513, e.shindagesh = 64329, e.shindageshhebrew = 64329, e.shindageshshindot = 64300, e.shindageshshindothebrew = 64300, e.shindageshsindot = 64301, e.shindageshsindothebrew = 64301, e.shindothebrew = 1473, e.shinhebrew = 1513, e.shinshindot = 64298, e.shinshindothebrew = 64298, e.shinsindot = 64299, e.shinsindothebrew = 64299, e.shook = 642, e.sigma = 963, e.sigma1 = 962, e.sigmafinal = 962, e.sigmalunatesymbolgreek = 1010, e.sihiragana = 12375, e.sikatakana = 12471, e.sikatakanahalfwidth = 65404, e.siluqhebrew = 1469, e.siluqlefthebrew = 1469, e.similar = 8764, e.sindothebrew = 1474, e.siosacirclekorean = 12916, e.siosaparenkorean = 12820, e.sioscieuckorean = 12670, e.sioscirclekorean = 12902, e.sioskiyeokkorean = 12666, e.sioskorean = 12613, e.siosnieunkorean = 12667, e.siosparenkorean = 12806, e.siospieupkorean = 12669, e.siostikeutkorean = 12668, e.six = 54, e.sixarabic = 1638, e.sixbengali = 2540, e.sixcircle = 9317, e.sixcircleinversesansserif = 10127, e.sixdeva = 2412, e.sixgujarati = 2796, e.sixgurmukhi = 2668, e.sixhackarabic = 1638, e.sixhangzhou = 12326, e.sixideographicparen = 12837, e.sixinferior = 8326, e.sixmonospace = 65302, e.sixoldstyle = 63286, e.sixparen = 9337, e.sixperiod = 9357, e.sixpersian = 1782, e.sixroman = 8565, e.sixsuperior = 8310, e.sixteencircle = 9327, e.sixteencurrencydenominatorbengali = 2553, e.sixteenparen = 9347, e.sixteenperiod = 9367, e.sixthai = 3670, e.slash = 47, e.slashmonospace = 65295, e.slong = 383, e.slongdotaccent = 7835, e.smileface = 9786, e.smonospace = 65363, e.sofpasuqhebrew = 1475, e.softhyphen = 173, e.softsigncyrillic = 1100, e.sohiragana = 12381, e.sokatakana = 12477, e.sokatakanahalfwidth = 65407, e.soliduslongoverlaycmb = 824, e.solidusshortoverlaycmb = 823, e.sorusithai = 3625, e.sosalathai = 3624, e.sosothai = 3595, e.sosuathai = 3626, e.space = 32, e.spacehackarabic = 32, e.spade = 9824, e.spadesuitblack = 9824, e.spadesuitwhite = 9828, e.sparen = 9390, e.squarebelowcmb = 827, e.squarecc = 13252, e.squarecm = 13213, e.squarediagonalcrosshatchfill = 9641, e.squarehorizontalfill = 9636, e.squarekg = 13199, e.squarekm = 13214, e.squarekmcapital = 13262, e.squareln = 13265, e.squarelog = 13266, e.squaremg = 13198, e.squaremil = 13269, e.squaremm = 13212, e.squaremsquared = 13217, e.squareorthogonalcrosshatchfill = 9638, e.squareupperlefttolowerrightfill = 9639, e.squareupperrighttolowerleftfill = 9640, e.squareverticalfill = 9637, e.squarewhitewithsmallblack = 9635, e.srsquare = 13275, e.ssabengali = 2487, e.ssadeva = 2359, e.ssagujarati = 2743, e.ssangcieuckorean = 12617, e.ssanghieuhkorean = 12677, e.ssangieungkorean = 12672, e.ssangkiyeokkorean = 12594, e.ssangnieunkorean = 12645, e.ssangpieupkorean = 12611, e.ssangsioskorean = 12614, e.ssangtikeutkorean = 12600, e.ssuperior = 63218, e.sterling = 163, e.sterlingmonospace = 65505, e.strokelongoverlaycmb = 822, e.strokeshortoverlaycmb = 821, e.subset = 8834, e.subsetnotequal = 8842, e.subsetorequal = 8838, e.succeeds = 8827, e.suchthat = 8715, e.suhiragana = 12377, e.sukatakana = 12473, e.sukatakanahalfwidth = 65405, e.sukunarabic = 1618, e.summation = 8721, e.sun = 9788, e.superset = 8835, e.supersetnotequal = 8843, e.supersetorequal = 8839, e.svsquare = 13276, e.syouwaerasquare = 13180, e.t = 116, e.tabengali = 2468, e.tackdown = 8868, e.tackleft = 8867, e.tadeva = 2340, e.tagujarati = 2724, e.tagurmukhi = 2596, e.taharabic = 1591, e.tahfinalarabic = 65218, e.tahinitialarabic = 65219, e.tahiragana = 12383, e.tahmedialarabic = 65220, e.taisyouerasquare = 13181, e.takatakana = 12479, e.takatakanahalfwidth = 65408, e.tatweelarabic = 1600, e.tau = 964, e.tav = 1514, e.tavdages = 64330, e.tavdagesh = 64330, e.tavdageshhebrew = 64330, e.tavhebrew = 1514, e.tbar = 359, e.tbopomofo = 12554, e.tcaron = 357, e.tccurl = 680, e.tcedilla = 355, e.tcheharabic = 1670, e.tchehfinalarabic = 64379, e.tchehinitialarabic = 64380, e.tchehmedialarabic = 64381, e.tcircle = 9443, e.tcircumflexbelow = 7793, e.tcommaaccent = 355, e.tdieresis = 7831, e.tdotaccent = 7787, e.tdotbelow = 7789, e.tecyrillic = 1090, e.tedescendercyrillic = 1197, e.teharabic = 1578, e.tehfinalarabic = 65174, e.tehhahinitialarabic = 64674, e.tehhahisolatedarabic = 64524, e.tehinitialarabic = 65175, e.tehiragana = 12390, e.tehjeeminitialarabic = 64673, e.tehjeemisolatedarabic = 64523, e.tehmarbutaarabic = 1577, e.tehmarbutafinalarabic = 65172, e.tehmedialarabic = 65176, e.tehmeeminitialarabic = 64676, e.tehmeemisolatedarabic = 64526, e.tehnoonfinalarabic = 64627, e.tekatakana = 12486, e.tekatakanahalfwidth = 65411, e.telephone = 8481, e.telephoneblack = 9742, e.telishagedolahebrew = 1440, e.telishaqetanahebrew = 1449, e.tencircle = 9321, e.tenideographicparen = 12841, e.tenparen = 9341, e.tenperiod = 9361, e.tenroman = 8569, e.tesh = 679, e.tet = 1496, e.tetdagesh = 64312, e.tetdageshhebrew = 64312, e.tethebrew = 1496, e.tetsecyrillic = 1205, e.tevirhebrew = 1435, e.tevirlefthebrew = 1435, e.thabengali = 2469, e.thadeva = 2341, e.thagujarati = 2725, e.thagurmukhi = 2597, e.thalarabic = 1584, e.thalfinalarabic = 65196, e.thanthakhatlowleftthai = 63640, e.thanthakhatlowrightthai = 63639, e.thanthakhatthai = 3660, e.thanthakhatupperleftthai = 63638, e.theharabic = 1579, e.thehfinalarabic = 65178, e.thehinitialarabic = 65179, e.thehmedialarabic = 65180, e.thereexists = 8707, e.therefore = 8756, e.theta = 952, e.theta1 = 977, e.thetasymbolgreek = 977, e.thieuthacirclekorean = 12921, e.thieuthaparenkorean = 12825, e.thieuthcirclekorean = 12907, e.thieuthkorean = 12620, e.thieuthparenkorean = 12811, e.thirteencircle = 9324, e.thirteenparen = 9344, e.thirteenperiod = 9364, e.thonangmonthothai = 3601, e.thook = 429, e.thophuthaothai = 3602, e.thorn = 254, e.thothahanthai = 3607, e.thothanthai = 3600, e.thothongthai = 3608, e.thothungthai = 3606, e.thousandcyrillic = 1154, e.thousandsseparatorarabic = 1644, e.thousandsseparatorpersian = 1644, e.three = 51, e.threearabic = 1635, e.threebengali = 2537, e.threecircle = 9314, e.threecircleinversesansserif = 10124, e.threedeva = 2409, e.threeeighths = 8540, e.threegujarati = 2793, e.threegurmukhi = 2665, e.threehackarabic = 1635, e.threehangzhou = 12323, e.threeideographicparen = 12834, e.threeinferior = 8323, e.threemonospace = 65299, e.threenumeratorbengali = 2550, e.threeoldstyle = 63283, e.threeparen = 9334, e.threeperiod = 9354, e.threepersian = 1779, e.threequarters = 190, e.threequartersemdash = 63198, e.threeroman = 8562, e.threesuperior = 179, e.threethai = 3667, e.thzsquare = 13204, e.tihiragana = 12385, e.tikatakana = 12481, e.tikatakanahalfwidth = 65409, e.tikeutacirclekorean = 12912, e.tikeutaparenkorean = 12816, e.tikeutcirclekorean = 12898, e.tikeutkorean = 12599, e.tikeutparenkorean = 12802, e.tilde = 732, e.tildebelowcmb = 816, e.tildecmb = 771, e.tildecomb = 771, e.tildedoublecmb = 864, e.tildeoperator = 8764, e.tildeoverlaycmb = 820, e.tildeverticalcmb = 830, e.timescircle = 8855, e.tipehahebrew = 1430, e.tipehalefthebrew = 1430, e.tippigurmukhi = 2672, e.titlocyrilliccmb = 1155, e.tiwnarmenian = 1407, e.tlinebelow = 7791, e.tmonospace = 65364, e.toarmenian = 1385, e.tohiragana = 12392, e.tokatakana = 12488, e.tokatakanahalfwidth = 65412, e.tonebarextrahighmod = 741, e.tonebarextralowmod = 745, e.tonebarhighmod = 742, e.tonebarlowmod = 744, e.tonebarmidmod = 743, e.tonefive = 445, e.tonesix = 389, e.tonetwo = 424, e.tonos = 900, e.tonsquare = 13095, e.topatakthai = 3599, e.tortoiseshellbracketleft = 12308, e.tortoiseshellbracketleftsmall = 65117, e.tortoiseshellbracketleftvertical = 65081, e.tortoiseshellbracketright = 12309, e.tortoiseshellbracketrightsmall = 65118, e.tortoiseshellbracketrightvertical = 65082, e.totaothai = 3605, e.tpalatalhook = 427, e.tparen = 9391, e.trademark = 8482, e.trademarksans = 63722, e.trademarkserif = 63195, e.tretroflexhook = 648, e.triagdn = 9660, e.triaglf = 9668, e.triagrt = 9658, e.triagup = 9650, e.ts = 678, e.tsadi = 1510, e.tsadidagesh = 64326, e.tsadidageshhebrew = 64326, e.tsadihebrew = 1510, e.tsecyrillic = 1094, e.tsere = 1461, e.tsere12 = 1461, e.tsere1e = 1461, e.tsere2b = 1461, e.tserehebrew = 1461, e.tserenarrowhebrew = 1461, e.tserequarterhebrew = 1461, e.tserewidehebrew = 1461, e.tshecyrillic = 1115, e.tsuperior = 63219, e.ttabengali = 2463, e.ttadeva = 2335, e.ttagujarati = 2719, e.ttagurmukhi = 2591, e.tteharabic = 1657, e.ttehfinalarabic = 64359, e.ttehinitialarabic = 64360, e.ttehmedialarabic = 64361, e.tthabengali = 2464, e.tthadeva = 2336, e.tthagujarati = 2720, e.tthagurmukhi = 2592, e.tturned = 647, e.tuhiragana = 12388, e.tukatakana = 12484, e.tukatakanahalfwidth = 65410, e.tusmallhiragana = 12387, e.tusmallkatakana = 12483, e.tusmallkatakanahalfwidth = 65391, e.twelvecircle = 9323, e.twelveparen = 9343, e.twelveperiod = 9363, e.twelveroman = 8571, e.twentycircle = 9331, e.twentyhangzhou = 21316, e.twentyparen = 9351, e.twentyperiod = 9371, e.two = 50, e.twoarabic = 1634, e.twobengali = 2536, e.twocircle = 9313, e.twocircleinversesansserif = 10123, e.twodeva = 2408, e.twodotenleader = 8229, e.twodotleader = 8229, e.twodotleadervertical = 65072, e.twogujarati = 2792, e.twogurmukhi = 2664, e.twohackarabic = 1634, e.twohangzhou = 12322, e.twoideographicparen = 12833, e.twoinferior = 8322, e.twomonospace = 65298, e.twonumeratorbengali = 2549, e.twooldstyle = 63282, e.twoparen = 9333, e.twoperiod = 9353, e.twopersian = 1778, e.tworoman = 8561, e.twostroke = 443, e.twosuperior = 178, e.twothai = 3666, e.twothirds = 8532, e.u = 117, e.uacute = 250, e.ubar = 649, e.ubengali = 2441, e.ubopomofo = 12584, e.ubreve = 365, e.ucaron = 468, e.ucircle = 9444, e.ucircumflex = 251, e.ucircumflexbelow = 7799, e.ucyrillic = 1091, e.udattadeva = 2385, e.udblacute = 369, e.udblgrave = 533, e.udeva = 2313, e.udieresis = 252, e.udieresisacute = 472, e.udieresisbelow = 7795, e.udieresiscaron = 474, e.udieresiscyrillic = 1265, e.udieresisgrave = 476, e.udieresismacron = 470, e.udotbelow = 7909, e.ugrave = 249, e.ugujarati = 2697, e.ugurmukhi = 2569, e.uhiragana = 12358, e.uhookabove = 7911, e.uhorn = 432, e.uhornacute = 7913, e.uhorndotbelow = 7921, e.uhorngrave = 7915, e.uhornhookabove = 7917, e.uhorntilde = 7919, e.uhungarumlaut = 369, e.uhungarumlautcyrillic = 1267, e.uinvertedbreve = 535, e.ukatakana = 12454, e.ukatakanahalfwidth = 65395, e.ukcyrillic = 1145, e.ukorean = 12636, e.umacron = 363, e.umacroncyrillic = 1263, e.umacrondieresis = 7803, e.umatragurmukhi = 2625, e.umonospace = 65365, e.underscore = 95, e.underscoredbl = 8215, e.underscoremonospace = 65343, e.underscorevertical = 65075, e.underscorewavy = 65103, e.union = 8746, e.universal = 8704, e.uogonek = 371, e.uparen = 9392, e.upblock = 9600, e.upperdothebrew = 1476, e.upsilon = 965, e.upsilondieresis = 971, e.upsilondieresistonos = 944, e.upsilonlatin = 650, e.upsilontonos = 973, e.uptackbelowcmb = 797, e.uptackmod = 724, e.uragurmukhi = 2675, e.uring = 367, e.ushortcyrillic = 1118, e.usmallhiragana = 12357, e.usmallkatakana = 12453, e.usmallkatakanahalfwidth = 65385, e.ustraightcyrillic = 1199, e.ustraightstrokecyrillic = 1201, e.utilde = 361, e.utildeacute = 7801, e.utildebelow = 7797, e.uubengali = 2442, e.uudeva = 2314, e.uugujarati = 2698, e.uugurmukhi = 2570, e.uumatragurmukhi = 2626, e.uuvowelsignbengali = 2498, e.uuvowelsigndeva = 2370, e.uuvowelsigngujarati = 2754, e.uvowelsignbengali = 2497, e.uvowelsigndeva = 2369, e.uvowelsigngujarati = 2753, e.v = 118, e.vadeva = 2357, e.vagujarati = 2741, e.vagurmukhi = 2613, e.vakatakana = 12535, e.vav = 1493, e.vavdagesh = 64309, e.vavdagesh65 = 64309, e.vavdageshhebrew = 64309, e.vavhebrew = 1493, e.vavholam = 64331, e.vavholamhebrew = 64331, e.vavvavhebrew = 1520, e.vavyodhebrew = 1521, e.vcircle = 9445, e.vdotbelow = 7807, e.vecyrillic = 1074, e.veharabic = 1700, e.vehfinalarabic = 64363, e.vehinitialarabic = 64364, e.vehmedialarabic = 64365, e.vekatakana = 12537, e.venus = 9792, e.verticalbar = 124, e.verticallineabovecmb = 781, e.verticallinebelowcmb = 809, e.verticallinelowmod = 716, e.verticallinemod = 712, e.vewarmenian = 1406, e.vhook = 651, e.vikatakana = 12536, e.viramabengali = 2509, e.viramadeva = 2381, e.viramagujarati = 2765, e.visargabengali = 2435, e.visargadeva = 2307, e.visargagujarati = 2691, e.vmonospace = 65366, e.voarmenian = 1400, e.voicediterationhiragana = 12446, e.voicediterationkatakana = 12542, e.voicedmarkkana = 12443, e.voicedmarkkanahalfwidth = 65438, e.vokatakana = 12538, e.vparen = 9393, e.vtilde = 7805, e.vturned = 652, e.vuhiragana = 12436, e.vukatakana = 12532, e.w = 119, e.wacute = 7811, e.waekorean = 12633, e.wahiragana = 12431, e.wakatakana = 12527, e.wakatakanahalfwidth = 65436, e.wakorean = 12632, e.wasmallhiragana = 12430, e.wasmallkatakana = 12526, e.wattosquare = 13143, e.wavedash = 12316, e.wavyunderscorevertical = 65076, e.wawarabic = 1608, e.wawfinalarabic = 65262, e.wawhamzaabovearabic = 1572, e.wawhamzaabovefinalarabic = 65158, e.wbsquare = 13277, e.wcircle = 9446, e.wcircumflex = 373, e.wdieresis = 7813, e.wdotaccent = 7815, e.wdotbelow = 7817, e.wehiragana = 12433, e.weierstrass = 8472, e.wekatakana = 12529, e.wekorean = 12638, e.weokorean = 12637, e.wgrave = 7809, e.whitebullet = 9702, e.whitecircle = 9675, e.whitecircleinverse = 9689, e.whitecornerbracketleft = 12302, e.whitecornerbracketleftvertical = 65091, e.whitecornerbracketright = 12303, e.whitecornerbracketrightvertical = 65092, e.whitediamond = 9671, e.whitediamondcontainingblacksmalldiamond = 9672, e.whitedownpointingsmalltriangle = 9663, e.whitedownpointingtriangle = 9661, e.whiteleftpointingsmalltriangle = 9667, e.whiteleftpointingtriangle = 9665, e.whitelenticularbracketleft = 12310, e.whitelenticularbracketright = 12311, e.whiterightpointingsmalltriangle = 9657, e.whiterightpointingtriangle = 9655, e.whitesmallsquare = 9643, e.whitesmilingface = 9786, e.whitesquare = 9633, e.whitestar = 9734, e.whitetelephone = 9743, e.whitetortoiseshellbracketleft = 12312, e.whitetortoiseshellbracketright = 12313, e.whiteuppointingsmalltriangle = 9653, e.whiteuppointingtriangle = 9651, e.wihiragana = 12432, e.wikatakana = 12528, e.wikorean = 12639, e.wmonospace = 65367, e.wohiragana = 12434, e.wokatakana = 12530, e.wokatakanahalfwidth = 65382, e.won = 8361, e.wonmonospace = 65510, e.wowaenthai = 3623, e.wparen = 9394, e.wring = 7832, e.wsuperior = 695, e.wturned = 653, e.wynn = 447, e.x = 120, e.xabovecmb = 829, e.xbopomofo = 12562, e.xcircle = 9447, e.xdieresis = 7821, e.xdotaccent = 7819, e.xeharmenian = 1389, e.xi = 958, e.xmonospace = 65368, e.xparen = 9395, e.xsuperior = 739, e.y = 121, e.yaadosquare = 13134, e.yabengali = 2479, e.yacute = 253, e.yadeva = 2351, e.yaekorean = 12626, e.yagujarati = 2735, e.yagurmukhi = 2607, e.yahiragana = 12420, e.yakatakana = 12516, e.yakatakanahalfwidth = 65428, e.yakorean = 12625, e.yamakkanthai = 3662, e.yasmallhiragana = 12419, e.yasmallkatakana = 12515, e.yasmallkatakanahalfwidth = 65388, e.yatcyrillic = 1123, e.ycircle = 9448, e.ycircumflex = 375, e.ydieresis = 255, e.ydotaccent = 7823, e.ydotbelow = 7925, e.yeharabic = 1610, e.yehbarreearabic = 1746, e.yehbarreefinalarabic = 64431, e.yehfinalarabic = 65266, e.yehhamzaabovearabic = 1574, e.yehhamzaabovefinalarabic = 65162, e.yehhamzaaboveinitialarabic = 65163, e.yehhamzaabovemedialarabic = 65164, e.yehinitialarabic = 65267, e.yehmedialarabic = 65268, e.yehmeeminitialarabic = 64733, e.yehmeemisolatedarabic = 64600, e.yehnoonfinalarabic = 64660, e.yehthreedotsbelowarabic = 1745, e.yekorean = 12630, e.yen = 165, e.yenmonospace = 65509, e.yeokorean = 12629, e.yeorinhieuhkorean = 12678, e.yerahbenyomohebrew = 1450, e.yerahbenyomolefthebrew = 1450, e.yericyrillic = 1099, e.yerudieresiscyrillic = 1273, e.yesieungkorean = 12673, e.yesieungpansioskorean = 12675, e.yesieungsioskorean = 12674, e.yetivhebrew = 1434, e.ygrave = 7923, e.yhook = 436, e.yhookabove = 7927, e.yiarmenian = 1397, e.yicyrillic = 1111, e.yikorean = 12642, e.yinyang = 9775, e.yiwnarmenian = 1410, e.ymonospace = 65369, e.yod = 1497, e.yoddagesh = 64313, e.yoddageshhebrew = 64313, e.yodhebrew = 1497, e.yodyodhebrew = 1522, e.yodyodpatahhebrew = 64287, e.yohiragana = 12424, e.yoikorean = 12681, e.yokatakana = 12520, e.yokatakanahalfwidth = 65430, e.yokorean = 12635, e.yosmallhiragana = 12423, e.yosmallkatakana = 12519, e.yosmallkatakanahalfwidth = 65390, e.yotgreek = 1011, e.yoyaekorean = 12680, e.yoyakorean = 12679, e.yoyakthai = 3618, e.yoyingthai = 3597, e.yparen = 9396, e.ypogegrammeni = 890, e.ypogegrammenigreekcmb = 837, e.yr = 422, e.yring = 7833, e.ysuperior = 696, e.ytilde = 7929, e.yturned = 654, e.yuhiragana = 12422, e.yuikorean = 12684, e.yukatakana = 12518, e.yukatakanahalfwidth = 65429, e.yukorean = 12640, e.yusbigcyrillic = 1131, e.yusbigiotifiedcyrillic = 1133, e.yuslittlecyrillic = 1127, e.yuslittleiotifiedcyrillic = 1129, e.yusmallhiragana = 12421, e.yusmallkatakana = 12517, e.yusmallkatakanahalfwidth = 65389, e.yuyekorean = 12683, e.yuyeokorean = 12682, e.yyabengali = 2527, e.yyadeva = 2399, e.z = 122, e.zaarmenian = 1382, e.zacute = 378, e.zadeva = 2395, e.zagurmukhi = 2651, e.zaharabic = 1592, e.zahfinalarabic = 65222, e.zahinitialarabic = 65223, e.zahiragana = 12374, e.zahmedialarabic = 65224, e.zainarabic = 1586, e.zainfinalarabic = 65200, e.zakatakana = 12470, e.zaqefgadolhebrew = 1429, e.zaqefqatanhebrew = 1428, e.zarqahebrew = 1432, e.zayin = 1494, e.zayindagesh = 64310, e.zayindageshhebrew = 64310, e.zayinhebrew = 1494, e.zbopomofo = 12567, e.zcaron = 382, e.zcircle = 9449, e.zcircumflex = 7825, e.zcurl = 657, e.zdot = 380, e.zdotaccent = 380, e.zdotbelow = 7827, e.zecyrillic = 1079, e.zedescendercyrillic = 1177, e.zedieresiscyrillic = 1247, e.zehiragana = 12380, e.zekatakana = 12476, e.zero = 48, e.zeroarabic = 1632, e.zerobengali = 2534, e.zerodeva = 2406, e.zerogujarati = 2790, e.zerogurmukhi = 2662, e.zerohackarabic = 1632, e.zeroinferior = 8320, e.zeromonospace = 65296, e.zerooldstyle = 63280, e.zeropersian = 1776, e.zerosuperior = 8304, e.zerothai = 3664, e.zerowidthjoiner = 65279, e.zerowidthnonjoiner = 8204, e.zerowidthspace = 8203, e.zeta = 950, e.zhbopomofo = 12563, e.zhearmenian = 1386, e.zhebrevecyrillic = 1218, e.zhecyrillic = 1078, e.zhedescendercyrillic = 1175, e.zhedieresiscyrillic = 1245, e.zihiragana = 12376, e.zikatakana = 12472, e.zinorhebrew = 1454, e.zlinebelow = 7829, e.zmonospace = 65370, e.zohiragana = 12382, e.zokatakana = 12478, e.zparen = 9397, e.zretroflexhook = 656, e.zstroke = 438, e.zuhiragana = 12378, e.zukatakana = 12474, e[".notdef"] = 0, e.angbracketleftbig = 9001, e.angbracketleftBig = 9001, e.angbracketleftbigg = 9001, e.angbracketleftBigg = 9001, e.angbracketrightBig = 9002, e.angbracketrightbig = 9002, e.angbracketrightBigg = 9002, e.angbracketrightbigg = 9002, e.arrowhookleft = 8618, e.arrowhookright = 8617, e.arrowlefttophalf = 8636, e.arrowleftbothalf = 8637, e.arrownortheast = 8599, e.arrownorthwest = 8598, e.arrowrighttophalf = 8640, e.arrowrightbothalf = 8641, e.arrowsoutheast = 8600, e.arrowsouthwest = 8601, e.backslashbig = 8726, e.backslashBig = 8726, e.backslashBigg = 8726, e.backslashbigg = 8726, e.bardbl = 8214, e.bracehtipdownleft = 65079, e.bracehtipdownright = 65079, e.bracehtipupleft = 65080, e.bracehtipupright = 65080, e.braceleftBig = 123, e.braceleftbig = 123, e.braceleftbigg = 123, e.braceleftBigg = 123, e.bracerightBig = 125, e.bracerightbig = 125, e.bracerightbigg = 125, e.bracerightBigg = 125, e.bracketleftbig = 91, e.bracketleftBig = 91, e.bracketleftbigg = 91, e.bracketleftBigg = 91, e.bracketrightBig = 93, e.bracketrightbig = 93, e.bracketrightbigg = 93, e.bracketrightBigg = 93, e.ceilingleftbig = 8968, e.ceilingleftBig = 8968, e.ceilingleftBigg = 8968, e.ceilingleftbigg = 8968, e.ceilingrightbig = 8969, e.ceilingrightBig = 8969, e.ceilingrightbigg = 8969, e.ceilingrightBigg = 8969, e.circledotdisplay = 8857, e.circledottext = 8857, e.circlemultiplydisplay = 8855, e.circlemultiplytext = 8855, e.circleplusdisplay = 8853, e.circleplustext = 8853, e.contintegraldisplay = 8750, e.contintegraltext = 8750, e.coproductdisplay = 8720, e.coproducttext = 8720, e.floorleftBig = 8970, e.floorleftbig = 8970, e.floorleftbigg = 8970, e.floorleftBigg = 8970, e.floorrightbig = 8971, e.floorrightBig = 8971, e.floorrightBigg = 8971, e.floorrightbigg = 8971, e.hatwide = 770, e.hatwider = 770, e.hatwidest = 770, e.intercal = 7488, e.integraldisplay = 8747, e.integraltext = 8747, e.intersectiondisplay = 8898, e.intersectiontext = 8898, e.logicalanddisplay = 8743, e.logicalandtext = 8743, e.logicalordisplay = 8744, e.logicalortext = 8744, e.parenleftBig = 40, e.parenleftbig = 40, e.parenleftBigg = 40, e.parenleftbigg = 40, e.parenrightBig = 41, e.parenrightbig = 41, e.parenrightBigg = 41, e.parenrightbigg = 41, e.prime = 8242, e.productdisplay = 8719, e.producttext = 8719, e.radicalbig = 8730, e.radicalBig = 8730, e.radicalBigg = 8730, e.radicalbigg = 8730, e.radicalbt = 8730, e.radicaltp = 8730, e.radicalvertex = 8730, e.slashbig = 47, e.slashBig = 47, e.slashBigg = 47, e.slashbigg = 47, e.summationdisplay = 8721, e.summationtext = 8721, e.tildewide = 732, e.tildewider = 732, e.tildewidest = 732, e.uniondisplay = 8899, e.unionmultidisplay = 8846, e.unionmultitext = 8846, e.unionsqdisplay = 8852, e.unionsqtext = 8852, e.uniontext = 8899, e.vextenddouble = 8741, e.vextendsingle = 8739;
          });
          b.getGlyphsUnicode = P;
          const D = (0, n.getLookupTableFactory)(function(e) {
            e.space = 32, e.a1 = 9985, e.a2 = 9986, e.a202 = 9987, e.a3 = 9988, e.a4 = 9742, e.a5 = 9990, e.a119 = 9991, e.a118 = 9992, e.a117 = 9993, e.a11 = 9755, e.a12 = 9758, e.a13 = 9996, e.a14 = 9997, e.a15 = 9998, e.a16 = 9999, e.a105 = 1e4, e.a17 = 10001, e.a18 = 10002, e.a19 = 10003, e.a20 = 10004, e.a21 = 10005, e.a22 = 10006, e.a23 = 10007, e.a24 = 10008, e.a25 = 10009, e.a26 = 10010, e.a27 = 10011, e.a28 = 10012, e.a6 = 10013, e.a7 = 10014, e.a8 = 10015, e.a9 = 10016, e.a10 = 10017, e.a29 = 10018, e.a30 = 10019, e.a31 = 10020, e.a32 = 10021, e.a33 = 10022, e.a34 = 10023, e.a35 = 9733, e.a36 = 10025, e.a37 = 10026, e.a38 = 10027, e.a39 = 10028, e.a40 = 10029, e.a41 = 10030, e.a42 = 10031, e.a43 = 10032, e.a44 = 10033, e.a45 = 10034, e.a46 = 10035, e.a47 = 10036, e.a48 = 10037, e.a49 = 10038, e.a50 = 10039, e.a51 = 10040, e.a52 = 10041, e.a53 = 10042, e.a54 = 10043, e.a55 = 10044, e.a56 = 10045, e.a57 = 10046, e.a58 = 10047, e.a59 = 10048, e.a60 = 10049, e.a61 = 10050, e.a62 = 10051, e.a63 = 10052, e.a64 = 10053, e.a65 = 10054, e.a66 = 10055, e.a67 = 10056, e.a68 = 10057, e.a69 = 10058, e.a70 = 10059, e.a71 = 9679, e.a72 = 10061, e.a73 = 9632, e.a74 = 10063, e.a203 = 10064, e.a75 = 10065, e.a204 = 10066, e.a76 = 9650, e.a77 = 9660, e.a78 = 9670, e.a79 = 10070, e.a81 = 9687, e.a82 = 10072, e.a83 = 10073, e.a84 = 10074, e.a97 = 10075, e.a98 = 10076, e.a99 = 10077, e.a100 = 10078, e.a101 = 10081, e.a102 = 10082, e.a103 = 10083, e.a104 = 10084, e.a106 = 10085, e.a107 = 10086, e.a108 = 10087, e.a112 = 9827, e.a111 = 9830, e.a110 = 9829, e.a109 = 9824, e.a120 = 9312, e.a121 = 9313, e.a122 = 9314, e.a123 = 9315, e.a124 = 9316, e.a125 = 9317, e.a126 = 9318, e.a127 = 9319, e.a128 = 9320, e.a129 = 9321, e.a130 = 10102, e.a131 = 10103, e.a132 = 10104, e.a133 = 10105, e.a134 = 10106, e.a135 = 10107, e.a136 = 10108, e.a137 = 10109, e.a138 = 10110, e.a139 = 10111, e.a140 = 10112, e.a141 = 10113, e.a142 = 10114, e.a143 = 10115, e.a144 = 10116, e.a145 = 10117, e.a146 = 10118, e.a147 = 10119, e.a148 = 10120, e.a149 = 10121, e.a150 = 10122, e.a151 = 10123, e.a152 = 10124, e.a153 = 10125, e.a154 = 10126, e.a155 = 10127, e.a156 = 10128, e.a157 = 10129, e.a158 = 10130, e.a159 = 10131, e.a160 = 10132, e.a161 = 8594, e.a163 = 8596, e.a164 = 8597, e.a196 = 10136, e.a165 = 10137, e.a192 = 10138, e.a166 = 10139, e.a167 = 10140, e.a168 = 10141, e.a169 = 10142, e.a170 = 10143, e.a171 = 10144, e.a172 = 10145, e.a173 = 10146, e.a162 = 10147, e.a174 = 10148, e.a175 = 10149, e.a176 = 10150, e.a177 = 10151, e.a178 = 10152, e.a179 = 10153, e.a193 = 10154, e.a180 = 10155, e.a199 = 10156, e.a181 = 10157, e.a200 = 10158, e.a182 = 10159, e.a201 = 10161, e.a183 = 10162, e.a184 = 10163, e.a197 = 10164, e.a185 = 10165, e.a194 = 10166, e.a198 = 10167, e.a186 = 10168, e.a195 = 10169, e.a187 = 10170, e.a188 = 10171, e.a189 = 10172, e.a190 = 10173, e.a191 = 10174, e.a89 = 10088, e.a90 = 10089, e.a93 = 10090, e.a94 = 10091, e.a91 = 10092, e.a92 = 10093, e.a205 = 10094, e.a85 = 10095, e.a206 = 10096, e.a86 = 10097, e.a87 = 10098, e.a88 = 10099, e.a95 = 10100, e.a96 = 10101, e[".notdef"] = 0;
          });
          b.getDingbatsGlyphsUnicode = D;
        },
        /* 40 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.clearUnicodeCaches = F, b.getCharUnicodeCategory = E, b.getUnicodeForGlyph = e, b.getUnicodeRangeFor = l, b.mapSpecialUnicodeValues = D;
          var n = ce(3);
          const P = (0, n.getLookupTableFactory)(function(f) {
            f[63721] = 169, f[63193] = 169, f[63720] = 174, f[63194] = 174, f[63722] = 8482, f[63195] = 8482, f[63729] = 9127, f[63730] = 9128, f[63731] = 9129, f[63740] = 9131, f[63741] = 9132, f[63742] = 9133, f[63726] = 9121, f[63727] = 9122, f[63728] = 9123, f[63737] = 9124, f[63738] = 9125, f[63739] = 9126, f[63723] = 9115, f[63724] = 9116, f[63725] = 9117, f[63734] = 9118, f[63735] = 9119, f[63736] = 9120;
          });
          function D(f) {
            return f >= 65520 && f <= 65535 ? 0 : f >= 62976 && f <= 63743 ? P()[f] || f : f === 173 ? 45 : f;
          }
          function e(f, x) {
            let a = x[f];
            if (a !== void 0)
              return a;
            if (!f)
              return -1;
            if (f[0] === "u") {
              const N = f.length;
              let p;
              if (N === 7 && f[1] === "n" && f[2] === "i")
                p = f.substring(3);
              else if (N >= 5 && N <= 7)
                p = f.substring(1);
              else
                return -1;
              if (p === p.toUpperCase() && (a = parseInt(p, 16), a >= 0))
                return a;
            }
            return -1;
          }
          const t = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
          function l(f, x = -1) {
            if (x !== -1) {
              const a = t[x];
              for (let N = 0, p = a.length; N < p; N += 2)
                if (f >= a[N] && f <= a[N + 1])
                  return x;
            }
            for (let a = 0, N = t.length; a < N; a++) {
              const p = t[a];
              for (let O = 0, M = p.length; O < M; O += 2)
                if (f >= p[O] && f <= p[O + 1])
                  return a;
            }
            return -1;
          }
          const V = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), te = /* @__PURE__ */ new Map();
          function E(f) {
            const x = te.get(f);
            if (x)
              return x;
            const a = f.match(V), N = {
              isWhitespace: !!(a != null && a[1]),
              isZeroWidthDiacritic: !!(a != null && a[2]),
              isInvisibleFormatMark: !!(a != null && a[3])
            };
            return te.set(f, N), N;
          }
          function F() {
            te.clear();
          }
        },
        /* 41 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.getSerifFonts = b.getNonStdFontMap = b.getGlyphMapForStandardFonts = b.getFontNameToFileMap = void 0, b.getStandardFontName = f, b.getSymbolsFonts = b.getSupplementalGlyphMapForCalibri = b.getSupplementalGlyphMapForArialBlack = b.getStdFontMap = void 0, b.isKnownFontName = x;
          var n = ce(3), P = ce(38);
          const D = (0, n.getLookupTableFactory)(function(a) {
            a["Times-Roman"] = "Times-Roman", a.Helvetica = "Helvetica", a.Courier = "Courier", a.Symbol = "Symbol", a["Times-Bold"] = "Times-Bold", a["Helvetica-Bold"] = "Helvetica-Bold", a["Courier-Bold"] = "Courier-Bold", a.ZapfDingbats = "ZapfDingbats", a["Times-Italic"] = "Times-Italic", a["Helvetica-Oblique"] = "Helvetica-Oblique", a["Courier-Oblique"] = "Courier-Oblique", a["Times-BoldItalic"] = "Times-BoldItalic", a["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", a["Courier-BoldOblique"] = "Courier-BoldOblique", a.ArialNarrow = "Helvetica", a["ArialNarrow-Bold"] = "Helvetica-Bold", a["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", a["ArialNarrow-Italic"] = "Helvetica-Oblique", a.ArialBlack = "Helvetica", a["ArialBlack-Bold"] = "Helvetica-Bold", a["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", a["ArialBlack-Italic"] = "Helvetica-Oblique", a["Arial-Black"] = "Helvetica", a["Arial-Black-Bold"] = "Helvetica-Bold", a["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", a["Arial-Black-Italic"] = "Helvetica-Oblique", a.Arial = "Helvetica", a["Arial-Bold"] = "Helvetica-Bold", a["Arial-BoldItalic"] = "Helvetica-BoldOblique", a["Arial-Italic"] = "Helvetica-Oblique", a.ArialMT = "Helvetica", a["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", a["Arial-BoldMT"] = "Helvetica-Bold", a["Arial-ItalicMT"] = "Helvetica-Oblique", a["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", a["Arial-BoldMT-Bold"] = "Helvetica-Bold", a["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", a.ArialUnicodeMS = "Helvetica", a["ArialUnicodeMS-Bold"] = "Helvetica-Bold", a["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", a["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", a["Courier-BoldItalic"] = "Courier-BoldOblique", a["Courier-Italic"] = "Courier-Oblique", a.CourierNew = "Courier", a["CourierNew-Bold"] = "Courier-Bold", a["CourierNew-BoldItalic"] = "Courier-BoldOblique", a["CourierNew-Italic"] = "Courier-Oblique", a["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", a["CourierNewPS-BoldMT"] = "Courier-Bold", a["CourierNewPS-ItalicMT"] = "Courier-Oblique", a.CourierNewPSMT = "Courier", a["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", a["Helvetica-Italic"] = "Helvetica-Oblique", a["Symbol-Bold"] = "Symbol", a["Symbol-BoldItalic"] = "Symbol", a["Symbol-Italic"] = "Symbol", a.TimesNewRoman = "Times-Roman", a["TimesNewRoman-Bold"] = "Times-Bold", a["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", a["TimesNewRoman-Italic"] = "Times-Italic", a.TimesNewRomanPS = "Times-Roman", a["TimesNewRomanPS-Bold"] = "Times-Bold", a["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", a["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", a["TimesNewRomanPS-BoldMT"] = "Times-Bold", a["TimesNewRomanPS-Italic"] = "Times-Italic", a["TimesNewRomanPS-ItalicMT"] = "Times-Italic", a.TimesNewRomanPSMT = "Times-Roman", a["TimesNewRomanPSMT-Bold"] = "Times-Bold", a["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", a["TimesNewRomanPSMT-Italic"] = "Times-Italic";
          });
          b.getStdFontMap = D;
          const e = (0, n.getLookupTableFactory)(function(a) {
            a.Courier = "FoxitFixed.pfb", a["Courier-Bold"] = "FoxitFixedBold.pfb", a["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", a["Courier-Oblique"] = "FoxitFixedItalic.pfb", a.Helvetica = "LiberationSans-Regular.ttf", a["Helvetica-Bold"] = "LiberationSans-Bold.ttf", a["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", a["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", a["Times-Roman"] = "FoxitSerif.pfb", a["Times-Bold"] = "FoxitSerifBold.pfb", a["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", a["Times-Italic"] = "FoxitSerifItalic.pfb", a.Symbol = "FoxitSymbol.pfb", a.ZapfDingbats = "FoxitDingbats.pfb", a["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", a["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", a["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", a["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
          });
          b.getFontNameToFileMap = e;
          const t = (0, n.getLookupTableFactory)(function(a) {
            a.Calibri = "Helvetica", a["Calibri-Bold"] = "Helvetica-Bold", a["Calibri-BoldItalic"] = "Helvetica-BoldOblique", a["Calibri-Italic"] = "Helvetica-Oblique", a.CenturyGothic = "Helvetica", a["CenturyGothic-Bold"] = "Helvetica-Bold", a["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", a["CenturyGothic-Italic"] = "Helvetica-Oblique", a.ComicSansMS = "Comic Sans MS", a["ComicSansMS-Bold"] = "Comic Sans MS-Bold", a["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", a["ComicSansMS-Italic"] = "Comic Sans MS-Italic", a.Impact = "Helvetica", a["ItcSymbol-Bold"] = "Helvetica-Bold", a["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", a["ItcSymbol-Book"] = "Helvetica", a["ItcSymbol-BookItalic"] = "Helvetica-Oblique", a["ItcSymbol-Medium"] = "Helvetica", a["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", a.LucidaConsole = "Courier", a["LucidaConsole-Bold"] = "Courier-Bold", a["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", a["LucidaConsole-Italic"] = "Courier-Oblique", a["LucidaSans-Demi"] = "Helvetica-Bold", a["MS-Gothic"] = "MS Gothic", a["MS-Gothic-Bold"] = "MS Gothic-Bold", a["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", a["MS-Gothic-Italic"] = "MS Gothic-Italic", a["MS-Mincho"] = "MS Mincho", a["MS-Mincho-Bold"] = "MS Mincho-Bold", a["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", a["MS-Mincho-Italic"] = "MS Mincho-Italic", a["MS-PGothic"] = "MS PGothic", a["MS-PGothic-Bold"] = "MS PGothic-Bold", a["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", a["MS-PGothic-Italic"] = "MS PGothic-Italic", a["MS-PMincho"] = "MS PMincho", a["MS-PMincho-Bold"] = "MS PMincho-Bold", a["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", a["MS-PMincho-Italic"] = "MS PMincho-Italic", a.NuptialScript = "Times-Italic", a.SegoeUISymbol = "Helvetica";
          });
          b.getNonStdFontMap = t;
          const l = (0, n.getLookupTableFactory)(function(a) {
            a["Adobe Jenson"] = !0, a["Adobe Text"] = !0, a.Albertus = !0, a.Aldus = !0, a.Alexandria = !0, a.Algerian = !0, a["American Typewriter"] = !0, a.Antiqua = !0, a.Apex = !0, a.Arno = !0, a.Aster = !0, a.Aurora = !0, a.Baskerville = !0, a.Bell = !0, a.Bembo = !0, a["Bembo Schoolbook"] = !0, a.Benguiat = !0, a["Berkeley Old Style"] = !0, a["Bernhard Modern"] = !0, a["Berthold City"] = !0, a.Bodoni = !0, a["Bauer Bodoni"] = !0, a["Book Antiqua"] = !0, a.Bookman = !0, a["Bordeaux Roman"] = !0, a["Californian FB"] = !0, a.Calisto = !0, a.Calvert = !0, a.Capitals = !0, a.Cambria = !0, a.Cartier = !0, a.Caslon = !0, a.Catull = !0, a.Centaur = !0, a["Century Old Style"] = !0, a["Century Schoolbook"] = !0, a.Chaparral = !0, a["Charis SIL"] = !0, a.Cheltenham = !0, a["Cholla Slab"] = !0, a.Clarendon = !0, a.Clearface = !0, a.Cochin = !0, a.Colonna = !0, a["Computer Modern"] = !0, a["Concrete Roman"] = !0, a.Constantia = !0, a["Cooper Black"] = !0, a.Corona = !0, a.Ecotype = !0, a.Egyptienne = !0, a.Elephant = !0, a.Excelsior = !0, a.Fairfield = !0, a["FF Scala"] = !0, a.Folkard = !0, a.Footlight = !0, a.FreeSerif = !0, a["Friz Quadrata"] = !0, a.Garamond = !0, a.Gentium = !0, a.Georgia = !0, a.Gloucester = !0, a["Goudy Old Style"] = !0, a["Goudy Schoolbook"] = !0, a["Goudy Pro Font"] = !0, a.Granjon = !0, a["Guardian Egyptian"] = !0, a.Heather = !0, a.Hercules = !0, a["High Tower Text"] = !0, a.Hiroshige = !0, a["Hoefler Text"] = !0, a["Humana Serif"] = !0, a.Imprint = !0, a["Ionic No. 5"] = !0, a.Janson = !0, a.Joanna = !0, a.Korinna = !0, a.Lexicon = !0, a.LiberationSerif = !0, a["Liberation Serif"] = !0, a["Linux Libertine"] = !0, a.Literaturnaya = !0, a.Lucida = !0, a["Lucida Bright"] = !0, a.Melior = !0, a.Memphis = !0, a.Miller = !0, a.Minion = !0, a.Modern = !0, a["Mona Lisa"] = !0, a["Mrs Eaves"] = !0, a["MS Serif"] = !0, a["Museo Slab"] = !0, a["New York"] = !0, a["Nimbus Roman"] = !0, a["NPS Rawlinson Roadway"] = !0, a.NuptialScript = !0, a.Palatino = !0, a.Perpetua = !0, a.Plantin = !0, a["Plantin Schoolbook"] = !0, a.Playbill = !0, a["Poor Richard"] = !0, a["Rawlinson Roadway"] = !0, a.Renault = !0, a.Requiem = !0, a.Rockwell = !0, a.Roman = !0, a["Rotis Serif"] = !0, a.Sabon = !0, a.Scala = !0, a.Seagull = !0, a.Sistina = !0, a.Souvenir = !0, a.STIX = !0, a["Stone Informal"] = !0, a["Stone Serif"] = !0, a.Sylfaen = !0, a.Times = !0, a.Trajan = !0, a.Trinité = !0, a["Trump Mediaeval"] = !0, a.Utopia = !0, a["Vale Type"] = !0, a["Bitstream Vera"] = !0, a["Vera Serif"] = !0, a.Versailles = !0, a.Wanted = !0, a.Weiss = !0, a["Wide Latin"] = !0, a.Windsor = !0, a.XITS = !0;
          });
          b.getSerifFonts = l;
          const V = (0, n.getLookupTableFactory)(function(a) {
            a.Dingbats = !0, a.Symbol = !0, a.ZapfDingbats = !0, a.Wingdings = !0, a["Wingdings-Bold"] = !0, a["Wingdings-Regular"] = !0;
          });
          b.getSymbolsFonts = V;
          const te = (0, n.getLookupTableFactory)(function(a) {
            a[2] = 10, a[3] = 32, a[4] = 33, a[5] = 34, a[6] = 35, a[7] = 36, a[8] = 37, a[9] = 38, a[10] = 39, a[11] = 40, a[12] = 41, a[13] = 42, a[14] = 43, a[15] = 44, a[16] = 45, a[17] = 46, a[18] = 47, a[19] = 48, a[20] = 49, a[21] = 50, a[22] = 51, a[23] = 52, a[24] = 53, a[25] = 54, a[26] = 55, a[27] = 56, a[28] = 57, a[29] = 58, a[30] = 894, a[31] = 60, a[32] = 61, a[33] = 62, a[34] = 63, a[35] = 64, a[36] = 65, a[37] = 66, a[38] = 67, a[39] = 68, a[40] = 69, a[41] = 70, a[42] = 71, a[43] = 72, a[44] = 73, a[45] = 74, a[46] = 75, a[47] = 76, a[48] = 77, a[49] = 78, a[50] = 79, a[51] = 80, a[52] = 81, a[53] = 82, a[54] = 83, a[55] = 84, a[56] = 85, a[57] = 86, a[58] = 87, a[59] = 88, a[60] = 89, a[61] = 90, a[62] = 91, a[63] = 92, a[64] = 93, a[65] = 94, a[66] = 95, a[67] = 96, a[68] = 97, a[69] = 98, a[70] = 99, a[71] = 100, a[72] = 101, a[73] = 102, a[74] = 103, a[75] = 104, a[76] = 105, a[77] = 106, a[78] = 107, a[79] = 108, a[80] = 109, a[81] = 110, a[82] = 111, a[83] = 112, a[84] = 113, a[85] = 114, a[86] = 115, a[87] = 116, a[88] = 117, a[89] = 118, a[90] = 119, a[91] = 120, a[92] = 121, a[93] = 122, a[94] = 123, a[95] = 124, a[96] = 125, a[97] = 126, a[98] = 196, a[99] = 197, a[100] = 199, a[101] = 201, a[102] = 209, a[103] = 214, a[104] = 220, a[105] = 225, a[106] = 224, a[107] = 226, a[108] = 228, a[109] = 227, a[110] = 229, a[111] = 231, a[112] = 233, a[113] = 232, a[114] = 234, a[115] = 235, a[116] = 237, a[117] = 236, a[118] = 238, a[119] = 239, a[120] = 241, a[121] = 243, a[122] = 242, a[123] = 244, a[124] = 246, a[125] = 245, a[126] = 250, a[127] = 249, a[128] = 251, a[129] = 252, a[130] = 8224, a[131] = 176, a[132] = 162, a[133] = 163, a[134] = 167, a[135] = 8226, a[136] = 182, a[137] = 223, a[138] = 174, a[139] = 169, a[140] = 8482, a[141] = 180, a[142] = 168, a[143] = 8800, a[144] = 198, a[145] = 216, a[146] = 8734, a[147] = 177, a[148] = 8804, a[149] = 8805, a[150] = 165, a[151] = 181, a[152] = 8706, a[153] = 8721, a[154] = 8719, a[156] = 8747, a[157] = 170, a[158] = 186, a[159] = 8486, a[160] = 230, a[161] = 248, a[162] = 191, a[163] = 161, a[164] = 172, a[165] = 8730, a[166] = 402, a[167] = 8776, a[168] = 8710, a[169] = 171, a[170] = 187, a[171] = 8230, a[179] = 8220, a[180] = 8221, a[181] = 8216, a[182] = 8217, a[200] = 193, a[203] = 205, a[207] = 211, a[210] = 218, a[223] = 711, a[224] = 321, a[225] = 322, a[226] = 352, a[227] = 353, a[228] = 381, a[229] = 382, a[233] = 221, a[234] = 253, a[252] = 263, a[253] = 268, a[254] = 269, a[258] = 258, a[260] = 260, a[261] = 261, a[265] = 280, a[266] = 281, a[267] = 282, a[268] = 283, a[269] = 313, a[275] = 323, a[276] = 324, a[278] = 328, a[283] = 344, a[284] = 345, a[285] = 346, a[286] = 347, a[292] = 367, a[295] = 377, a[296] = 378, a[298] = 380, a[305] = 963, a[306] = 964, a[307] = 966, a[308] = 8215, a[309] = 8252, a[310] = 8319, a[311] = 8359, a[312] = 8592, a[313] = 8593, a[337] = 9552, a[493] = 1039, a[494] = 1040, a[672] = 1488, a[673] = 1489, a[674] = 1490, a[675] = 1491, a[676] = 1492, a[677] = 1493, a[678] = 1494, a[679] = 1495, a[680] = 1496, a[681] = 1497, a[682] = 1498, a[683] = 1499, a[684] = 1500, a[685] = 1501, a[686] = 1502, a[687] = 1503, a[688] = 1504, a[689] = 1505, a[690] = 1506, a[691] = 1507, a[692] = 1508, a[693] = 1509, a[694] = 1510, a[695] = 1511, a[696] = 1512, a[697] = 1513, a[698] = 1514, a[705] = 1524, a[706] = 8362, a[710] = 64288, a[711] = 64298, a[759] = 1617, a[761] = 1776, a[763] = 1778, a[775] = 1652, a[777] = 1764, a[778] = 1780, a[779] = 1781, a[780] = 1782, a[782] = 771, a[783] = 64726, a[786] = 8363, a[788] = 8532, a[790] = 768, a[791] = 769, a[792] = 768, a[795] = 803, a[797] = 64336, a[798] = 64337, a[799] = 64342, a[800] = 64343, a[801] = 64344, a[802] = 64345, a[803] = 64362, a[804] = 64363, a[805] = 64364, a[2424] = 7821, a[2425] = 7822, a[2426] = 7823, a[2427] = 7824, a[2428] = 7825, a[2429] = 7826, a[2430] = 7827, a[2433] = 7682, a[2678] = 8045, a[2679] = 8046, a[2830] = 1552, a[2838] = 686, a[2840] = 751, a[2842] = 753, a[2843] = 754, a[2844] = 755, a[2846] = 757, a[2856] = 767, a[2857] = 848, a[2858] = 849, a[2862] = 853, a[2863] = 854, a[2864] = 855, a[2865] = 861, a[2866] = 862, a[2906] = 7460, a[2908] = 7462, a[2909] = 7463, a[2910] = 7464, a[2912] = 7466, a[2913] = 7467, a[2914] = 7468, a[2916] = 7470, a[2917] = 7471, a[2918] = 7472, a[2920] = 7474, a[2921] = 7475, a[2922] = 7476, a[2924] = 7478, a[2925] = 7479, a[2926] = 7480, a[2928] = 7482, a[2929] = 7483, a[2930] = 7484, a[2932] = 7486, a[2933] = 7487, a[2934] = 7488, a[2936] = 7490, a[2937] = 7491, a[2938] = 7492, a[2940] = 7494, a[2941] = 7495, a[2942] = 7496, a[2944] = 7498, a[2946] = 7500, a[2948] = 7502, a[2950] = 7504, a[2951] = 7505, a[2952] = 7506, a[2954] = 7508, a[2955] = 7509, a[2956] = 7510, a[2958] = 7512, a[2959] = 7513, a[2960] = 7514, a[2962] = 7516, a[2963] = 7517, a[2964] = 7518, a[2966] = 7520, a[2967] = 7521, a[2968] = 7522, a[2970] = 7524, a[2971] = 7525, a[2972] = 7526, a[2974] = 7528, a[2975] = 7529, a[2976] = 7530, a[2978] = 1537, a[2979] = 1538, a[2980] = 1539, a[2982] = 1549, a[2983] = 1551, a[2984] = 1552, a[2986] = 1554, a[2987] = 1555, a[2988] = 1556, a[2990] = 1623, a[2991] = 1624, a[2995] = 1775, a[2999] = 1791, a[3002] = 64290, a[3003] = 64291, a[3004] = 64292, a[3006] = 64294, a[3007] = 64295, a[3008] = 64296, a[3011] = 1900, a[3014] = 8223, a[3015] = 8244, a[3017] = 7532, a[3018] = 7533, a[3019] = 7534, a[3075] = 7590, a[3076] = 7591, a[3079] = 7594, a[3080] = 7595, a[3083] = 7598, a[3084] = 7599, a[3087] = 7602, a[3088] = 7603, a[3091] = 7606, a[3092] = 7607, a[3095] = 7610, a[3096] = 7611, a[3099] = 7614, a[3100] = 7615, a[3103] = 7618, a[3104] = 7619, a[3107] = 8337, a[3108] = 8338, a[3116] = 1884, a[3119] = 1885, a[3120] = 1885, a[3123] = 1886, a[3124] = 1886, a[3127] = 1887, a[3128] = 1887, a[3131] = 1888, a[3132] = 1888, a[3135] = 1889, a[3136] = 1889, a[3139] = 1890, a[3140] = 1890, a[3143] = 1891, a[3144] = 1891, a[3147] = 1892, a[3148] = 1892, a[3153] = 580, a[3154] = 581, a[3157] = 584, a[3158] = 585, a[3161] = 588, a[3162] = 589, a[3165] = 891, a[3166] = 892, a[3169] = 1274, a[3170] = 1275, a[3173] = 1278, a[3174] = 1279, a[3181] = 7622, a[3182] = 7623, a[3282] = 11799, a[3316] = 578, a[3379] = 42785, a[3393] = 1159, a[3416] = 8377;
          });
          b.getGlyphMapForStandardFonts = te;
          const E = (0, n.getLookupTableFactory)(function(a) {
            a[227] = 322, a[264] = 261, a[291] = 346;
          });
          b.getSupplementalGlyphMapForArialBlack = E;
          const F = (0, n.getLookupTableFactory)(function(a) {
            a[1] = 32, a[4] = 65, a[5] = 192, a[6] = 193, a[9] = 196, a[17] = 66, a[18] = 67, a[21] = 268, a[24] = 68, a[28] = 69, a[29] = 200, a[30] = 201, a[32] = 282, a[38] = 70, a[39] = 71, a[44] = 72, a[47] = 73, a[48] = 204, a[49] = 205, a[58] = 74, a[60] = 75, a[62] = 76, a[68] = 77, a[69] = 78, a[75] = 79, a[76] = 210, a[80] = 214, a[87] = 80, a[89] = 81, a[90] = 82, a[92] = 344, a[94] = 83, a[97] = 352, a[100] = 84, a[104] = 85, a[109] = 220, a[115] = 86, a[116] = 87, a[121] = 88, a[122] = 89, a[124] = 221, a[127] = 90, a[129] = 381, a[258] = 97, a[259] = 224, a[260] = 225, a[263] = 228, a[268] = 261, a[271] = 98, a[272] = 99, a[273] = 263, a[275] = 269, a[282] = 100, a[286] = 101, a[287] = 232, a[288] = 233, a[290] = 283, a[295] = 281, a[296] = 102, a[336] = 103, a[346] = 104, a[349] = 105, a[350] = 236, a[351] = 237, a[361] = 106, a[364] = 107, a[367] = 108, a[371] = 322, a[373] = 109, a[374] = 110, a[381] = 111, a[382] = 242, a[383] = 243, a[386] = 246, a[393] = 112, a[395] = 113, a[396] = 114, a[398] = 345, a[400] = 115, a[401] = 347, a[403] = 353, a[410] = 116, a[437] = 117, a[442] = 252, a[448] = 118, a[449] = 119, a[454] = 120, a[455] = 121, a[457] = 253, a[460] = 122, a[462] = 382, a[463] = 380, a[853] = 44, a[855] = 58, a[856] = 46, a[876] = 47, a[878] = 45, a[882] = 45, a[894] = 40, a[895] = 41, a[896] = 91, a[897] = 93, a[923] = 64, a[1004] = 48, a[1005] = 49, a[1006] = 50, a[1007] = 51, a[1008] = 52, a[1009] = 53, a[1010] = 54, a[1011] = 55, a[1012] = 56, a[1013] = 57, a[1081] = 37, a[1085] = 43, a[1086] = 45;
          });
          b.getSupplementalGlyphMapForCalibri = F;
          function f(a) {
            const N = (0, P.normalizeFontName)(a);
            return D()[N];
          }
          function x(a) {
            const N = (0, P.normalizeFontName)(a);
            return !!(D()[N] || t()[N] || l()[N] || V()[N]);
          }
        },
        /* 42 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ToUnicodeMap = b.IdentityToUnicodeMap = void 0;
          var n = ce(2);
          class P {
            constructor(t = []) {
              this._map = t;
            }
            get length() {
              return this._map.length;
            }
            forEach(t) {
              for (const l in this._map)
                t(l, this._map[l].charCodeAt(0));
            }
            has(t) {
              return this._map[t] !== void 0;
            }
            get(t) {
              return this._map[t];
            }
            charCodeOf(t) {
              const l = this._map;
              if (l.length <= 65536)
                return l.indexOf(t);
              for (const V in l)
                if (l[V] === t)
                  return V | 0;
              return -1;
            }
            amend(t) {
              for (const l in t)
                this._map[l] = t[l];
            }
          }
          b.ToUnicodeMap = P;
          class D {
            constructor(t, l) {
              this.firstChar = t, this.lastChar = l;
            }
            get length() {
              return this.lastChar + 1 - this.firstChar;
            }
            forEach(t) {
              for (let l = this.firstChar, V = this.lastChar; l <= V; l++)
                t(l, l);
            }
            has(t) {
              return this.firstChar <= t && t <= this.lastChar;
            }
            get(t) {
              if (this.firstChar <= t && t <= this.lastChar)
                return String.fromCharCode(t);
            }
            charCodeOf(t) {
              return Number.isInteger(t) && t >= this.firstChar && t <= this.lastChar ? t : -1;
            }
            amend(t) {
              (0, n.unreachable)("Should not call amend()");
            }
          }
          b.IdentityToUnicodeMap = D;
        },
        /* 43 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.CFFFont = void 0;
          var n = ce(35), P = ce(38), D = ce(2);
          class e {
            constructor(l, V) {
              this.properties = V;
              const te = new n.CFFParser(l, V, P.SEAC_ANALYSIS_ENABLED);
              this.cff = te.parse(), this.cff.duplicateFirstGlyph();
              const E = new n.CFFCompiler(this.cff);
              this.seacs = this.cff.seacs;
              try {
                this.data = E.compile();
              } catch {
                (0, D.warn)("Failed to compile font " + V.loadedName), this.data = l;
              }
              this._createBuiltInEncoding();
            }
            get numGlyphs() {
              return this.cff.charStrings.count;
            }
            getCharset() {
              return this.cff.charset.charset;
            }
            getGlyphMapping() {
              const l = this.cff, V = this.properties, {
                cidToGidMap: te,
                cMap: E
              } = V, F = l.charset.charset;
              let f, x;
              if (V.composite) {
                let N;
                if ((te == null ? void 0 : te.length) > 0) {
                  N = /* @__PURE__ */ Object.create(null);
                  for (let O = 0, M = te.length; O < M; O++) {
                    const R = te[O];
                    R !== void 0 && (N[R] = O);
                  }
                }
                f = /* @__PURE__ */ Object.create(null);
                let p;
                if (l.isCIDFont)
                  for (x = 0; x < F.length; x++) {
                    const O = F[x];
                    p = E.charCodeOf(O), (N == null ? void 0 : N[p]) !== void 0 && (p = N[p]), f[p] = x;
                  }
                else
                  for (x = 0; x < l.charStrings.count; x++)
                    p = E.charCodeOf(x), f[p] = x;
                return f;
              }
              let a = l.encoding ? l.encoding.encoding : null;
              return V.isInternalFont && (a = V.defaultEncoding), f = (0, P.type1FontGlyphMapping)(V, a, F), f;
            }
            hasGlyphId(l) {
              return this.cff.hasGlyphId(l);
            }
            _createBuiltInEncoding() {
              const {
                charset: l,
                encoding: V
              } = this.cff;
              if (!l || !V)
                return;
              const te = l.charset, E = V.encoding, F = [];
              for (const f in E) {
                const x = E[f];
                if (x >= 0) {
                  const a = te[x];
                  a && (F[f] = a);
                }
              }
              F.length > 0 && (this.properties.builtInEncoding = F);
            }
          }
          b.CFFFont = e;
        },
        /* 44 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.FontRendererFactory = void 0;
          var n = ce(2), P = ce(35), D = ce(39), e = ce(37), t = ce(8);
          function l(o, c) {
            return (o[c] << 24 | o[c + 1] << 16 | o[c + 2] << 8 | o[c + 3]) >>> 0;
          }
          function V(o, c) {
            return o[c] << 8 | o[c + 1];
          }
          function te(o, c) {
            return (o[c] << 24 | o[c + 1] << 16) >> 16;
          }
          function E(o, c) {
            return o[c] << 24 >> 24;
          }
          function F(o, c) {
            return te(o, c) / 16384;
          }
          function f(o) {
            const c = o.length;
            let I = 32768;
            return c < 1240 ? I = 107 : c < 33900 && (I = 1131), I;
          }
          function x(o, c, I) {
            const s = V(o, c + 2) === 1 ? l(o, c + 8) : l(o, c + 16), r = V(o, c + s);
            let u, C, d;
            if (r === 4) {
              V(o, c + s + 2);
              const y = V(o, c + s + 6) >> 1;
              for (C = c + s + 14, u = [], d = 0; d < y; d++, C += 2)
                u[d] = {
                  end: V(o, C)
                };
              for (C += 2, d = 0; d < y; d++, C += 2)
                u[d].start = V(o, C);
              for (d = 0; d < y; d++, C += 2)
                u[d].idDelta = V(o, C);
              for (d = 0; d < y; d++, C += 2) {
                let _ = V(o, C);
                if (_ !== 0) {
                  u[d].ids = [];
                  for (let $ = 0, S = u[d].end - u[d].start + 1; $ < S; $++)
                    u[d].ids[$] = V(o, C + _), _ += 2;
                }
              }
              return u;
            } else if (r === 12) {
              const y = l(o, c + s + 12);
              for (C = c + s + 16, u = [], d = 0; d < y; d++)
                c = l(o, C), u.push({
                  start: c,
                  end: l(o, C + 4),
                  idDelta: l(o, C + 8) - c
                }), C += 12;
              return u;
            }
            throw new n.FormatError(`unsupported cmap: ${r}`);
          }
          function a(o, c, I, s) {
            var d, y, _;
            const r = {}, C = new P.CFFParser(new t.Stream(o, c, I - c), r, s).parse();
            return {
              glyphs: C.charStrings.objects,
              subrs: (y = (d = C.topDict.privateDict) == null ? void 0 : d.subrsIndex) == null ? void 0 : y.objects,
              gsubrs: (_ = C.globalSubrIndex) == null ? void 0 : _.objects,
              isCFFCIDFont: C.isCIDFont,
              fdSelect: C.fdSelect,
              fdArray: C.fdArray
            };
          }
          function N(o, c, I) {
            let s, r;
            I ? (s = 4, r = l) : (s = 2, r = (d, y) => 2 * V(d, y));
            const u = [];
            let C = r(c, 0);
            for (let d = s; d < c.length; d += s) {
              const y = r(c, d);
              u.push(o.subarray(C, y)), C = y;
            }
            return u;
          }
          function p(o, c) {
            const I = c.codePointAt(0);
            let s = 0, r = 0, u = o.length - 1;
            for (; r < u; ) {
              const C = r + u + 1 >> 1;
              I < o[C].start ? u = C - 1 : r = C;
            }
            return o[r].start <= I && I <= o[r].end && (s = o[r].idDelta + (o[r].ids ? o[r].ids[I - o[r].start] : I) & 65535), {
              charCode: I,
              glyphId: s
            };
          }
          function O(o, c, I) {
            function s(S, v) {
              c.push({
                cmd: "moveTo",
                args: [S, v]
              });
            }
            function r(S, v) {
              c.push({
                cmd: "lineTo",
                args: [S, v]
              });
            }
            function u(S, v, m, h) {
              c.push({
                cmd: "quadraticCurveTo",
                args: [S, v, m, h]
              });
            }
            let C = 0;
            const d = te(o, C);
            let y, _ = 0, $ = 0;
            if (C += 10, d < 0)
              do {
                y = V(o, C);
                const S = V(o, C + 2);
                C += 4;
                let v, m;
                y & 1 ? (y & 2 ? (v = te(o, C), m = te(o, C + 2)) : (v = V(o, C), m = V(o, C + 2)), C += 4) : y & 2 ? (v = E(o, C++), m = E(o, C++)) : (v = o[C++], m = o[C++]), y & 2 ? (_ = v, $ = m) : (_ = 0, $ = 0);
                let h = 1, A = 1, j = 0, G = 0;
                y & 8 ? (h = A = F(o, C), C += 2) : y & 64 ? (h = F(o, C), A = F(o, C + 2), C += 4) : y & 128 && (h = F(o, C), j = F(o, C + 2), G = F(o, C + 4), A = F(o, C + 6), C += 8);
                const J = I.glyphs[S];
                J && (c.push({
                  cmd: "save"
                }, {
                  cmd: "transform",
                  args: [h, j, G, A, _, $]
                }), O(J, c, I), c.push({
                  cmd: "restore"
                }));
              } while (y & 32);
            else {
              const S = [];
              let v, m;
              for (v = 0; v < d; v++)
                S.push(V(o, C)), C += 2;
              const h = V(o, C);
              C += 2 + h;
              const A = S.at(-1) + 1, j = [];
              for (; j.length < A; ) {
                y = o[C++];
                let J = 1;
                for (y & 8 && (J += o[C++]); J-- > 0; )
                  j.push({
                    flags: y
                  });
              }
              for (v = 0; v < A; v++) {
                switch (j[v].flags & 18) {
                  case 0:
                    _ += te(o, C), C += 2;
                    break;
                  case 2:
                    _ -= o[C++];
                    break;
                  case 18:
                    _ += o[C++];
                    break;
                }
                j[v].x = _;
              }
              for (v = 0; v < A; v++) {
                switch (j[v].flags & 36) {
                  case 0:
                    $ += te(o, C), C += 2;
                    break;
                  case 4:
                    $ -= o[C++];
                    break;
                  case 36:
                    $ += o[C++];
                    break;
                }
                j[v].y = $;
              }
              let G = 0;
              for (C = 0; C < d; C++) {
                const J = S[C], oe = j.slice(G, J + 1);
                if (oe[0].flags & 1)
                  oe.push(oe[0]);
                else if (oe.at(-1).flags & 1)
                  oe.unshift(oe.at(-1));
                else {
                  const q = {
                    flags: 1,
                    x: (oe[0].x + oe.at(-1).x) / 2,
                    y: (oe[0].y + oe.at(-1).y) / 2
                  };
                  oe.unshift(q), oe.push(q);
                }
                for (s(oe[0].x, oe[0].y), v = 1, m = oe.length; v < m; v++)
                  oe[v].flags & 1 ? r(oe[v].x, oe[v].y) : oe[v + 1].flags & 1 ? (u(oe[v].x, oe[v].y, oe[v + 1].x, oe[v + 1].y), v++) : u(oe[v].x, oe[v].y, (oe[v].x + oe[v + 1].x) / 2, (oe[v].y + oe[v + 1].y) / 2);
                G = J + 1;
              }
            }
          }
          function M(o, c, I, s) {
            function r(v, m) {
              c.push({
                cmd: "moveTo",
                args: [v, m]
              });
            }
            function u(v, m) {
              c.push({
                cmd: "lineTo",
                args: [v, m]
              });
            }
            function C(v, m, h, A, j, G) {
              c.push({
                cmd: "bezierCurveTo",
                args: [v, m, h, A, j, G]
              });
            }
            const d = [];
            let y = 0, _ = 0, $ = 0;
            function S(v) {
              var h;
              let m = 0;
              for (; m < v.length; ) {
                let A = !1, j = v[m++], G, J, oe, q, re, K, Z, w, k;
                switch (j) {
                  case 1:
                    $ += d.length >> 1, A = !0;
                    break;
                  case 3:
                    $ += d.length >> 1, A = !0;
                    break;
                  case 4:
                    _ += d.pop(), r(y, _), A = !0;
                    break;
                  case 5:
                    for (; d.length > 0; )
                      y += d.shift(), _ += d.shift(), u(y, _);
                    break;
                  case 6:
                    for (; d.length > 0 && (y += d.shift(), u(y, _), d.length !== 0); )
                      _ += d.shift(), u(y, _);
                    break;
                  case 7:
                    for (; d.length > 0 && (_ += d.shift(), u(y, _), d.length !== 0); )
                      y += d.shift(), u(y, _);
                    break;
                  case 8:
                    for (; d.length > 0; )
                      G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _);
                    break;
                  case 10:
                    if (w = d.pop(), k = null, I.isCFFCIDFont) {
                      const X = I.fdSelect.getFDIndex(s);
                      if (X >= 0 && X < I.fdArray.length) {
                        const H = I.fdArray[X];
                        let Y;
                        (h = H.privateDict) != null && h.subrsIndex && (Y = H.privateDict.subrsIndex.objects), Y && (w += f(Y), k = Y[w]);
                      } else
                        (0, n.warn)("Invalid fd index for glyph index.");
                    } else
                      k = I.subrs[w + I.subrsBias];
                    k && S(k);
                    break;
                  case 11:
                    return;
                  case 12:
                    switch (j = v[m++], j) {
                      case 34:
                        G = y + d.shift(), J = G + d.shift(), re = _ + d.shift(), y = J + d.shift(), C(G, _, J, re, y, re), G = y + d.shift(), J = G + d.shift(), y = J + d.shift(), C(G, re, J, _, y, _);
                        break;
                      case 35:
                        G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _), G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _), d.pop();
                        break;
                      case 36:
                        G = y + d.shift(), re = _ + d.shift(), J = G + d.shift(), K = re + d.shift(), y = J + d.shift(), C(G, re, J, K, y, K), G = y + d.shift(), J = G + d.shift(), Z = K + d.shift(), y = J + d.shift(), C(G, K, J, Z, y, _);
                        break;
                      case 37:
                        const X = y, H = _;
                        G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _), G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J, _ = q, Math.abs(y - X) > Math.abs(_ - H) ? y += d.shift() : _ += d.shift(), C(G, oe, J, q, y, _);
                        break;
                      default:
                        throw new n.FormatError(`unknown operator: 12 ${j}`);
                    }
                    break;
                  case 14:
                    if (d.length >= 4) {
                      const X = d.pop(), H = d.pop();
                      _ = d.pop(), y = d.pop(), c.push({
                        cmd: "save"
                      }, {
                        cmd: "translate",
                        args: [y, _]
                      });
                      let Y = p(I.cmap, String.fromCharCode(I.glyphNameMap[e.StandardEncoding[X]]));
                      M(I.glyphs[Y.glyphId], c, I, Y.glyphId), c.push({
                        cmd: "restore"
                      }), Y = p(I.cmap, String.fromCharCode(I.glyphNameMap[e.StandardEncoding[H]])), M(I.glyphs[Y.glyphId], c, I, Y.glyphId);
                    }
                    return;
                  case 18:
                    $ += d.length >> 1, A = !0;
                    break;
                  case 19:
                    $ += d.length >> 1, m += $ + 7 >> 3, A = !0;
                    break;
                  case 20:
                    $ += d.length >> 1, m += $ + 7 >> 3, A = !0;
                    break;
                  case 21:
                    _ += d.pop(), y += d.pop(), r(y, _), A = !0;
                    break;
                  case 22:
                    y += d.pop(), r(y, _), A = !0;
                    break;
                  case 23:
                    $ += d.length >> 1, A = !0;
                    break;
                  case 24:
                    for (; d.length > 2; )
                      G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _);
                    y += d.shift(), _ += d.shift(), u(y, _);
                    break;
                  case 25:
                    for (; d.length > 6; )
                      y += d.shift(), _ += d.shift(), u(y, _);
                    G = y + d.shift(), oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + d.shift(), C(G, oe, J, q, y, _);
                    break;
                  case 26:
                    for (d.length % 2 && (y += d.shift()); d.length > 0; )
                      G = y, oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J, _ = q + d.shift(), C(G, oe, J, q, y, _);
                    break;
                  case 27:
                    for (d.length % 2 && (_ += d.shift()); d.length > 0; )
                      G = y + d.shift(), oe = _, J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q, C(G, oe, J, q, y, _);
                    break;
                  case 28:
                    d.push((v[m] << 24 | v[m + 1] << 16) >> 16), m += 2;
                    break;
                  case 29:
                    w = d.pop() + I.gsubrsBias, k = I.gsubrs[w], k && S(k);
                    break;
                  case 30:
                    for (; d.length > 0 && (G = y, oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + (d.length === 1 ? d.shift() : 0), C(G, oe, J, q, y, _), d.length !== 0); )
                      G = y + d.shift(), oe = _, J = G + d.shift(), q = oe + d.shift(), _ = q + d.shift(), y = J + (d.length === 1 ? d.shift() : 0), C(G, oe, J, q, y, _);
                    break;
                  case 31:
                    for (; d.length > 0 && (G = y + d.shift(), oe = _, J = G + d.shift(), q = oe + d.shift(), _ = q + d.shift(), y = J + (d.length === 1 ? d.shift() : 0), C(G, oe, J, q, y, _), d.length !== 0); )
                      G = y, oe = _ + d.shift(), J = G + d.shift(), q = oe + d.shift(), y = J + d.shift(), _ = q + (d.length === 1 ? d.shift() : 0), C(G, oe, J, q, y, _);
                    break;
                  default:
                    if (j < 32)
                      throw new n.FormatError(`unknown operator: ${j}`);
                    j < 247 ? d.push(j - 139) : j < 251 ? d.push((j - 247) * 256 + v[m++] + 108) : j < 255 ? d.push(-(j - 251) * 256 - v[m++] - 108) : (d.push((v[m] << 24 | v[m + 1] << 16 | v[m + 2] << 8 | v[m + 3]) / 65536), m += 4);
                    break;
                }
                A && (d.length = 0);
              }
            }
            S(o);
          }
          const R = [];
          class z {
            constructor(c) {
              this.constructor === z && (0, n.unreachable)("Cannot initialize CompiledFont."), this.fontMatrix = c, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
            }
            getPathJs(c) {
              const {
                charCode: I,
                glyphId: s
              } = p(this.cmap, c);
              let r = this.compiledGlyphs[s];
              if (!r)
                try {
                  r = this.compileGlyph(this.glyphs[s], s), this.compiledGlyphs[s] = r;
                } catch (u) {
                  throw this.compiledGlyphs[s] = R, this.compiledCharCodeToGlyphId[I] === void 0 && (this.compiledCharCodeToGlyphId[I] = s), u;
                }
              return this.compiledCharCodeToGlyphId[I] === void 0 && (this.compiledCharCodeToGlyphId[I] = s), r;
            }
            compileGlyph(c, I) {
              if (!c || c.length === 0 || c[0] === 14)
                return R;
              let s = this.fontMatrix;
              if (this.isCFFCIDFont) {
                const u = this.fdSelect.getFDIndex(I);
                u >= 0 && u < this.fdArray.length ? s = this.fdArray[u].getByName("FontMatrix") || n.FONT_IDENTITY_MATRIX : (0, n.warn)("Invalid fd index for glyph index.");
              }
              const r = [{
                cmd: "save"
              }, {
                cmd: "transform",
                args: s.slice()
              }, {
                cmd: "scale",
                args: ["size", "-size"]
              }];
              return this.compileGlyphImpl(c, r, I), r.push({
                cmd: "restore"
              }), r;
            }
            compileGlyphImpl() {
              (0, n.unreachable)("Children classes should implement this.");
            }
            hasBuiltPath(c) {
              const {
                charCode: I,
                glyphId: s
              } = p(this.cmap, c);
              return this.compiledGlyphs[s] !== void 0 && this.compiledCharCodeToGlyphId[I] !== void 0;
            }
          }
          class W extends z {
            constructor(c, I, s) {
              super(s || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = c, this.cmap = I;
            }
            compileGlyphImpl(c, I) {
              O(c, I, this);
            }
          }
          class g extends z {
            constructor(c, I, s, r) {
              super(s || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = c.glyphs, this.gsubrs = c.gsubrs || [], this.subrs = c.subrs || [], this.cmap = I, this.glyphNameMap = r || (0, D.getGlyphsUnicode)(), this.gsubrsBias = f(this.gsubrs), this.subrsBias = f(this.subrs), this.isCFFCIDFont = c.isCFFCIDFont, this.fdSelect = c.fdSelect, this.fdArray = c.fdArray;
            }
            compileGlyphImpl(c, I, s) {
              M(c, I, this, s);
            }
          }
          class T {
            static create(c, I) {
              const s = new Uint8Array(c.data);
              let r, u, C, d, y, _;
              const $ = V(s, 4);
              for (let S = 0, v = 12; S < $; S++, v += 16) {
                const m = (0, n.bytesToString)(s.subarray(v, v + 4)), h = l(s, v + 8), A = l(s, v + 12);
                switch (m) {
                  case "cmap":
                    r = x(s, h);
                    break;
                  case "glyf":
                    u = s.subarray(h, h + A);
                    break;
                  case "loca":
                    C = s.subarray(h, h + A);
                    break;
                  case "head":
                    _ = V(s, h + 18), y = V(s, h + 50);
                    break;
                  case "CFF ":
                    d = a(s, h, h + A, I);
                    break;
                }
              }
              if (u) {
                const S = _ ? [1 / _, 0, 0, 1 / _, 0, 0] : c.fontMatrix;
                return new W(N(u, C, y), r, S);
              }
              return new g(d, r, c.fontMatrix, c.glyphNameMap);
            }
          }
          b.FontRendererFactory = T;
        },
        /* 45 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.getMetrics = b.getFontBasicMetrics = void 0;
          var n = ce(3);
          const P = (0, n.getLookupTableFactory)(function(e) {
            e.Courier = 600, e["Courier-Bold"] = 600, e["Courier-BoldOblique"] = 600, e["Courier-Oblique"] = 600, e.Helvetica = (0, n.getLookupTableFactory)(function(t) {
              t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
            }), e["Helvetica-Bold"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
            }), e["Helvetica-BoldOblique"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
            }), e["Helvetica-Oblique"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
            }), e.Symbol = (0, n.getLookupTableFactory)(function(t) {
              t.space = 250, t.exclam = 333, t.universal = 713, t.numbersign = 500, t.existential = 549, t.percent = 833, t.ampersand = 778, t.suchthat = 439, t.parenleft = 333, t.parenright = 333, t.asteriskmath = 500, t.plus = 549, t.comma = 250, t.minus = 549, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 549, t.equal = 549, t.greater = 549, t.question = 444, t.congruent = 549, t.Alpha = 722, t.Beta = 667, t.Chi = 722, t.Delta = 612, t.Epsilon = 611, t.Phi = 763, t.Gamma = 603, t.Eta = 722, t.Iota = 333, t.theta1 = 631, t.Kappa = 722, t.Lambda = 686, t.Mu = 889, t.Nu = 722, t.Omicron = 722, t.Pi = 768, t.Theta = 741, t.Rho = 556, t.Sigma = 592, t.Tau = 611, t.Upsilon = 690, t.sigma1 = 439, t.Omega = 768, t.Xi = 645, t.Psi = 795, t.Zeta = 611, t.bracketleft = 333, t.therefore = 863, t.bracketright = 333, t.perpendicular = 658, t.underscore = 500, t.radicalex = 500, t.alpha = 631, t.beta = 549, t.chi = 549, t.delta = 494, t.epsilon = 439, t.phi = 521, t.gamma = 411, t.eta = 603, t.iota = 329, t.phi1 = 603, t.kappa = 549, t.lambda = 549, t.mu = 576, t.nu = 521, t.omicron = 549, t.pi = 549, t.theta = 521, t.rho = 549, t.sigma = 603, t.tau = 439, t.upsilon = 576, t.omega1 = 713, t.omega = 686, t.xi = 493, t.psi = 686, t.zeta = 494, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.similar = 549, t.Euro = 750, t.Upsilon1 = 620, t.minute = 247, t.lessequal = 549, t.fraction = 167, t.infinity = 713, t.florin = 500, t.club = 753, t.diamond = 753, t.heart = 753, t.spade = 753, t.arrowboth = 1042, t.arrowleft = 987, t.arrowup = 603, t.arrowright = 987, t.arrowdown = 603, t.degree = 400, t.plusminus = 549, t.second = 411, t.greaterequal = 549, t.multiply = 549, t.proportional = 713, t.partialdiff = 494, t.bullet = 460, t.divide = 549, t.notequal = 549, t.equivalence = 549, t.approxequal = 549, t.ellipsis = 1e3, t.arrowvertex = 603, t.arrowhorizex = 1e3, t.carriagereturn = 658, t.aleph = 823, t.Ifraktur = 686, t.Rfraktur = 795, t.weierstrass = 987, t.circlemultiply = 768, t.circleplus = 768, t.emptyset = 823, t.intersection = 768, t.union = 768, t.propersuperset = 713, t.reflexsuperset = 713, t.notsubset = 713, t.propersubset = 713, t.reflexsubset = 713, t.element = 713, t.notelement = 713, t.angle = 768, t.gradient = 713, t.registerserif = 790, t.copyrightserif = 790, t.trademarkserif = 890, t.product = 823, t.radical = 549, t.dotmath = 250, t.logicalnot = 713, t.logicaland = 603, t.logicalor = 603, t.arrowdblboth = 1042, t.arrowdblleft = 987, t.arrowdblup = 603, t.arrowdblright = 987, t.arrowdbldown = 603, t.lozenge = 494, t.angleleft = 329, t.registersans = 790, t.copyrightsans = 790, t.trademarksans = 786, t.summation = 713, t.parenlefttp = 384, t.parenleftex = 384, t.parenleftbt = 384, t.bracketlefttp = 384, t.bracketleftex = 384, t.bracketleftbt = 384, t.bracelefttp = 494, t.braceleftmid = 494, t.braceleftbt = 494, t.braceex = 494, t.angleright = 329, t.integral = 274, t.integraltp = 686, t.integralex = 686, t.integralbt = 686, t.parenrighttp = 384, t.parenrightex = 384, t.parenrightbt = 384, t.bracketrighttp = 384, t.bracketrightex = 384, t.bracketrightbt = 384, t.bracerighttp = 494, t.bracerightmid = 494, t.bracerightbt = 494, t.apple = 790;
            }), e["Times-Roman"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 250, t.exclam = 333, t.quotedbl = 408, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 564, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 564, t.equal = 564, t.greater = 564, t.question = 444, t.at = 921, t.A = 722, t.B = 667, t.C = 667, t.D = 722, t.E = 611, t.F = 556, t.G = 722, t.H = 722, t.I = 333, t.J = 389, t.K = 722, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 556, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 722, t.W = 944, t.X = 722, t.Y = 722, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 469, t.underscore = 500, t.quoteleft = 333, t.a = 444, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 333, t.s = 389, t.t = 278, t.u = 500, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.asciitilde = 541, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 180, t.quotedblleft = 444, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 453, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 444, t.quotedblright = 444, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 444, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 889, t.ordfeminine = 276, t.Lslash = 611, t.Oslash = 722, t.OE = 889, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 444, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 722, t.divide = 564, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 444, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 444, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 444, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 444, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 444, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 444, t.Amacron = 722, t.rcaron = 333, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 556, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 588, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 722, t.Abreve = 722, t.multiply = 564, t.uacute = 500, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 444, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 722, t.Iacute = 333, t.plusminus = 564, t.brokenbar = 200, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 333, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 326, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 444, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 344, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 722, t.zdotaccent = 444, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 500, t.minus = 564, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 564, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
            }), e["Times-Bold"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 250, t.exclam = 333, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 1e3, t.ampersand = 833, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 930, t.A = 722, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 778, t.I = 389, t.J = 500, t.K = 778, t.L = 667, t.M = 944, t.N = 722, t.O = 778, t.P = 611, t.Q = 778, t.R = 722, t.S = 556, t.T = 667, t.U = 722, t.V = 722, t.W = 1e3, t.X = 722, t.Y = 722, t.Z = 667, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 581, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 556, t.c = 444, t.d = 556, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 333, t.k = 556, t.l = 278, t.m = 833, t.n = 556, t.o = 500, t.p = 556, t.q = 556, t.r = 444, t.s = 389, t.t = 333, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 394, t.bar = 220, t.braceright = 394, t.asciitilde = 520, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 540, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 300, t.Lslash = 667, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 330, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 556, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 722, t.divide = 570, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 667, t.Cacute = 722, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 722, t.rcaron = 444, t.ccedilla = 444, t.Zdotaccent = 667, t.Thorn = 611, t.Omacron = 778, t.Racute = 722, t.Sacute = 556, t.dcaron = 672, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 570, t.uacute = 556, t.Tcaron = 667, t.partialdiff = 494, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 778, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 444, t.omacron = 500, t.Zacute = 667, t.Zcaron = 667, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 416, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 778, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 300, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 394, t.Kcommaaccent = 778, t.Lacute = 667, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 667, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 500, t.Ccaron = 722, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 444, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 722, t.Lcommaaccent = 667, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 444, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 556, t.minus = 570, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 333, t.logicalnot = 570, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
            }), e["Times-BoldItalic"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 250, t.exclam = 389, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 832, t.A = 667, t.B = 667, t.C = 667, t.D = 722, t.E = 667, t.F = 667, t.G = 722, t.H = 778, t.I = 389, t.J = 500, t.K = 667, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 611, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 667, t.W = 889, t.X = 667, t.Y = 611, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 570, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 556, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 556, t.v = 444, t.w = 667, t.x = 500, t.y = 444, t.z = 389, t.braceleft = 348, t.bar = 220, t.braceright = 348, t.asciitilde = 570, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 500, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 944, t.ordfeminine = 266, t.Lslash = 611, t.Oslash = 722, t.OE = 944, t.ordmasculine = 300, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 611, t.divide = 570, t.Yacute = 611, t.Acircumflex = 667, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 667, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 611, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 608, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 667, t.Abreve = 667, t.multiply = 570, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 444, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 722, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 366, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 576, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 382, t.Kcommaaccent = 667, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 500, t.minus = 606, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 606, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
            }), e["Times-Italic"] = (0, n.getLookupTableFactory)(function(t) {
              t.space = 250, t.exclam = 333, t.quotedbl = 420, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 675, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 675, t.equal = 675, t.greater = 675, t.question = 500, t.at = 920, t.A = 611, t.B = 611, t.C = 667, t.D = 722, t.E = 611, t.F = 611, t.G = 722, t.H = 722, t.I = 333, t.J = 444, t.K = 667, t.L = 556, t.M = 833, t.N = 667, t.O = 722, t.P = 611, t.Q = 722, t.R = 611, t.S = 500, t.T = 556, t.U = 722, t.V = 611, t.W = 833, t.X = 611, t.Y = 556, t.Z = 556, t.bracketleft = 389, t.backslash = 278, t.bracketright = 389, t.asciicircum = 422, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 278, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 444, t.l = 278, t.m = 722, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 500, t.v = 444, t.w = 667, t.x = 444, t.y = 444, t.z = 389, t.braceleft = 400, t.bar = 275, t.braceright = 400, t.asciitilde = 541, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 214, t.quotedblleft = 556, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 523, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 556, t.quotedblright = 556, t.guillemotright = 500, t.ellipsis = 889, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 889, t.AE = 889, t.ordfeminine = 276, t.Lslash = 556, t.Oslash = 722, t.OE = 944, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 667, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 556, t.divide = 675, t.Yacute = 556, t.Acircumflex = 611, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 667, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 556, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 611, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 500, t.Amacron = 611, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 556, t.Thorn = 611, t.Omacron = 722, t.Racute = 611, t.Sacute = 500, t.dcaron = 544, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 611, t.Abreve = 611, t.multiply = 675, t.uacute = 500, t.Tcaron = 556, t.partialdiff = 476, t.ydieresis = 444, t.Nacute = 667, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 667, t.Iacute = 333, t.plusminus = 675, t.brokenbar = 275, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 389, t.omacron = 500, t.Zacute = 556, t.Zcaron = 556, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 300, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 611, t.Adieresis = 611, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 500, t.lcaron = 300, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 500, t.Scommaaccent = 500, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 667, t.otilde = 500, t.Rcommaaccent = 611, t.Lcommaaccent = 556, t.Atilde = 611, t.Aogonek = 611, t.Aring = 611, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 444, t.minus = 675, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 675, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
            }), e.ZapfDingbats = (0, n.getLookupTableFactory)(function(t) {
              t.space = 278, t.a1 = 974, t.a2 = 961, t.a202 = 974, t.a3 = 980, t.a4 = 719, t.a5 = 789, t.a119 = 790, t.a118 = 791, t.a117 = 690, t.a11 = 960, t.a12 = 939, t.a13 = 549, t.a14 = 855, t.a15 = 911, t.a16 = 933, t.a105 = 911, t.a17 = 945, t.a18 = 974, t.a19 = 755, t.a20 = 846, t.a21 = 762, t.a22 = 761, t.a23 = 571, t.a24 = 677, t.a25 = 763, t.a26 = 760, t.a27 = 759, t.a28 = 754, t.a6 = 494, t.a7 = 552, t.a8 = 537, t.a9 = 577, t.a10 = 692, t.a29 = 786, t.a30 = 788, t.a31 = 788, t.a32 = 790, t.a33 = 793, t.a34 = 794, t.a35 = 816, t.a36 = 823, t.a37 = 789, t.a38 = 841, t.a39 = 823, t.a40 = 833, t.a41 = 816, t.a42 = 831, t.a43 = 923, t.a44 = 744, t.a45 = 723, t.a46 = 749, t.a47 = 790, t.a48 = 792, t.a49 = 695, t.a50 = 776, t.a51 = 768, t.a52 = 792, t.a53 = 759, t.a54 = 707, t.a55 = 708, t.a56 = 682, t.a57 = 701, t.a58 = 826, t.a59 = 815, t.a60 = 789, t.a61 = 789, t.a62 = 707, t.a63 = 687, t.a64 = 696, t.a65 = 689, t.a66 = 786, t.a67 = 787, t.a68 = 713, t.a69 = 791, t.a70 = 785, t.a71 = 791, t.a72 = 873, t.a73 = 761, t.a74 = 762, t.a203 = 762, t.a75 = 759, t.a204 = 759, t.a76 = 892, t.a77 = 892, t.a78 = 788, t.a79 = 784, t.a81 = 438, t.a82 = 138, t.a83 = 277, t.a84 = 415, t.a97 = 392, t.a98 = 392, t.a99 = 668, t.a100 = 668, t.a89 = 390, t.a90 = 390, t.a93 = 317, t.a94 = 317, t.a91 = 276, t.a92 = 276, t.a205 = 509, t.a85 = 509, t.a206 = 410, t.a86 = 410, t.a87 = 234, t.a88 = 234, t.a95 = 334, t.a96 = 334, t.a101 = 732, t.a102 = 544, t.a103 = 544, t.a104 = 910, t.a106 = 667, t.a107 = 760, t.a108 = 760, t.a112 = 776, t.a111 = 595, t.a110 = 694, t.a109 = 626, t.a120 = 788, t.a121 = 788, t.a122 = 788, t.a123 = 788, t.a124 = 788, t.a125 = 788, t.a126 = 788, t.a127 = 788, t.a128 = 788, t.a129 = 788, t.a130 = 788, t.a131 = 788, t.a132 = 788, t.a133 = 788, t.a134 = 788, t.a135 = 788, t.a136 = 788, t.a137 = 788, t.a138 = 788, t.a139 = 788, t.a140 = 788, t.a141 = 788, t.a142 = 788, t.a143 = 788, t.a144 = 788, t.a145 = 788, t.a146 = 788, t.a147 = 788, t.a148 = 788, t.a149 = 788, t.a150 = 788, t.a151 = 788, t.a152 = 788, t.a153 = 788, t.a154 = 788, t.a155 = 788, t.a156 = 788, t.a157 = 788, t.a158 = 788, t.a159 = 788, t.a160 = 894, t.a161 = 838, t.a163 = 1016, t.a164 = 458, t.a196 = 748, t.a165 = 924, t.a192 = 748, t.a166 = 918, t.a167 = 927, t.a168 = 928, t.a169 = 928, t.a170 = 834, t.a171 = 873, t.a172 = 828, t.a173 = 924, t.a162 = 924, t.a174 = 917, t.a175 = 930, t.a176 = 931, t.a177 = 463, t.a178 = 883, t.a179 = 836, t.a193 = 836, t.a180 = 867, t.a199 = 867, t.a181 = 696, t.a200 = 696, t.a182 = 874, t.a201 = 874, t.a183 = 760, t.a184 = 946, t.a197 = 771, t.a185 = 865, t.a194 = 771, t.a198 = 888, t.a186 = 967, t.a195 = 888, t.a187 = 831, t.a188 = 873, t.a189 = 927, t.a190 = 970, t.a191 = 918;
            });
          });
          b.getMetrics = P;
          const D = (0, n.getLookupTableFactory)(function(e) {
            e.Courier = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: -426
            }, e["Courier-Bold"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 439
            }, e["Courier-Oblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, e["Courier-BoldOblique"] = {
              ascent: 629,
              descent: -157,
              capHeight: 562,
              xHeight: 426
            }, e.Helvetica = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, e["Helvetica-Bold"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, e["Helvetica-Oblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 523
            }, e["Helvetica-BoldOblique"] = {
              ascent: 718,
              descent: -207,
              capHeight: 718,
              xHeight: 532
            }, e["Times-Roman"] = {
              ascent: 683,
              descent: -217,
              capHeight: 662,
              xHeight: 450
            }, e["Times-Bold"] = {
              ascent: 683,
              descent: -217,
              capHeight: 676,
              xHeight: 461
            }, e["Times-Italic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 653,
              xHeight: 441
            }, e["Times-BoldItalic"] = {
              ascent: 683,
              descent: -217,
              capHeight: 669,
              xHeight: 462
            }, e.Symbol = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            }, e.ZapfDingbats = {
              ascent: Math.NaN,
              descent: Math.NaN,
              capHeight: Math.NaN,
              xHeight: Math.NaN
            };
          });
          b.getFontBasicMetrics = D;
        },
        /* 46 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.GlyfTable = void 0;
          const ce = 1, n = 2, P = 4, D = 8, e = 16, t = 32, l = 64, V = 1, te = 2, E = 8, F = 32, f = 64, x = 128, a = 256;
          class N {
            constructor({
              glyfTable: g,
              isGlyphLocationsLong: T,
              locaTable: o,
              numGlyphs: c
            }) {
              this.glyphs = [];
              const I = new DataView(o.buffer, o.byteOffset, o.byteLength), s = new DataView(g.buffer, g.byteOffset, g.byteLength), r = T ? 4 : 2;
              let u = T ? I.getUint32(0) : 2 * I.getUint16(0), C = 0;
              for (let d = 0; d < c; d++) {
                C += r;
                const y = T ? I.getUint32(C) : 2 * I.getUint16(C);
                if (y === u) {
                  this.glyphs.push(new p({}));
                  continue;
                }
                const _ = p.parse(u, s);
                this.glyphs.push(_), u = y;
              }
            }
            getSize() {
              return this.glyphs.reduce((g, T) => {
                const o = T.getSize();
                return g + (o + 3 & -4);
              }, 0);
            }
            write() {
              const g = this.getSize(), T = new DataView(new ArrayBuffer(g)), o = g > 131070, c = o ? 4 : 2, I = new DataView(new ArrayBuffer((this.glyphs.length + 1) * c));
              o ? I.setUint32(0, 0) : I.setUint16(0, 0);
              let s = 0, r = 0;
              for (const u of this.glyphs)
                s += u.write(s, T), s = s + 3 & -4, r += c, o ? I.setUint32(r, s) : I.setUint16(r, s >> 1);
              return {
                isLocationLong: o,
                loca: new Uint8Array(I.buffer),
                glyf: new Uint8Array(T.buffer)
              };
            }
            scale(g) {
              for (let T = 0, o = this.glyphs.length; T < o; T++)
                this.glyphs[T].scale(g[T]);
            }
          }
          b.GlyfTable = N;
          class p {
            constructor({
              header: g = null,
              simple: T = null,
              composites: o = null
            }) {
              this.header = g, this.simple = T, this.composites = o;
            }
            static parse(g, T) {
              const [o, c] = O.parse(g, T);
              if (g += o, c.numberOfContours < 0) {
                const s = [];
                for (; ; ) {
                  const [r, u] = z.parse(g, T);
                  if (g += r, s.push(u), !(u.flags & F))
                    break;
                }
                return new p({
                  header: c,
                  composites: s
                });
              }
              const I = R.parse(g, T, c.numberOfContours);
              return new p({
                header: c,
                simple: I
              });
            }
            getSize() {
              if (!this.header)
                return 0;
              const g = this.simple ? this.simple.getSize() : this.composites.reduce((T, o) => T + o.getSize(), 0);
              return this.header.getSize() + g;
            }
            write(g, T) {
              if (!this.header)
                return 0;
              const o = g;
              if (g += this.header.write(g, T), this.simple)
                g += this.simple.write(g, T);
              else
                for (const c of this.composites)
                  g += c.write(g, T);
              return g - o;
            }
            scale(g) {
              if (!this.header)
                return;
              const T = (this.header.xMin + this.header.xMax) / 2;
              if (this.header.scale(T, g), this.simple)
                this.simple.scale(T, g);
              else
                for (const o of this.composites)
                  o.scale(T, g);
            }
          }
          class O {
            constructor({
              numberOfContours: g,
              xMin: T,
              yMin: o,
              xMax: c,
              yMax: I
            }) {
              this.numberOfContours = g, this.xMin = T, this.yMin = o, this.xMax = c, this.yMax = I;
            }
            static parse(g, T) {
              return [10, new O({
                numberOfContours: T.getInt16(g),
                xMin: T.getInt16(g + 2),
                yMin: T.getInt16(g + 4),
                xMax: T.getInt16(g + 6),
                yMax: T.getInt16(g + 8)
              })];
            }
            getSize() {
              return 10;
            }
            write(g, T) {
              return T.setInt16(g, this.numberOfContours), T.setInt16(g + 2, this.xMin), T.setInt16(g + 4, this.yMin), T.setInt16(g + 6, this.xMax), T.setInt16(g + 8, this.yMax), 10;
            }
            scale(g, T) {
              this.xMin = Math.round(g + (this.xMin - g) * T), this.xMax = Math.round(g + (this.xMax - g) * T);
            }
          }
          class M {
            constructor({
              flags: g,
              xCoordinates: T,
              yCoordinates: o
            }) {
              this.xCoordinates = T, this.yCoordinates = o, this.flags = g;
            }
          }
          class R {
            constructor({
              contours: g,
              instructions: T
            }) {
              this.contours = g, this.instructions = T;
            }
            static parse(g, T, o) {
              const c = [];
              for (let m = 0; m < o; m++) {
                const h = T.getUint16(g);
                g += 2, c.push(h);
              }
              const I = c[o - 1] + 1, s = T.getUint16(g);
              g += 2;
              const r = new Uint8Array(T).slice(g, g + s);
              g += s;
              const u = [];
              for (let m = 0; m < I; g++, m++) {
                let h = T.getUint8(g);
                if (u.push(h), h & D) {
                  const A = T.getUint8(++g);
                  h ^= D;
                  for (let j = 0; j < A; j++)
                    u.push(h);
                  m += A;
                }
              }
              const C = [];
              let d = [], y = [], _ = [];
              const $ = [];
              let S = 0, v = 0;
              for (let m = 0; m < I; m++) {
                const h = u[m];
                if (h & n) {
                  const A = T.getUint8(g++);
                  v += h & e ? A : -A, d.push(v);
                } else
                  h & e || (v += T.getInt16(g), g += 2), d.push(v);
                c[S] === m && (S++, C.push(d), d = []);
              }
              v = 0, S = 0;
              for (let m = 0; m < I; m++) {
                const h = u[m];
                if (h & P) {
                  const A = T.getUint8(g++);
                  v += h & t ? A : -A, y.push(v);
                } else
                  h & t || (v += T.getInt16(g), g += 2), y.push(v);
                _.push(h & ce | h & l), c[S] === m && (d = C[S], S++, $.push(new M({
                  flags: _,
                  xCoordinates: d,
                  yCoordinates: y
                })), y = [], _ = []);
              }
              return new R({
                contours: $,
                instructions: r
              });
            }
            getSize() {
              let g = this.contours.length * 2 + 2 + this.instructions.length, T = 0, o = 0;
              for (const c of this.contours) {
                g += c.flags.length;
                for (let I = 0, s = c.xCoordinates.length; I < s; I++) {
                  const r = c.xCoordinates[I], u = c.yCoordinates[I];
                  let C = Math.abs(r - T);
                  C > 255 ? g += 2 : C > 0 && (g += 1), T = r, C = Math.abs(u - o), C > 255 ? g += 2 : C > 0 && (g += 1), o = u;
                }
              }
              return g;
            }
            write(g, T) {
              const o = g, c = [], I = [], s = [];
              let r = 0, u = 0;
              for (const C of this.contours) {
                for (let d = 0, y = C.xCoordinates.length; d < y; d++) {
                  let _ = C.flags[d];
                  const $ = C.xCoordinates[d];
                  let S = $ - r;
                  if (S === 0)
                    _ |= e, c.push(0);
                  else {
                    const m = Math.abs(S);
                    m <= 255 ? (_ |= S >= 0 ? n | e : n, c.push(m)) : c.push(S);
                  }
                  r = $;
                  const v = C.yCoordinates[d];
                  if (S = v - u, S === 0)
                    _ |= t, I.push(0);
                  else {
                    const m = Math.abs(S);
                    m <= 255 ? (_ |= S >= 0 ? P | t : P, I.push(m)) : I.push(S);
                  }
                  u = v, s.push(_);
                }
                T.setUint16(g, c.length - 1), g += 2;
              }
              T.setUint16(g, this.instructions.length), g += 2, this.instructions.length && (new Uint8Array(T.buffer, 0, T.buffer.byteLength).set(this.instructions, g), g += this.instructions.length);
              for (const C of s)
                T.setUint8(g++, C);
              for (let C = 0, d = c.length; C < d; C++) {
                const y = c[C], _ = s[C];
                _ & n ? T.setUint8(g++, y) : _ & e || (T.setInt16(g, y), g += 2);
              }
              for (let C = 0, d = I.length; C < d; C++) {
                const y = I[C], _ = s[C];
                _ & P ? T.setUint8(g++, y) : _ & t || (T.setInt16(g, y), g += 2);
              }
              return g - o;
            }
            scale(g, T) {
              for (const o of this.contours)
                if (o.xCoordinates.length !== 0)
                  for (let c = 0, I = o.xCoordinates.length; c < I; c++)
                    o.xCoordinates[c] = Math.round(g + (o.xCoordinates[c] - g) * T);
            }
          }
          class z {
            constructor({
              flags: g,
              glyphIndex: T,
              argument1: o,
              argument2: c,
              transf: I,
              instructions: s
            }) {
              this.flags = g, this.glyphIndex = T, this.argument1 = o, this.argument2 = c, this.transf = I, this.instructions = s;
            }
            static parse(g, T) {
              const o = g, c = [];
              let I = T.getUint16(g);
              const s = T.getUint16(g + 2);
              g += 4;
              let r, u;
              I & V ? (I & te ? (r = T.getInt16(g), u = T.getInt16(g + 2)) : (r = T.getUint16(g), u = T.getUint16(g + 2)), g += 4, I ^= V) : (I & te ? (r = T.getInt8(g), u = T.getInt8(g + 1)) : (r = T.getUint8(g), u = T.getUint8(g + 1)), g += 2), I & E ? (c.push(T.getUint16(g)), g += 2) : I & f ? (c.push(T.getUint16(g), T.getUint16(g + 2)), g += 4) : I & x && (c.push(T.getUint16(g), T.getUint16(g + 2), T.getUint16(g + 4), T.getUint16(g + 6)), g += 8);
              let C = null;
              if (I & a) {
                const d = T.getUint16(g);
                g += 2, C = new Uint8Array(T).slice(g, g + d), g += d;
              }
              return [g - o, new z({
                flags: I,
                glyphIndex: s,
                argument1: r,
                argument2: u,
                transf: c,
                instructions: C
              })];
            }
            getSize() {
              let g = 4 + this.transf.length * 2;
              return this.flags & a && (g += 2 + this.instructions.length), g += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (g += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (g += 2), g;
            }
            write(g, T) {
              const o = g;
              return this.flags & te ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= V) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= V), T.setUint16(g, this.flags), T.setUint16(g + 2, this.glyphIndex), g += 4, this.flags & V ? (this.flags & te ? (T.setInt16(g, this.argument1), T.setInt16(g + 2, this.argument2)) : (T.setUint16(g, this.argument1), T.setUint16(g + 2, this.argument2)), g += 4) : (T.setUint8(g, this.argument1), T.setUint8(g + 1, this.argument2), g += 2), this.flags & a && (T.setUint16(g, this.instructions.length), g += 2, this.instructions.length && (new Uint8Array(T.buffer, 0, T.buffer.byteLength).set(this.instructions, g), g += this.instructions.length)), g - o;
            }
            scale(g, T) {
            }
          }
        },
        /* 47 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.OpenTypeFileBuilder = void 0;
          var n = ce(3), P = ce(2);
          function D(E, F, f) {
            E[F] = f >> 8 & 255, E[F + 1] = f & 255;
          }
          function e(E, F, f) {
            E[F] = f >> 24 & 255, E[F + 1] = f >> 16 & 255, E[F + 2] = f >> 8 & 255, E[F + 3] = f & 255;
          }
          function t(E, F, f) {
            if (f instanceof Uint8Array)
              E.set(f, F);
            else if (typeof f == "string")
              for (let x = 0, a = f.length; x < a; x++)
                E[F++] = f.charCodeAt(x) & 255;
            else
              for (const x of f)
                E[F++] = x & 255;
          }
          const l = 12, V = 16;
          class te {
            constructor(F) {
              this.sfnt = F, this.tables = /* @__PURE__ */ Object.create(null);
            }
            static getSearchParams(F, f) {
              let x = 1, a = 0;
              for (; (x ^ F) > x; )
                x <<= 1, a++;
              const N = x * f;
              return {
                range: N,
                entry: a,
                rangeShift: f * F - N
              };
            }
            toArray() {
              let F = this.sfnt;
              const f = this.tables, x = Object.keys(f);
              x.sort();
              const a = x.length;
              let N, p, O, M, R, z = l + a * V;
              const W = [z];
              for (N = 0; N < a; N++) {
                M = f[x[N]];
                const o = (M.length + 3 & -4) >>> 0;
                z += o, W.push(z);
              }
              const g = new Uint8Array(z);
              for (N = 0; N < a; N++)
                M = f[x[N]], t(g, W[N], M);
              F === "true" && (F = (0, P.string32)(65536)), g[0] = F.charCodeAt(0) & 255, g[1] = F.charCodeAt(1) & 255, g[2] = F.charCodeAt(2) & 255, g[3] = F.charCodeAt(3) & 255, D(g, 4, a);
              const T = te.getSearchParams(a, 16);
              for (D(g, 6, T.range), D(g, 8, T.entry), D(g, 10, T.rangeShift), z = l, N = 0; N < a; N++) {
                R = x[N], g[z] = R.charCodeAt(0) & 255, g[z + 1] = R.charCodeAt(1) & 255, g[z + 2] = R.charCodeAt(2) & 255, g[z + 3] = R.charCodeAt(3) & 255;
                let o = 0;
                for (p = W[N], O = W[N + 1]; p < O; p += 4) {
                  const c = (0, n.readUint32)(g, p);
                  o = o + c >>> 0;
                }
                e(g, z + 4, o), e(g, z + 8, W[N]), e(g, z + 12, f[R].length), z += V;
              }
              return g;
            }
            addTable(F, f) {
              if (F in this.tables)
                throw new Error("Table " + F + " already exists");
              this.tables[F] = f;
            }
          }
          b.OpenTypeFileBuilder = te;
        },
        /* 48 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Type1Font = void 0;
          var n = ce(35), P = ce(2), D = ce(38), e = ce(3), t = ce(8), l = ce(49);
          function V(f, x, a) {
            const N = f.length, p = x.length, O = N - p;
            let M = a, R = !1;
            for (; M < O; ) {
              let z = 0;
              for (; z < p && f[M + z] === x[z]; )
                z++;
              if (z >= p) {
                for (M += z; M < N && (0, e.isWhiteSpace)(f[M]); )
                  M++;
                R = !0;
                break;
              }
              M++;
            }
            return {
              found: R,
              length: M
            };
          }
          function te(f, x) {
            const a = [101, 101, 120, 101, 99], N = f.pos;
            let p, O, M;
            try {
              p = f.getBytes(x), O = p.length;
            } catch {
            }
            if (O === x && (M = V(p, a, x - 2 * a.length), M.found && M.length === x))
              return {
                stream: new t.Stream(p),
                length: x
              };
            (0, P.warn)('Invalid "Length1" property in Type1 font -- trying to recover.'), f.pos = N;
            const R = 2048;
            let z;
            for (; ; ) {
              const W = f.peekBytes(R);
              if (M = V(W, a, 0), M.length === 0)
                break;
              if (f.pos += M.length, M.found) {
                z = f.pos - N;
                break;
              }
            }
            return f.pos = N, z ? {
              stream: new t.Stream(f.getBytes(z)),
              length: z
            } : ((0, P.warn)('Unable to recover "Length1" property in Type1 font -- using as is.'), {
              stream: new t.Stream(f.getBytes(x)),
              length: x
            });
          }
          function E(f, x) {
            const a = f.getBytes();
            if (a.length === 0)
              throw new P.FormatError("getEexecBlock - no font program found.");
            return {
              stream: new t.Stream(a),
              length: a.length
            };
          }
          class F {
            constructor(x, a, N) {
              let O = N.length1;
              N.length2;
              let M = a.peekBytes(6);
              const R = M[0] === 128 && M[1] === 1;
              R && (a.skip(6), O = M[5] << 24 | M[4] << 16 | M[3] << 8 | M[2]);
              const z = te(a, O);
              new l.Type1Parser(z.stream, !1, D.SEAC_ANALYSIS_ENABLED).extractFontHeader(N), R && (M = a.getBytes(6), M[5] << 24 | M[4] << 16 | M[3] << 8 | M[2]);
              const g = E(a), o = new l.Type1Parser(g.stream, !0, D.SEAC_ANALYSIS_ENABLED).extractFontProgram(N);
              for (const r in o.properties)
                N[r] = o.properties[r];
              const c = o.charstrings, I = this.getType2Charstrings(c), s = this.getType2Subrs(o.subrs);
              this.charstrings = c, this.data = this.wrap(x, I, this.charstrings, s, N), this.seacs = this.getSeacs(o.charstrings);
            }
            get numGlyphs() {
              return this.charstrings.length + 1;
            }
            getCharset() {
              const x = [".notdef"];
              for (const {
                glyphName: a
              } of this.charstrings)
                x.push(a);
              return x;
            }
            getGlyphMapping(x) {
              const a = this.charstrings;
              if (x.composite) {
                const R = /* @__PURE__ */ Object.create(null);
                for (let z = 0, W = a.length; z < W; z++) {
                  const g = x.cMap.charCodeOf(z);
                  R[g] = z + 1;
                }
                return R;
              }
              const N = [".notdef"];
              let p, O;
              for (O = 0; O < a.length; O++)
                N.push(a[O].glyphName);
              const M = x.builtInEncoding;
              if (M) {
                p = /* @__PURE__ */ Object.create(null);
                for (const R in M)
                  O = N.indexOf(M[R]), O >= 0 && (p[R] = O);
              }
              return (0, D.type1FontGlyphMapping)(x, p, N);
            }
            hasGlyphId(x) {
              return x < 0 || x >= this.numGlyphs ? !1 : x === 0 ? !0 : this.charstrings[x - 1].charstring.length > 0;
            }
            getSeacs(x) {
              const a = [];
              for (let N = 0, p = x.length; N < p; N++) {
                const O = x[N];
                O.seac && (a[N + 1] = O.seac);
              }
              return a;
            }
            getType2Charstrings(x) {
              const a = [];
              for (const N of x)
                a.push(N.charstring);
              return a;
            }
            getType2Subrs(x) {
              let a = 0;
              const N = x.length;
              N < 1133 ? a = 107 : N < 33769 ? a = 1131 : a = 32768;
              const p = [];
              let O;
              for (O = 0; O < a; O++)
                p.push([11]);
              for (O = 0; O < N; O++)
                p.push(x[O]);
              return p;
            }
            wrap(x, a, N, p, O) {
              const M = new n.CFF();
              M.header = new n.CFFHeader(1, 0, 4, 4), M.names = [x];
              const R = new n.CFFTopDict();
              R.setByName("version", 391), R.setByName("Notice", 392), R.setByName("FullName", 393), R.setByName("FamilyName", 394), R.setByName("Weight", 395), R.setByName("Encoding", null), R.setByName("FontMatrix", O.fontMatrix), R.setByName("FontBBox", O.bbox), R.setByName("charset", null), R.setByName("CharStrings", null), R.setByName("Private", null), M.topDict = R;
              const z = new n.CFFStrings();
              z.add("Version 0.11"), z.add("See original notice"), z.add(x), z.add(x), z.add("Medium"), M.strings = z, M.globalSubrIndex = new n.CFFIndex();
              const W = a.length, g = [".notdef"];
              let T, o;
              for (T = 0; T < W; T++) {
                const C = N[T].glyphName;
                n.CFFStandardStrings.indexOf(C) === -1 && z.add(C), g.push(C);
              }
              M.charset = new n.CFFCharset(!1, 0, g);
              const c = new n.CFFIndex();
              for (c.add([139, 14]), T = 0; T < W; T++)
                c.add(a[T]);
              M.charStrings = c;
              const I = new n.CFFPrivateDict();
              I.setByName("Subrs", null);
              const s = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
              for (T = 0, o = s.length; T < o; T++) {
                const C = s[T];
                if (!(C in O.privateData))
                  continue;
                const d = O.privateData[C];
                if (Array.isArray(d))
                  for (let y = d.length - 1; y > 0; y--)
                    d[y] -= d[y - 1];
                I.setByName(C, d);
              }
              M.topDict.privateDict = I;
              const r = new n.CFFIndex();
              for (T = 0, o = p.length; T < o; T++)
                r.add(p[T]);
              return I.subrsIndex = r, new n.CFFCompiler(M).compile();
            }
          }
          b.Type1Font = F;
        },
        /* 49 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Type1Parser = void 0;
          var n = ce(37), P = ce(3), D = ce(8), e = ce(2);
          const t = !1, l = {
            hstem: [1],
            vstem: [3],
            vmoveto: [4],
            rlineto: [5],
            hlineto: [6],
            vlineto: [7],
            rrcurveto: [8],
            callsubr: [10],
            flex: [12, 35],
            drop: [12, 18],
            endchar: [14],
            rmoveto: [21],
            hmoveto: [22],
            vhcurveto: [30],
            hvcurveto: [31]
          };
          class V {
            constructor() {
              this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
            }
            convert(O, M, R) {
              const z = O.length;
              let W = !1, g, T, o;
              for (let c = 0; c < z; c++) {
                let I = O[c];
                if (I < 32) {
                  switch (I === 12 && (I = (I << 8) + O[++c]), I) {
                    case 1: {
                      this.stack = [];
                      break;
                    }
                    case 3: {
                      this.stack = [];
                      break;
                    }
                    case 4:
                      if (this.flexing) {
                        if (this.stack.length < 1) {
                          W = !0;
                          break;
                        }
                        const d = this.stack.pop();
                        this.stack.push(0, d);
                        break;
                      }
                      W = this.executeCommand(1, l.vmoveto);
                      break;
                    case 5:
                      W = this.executeCommand(2, l.rlineto);
                      break;
                    case 6:
                      W = this.executeCommand(1, l.hlineto);
                      break;
                    case 7:
                      W = this.executeCommand(1, l.vlineto);
                      break;
                    case 8:
                      W = this.executeCommand(6, l.rrcurveto);
                      break;
                    case 9:
                      this.stack = [];
                      break;
                    case 10:
                      if (this.stack.length < 1) {
                        W = !0;
                        break;
                      }
                      if (o = this.stack.pop(), !M[o]) {
                        W = !0;
                        break;
                      }
                      W = this.convert(M[o], M, R);
                      break;
                    case 11:
                      return W;
                    case 13:
                      if (this.stack.length < 2) {
                        W = !0;
                        break;
                      }
                      g = this.stack.pop(), T = this.stack.pop(), this.lsb = T, this.width = g, this.stack.push(g, T), W = this.executeCommand(2, l.hmoveto);
                      break;
                    case 14:
                      this.output.push(l.endchar[0]);
                      break;
                    case 21:
                      if (this.flexing)
                        break;
                      W = this.executeCommand(2, l.rmoveto);
                      break;
                    case 22:
                      if (this.flexing) {
                        this.stack.push(0);
                        break;
                      }
                      W = this.executeCommand(1, l.hmoveto);
                      break;
                    case 30:
                      W = this.executeCommand(4, l.vhcurveto);
                      break;
                    case 31:
                      W = this.executeCommand(4, l.hvcurveto);
                      break;
                    case 3072:
                      this.stack = [];
                      break;
                    case 3073: {
                      this.stack = [];
                      break;
                    }
                    case 3074: {
                      this.stack = [];
                      break;
                    }
                    case 3078:
                      if (R) {
                        const d = this.stack.at(-5);
                        this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - d, W = this.executeCommand(0, l.endchar);
                      } else
                        W = this.executeCommand(4, l.endchar);
                      break;
                    case 3079:
                      if (this.stack.length < 4) {
                        W = !0;
                        break;
                      }
                      this.stack.pop(), g = this.stack.pop();
                      const s = this.stack.pop();
                      T = this.stack.pop(), this.lsb = T, this.width = g, this.stack.push(g, T, s), W = this.executeCommand(3, l.rmoveto);
                      break;
                    case 3084:
                      if (this.stack.length < 2) {
                        W = !0;
                        break;
                      }
                      const r = this.stack.pop(), u = this.stack.pop();
                      this.stack.push(u / r);
                      break;
                    case 3088:
                      if (this.stack.length < 2) {
                        W = !0;
                        break;
                      }
                      o = this.stack.pop();
                      const C = this.stack.pop();
                      if (o === 0 && C === 3) {
                        const d = this.stack.splice(-17, 17);
                        this.stack.push(d[2] + d[0], d[3] + d[1], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11], d[12], d[13], d[14]), W = this.executeCommand(13, l.flex, !0), this.flexing = !1, this.stack.push(d[15], d[16]);
                      } else
                        o === 1 && C === 0 && (this.flexing = !0);
                      break;
                    case 3089:
                      break;
                    case 3105:
                      this.stack = [];
                      break;
                    default:
                      (0, e.warn)('Unknown type 1 charstring command of "' + I + '"');
                      break;
                  }
                  if (W)
                    break;
                  continue;
                } else
                  I <= 246 ? I -= 139 : I <= 250 ? I = (I - 247) * 256 + O[++c] + 108 : I <= 254 ? I = -((I - 251) * 256) - O[++c] - 108 : I = (O[++c] & 255) << 24 | (O[++c] & 255) << 16 | (O[++c] & 255) << 8 | (O[++c] & 255) << 0;
                this.stack.push(I);
              }
              return W;
            }
            executeCommand(O, M, R) {
              const z = this.stack.length;
              if (O > z)
                return !0;
              const W = z - O;
              for (let g = W; g < z; g++) {
                let T = this.stack[g];
                Number.isInteger(T) ? this.output.push(28, T >> 8 & 255, T & 255) : (T = 65536 * T | 0, this.output.push(255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255));
              }
              return this.output.push(...M), R ? this.stack.splice(W, O) : this.stack.length = 0, !1;
            }
          }
          const te = 55665, E = 4330;
          function F(p) {
            return p >= 48 && p <= 57 || p >= 65 && p <= 70 || p >= 97 && p <= 102;
          }
          function f(p, O, M) {
            if (M >= p.length)
              return new Uint8Array(0);
            const R = 52845, z = 22719;
            let W = O | 0, g, T;
            for (g = 0; g < M; g++)
              W = (p[g] + W) * R + z & 65535;
            const o = p.length - M, c = new Uint8Array(o);
            for (g = M, T = 0; T < o; g++, T++) {
              const I = p[g];
              c[T] = I ^ W >> 8, W = (I + W) * R + z & 65535;
            }
            return c;
          }
          function x(p, O, M) {
            let W = O | 0;
            const g = p.length, T = g >>> 1, o = new Uint8Array(T);
            let c, I;
            for (c = 0, I = 0; c < g; c++) {
              const s = p[c];
              if (!F(s))
                continue;
              c++;
              let r;
              for (; c < g && !F(r = p[c]); )
                c++;
              if (c < g) {
                const u = parseInt(String.fromCharCode(s, r), 16);
                o[I++] = u ^ W >> 8, W = (u + W) * 52845 + 22719 & 65535;
              }
            }
            return o.slice(M, I);
          }
          function a(p) {
            return p === 47 || p === 91 || p === 93 || p === 123 || p === 125 || p === 40 || p === 41;
          }
          class N {
            constructor(O, M, R) {
              if (M) {
                const z = O.getBytes(), W = !((F(z[0]) || (0, P.isWhiteSpace)(z[0])) && F(z[1]) && F(z[2]) && F(z[3]) && F(z[4]) && F(z[5]) && F(z[6]) && F(z[7]));
                O = new D.Stream(W ? f(z, te, 4) : x(z, te, 4));
              }
              this.seacAnalysisEnabled = !!R, this.stream = O, this.nextChar();
            }
            readNumberArray() {
              this.getToken();
              const O = [];
              for (; ; ) {
                const M = this.getToken();
                if (M === null || M === "]" || M === "}")
                  break;
                O.push(parseFloat(M || 0));
              }
              return O;
            }
            readNumber() {
              const O = this.getToken();
              return parseFloat(O || 0);
            }
            readInt() {
              const O = this.getToken();
              return parseInt(O || 0, 10) | 0;
            }
            readBoolean() {
              return this.getToken() === "true" ? 1 : 0;
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            prevChar() {
              return this.stream.skip(-2), this.currentChar = this.stream.getByte();
            }
            getToken() {
              let O = !1, M = this.currentChar;
              for (; ; ) {
                if (M === -1)
                  return null;
                if (O)
                  (M === 10 || M === 13) && (O = !1);
                else if (M === 37)
                  O = !0;
                else if (!(0, P.isWhiteSpace)(M))
                  break;
                M = this.nextChar();
              }
              if (a(M))
                return this.nextChar(), String.fromCharCode(M);
              let R = "";
              do
                R += String.fromCharCode(M), M = this.nextChar();
              while (M >= 0 && !(0, P.isWhiteSpace)(M) && !a(M));
              return R;
            }
            readCharStrings(O, M) {
              return M === -1 ? O : f(O, E, M);
            }
            extractFontProgram(O) {
              const M = this.stream, R = [], z = [], W = /* @__PURE__ */ Object.create(null);
              W.lenIV = 4;
              const g = {
                subrs: [],
                charstrings: [],
                properties: {
                  privateData: W
                }
              };
              let T, o, c, I;
              for (; (T = this.getToken()) !== null; )
                if (T === "/")
                  switch (T = this.getToken(), T) {
                    case "CharStrings":
                      for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); T = this.getToken(), !(T === null || T === "end"); ) {
                        if (T !== "/")
                          continue;
                        const r = this.getToken();
                        o = this.readInt(), this.getToken(), c = o > 0 ? M.getBytes(o) : new Uint8Array(0), I = g.properties.privateData.lenIV;
                        const u = this.readCharStrings(c, I);
                        this.nextChar(), T = this.getToken(), T === "noaccess" ? this.getToken() : T === "/" && this.prevChar(), z.push({
                          glyph: r,
                          encoded: u
                        });
                      }
                      break;
                    case "Subrs":
                      for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
                        const r = this.readInt();
                        o = this.readInt(), this.getToken(), c = o > 0 ? M.getBytes(o) : new Uint8Array(0), I = g.properties.privateData.lenIV;
                        const u = this.readCharStrings(c, I);
                        this.nextChar(), T = this.getToken(), T === "noaccess" && this.getToken(), R[r] = u;
                      }
                      break;
                    case "BlueValues":
                    case "OtherBlues":
                    case "FamilyBlues":
                    case "FamilyOtherBlues":
                      const s = this.readNumberArray();
                      s.length > 0 && s.length % 2 === 0 && t && (g.properties.privateData[T] = s);
                      break;
                    case "StemSnapH":
                    case "StemSnapV":
                      g.properties.privateData[T] = this.readNumberArray();
                      break;
                    case "StdHW":
                    case "StdVW":
                      g.properties.privateData[T] = this.readNumberArray()[0];
                      break;
                    case "BlueShift":
                    case "lenIV":
                    case "BlueFuzz":
                    case "BlueScale":
                    case "LanguageGroup":
                      g.properties.privateData[T] = this.readNumber();
                      break;
                    case "ExpansionFactor":
                      g.properties.privateData[T] = this.readNumber() || 0.06;
                      break;
                    case "ForceBold":
                      g.properties.privateData[T] = this.readBoolean();
                      break;
                  }
              for (const {
                encoded: s,
                glyph: r
              } of z) {
                const u = new V(), C = u.convert(s, R, this.seacAnalysisEnabled);
                let d = u.output;
                C && (d = [14]);
                const y = {
                  glyphName: r,
                  charstring: d,
                  width: u.width,
                  lsb: u.lsb,
                  seac: u.seac
                };
                if (r === ".notdef" ? g.charstrings.unshift(y) : g.charstrings.push(y), O.builtInEncoding) {
                  const _ = O.builtInEncoding.indexOf(r);
                  _ > -1 && O.widths[_] === void 0 && _ >= O.firstChar && _ <= O.lastChar && (O.widths[_] = u.width);
                }
              }
              return g;
            }
            extractFontHeader(O) {
              let M;
              for (; (M = this.getToken()) !== null; )
                if (M === "/")
                  switch (M = this.getToken(), M) {
                    case "FontMatrix":
                      const R = this.readNumberArray();
                      O.fontMatrix = R;
                      break;
                    case "Encoding":
                      const z = this.getToken();
                      let W;
                      if (!/^\d+$/.test(z))
                        W = (0, n.getEncoding)(z);
                      else {
                        W = [];
                        const T = parseInt(z, 10) | 0;
                        this.getToken();
                        for (let o = 0; o < T; o++) {
                          for (M = this.getToken(); M !== "dup" && M !== "def"; )
                            if (M = this.getToken(), M === null)
                              return;
                          if (M === "def")
                            break;
                          const c = this.readInt();
                          this.getToken();
                          const I = this.getToken();
                          W[c] = I, this.getToken();
                        }
                      }
                      O.builtInEncoding = W;
                      break;
                    case "FontBBox":
                      const g = this.readNumberArray();
                      O.ascent = Math.max(g[3], g[1]), O.descent = Math.min(g[1], g[3]), O.ascentScaled = !0;
                      break;
                  }
            }
          }
          b.Type1Parser = N;
        },
        /* 50 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Pattern = void 0, b.clearPatternCaches = a, b.getTilingPatternIR = O;
          var n = ce(2), P = ce(5), D = ce(12), e = ce(3);
          const t = {
            FUNCTION_BASED: 1,
            AXIAL: 2,
            RADIAL: 3,
            FREE_FORM_MESH: 4,
            LATTICE_FORM_MESH: 5,
            COONS_PATCH_MESH: 6,
            TENSOR_PATCH_MESH: 7
          };
          class l {
            constructor() {
              (0, n.unreachable)("Cannot initialize Pattern.");
            }
            static parseShading(W, g, T, o, c) {
              const I = W instanceof P.BaseStream ? W.dict : W, s = I.get("ShadingType");
              try {
                switch (s) {
                  case t.AXIAL:
                  case t.RADIAL:
                    return new te(I, g, T, o, c);
                  case t.FREE_FORM_MESH:
                  case t.LATTICE_FORM_MESH:
                  case t.COONS_PATCH_MESH:
                  case t.TENSOR_PATCH_MESH:
                    return new N(W, g, T, o, c);
                  default:
                    throw new n.FormatError("Unsupported ShadingType: " + s);
                }
              } catch (r) {
                if (r instanceof e.MissingDataException)
                  throw r;
                return (0, n.warn)(r), new p();
              }
            }
          }
          b.Pattern = l;
          const M = class M {
            constructor() {
              this.constructor === M && (0, n.unreachable)("Cannot initialize BaseShading.");
            }
            getIR() {
              (0, n.unreachable)("Abstract method `getIR` called.");
            }
          };
          Ut(M, "SMALL_NUMBER", 1e-6);
          let V = M;
          class te extends V {
            constructor(W, g, T, o, c) {
              super(), this.coordsArr = W.getArray("Coords"), this.shadingType = W.get("ShadingType");
              const I = D.ColorSpace.parse({
                cs: W.getRaw("CS") || W.getRaw("ColorSpace"),
                xref: g,
                resources: T,
                pdfFunctionFactory: o,
                localColorSpaceCache: c
              }), s = W.getArray("BBox");
              this.bbox = Array.isArray(s) && s.length === 4 ? n.Util.normalizeRect(s) : null;
              let r = 0, u = 1;
              if (W.has("Domain")) {
                const ie = W.getArray("Domain");
                r = ie[0], u = ie[1];
              }
              let C = !1, d = !1;
              if (W.has("Extend")) {
                const ie = W.getArray("Extend");
                C = ie[0], d = ie[1];
              }
              if (this.shadingType === t.RADIAL && (!C || !d)) {
                const [ie, ne, U, ae, Q, L] = this.coordsArr, ee = Math.hypot(ie - ae, ne - Q);
                U <= L + ee && L <= U + ee && (0, n.warn)("Unsupported radial gradient.");
              }
              this.extendStart = C, this.extendEnd = d;
              const y = W.getRaw("Function"), _ = o.createFromArray(y), $ = 840, S = (u - r) / $, v = this.colorStops = [];
              if (r >= u || S <= 0) {
                (0, n.info)("Bad shading domain.");
                return;
              }
              const m = new Float32Array(I.numComps), h = new Float32Array(1);
              let A, j = 0;
              h[0] = r, _(h, 0, m, 0);
              let G = I.getRgb(m, 0);
              const J = n.Util.makeHexColor(G[0], G[1], G[2]);
              v.push([0, J]);
              let oe = 1;
              h[0] = r + S, _(h, 0, m, 0);
              let q = I.getRgb(m, 0), re = q[0] - G[0] + 1, K = q[1] - G[1] + 1, Z = q[2] - G[2] + 1, w = q[0] - G[0] - 1, k = q[1] - G[1] - 1, X = q[2] - G[2] - 1;
              for (let ie = 2; ie < $; ie++) {
                h[0] = r + ie * S, _(h, 0, m, 0), A = I.getRgb(m, 0);
                const ne = ie - j;
                if (re = Math.min(re, (A[0] - G[0] + 1) / ne), K = Math.min(K, (A[1] - G[1] + 1) / ne), Z = Math.min(Z, (A[2] - G[2] + 1) / ne), w = Math.max(w, (A[0] - G[0] - 1) / ne), k = Math.max(k, (A[1] - G[1] - 1) / ne), X = Math.max(X, (A[2] - G[2] - 1) / ne), !(w <= re && k <= K && X <= Z)) {
                  const ae = n.Util.makeHexColor(q[0], q[1], q[2]);
                  v.push([oe / $, ae]), re = A[0] - q[0] + 1, K = A[1] - q[1] + 1, Z = A[2] - q[2] + 1, w = A[0] - q[0] - 1, k = A[1] - q[1] - 1, X = A[2] - q[2] - 1, j = oe, G = q;
                }
                oe = ie, q = A;
              }
              const H = n.Util.makeHexColor(q[0], q[1], q[2]);
              v.push([1, H]);
              let Y = "transparent";
              W.has("Background") && (A = I.getRgb(W.get("Background"), 0), Y = n.Util.makeHexColor(A[0], A[1], A[2])), C || (v.unshift([0, Y]), v[1][0] += V.SMALL_NUMBER), d || (v.at(-1)[0] -= V.SMALL_NUMBER, v.push([1, Y])), this.colorStops = v;
            }
            getIR() {
              const W = this.coordsArr, g = this.shadingType;
              let T, o, c, I, s;
              return g === t.AXIAL ? (o = [W[0], W[1]], c = [W[2], W[3]], I = null, s = null, T = "axial") : g === t.RADIAL ? (o = [W[0], W[1]], c = [W[3], W[4]], I = W[2], s = W[5], T = "radial") : (0, n.unreachable)(`getPattern type unknown: ${g}`), ["RadialAxial", T, this.bbox, this.colorStops, o, c, I, s];
            }
          }
          class E {
            constructor(W, g) {
              this.stream = W, this.context = g, this.buffer = 0, this.bufferLength = 0;
              const T = g.numComps;
              this.tmpCompsBuf = new Float32Array(T);
              const o = g.colorSpace.numComps;
              this.tmpCsCompsBuf = g.colorFn ? new Float32Array(o) : this.tmpCompsBuf;
            }
            get hasData() {
              if (this.stream.end)
                return this.stream.pos < this.stream.end;
              if (this.bufferLength > 0)
                return !0;
              const W = this.stream.getByte();
              return W < 0 ? !1 : (this.buffer = W, this.bufferLength = 8, !0);
            }
            readBits(W) {
              let g = this.buffer, T = this.bufferLength;
              if (W === 32) {
                if (T === 0)
                  return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
                g = g << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
                const o = this.stream.getByte();
                return this.buffer = o & (1 << T) - 1, (g << 8 - T | (o & 255) >> T) >>> 0;
              }
              if (W === 8 && T === 0)
                return this.stream.getByte();
              for (; T < W; )
                g = g << 8 | this.stream.getByte(), T += 8;
              return T -= W, this.bufferLength = T, this.buffer = g & (1 << T) - 1, g >> T;
            }
            align() {
              this.buffer = 0, this.bufferLength = 0;
            }
            readFlag() {
              return this.readBits(this.context.bitsPerFlag);
            }
            readCoordinate() {
              const W = this.context.bitsPerCoordinate, g = this.readBits(W), T = this.readBits(W), o = this.context.decode, c = W < 32 ? 1 / ((1 << W) - 1) : 23283064365386963e-26;
              return [g * c * (o[1] - o[0]) + o[0], T * c * (o[3] - o[2]) + o[2]];
            }
            readComponents() {
              const W = this.context.numComps, g = this.context.bitsPerComponent, T = g < 32 ? 1 / ((1 << g) - 1) : 23283064365386963e-26, o = this.context.decode, c = this.tmpCompsBuf;
              for (let s = 0, r = 4; s < W; s++, r += 2) {
                const u = this.readBits(g);
                c[s] = u * T * (o[r + 1] - o[r]) + o[r];
              }
              const I = this.tmpCsCompsBuf;
              return this.context.colorFn && this.context.colorFn(c, 0, I, 0), this.context.colorSpace.getRgb(I, 0);
            }
          }
          let F = /* @__PURE__ */ Object.create(null);
          function f(z) {
            const W = [];
            for (let g = 0; g <= z; g++) {
              const T = g / z, o = 1 - T;
              W.push(new Float32Array([o ** 3, 3 * T * o ** 2, 3 * T ** 2 * o, T ** 3]));
            }
            return W;
          }
          function x(z) {
            return F[z] || (F[z] = f(z));
          }
          function a() {
            F = /* @__PURE__ */ Object.create(null);
          }
          const R = class R extends V {
            constructor(W, g, T, o, c) {
              if (super(), !(W instanceof P.BaseStream))
                throw new n.FormatError("Mesh data is not a stream");
              const I = W.dict;
              this.shadingType = I.get("ShadingType");
              const s = I.getArray("BBox");
              this.bbox = Array.isArray(s) && s.length === 4 ? n.Util.normalizeRect(s) : null;
              const r = D.ColorSpace.parse({
                cs: I.getRaw("CS") || I.getRaw("ColorSpace"),
                xref: g,
                resources: T,
                pdfFunctionFactory: o,
                localColorSpaceCache: c
              });
              this.background = I.has("Background") ? r.getRgb(I.get("Background"), 0) : null;
              const u = I.getRaw("Function"), C = u ? o.createFromArray(u) : null;
              this.coords = [], this.colors = [], this.figures = [];
              const d = {
                bitsPerCoordinate: I.get("BitsPerCoordinate"),
                bitsPerComponent: I.get("BitsPerComponent"),
                bitsPerFlag: I.get("BitsPerFlag"),
                decode: I.getArray("Decode"),
                colorFn: C,
                colorSpace: r,
                numComps: C ? 1 : r.numComps
              }, y = new E(W, d);
              let _ = !1;
              switch (this.shadingType) {
                case t.FREE_FORM_MESH:
                  this._decodeType4Shading(y);
                  break;
                case t.LATTICE_FORM_MESH:
                  const $ = I.get("VerticesPerRow") | 0;
                  if ($ < 2)
                    throw new n.FormatError("Invalid VerticesPerRow");
                  this._decodeType5Shading(y, $);
                  break;
                case t.COONS_PATCH_MESH:
                  this._decodeType6Shading(y), _ = !0;
                  break;
                case t.TENSOR_PATCH_MESH:
                  this._decodeType7Shading(y), _ = !0;
                  break;
                default:
                  (0, n.unreachable)("Unsupported mesh type.");
                  break;
              }
              if (_) {
                this._updateBounds();
                for (let $ = 0, S = this.figures.length; $ < S; $++)
                  this._buildFigureFromPatch($);
              }
              this._updateBounds(), this._packData();
            }
            _decodeType4Shading(W) {
              const g = this.coords, T = this.colors, o = [];
              let c = 0;
              for (; W.hasData; ) {
                const I = W.readFlag(), s = W.readCoordinate(), r = W.readComponents();
                if (c === 0) {
                  if (!(0 <= I && I <= 2))
                    throw new n.FormatError("Unknown type4 flag");
                  switch (I) {
                    case 0:
                      c = 3;
                      break;
                    case 1:
                      o.push(o.at(-2), o.at(-1)), c = 1;
                      break;
                    case 2:
                      o.push(o.at(-3), o.at(-1)), c = 1;
                      break;
                  }
                }
                o.push(g.length), g.push(s), T.push(r), c--, W.align();
              }
              this.figures.push({
                type: "triangles",
                coords: new Int32Array(o),
                colors: new Int32Array(o)
              });
            }
            _decodeType5Shading(W, g) {
              const T = this.coords, o = this.colors, c = [];
              for (; W.hasData; ) {
                const I = W.readCoordinate(), s = W.readComponents();
                c.push(T.length), T.push(I), o.push(s);
              }
              this.figures.push({
                type: "lattice",
                coords: new Int32Array(c),
                colors: new Int32Array(c),
                verticesPerRow: g
              });
            }
            _decodeType6Shading(W) {
              const g = this.coords, T = this.colors, o = new Int32Array(16), c = new Int32Array(4);
              for (; W.hasData; ) {
                const I = W.readFlag();
                if (!(0 <= I && I <= 3))
                  throw new n.FormatError("Unknown type6 flag");
                const s = g.length;
                for (let _ = 0, $ = I !== 0 ? 8 : 12; _ < $; _++)
                  g.push(W.readCoordinate());
                const r = T.length;
                for (let _ = 0, $ = I !== 0 ? 2 : 4; _ < $; _++)
                  T.push(W.readComponents());
                let u, C, d, y;
                switch (I) {
                  case 0:
                    o[12] = s + 3, o[13] = s + 4, o[14] = s + 5, o[15] = s + 6, o[8] = s + 2, o[11] = s + 7, o[4] = s + 1, o[7] = s + 8, o[0] = s, o[1] = s + 11, o[2] = s + 10, o[3] = s + 9, c[2] = r + 1, c[3] = r + 2, c[0] = r, c[1] = r + 3;
                    break;
                  case 1:
                    u = o[12], C = o[13], d = o[14], y = o[15], o[12] = y, o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = d, o[11] = s + 3, o[4] = C, o[7] = s + 4, o[0] = u, o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, u = c[2], C = c[3], c[2] = C, c[3] = r, c[0] = u, c[1] = r + 1;
                    break;
                  case 2:
                    u = o[15], C = o[11], o[12] = o[3], o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = o[7], o[11] = s + 3, o[4] = C, o[7] = s + 4, o[0] = u, o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, u = c[3], c[2] = c[1], c[3] = r, c[0] = u, c[1] = r + 1;
                    break;
                  case 3:
                    o[12] = o[0], o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = o[1], o[11] = s + 3, o[4] = o[2], o[7] = s + 4, o[0] = o[3], o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, c[2] = c[0], c[3] = r, c[0] = c[1], c[1] = r + 1;
                    break;
                }
                o[5] = g.length, g.push([(-4 * g[o[0]][0] - g[o[15]][0] + 6 * (g[o[4]][0] + g[o[1]][0]) - 2 * (g[o[12]][0] + g[o[3]][0]) + 3 * (g[o[13]][0] + g[o[7]][0])) / 9, (-4 * g[o[0]][1] - g[o[15]][1] + 6 * (g[o[4]][1] + g[o[1]][1]) - 2 * (g[o[12]][1] + g[o[3]][1]) + 3 * (g[o[13]][1] + g[o[7]][1])) / 9]), o[6] = g.length, g.push([(-4 * g[o[3]][0] - g[o[12]][0] + 6 * (g[o[2]][0] + g[o[7]][0]) - 2 * (g[o[0]][0] + g[o[15]][0]) + 3 * (g[o[4]][0] + g[o[14]][0])) / 9, (-4 * g[o[3]][1] - g[o[12]][1] + 6 * (g[o[2]][1] + g[o[7]][1]) - 2 * (g[o[0]][1] + g[o[15]][1]) + 3 * (g[o[4]][1] + g[o[14]][1])) / 9]), o[9] = g.length, g.push([(-4 * g[o[12]][0] - g[o[3]][0] + 6 * (g[o[8]][0] + g[o[13]][0]) - 2 * (g[o[0]][0] + g[o[15]][0]) + 3 * (g[o[11]][0] + g[o[1]][0])) / 9, (-4 * g[o[12]][1] - g[o[3]][1] + 6 * (g[o[8]][1] + g[o[13]][1]) - 2 * (g[o[0]][1] + g[o[15]][1]) + 3 * (g[o[11]][1] + g[o[1]][1])) / 9]), o[10] = g.length, g.push([(-4 * g[o[15]][0] - g[o[0]][0] + 6 * (g[o[11]][0] + g[o[14]][0]) - 2 * (g[o[12]][0] + g[o[3]][0]) + 3 * (g[o[2]][0] + g[o[8]][0])) / 9, (-4 * g[o[15]][1] - g[o[0]][1] + 6 * (g[o[11]][1] + g[o[14]][1]) - 2 * (g[o[12]][1] + g[o[3]][1]) + 3 * (g[o[2]][1] + g[o[8]][1])) / 9]), this.figures.push({
                  type: "patch",
                  coords: new Int32Array(o),
                  colors: new Int32Array(c)
                });
              }
            }
            _decodeType7Shading(W) {
              const g = this.coords, T = this.colors, o = new Int32Array(16), c = new Int32Array(4);
              for (; W.hasData; ) {
                const I = W.readFlag();
                if (!(0 <= I && I <= 3))
                  throw new n.FormatError("Unknown type7 flag");
                const s = g.length;
                for (let _ = 0, $ = I !== 0 ? 12 : 16; _ < $; _++)
                  g.push(W.readCoordinate());
                const r = T.length;
                for (let _ = 0, $ = I !== 0 ? 2 : 4; _ < $; _++)
                  T.push(W.readComponents());
                let u, C, d, y;
                switch (I) {
                  case 0:
                    o[12] = s + 3, o[13] = s + 4, o[14] = s + 5, o[15] = s + 6, o[8] = s + 2, o[9] = s + 13, o[10] = s + 14, o[11] = s + 7, o[4] = s + 1, o[5] = s + 12, o[6] = s + 15, o[7] = s + 8, o[0] = s, o[1] = s + 11, o[2] = s + 10, o[3] = s + 9, c[2] = r + 1, c[3] = r + 2, c[0] = r, c[1] = r + 3;
                    break;
                  case 1:
                    u = o[12], C = o[13], d = o[14], y = o[15], o[12] = y, o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = d, o[9] = s + 9, o[10] = s + 10, o[11] = s + 3, o[4] = C, o[5] = s + 8, o[6] = s + 11, o[7] = s + 4, o[0] = u, o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, u = c[2], C = c[3], c[2] = C, c[3] = r, c[0] = u, c[1] = r + 1;
                    break;
                  case 2:
                    u = o[15], C = o[11], o[12] = o[3], o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = o[7], o[9] = s + 9, o[10] = s + 10, o[11] = s + 3, o[4] = C, o[5] = s + 8, o[6] = s + 11, o[7] = s + 4, o[0] = u, o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, u = c[3], c[2] = c[1], c[3] = r, c[0] = u, c[1] = r + 1;
                    break;
                  case 3:
                    o[12] = o[0], o[13] = s + 0, o[14] = s + 1, o[15] = s + 2, o[8] = o[1], o[9] = s + 9, o[10] = s + 10, o[11] = s + 3, o[4] = o[2], o[5] = s + 8, o[6] = s + 11, o[7] = s + 4, o[0] = o[3], o[1] = s + 7, o[2] = s + 6, o[3] = s + 5, c[2] = c[0], c[3] = r, c[0] = c[1], c[1] = r + 1;
                    break;
                }
                this.figures.push({
                  type: "patch",
                  coords: new Int32Array(o),
                  colors: new Int32Array(c)
                });
              }
            }
            _buildFigureFromPatch(W) {
              const g = this.figures[W];
              (0, n.assert)(g.type === "patch", "Unexpected patch mesh figure");
              const T = this.coords, o = this.colors, c = g.coords, I = g.colors, s = Math.min(T[c[0]][0], T[c[3]][0], T[c[12]][0], T[c[15]][0]), r = Math.min(T[c[0]][1], T[c[3]][1], T[c[12]][1], T[c[15]][1]), u = Math.max(T[c[0]][0], T[c[3]][0], T[c[12]][0], T[c[15]][0]), C = Math.max(T[c[0]][1], T[c[3]][1], T[c[12]][1], T[c[15]][1]);
              let d = Math.ceil((u - s) * R.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
              d = Math.max(R.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(R.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, d));
              let y = Math.ceil((C - r) * R.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
              y = Math.max(R.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(R.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, y));
              const _ = d + 1, $ = new Int32Array((y + 1) * _), S = new Int32Array((y + 1) * _);
              let v = 0;
              const m = new Uint8Array(3), h = new Uint8Array(3), A = o[I[0]], j = o[I[1]], G = o[I[2]], J = o[I[3]], oe = x(y), q = x(d);
              for (let re = 0; re <= y; re++) {
                m[0] = (A[0] * (y - re) + G[0] * re) / y | 0, m[1] = (A[1] * (y - re) + G[1] * re) / y | 0, m[2] = (A[2] * (y - re) + G[2] * re) / y | 0, h[0] = (j[0] * (y - re) + J[0] * re) / y | 0, h[1] = (j[1] * (y - re) + J[1] * re) / y | 0, h[2] = (j[2] * (y - re) + J[2] * re) / y | 0;
                for (let K = 0; K <= d; K++, v++) {
                  if ((re === 0 || re === y) && (K === 0 || K === d))
                    continue;
                  let Z = 0, w = 0, k = 0;
                  for (let H = 0; H <= 3; H++)
                    for (let Y = 0; Y <= 3; Y++, k++) {
                      const ie = oe[re][H] * q[K][Y];
                      Z += T[c[k]][0] * ie, w += T[c[k]][1] * ie;
                    }
                  $[v] = T.length, T.push([Z, w]), S[v] = o.length;
                  const X = new Uint8Array(3);
                  X[0] = (m[0] * (d - K) + h[0] * K) / d | 0, X[1] = (m[1] * (d - K) + h[1] * K) / d | 0, X[2] = (m[2] * (d - K) + h[2] * K) / d | 0, o.push(X);
                }
              }
              $[0] = c[0], S[0] = I[0], $[d] = c[3], S[d] = I[1], $[_ * y] = c[12], S[_ * y] = I[2], $[_ * y + d] = c[15], S[_ * y + d] = I[3], this.figures[W] = {
                type: "lattice",
                coords: $,
                colors: S,
                verticesPerRow: _
              };
            }
            _updateBounds() {
              let W = this.coords[0][0], g = this.coords[0][1], T = W, o = g;
              for (let c = 1, I = this.coords.length; c < I; c++) {
                const s = this.coords[c][0], r = this.coords[c][1];
                W = W > s ? s : W, g = g > r ? r : g, T = T < s ? s : T, o = o < r ? r : o;
              }
              this.bounds = [W, g, T, o];
            }
            _packData() {
              let W, g, T, o;
              const c = this.coords, I = new Float32Array(c.length * 2);
              for (W = 0, T = 0, g = c.length; W < g; W++) {
                const C = c[W];
                I[T++] = C[0], I[T++] = C[1];
              }
              this.coords = I;
              const s = this.colors, r = new Uint8Array(s.length * 3);
              for (W = 0, T = 0, g = s.length; W < g; W++) {
                const C = s[W];
                r[T++] = C[0], r[T++] = C[1], r[T++] = C[2];
              }
              this.colors = r;
              const u = this.figures;
              for (W = 0, g = u.length; W < g; W++) {
                const C = u[W], d = C.coords, y = C.colors;
                for (T = 0, o = d.length; T < o; T++)
                  d[T] *= 2, y[T] *= 3;
              }
            }
            getIR() {
              return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, this.bounds, this.bbox, this.background];
            }
          };
          Ut(R, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3), Ut(R, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20), Ut(R, "TRIANGLE_DENSITY", 20);
          let N = R;
          class p extends V {
            getIR() {
              return ["Dummy"];
            }
          }
          function O(z, W, g) {
            const T = W.getArray("Matrix"), o = n.Util.normalizeRect(W.getArray("BBox")), c = W.get("XStep"), I = W.get("YStep"), s = W.get("PaintType"), r = W.get("TilingType");
            if (o[2] - o[0] === 0 || o[3] - o[1] === 0)
              throw new n.FormatError(`Invalid getTilingPatternIR /BBox array: [${o}].`);
            return ["TilingPattern", g, z, T, o, c, I, s, r];
          }
        },
        /* 51 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.getXfaFontDict = x, b.getXfaFontName = F;
          var n = ce(52), P = ce(4), D = ce(53), e = ce(54), t = ce(55), l = ce(56), V = ce(3), te = ce(38);
          const E = (0, V.getLookupTableFactory)(function(a) {
            a["MyriadPro-Regular"] = a["PdfJS-Fallback-Regular"] = {
              name: "LiberationSans-Regular",
              factors: t.MyriadProRegularFactors,
              baseWidths: e.LiberationSansRegularWidths,
              baseMapping: e.LiberationSansRegularMapping,
              metrics: t.MyriadProRegularMetrics
            }, a["MyriadPro-Bold"] = a["PdfJS-Fallback-Bold"] = {
              name: "LiberationSans-Bold",
              factors: t.MyriadProBoldFactors,
              baseWidths: e.LiberationSansBoldWidths,
              baseMapping: e.LiberationSansBoldMapping,
              metrics: t.MyriadProBoldMetrics
            }, a["MyriadPro-It"] = a["MyriadPro-Italic"] = a["PdfJS-Fallback-Italic"] = {
              name: "LiberationSans-Italic",
              factors: t.MyriadProItalicFactors,
              baseWidths: e.LiberationSansItalicWidths,
              baseMapping: e.LiberationSansItalicMapping,
              metrics: t.MyriadProItalicMetrics
            }, a["MyriadPro-BoldIt"] = a["MyriadPro-BoldItalic"] = a["PdfJS-Fallback-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: t.MyriadProBoldItalicFactors,
              baseWidths: e.LiberationSansBoldItalicWidths,
              baseMapping: e.LiberationSansBoldItalicMapping,
              metrics: t.MyriadProBoldItalicMetrics
            }, a.ArialMT = a.Arial = a["Arial-Regular"] = {
              name: "LiberationSans-Regular",
              baseWidths: e.LiberationSansRegularWidths,
              baseMapping: e.LiberationSansRegularMapping
            }, a["Arial-BoldMT"] = a["Arial-Bold"] = {
              name: "LiberationSans-Bold",
              baseWidths: e.LiberationSansBoldWidths,
              baseMapping: e.LiberationSansBoldMapping
            }, a["Arial-ItalicMT"] = a["Arial-Italic"] = {
              name: "LiberationSans-Italic",
              baseWidths: e.LiberationSansItalicWidths,
              baseMapping: e.LiberationSansItalicMapping
            }, a["Arial-BoldItalicMT"] = a["Arial-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              baseWidths: e.LiberationSansBoldItalicWidths,
              baseMapping: e.LiberationSansBoldItalicMapping
            }, a["Calibri-Regular"] = {
              name: "LiberationSans-Regular",
              factors: n.CalibriRegularFactors,
              baseWidths: e.LiberationSansRegularWidths,
              baseMapping: e.LiberationSansRegularMapping,
              metrics: n.CalibriRegularMetrics
            }, a["Calibri-Bold"] = {
              name: "LiberationSans-Bold",
              factors: n.CalibriBoldFactors,
              baseWidths: e.LiberationSansBoldWidths,
              baseMapping: e.LiberationSansBoldMapping,
              metrics: n.CalibriBoldMetrics
            }, a["Calibri-Italic"] = {
              name: "LiberationSans-Italic",
              factors: n.CalibriItalicFactors,
              baseWidths: e.LiberationSansItalicWidths,
              baseMapping: e.LiberationSansItalicMapping,
              metrics: n.CalibriItalicMetrics
            }, a["Calibri-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: n.CalibriBoldItalicFactors,
              baseWidths: e.LiberationSansBoldItalicWidths,
              baseMapping: e.LiberationSansBoldItalicMapping,
              metrics: n.CalibriBoldItalicMetrics
            }, a["Segoeui-Regular"] = {
              name: "LiberationSans-Regular",
              factors: l.SegoeuiRegularFactors,
              baseWidths: e.LiberationSansRegularWidths,
              baseMapping: e.LiberationSansRegularMapping,
              metrics: l.SegoeuiRegularMetrics
            }, a["Segoeui-Bold"] = {
              name: "LiberationSans-Bold",
              factors: l.SegoeuiBoldFactors,
              baseWidths: e.LiberationSansBoldWidths,
              baseMapping: e.LiberationSansBoldMapping,
              metrics: l.SegoeuiBoldMetrics
            }, a["Segoeui-Italic"] = {
              name: "LiberationSans-Italic",
              factors: l.SegoeuiItalicFactors,
              baseWidths: e.LiberationSansItalicWidths,
              baseMapping: e.LiberationSansItalicMapping,
              metrics: l.SegoeuiItalicMetrics
            }, a["Segoeui-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: l.SegoeuiBoldItalicFactors,
              baseWidths: e.LiberationSansBoldItalicWidths,
              baseMapping: e.LiberationSansBoldItalicMapping,
              metrics: l.SegoeuiBoldItalicMetrics
            }, a["Helvetica-Regular"] = a.Helvetica = {
              name: "LiberationSans-Regular",
              factors: D.HelveticaRegularFactors,
              baseWidths: e.LiberationSansRegularWidths,
              baseMapping: e.LiberationSansRegularMapping,
              metrics: D.HelveticaRegularMetrics
            }, a["Helvetica-Bold"] = {
              name: "LiberationSans-Bold",
              factors: D.HelveticaBoldFactors,
              baseWidths: e.LiberationSansBoldWidths,
              baseMapping: e.LiberationSansBoldMapping,
              metrics: D.HelveticaBoldMetrics
            }, a["Helvetica-Italic"] = {
              name: "LiberationSans-Italic",
              factors: D.HelveticaItalicFactors,
              baseWidths: e.LiberationSansItalicWidths,
              baseMapping: e.LiberationSansItalicMapping,
              metrics: D.HelveticaItalicMetrics
            }, a["Helvetica-BoldItalic"] = {
              name: "LiberationSans-BoldItalic",
              factors: D.HelveticaBoldItalicFactors,
              baseWidths: e.LiberationSansBoldItalicWidths,
              baseMapping: e.LiberationSansBoldItalicMapping,
              metrics: D.HelveticaBoldItalicMetrics
            };
          });
          function F(a) {
            const N = (0, te.normalizeFontName)(a);
            return E()[N];
          }
          function f(a) {
            const N = F(a);
            if (!N)
              return null;
            const {
              baseWidths: p,
              baseMapping: O,
              factors: M
            } = N, R = M ? p.map((T, o) => T * M[o]) : p;
            let z = -2, W;
            const g = [];
            for (const [T, o] of O.map((c, I) => [c, I]).sort(([c], [I]) => c - I))
              T !== -1 && (T === z + 1 ? (W.push(R[o]), z += 1) : (z = T, W = [R[o]], g.push(T, W)));
            return g;
          }
          function x(a) {
            const N = f(a), p = new P.Dict(null);
            p.set("BaseFont", P.Name.get(a)), p.set("Type", P.Name.get("Font")), p.set("Subtype", P.Name.get("CIDFontType2")), p.set("Encoding", P.Name.get("Identity-H")), p.set("CIDToGIDMap", P.Name.get("Identity")), p.set("W", N), p.set("FirstChar", N[0]), p.set("LastChar", N.at(-2) + N.at(-1).length - 1);
            const O = new P.Dict(null);
            p.set("FontDescriptor", O);
            const M = new P.Dict(null);
            return M.set("Ordering", "Identity"), M.set("Registry", "Adobe"), M.set("Supplement", 0), p.set("CIDSystemInfo", M), p;
          }
        },
        /* 52 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.CalibriRegularMetrics = b.CalibriRegularFactors = b.CalibriItalicMetrics = b.CalibriItalicFactors = b.CalibriBoldMetrics = b.CalibriBoldItalicMetrics = b.CalibriBoldItalicFactors = b.CalibriBoldFactors = void 0;
          const ce = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.CalibriBoldFactors = ce;
          const n = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          b.CalibriBoldMetrics = n;
          const P = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.CalibriBoldItalicFactors = P;
          const D = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          b.CalibriBoldItalicMetrics = D;
          const e = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.CalibriItalicFactors = e;
          const t = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          b.CalibriItalicMetrics = t;
          const l = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.CalibriRegularFactors = l;
          const V = {
            lineHeight: 1.2207,
            lineGap: 0.2207
          };
          b.CalibriRegularMetrics = V;
        },
        /* 53 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.HelveticaRegularMetrics = b.HelveticaRegularFactors = b.HelveticaItalicMetrics = b.HelveticaItalicFactors = b.HelveticaBoldMetrics = b.HelveticaBoldItalicMetrics = b.HelveticaBoldItalicFactors = b.HelveticaBoldFactors = void 0;
          const ce = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.HelveticaBoldFactors = ce;
          const n = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.HelveticaBoldMetrics = n;
          const P = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.HelveticaBoldItalicFactors = P;
          const D = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          b.HelveticaBoldItalicMetrics = D;
          const e = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.HelveticaItalicFactors = e;
          const t = {
            lineHeight: 1.35,
            lineGap: 0.2
          };
          b.HelveticaItalicMetrics = t;
          const l = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.HelveticaRegularFactors = l;
          const V = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.HelveticaRegularMetrics = V;
        },
        /* 54 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.LiberationSansRegularWidths = b.LiberationSansRegularMapping = b.LiberationSansItalicWidths = b.LiberationSansItalicMapping = b.LiberationSansBoldWidths = b.LiberationSansBoldMapping = b.LiberationSansBoldItalicWidths = b.LiberationSansBoldItalicMapping = void 0;
          const ce = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          b.LiberationSansBoldWidths = ce;
          const n = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          b.LiberationSansBoldMapping = n;
          const P = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
          b.LiberationSansBoldItalicWidths = P;
          const D = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          b.LiberationSansBoldItalicMapping = D;
          const e = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          b.LiberationSansItalicWidths = e;
          const t = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          b.LiberationSansItalicMapping = t;
          const l = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
          b.LiberationSansRegularWidths = l;
          const V = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
          b.LiberationSansRegularMapping = V;
        },
        /* 55 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.MyriadProRegularMetrics = b.MyriadProRegularFactors = b.MyriadProItalicMetrics = b.MyriadProItalicFactors = b.MyriadProBoldMetrics = b.MyriadProBoldItalicMetrics = b.MyriadProBoldItalicFactors = b.MyriadProBoldFactors = void 0;
          const ce = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.MyriadProBoldFactors = ce;
          const n = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.MyriadProBoldMetrics = n;
          const P = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.MyriadProBoldItalicFactors = P;
          const D = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.MyriadProBoldItalicMetrics = D;
          const e = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.MyriadProItalicFactors = e;
          const t = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.MyriadProItalicMetrics = t;
          const l = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.MyriadProRegularFactors = l;
          const V = {
            lineHeight: 1.2,
            lineGap: 0.2
          };
          b.MyriadProRegularMetrics = V;
        },
        /* 56 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.SegoeuiRegularMetrics = b.SegoeuiRegularFactors = b.SegoeuiItalicMetrics = b.SegoeuiItalicFactors = b.SegoeuiBoldMetrics = b.SegoeuiBoldItalicMetrics = b.SegoeuiBoldItalicFactors = b.SegoeuiBoldFactors = void 0;
          const ce = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.SegoeuiBoldFactors = ce;
          const n = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          b.SegoeuiBoldMetrics = n;
          const P = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.SegoeuiBoldItalicFactors = P;
          const D = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          b.SegoeuiBoldItalicMetrics = D;
          const e = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.SegoeuiItalicFactors = e;
          const t = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          b.SegoeuiItalicMetrics = t;
          const l = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
          b.SegoeuiRegularFactors = l;
          const V = {
            lineHeight: 1.33008,
            lineGap: 0
          };
          b.SegoeuiRegularMetrics = V;
        },
        /* 57 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PostScriptEvaluator = b.PostScriptCompiler = b.PDFFunctionFactory = void 0, b.isPDFFunction = E;
          var n = ce(4), P = ce(2), D = ce(58), e = ce(5), t = ce(59);
          class l {
            constructor({
              xref: r,
              isEvalSupported: u = !0
            }) {
              this.xref = r, this.isEvalSupported = u !== !1;
            }
            create(r) {
              const u = this.getCached(r);
              if (u)
                return u;
              const C = te.parse({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fn: r instanceof n.Ref ? this.xref.fetch(r) : r
              });
              return this._cache(r, C), C;
            }
            createFromArray(r) {
              const u = this.getCached(r);
              if (u)
                return u;
              const C = te.parseArray({
                xref: this.xref,
                isEvalSupported: this.isEvalSupported,
                fnObj: r instanceof n.Ref ? this.xref.fetch(r) : r
              });
              return this._cache(r, C), C;
            }
            getCached(r) {
              var C;
              let u;
              if (r instanceof n.Ref ? u = r : r instanceof n.Dict ? u = r.objId : r instanceof e.BaseStream && (u = (C = r.dict) == null ? void 0 : C.objId), u) {
                const d = this._localFunctionCache.getByRef(u);
                if (d)
                  return d;
              }
              return null;
            }
            _cache(r, u) {
              var d;
              if (!u)
                throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
              let C;
              r instanceof n.Ref ? C = r : r instanceof n.Dict ? C = r.objId : r instanceof e.BaseStream && (C = (d = r.dict) == null ? void 0 : d.objId), C && this._localFunctionCache.set(null, C, u);
            }
            get _localFunctionCache() {
              return (0, P.shadow)(this, "_localFunctionCache", new t.LocalFunctionCache());
            }
          }
          b.PDFFunctionFactory = l;
          function V(s) {
            if (!Array.isArray(s))
              return null;
            const r = s.length;
            for (let u = 0; u < r; u++)
              if (typeof s[u] != "number") {
                const C = new Array(r);
                for (let d = 0; d < r; d++)
                  C[d] = +s[d];
                return C;
              }
            return s;
          }
          class te {
            static getSampleArray(r, u, C, d) {
              let y, _, $ = 1;
              for (y = 0, _ = r.length; y < _; y++)
                $ *= r[y];
              $ *= u;
              const S = new Array($);
              let v = 0, m = 0;
              const h = 1 / (2 ** C - 1), A = d.getBytes(($ * C + 7) / 8);
              let j = 0;
              for (y = 0; y < $; y++) {
                for (; v < C; )
                  m <<= 8, m |= A[j++], v += 8;
                v -= C, S[y] = (m >> v) * h, m &= (1 << v) - 1;
              }
              return S;
            }
            static parse({
              xref: r,
              isEvalSupported: u,
              fn: C
            }) {
              const d = C.dict || C;
              switch (d.get("FunctionType")) {
                case 0:
                  return this.constructSampled({
                    xref: r,
                    isEvalSupported: u,
                    fn: C,
                    dict: d
                  });
                case 1:
                  break;
                case 2:
                  return this.constructInterpolated({
                    xref: r,
                    isEvalSupported: u,
                    dict: d
                  });
                case 3:
                  return this.constructStiched({
                    xref: r,
                    isEvalSupported: u,
                    dict: d
                  });
                case 4:
                  return this.constructPostScript({
                    xref: r,
                    isEvalSupported: u,
                    fn: C,
                    dict: d
                  });
              }
              throw new P.FormatError("Unknown type of function");
            }
            static parseArray({
              xref: r,
              isEvalSupported: u,
              fnObj: C
            }) {
              if (!Array.isArray(C))
                return this.parse({
                  xref: r,
                  isEvalSupported: u,
                  fn: C
                });
              const d = [];
              for (const y of C)
                d.push(this.parse({
                  xref: r,
                  isEvalSupported: u,
                  fn: r.fetchIfRef(y)
                }));
              return function(y, _, $, S) {
                for (let v = 0, m = d.length; v < m; v++)
                  d[v](y, _, $, S + v);
              };
            }
            static constructSampled({
              xref: r,
              isEvalSupported: u,
              fn: C,
              dict: d
            }) {
              function y(q) {
                const re = q.length, K = [];
                let Z = 0;
                for (let w = 0; w < re; w += 2)
                  K[Z++] = [q[w], q[w + 1]];
                return K;
              }
              function _(q, re, K, Z, w) {
                return Z + (q - re) * ((w - Z) / (K - re));
              }
              let $ = V(d.getArray("Domain")), S = V(d.getArray("Range"));
              if (!$ || !S)
                throw new P.FormatError("No domain or range");
              const v = $.length / 2, m = S.length / 2;
              $ = y($), S = y(S);
              const h = V(d.getArray("Size")), A = d.get("BitsPerSample"), j = d.get("Order") || 1;
              j !== 1 && (0, P.info)("No support for cubic spline interpolation: " + j);
              let G = V(d.getArray("Encode"));
              if (G)
                G = y(G);
              else {
                G = [];
                for (let q = 0; q < v; ++q)
                  G.push([0, h[q] - 1]);
              }
              let J = V(d.getArray("Decode"));
              J = J ? y(J) : S;
              const oe = this.getSampleArray(h, m, A, C);
              return function(re, K, Z, w) {
                const k = 1 << v, X = new Float64Array(k), H = new Uint32Array(k);
                let Y, ie;
                for (ie = 0; ie < k; ie++)
                  X[ie] = 1;
                let ne = m, U = 1;
                for (Y = 0; Y < v; ++Y) {
                  const ae = $[Y][0], Q = $[Y][1], L = Math.min(Math.max(re[K + Y], ae), Q);
                  let ee = _(L, ae, Q, G[Y][0], G[Y][1]);
                  const se = h[Y];
                  ee = Math.min(Math.max(ee, 0), se - 1);
                  const le = ee < se - 1 ? Math.floor(ee) : ee - 1, ue = le + 1 - ee, de = ee - le, ge = le * ne, me = ge + ne;
                  for (ie = 0; ie < k; ie++)
                    ie & U ? (X[ie] *= de, H[ie] += me) : (X[ie] *= ue, H[ie] += ge);
                  ne *= se, U <<= 1;
                }
                for (ie = 0; ie < m; ++ie) {
                  let ae = 0;
                  for (Y = 0; Y < k; Y++)
                    ae += oe[H[Y] + ie] * X[Y];
                  ae = _(ae, 0, 1, J[ie][0], J[ie][1]), Z[w + ie] = Math.min(Math.max(ae, S[ie][0]), S[ie][1]);
                }
              };
            }
            static constructInterpolated({
              xref: r,
              isEvalSupported: u,
              dict: C
            }) {
              const d = V(C.getArray("C0")) || [0], y = V(C.getArray("C1")) || [1], _ = C.get("N"), $ = [];
              for (let v = 0, m = d.length; v < m; ++v)
                $.push(y[v] - d[v]);
              const S = $.length;
              return function(m, h, A, j) {
                const G = _ === 1 ? m[h] : m[h] ** _;
                for (let J = 0; J < S; ++J)
                  A[j + J] = d[J] + G * $[J];
              };
            }
            static constructStiched({
              xref: r,
              isEvalSupported: u,
              dict: C
            }) {
              const d = V(C.getArray("Domain"));
              if (!d)
                throw new P.FormatError("No domain");
              if (d.length / 2 !== 1)
                throw new P.FormatError("Bad domain for stiched function");
              const _ = [];
              for (const m of C.get("Functions"))
                _.push(this.parse({
                  xref: r,
                  isEvalSupported: u,
                  fn: r.fetchIfRef(m)
                }));
              const $ = V(C.getArray("Bounds")), S = V(C.getArray("Encode")), v = new Float32Array(1);
              return function(h, A, j, G) {
                const oe = function(H, Y, ie) {
                  return H > ie ? H = ie : H < Y && (H = Y), H;
                }(h[A], d[0], d[1]), q = $.length;
                let re;
                for (re = 0; re < q && !(oe < $[re]); ++re)
                  ;
                let K = d[0];
                re > 0 && (K = $[re - 1]);
                let Z = d[1];
                re < $.length && (Z = $[re]);
                const w = S[2 * re], k = S[2 * re + 1];
                v[0] = K === Z ? w : w + (oe - K) * (k - w) / (Z - K), _[re](v, 0, j, G);
              };
            }
            static constructPostScript({
              xref: r,
              isEvalSupported: u,
              fn: C,
              dict: d
            }) {
              const y = V(d.getArray("Domain")), _ = V(d.getArray("Range"));
              if (!y)
                throw new P.FormatError("No domain.");
              if (!_)
                throw new P.FormatError("No range.");
              const $ = new D.PostScriptLexer(C), v = new D.PostScriptParser($).parse();
              if (u && P.FeatureTest.isEvalSupported) {
                const q = new c().compile(v, y, _);
                if (q)
                  return new Function("src", "srcOffset", "dest", "destOffset", q);
              }
              (0, P.info)("Unable to compile PS function");
              const m = _.length >> 1, h = y.length >> 1, A = new f(v), j = /* @__PURE__ */ Object.create(null);
              let J = 2048 * 4;
              const oe = new Float32Array(h);
              return function(re, K, Z, w) {
                let k, X, H = "";
                const Y = oe;
                for (k = 0; k < h; k++)
                  X = re[K + k], Y[k] = X, H += X + "_";
                const ie = j[H];
                if (ie !== void 0) {
                  Z.set(ie, w);
                  return;
                }
                const ne = new Float32Array(m), U = A.execute(Y), ae = U.length - m;
                for (k = 0; k < m; k++) {
                  X = U[ae + k];
                  let Q = _[k * 2];
                  X < Q ? X = Q : (Q = _[k * 2 + 1], X > Q && (X = Q)), ne[k] = X;
                }
                J > 0 && (J--, j[H] = ne), Z.set(ne, w);
              };
            }
          }
          function E(s) {
            let r;
            if (s instanceof n.Dict)
              r = s;
            else if (s instanceof e.BaseStream)
              r = s.dict;
            else
              return !1;
            return r.has("FunctionType");
          }
          const I = class I {
            constructor(r) {
              this.stack = r ? Array.from(r) : [];
            }
            push(r) {
              if (this.stack.length >= I.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              this.stack.push(r);
            }
            pop() {
              if (this.stack.length <= 0)
                throw new Error("PostScript function stack underflow.");
              return this.stack.pop();
            }
            copy(r) {
              if (this.stack.length + r >= I.MAX_STACK_SIZE)
                throw new Error("PostScript function stack overflow.");
              const u = this.stack;
              for (let C = u.length - r, d = r - 1; d >= 0; d--, C++)
                u.push(u[C]);
            }
            index(r) {
              this.push(this.stack[this.stack.length - r - 1]);
            }
            roll(r, u) {
              const C = this.stack, d = C.length - r, y = C.length - 1, _ = d + (u - Math.floor(u / r) * r);
              for (let $ = d, S = y; $ < S; $++, S--) {
                const v = C[$];
                C[$] = C[S], C[S] = v;
              }
              for (let $ = d, S = _ - 1; $ < S; $++, S--) {
                const v = C[$];
                C[$] = C[S], C[S] = v;
              }
              for (let $ = _, S = y; $ < S; $++, S--) {
                const v = C[$];
                C[$] = C[S], C[S] = v;
              }
            }
          };
          Ut(I, "MAX_STACK_SIZE", 100);
          let F = I;
          class f {
            constructor(r) {
              this.operators = r;
            }
            execute(r) {
              const u = new F(r);
              let C = 0;
              const d = this.operators, y = d.length;
              let _, $, S;
              for (; C < y; ) {
                if (_ = d[C++], typeof _ == "number") {
                  u.push(_);
                  continue;
                }
                switch (_) {
                  case "jz":
                    S = u.pop(), $ = u.pop(), $ || (C = S);
                    break;
                  case "j":
                    $ = u.pop(), C = $;
                    break;
                  case "abs":
                    $ = u.pop(), u.push(Math.abs($));
                    break;
                  case "add":
                    S = u.pop(), $ = u.pop(), u.push($ + S);
                    break;
                  case "and":
                    S = u.pop(), $ = u.pop(), typeof $ == "boolean" && typeof S == "boolean" ? u.push($ && S) : u.push($ & S);
                    break;
                  case "atan":
                    S = u.pop(), $ = u.pop(), $ = Math.atan2($, S) / Math.PI * 180, $ < 0 && ($ += 360), u.push($);
                    break;
                  case "bitshift":
                    S = u.pop(), $ = u.pop(), $ > 0 ? u.push($ << S) : u.push($ >> S);
                    break;
                  case "ceiling":
                    $ = u.pop(), u.push(Math.ceil($));
                    break;
                  case "copy":
                    $ = u.pop(), u.copy($);
                    break;
                  case "cos":
                    $ = u.pop(), u.push(Math.cos($ % 360 / 180 * Math.PI));
                    break;
                  case "cvi":
                    $ = u.pop() | 0, u.push($);
                    break;
                  case "cvr":
                    break;
                  case "div":
                    S = u.pop(), $ = u.pop(), u.push($ / S);
                    break;
                  case "dup":
                    u.copy(1);
                    break;
                  case "eq":
                    S = u.pop(), $ = u.pop(), u.push($ === S);
                    break;
                  case "exch":
                    u.roll(2, 1);
                    break;
                  case "exp":
                    S = u.pop(), $ = u.pop(), u.push($ ** S);
                    break;
                  case "false":
                    u.push(!1);
                    break;
                  case "floor":
                    $ = u.pop(), u.push(Math.floor($));
                    break;
                  case "ge":
                    S = u.pop(), $ = u.pop(), u.push($ >= S);
                    break;
                  case "gt":
                    S = u.pop(), $ = u.pop(), u.push($ > S);
                    break;
                  case "idiv":
                    S = u.pop(), $ = u.pop(), u.push($ / S | 0);
                    break;
                  case "index":
                    $ = u.pop(), u.index($);
                    break;
                  case "le":
                    S = u.pop(), $ = u.pop(), u.push($ <= S);
                    break;
                  case "ln":
                    $ = u.pop(), u.push(Math.log($));
                    break;
                  case "log":
                    $ = u.pop(), u.push(Math.log10($));
                    break;
                  case "lt":
                    S = u.pop(), $ = u.pop(), u.push($ < S);
                    break;
                  case "mod":
                    S = u.pop(), $ = u.pop(), u.push($ % S);
                    break;
                  case "mul":
                    S = u.pop(), $ = u.pop(), u.push($ * S);
                    break;
                  case "ne":
                    S = u.pop(), $ = u.pop(), u.push($ !== S);
                    break;
                  case "neg":
                    $ = u.pop(), u.push(-$);
                    break;
                  case "not":
                    $ = u.pop(), typeof $ == "boolean" ? u.push(!$) : u.push(~$);
                    break;
                  case "or":
                    S = u.pop(), $ = u.pop(), typeof $ == "boolean" && typeof S == "boolean" ? u.push($ || S) : u.push($ | S);
                    break;
                  case "pop":
                    u.pop();
                    break;
                  case "roll":
                    S = u.pop(), $ = u.pop(), u.roll($, S);
                    break;
                  case "round":
                    $ = u.pop(), u.push(Math.round($));
                    break;
                  case "sin":
                    $ = u.pop(), u.push(Math.sin($ % 360 / 180 * Math.PI));
                    break;
                  case "sqrt":
                    $ = u.pop(), u.push(Math.sqrt($));
                    break;
                  case "sub":
                    S = u.pop(), $ = u.pop(), u.push($ - S);
                    break;
                  case "true":
                    u.push(!0);
                    break;
                  case "truncate":
                    $ = u.pop(), $ = $ < 0 ? Math.ceil($) : Math.floor($), u.push($);
                    break;
                  case "xor":
                    S = u.pop(), $ = u.pop(), typeof $ == "boolean" && typeof S == "boolean" ? u.push($ !== S) : u.push($ ^ S);
                    break;
                  default:
                    throw new P.FormatError(`Unknown operator ${_}`);
                }
              }
              return u.stack;
            }
          }
          b.PostScriptEvaluator = f;
          class x {
            constructor(r) {
              this.type = r;
            }
            visit(r) {
              (0, P.unreachable)("abstract method");
            }
          }
          class a extends x {
            constructor(r, u, C) {
              super("args"), this.index = r, this.min = u, this.max = C;
            }
            visit(r) {
              r.visitArgument(this);
            }
          }
          class N extends x {
            constructor(r) {
              super("literal"), this.number = r, this.min = r, this.max = r;
            }
            visit(r) {
              r.visitLiteral(this);
            }
          }
          class p extends x {
            constructor(r, u, C, d, y) {
              super("binary"), this.op = r, this.arg1 = u, this.arg2 = C, this.min = d, this.max = y;
            }
            visit(r) {
              r.visitBinaryOperation(this);
            }
          }
          class O extends x {
            constructor(r, u) {
              super("max"), this.arg = r, this.min = r.min, this.max = u;
            }
            visit(r) {
              r.visitMin(this);
            }
          }
          class M extends x {
            constructor(r, u, C) {
              super("var"), this.index = r, this.min = u, this.max = C;
            }
            visit(r) {
              r.visitVariable(this);
            }
          }
          class R extends x {
            constructor(r, u) {
              super("definition"), this.variable = r, this.arg = u;
            }
            visit(r) {
              r.visitVariableDefinition(this);
            }
          }
          class z {
            constructor() {
              this.parts = [];
            }
            visitArgument(r) {
              this.parts.push("Math.max(", r.min, ", Math.min(", r.max, ", src[srcOffset + ", r.index, "]))");
            }
            visitVariable(r) {
              this.parts.push("v", r.index);
            }
            visitLiteral(r) {
              this.parts.push(r.number);
            }
            visitBinaryOperation(r) {
              this.parts.push("("), r.arg1.visit(this), this.parts.push(" ", r.op, " "), r.arg2.visit(this), this.parts.push(")");
            }
            visitVariableDefinition(r) {
              this.parts.push("var "), r.variable.visit(this), this.parts.push(" = "), r.arg.visit(this), this.parts.push(";");
            }
            visitMin(r) {
              this.parts.push("Math.min("), r.arg.visit(this), this.parts.push(", ", r.max, ")");
            }
            toString() {
              return this.parts.join("");
            }
          }
          function W(s, r) {
            return r.type === "literal" && r.number === 0 ? s : s.type === "literal" && s.number === 0 ? r : r.type === "literal" && s.type === "literal" ? new N(s.number + r.number) : new p("+", s, r, s.min + r.min, s.max + r.max);
          }
          function g(s, r) {
            if (r.type === "literal") {
              if (r.number === 0)
                return new N(0);
              if (r.number === 1)
                return s;
              if (s.type === "literal")
                return new N(s.number * r.number);
            }
            if (s.type === "literal") {
              if (s.number === 0)
                return new N(0);
              if (s.number === 1)
                return r;
            }
            const u = Math.min(s.min * r.min, s.min * r.max, s.max * r.min, s.max * r.max), C = Math.max(s.min * r.min, s.min * r.max, s.max * r.min, s.max * r.max);
            return new p("*", s, r, u, C);
          }
          function T(s, r) {
            if (r.type === "literal") {
              if (r.number === 0)
                return s;
              if (s.type === "literal")
                return new N(s.number - r.number);
            }
            return r.type === "binary" && r.op === "-" && s.type === "literal" && s.number === 1 && r.arg1.type === "literal" && r.arg1.number === 1 ? r.arg2 : new p("-", s, r, s.min - r.max, s.max - r.min);
          }
          function o(s, r) {
            return s.min >= r ? new N(r) : s.max <= r ? s : new O(s, r);
          }
          class c {
            compile(r, u, C) {
              const d = [], y = [], _ = u.length >> 1, $ = C.length >> 1;
              let S = 0, v, m, h, A, j, G, J, oe;
              for (let re = 0; re < _; re++)
                d.push(new a(re, u[re * 2], u[re * 2 + 1]));
              for (let re = 0, K = r.length; re < K; re++) {
                if (oe = r[re], typeof oe == "number") {
                  d.push(new N(oe));
                  continue;
                }
                switch (oe) {
                  case "add":
                    if (d.length < 2)
                      return null;
                    A = d.pop(), h = d.pop(), d.push(W(h, A));
                    break;
                  case "cvr":
                    if (d.length < 1)
                      return null;
                    break;
                  case "mul":
                    if (d.length < 2)
                      return null;
                    A = d.pop(), h = d.pop(), d.push(g(h, A));
                    break;
                  case "sub":
                    if (d.length < 2)
                      return null;
                    A = d.pop(), h = d.pop(), d.push(T(h, A));
                    break;
                  case "exch":
                    if (d.length < 2)
                      return null;
                    j = d.pop(), G = d.pop(), d.push(j, G);
                    break;
                  case "pop":
                    if (d.length < 1)
                      return null;
                    d.pop();
                    break;
                  case "index":
                    if (d.length < 1 || (h = d.pop(), h.type !== "literal") || (v = h.number, v < 0 || !Number.isInteger(v) || d.length < v))
                      return null;
                    if (j = d[d.length - v - 1], j.type === "literal" || j.type === "var") {
                      d.push(j);
                      break;
                    }
                    J = new M(S++, j.min, j.max), d[d.length - v - 1] = J, d.push(J), y.push(new R(J, j));
                    break;
                  case "dup":
                    if (d.length < 1)
                      return null;
                    if (typeof r[re + 1] == "number" && r[re + 2] === "gt" && r[re + 3] === re + 7 && r[re + 4] === "jz" && r[re + 5] === "pop" && r[re + 6] === r[re + 1]) {
                      h = d.pop(), d.push(o(h, r[re + 1])), re += 6;
                      break;
                    }
                    if (j = d.at(-1), j.type === "literal" || j.type === "var") {
                      d.push(j);
                      break;
                    }
                    J = new M(S++, j.min, j.max), d[d.length - 1] = J, d.push(J), y.push(new R(J, j));
                    break;
                  case "roll":
                    if (d.length < 2 || (A = d.pop(), h = d.pop(), A.type !== "literal" || h.type !== "literal") || (m = A.number, v = h.number, v <= 0 || !Number.isInteger(v) || !Number.isInteger(m) || d.length < v))
                      return null;
                    if (m = (m % v + v) % v, m === 0)
                      break;
                    d.push(...d.splice(d.length - v, v - m));
                    break;
                  default:
                    return null;
                }
              }
              if (d.length !== $)
                return null;
              const q = [];
              for (const re of y) {
                const K = new z();
                re.visit(K), q.push(K.toString());
              }
              for (let re = 0, K = d.length; re < K; re++) {
                const Z = d[re], w = new z();
                Z.visit(w);
                const k = C[re * 2], X = C[re * 2 + 1], H = [w.toString()];
                k > Z.min && (H.unshift("Math.max(", k, ", "), H.push(")")), X < Z.max && (H.unshift("Math.min(", X, ", "), H.push(")")), H.unshift("dest[destOffset + ", re, "] = "), H.push(";"), q.push(H.join(""));
              }
              return q.join(`
`);
            }
          }
          b.PostScriptCompiler = c;
        },
        /* 58 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PostScriptParser = b.PostScriptLexer = void 0;
          var n = ce(2), P = ce(4), D = ce(3);
          class e {
            constructor(E) {
              this.lexer = E, this.operators = [], this.token = null, this.prev = null;
            }
            nextToken() {
              this.prev = this.token, this.token = this.lexer.getToken();
            }
            accept(E) {
              return this.token.type === E ? (this.nextToken(), !0) : !1;
            }
            expect(E) {
              if (this.accept(E))
                return !0;
              throw new n.FormatError(`Unexpected symbol: found ${this.token.type} expected ${E}.`);
            }
            parse() {
              return this.nextToken(), this.expect(t.LBRACE), this.parseBlock(), this.expect(t.RBRACE), this.operators;
            }
            parseBlock() {
              for (; ; )
                if (this.accept(t.NUMBER))
                  this.operators.push(this.prev.value);
                else if (this.accept(t.OPERATOR))
                  this.operators.push(this.prev.value);
                else if (this.accept(t.LBRACE))
                  this.parseCondition();
                else
                  return;
            }
            parseCondition() {
              const E = this.operators.length;
              if (this.operators.push(null, null), this.parseBlock(), this.expect(t.RBRACE), this.accept(t.IF))
                this.operators[E] = this.operators.length, this.operators[E + 1] = "jz";
              else if (this.accept(t.LBRACE)) {
                const F = this.operators.length;
                this.operators.push(null, null);
                const f = this.operators.length;
                this.parseBlock(), this.expect(t.RBRACE), this.expect(t.IFELSE), this.operators[F] = this.operators.length, this.operators[F + 1] = "j", this.operators[E] = f, this.operators[E + 1] = "jz";
              } else
                throw new n.FormatError("PS Function: error parsing conditional.");
            }
          }
          b.PostScriptParser = e;
          const t = {
            LBRACE: 0,
            RBRACE: 1,
            NUMBER: 2,
            OPERATOR: 3,
            IF: 4,
            IFELSE: 5
          };
          class l {
            static get opCache() {
              return (0, n.shadow)(this, "opCache", /* @__PURE__ */ Object.create(null));
            }
            constructor(E, F) {
              this.type = E, this.value = F;
            }
            static getOperator(E) {
              var F;
              return (F = l.opCache)[E] || (F[E] = new l(t.OPERATOR, E));
            }
            static get LBRACE() {
              return (0, n.shadow)(this, "LBRACE", new l(t.LBRACE, "{"));
            }
            static get RBRACE() {
              return (0, n.shadow)(this, "RBRACE", new l(t.RBRACE, "}"));
            }
            static get IF() {
              return (0, n.shadow)(this, "IF", new l(t.IF, "IF"));
            }
            static get IFELSE() {
              return (0, n.shadow)(this, "IFELSE", new l(t.IFELSE, "IFELSE"));
            }
          }
          class V {
            constructor(E) {
              this.stream = E, this.nextChar(), this.strBuf = [];
            }
            nextChar() {
              return this.currentChar = this.stream.getByte();
            }
            getToken() {
              let E = !1, F = this.currentChar;
              for (; ; ) {
                if (F < 0)
                  return P.EOF;
                if (E)
                  (F === 10 || F === 13) && (E = !1);
                else if (F === 37)
                  E = !0;
                else if (!(0, D.isWhiteSpace)(F))
                  break;
                F = this.nextChar();
              }
              switch (F | 0) {
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 43:
                case 45:
                case 46:
                  return new l(t.NUMBER, this.getNumber());
                case 123:
                  return this.nextChar(), l.LBRACE;
                case 125:
                  return this.nextChar(), l.RBRACE;
              }
              const f = this.strBuf;
              for (f.length = 0, f[0] = String.fromCharCode(F); (F = this.nextChar()) >= 0 && (F >= 65 && F <= 90 || F >= 97 && F <= 122); )
                f.push(String.fromCharCode(F));
              const x = f.join("");
              switch (x.toLowerCase()) {
                case "if":
                  return l.IF;
                case "ifelse":
                  return l.IFELSE;
                default:
                  return l.getOperator(x);
              }
            }
            getNumber() {
              let E = this.currentChar;
              const F = this.strBuf;
              for (F.length = 0, F[0] = String.fromCharCode(E); (E = this.nextChar()) >= 0 && (E >= 48 && E <= 57 || E === 45 || E === 46); )
                F.push(String.fromCharCode(E));
              const f = parseFloat(F.join(""));
              if (isNaN(f))
                throw new n.FormatError(`Invalid floating point number: ${f}`);
              return f;
            }
          }
          b.PostScriptLexer = V;
        },
        /* 59 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.RegionalImageCache = b.LocalTilingPatternCache = b.LocalImageCache = b.LocalGStateCache = b.LocalFunctionCache = b.LocalColorSpaceCache = b.GlobalImageCache = void 0;
          var n = ce(2), P = ce(4);
          class D {
            constructor(a) {
              this.constructor === D && (0, n.unreachable)("Cannot initialize BaseLocalCache."), this._onlyRefs = (a == null ? void 0 : a.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new P.RefSetCache();
            }
            getByName(a) {
              this._onlyRefs && (0, n.unreachable)("Should not call `getByName` method.");
              const N = this._nameRefMap.get(a);
              return N ? this.getByRef(N) : this._imageMap.get(a) || null;
            }
            getByRef(a) {
              return this._imageCache.get(a) || null;
            }
            set(a, N, p) {
              (0, n.unreachable)("Abstract method `set` called.");
            }
          }
          class e extends D {
            set(a, N = null, p) {
              if (typeof a != "string")
                throw new Error('LocalImageCache.set - expected "name" argument.');
              if (N) {
                if (this._imageCache.has(N))
                  return;
                this._nameRefMap.set(a, N), this._imageCache.put(N, p);
                return;
              }
              this._imageMap.has(a) || this._imageMap.set(a, p);
            }
          }
          b.LocalImageCache = e;
          class t extends D {
            set(a = null, N = null, p) {
              if (typeof a != "string" && !N)
                throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
              if (N) {
                if (this._imageCache.has(N))
                  return;
                a !== null && this._nameRefMap.set(a, N), this._imageCache.put(N, p);
                return;
              }
              this._imageMap.has(a) || this._imageMap.set(a, p);
            }
          }
          b.LocalColorSpaceCache = t;
          class l extends D {
            constructor(a) {
              super({
                onlyRefs: !0
              });
            }
            set(a = null, N, p) {
              if (!N)
                throw new Error('LocalFunctionCache.set - expected "ref" argument.');
              this._imageCache.has(N) || this._imageCache.put(N, p);
            }
          }
          b.LocalFunctionCache = l;
          class V extends D {
            set(a, N = null, p) {
              if (typeof a != "string")
                throw new Error('LocalGStateCache.set - expected "name" argument.');
              if (N) {
                if (this._imageCache.has(N))
                  return;
                this._nameRefMap.set(a, N), this._imageCache.put(N, p);
                return;
              }
              this._imageMap.has(a) || this._imageMap.set(a, p);
            }
          }
          b.LocalGStateCache = V;
          class te extends D {
            constructor(a) {
              super({
                onlyRefs: !0
              });
            }
            set(a = null, N, p) {
              if (!N)
                throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
              this._imageCache.has(N) || this._imageCache.put(N, p);
            }
          }
          b.LocalTilingPatternCache = te;
          class E extends D {
            constructor(a) {
              super({
                onlyRefs: !0
              });
            }
            set(a = null, N, p) {
              if (!N)
                throw new Error('RegionalImageCache.set - expected "ref" argument.');
              this._imageCache.has(N) || this._imageCache.put(N, p);
            }
          }
          b.RegionalImageCache = E;
          const f = class f {
            constructor() {
              this._refCache = new P.RefSetCache(), this._imageCache = new P.RefSetCache();
            }
            get _byteSize() {
              let a = 0;
              for (const N of this._imageCache)
                a += N.byteSize;
              return a;
            }
            get _cacheLimitReached() {
              return !(this._imageCache.size < f.MIN_IMAGES_TO_CACHE || this._byteSize < f.MAX_BYTE_SIZE);
            }
            shouldCache(a, N) {
              let p = this._refCache.get(a);
              return p || (p = /* @__PURE__ */ new Set(), this._refCache.put(a, p)), p.add(N), !(p.size < f.NUM_PAGES_THRESHOLD || !this._imageCache.has(a) && this._cacheLimitReached);
            }
            addByteSize(a, N) {
              const p = this._imageCache.get(a);
              p && (p.byteSize || (p.byteSize = N));
            }
            getData(a, N) {
              const p = this._refCache.get(a);
              if (!p || p.size < f.NUM_PAGES_THRESHOLD)
                return null;
              const O = this._imageCache.get(a);
              return O ? (p.add(N), O) : null;
            }
            setData(a, N) {
              if (!this._refCache.has(a))
                throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
              if (!this._imageCache.has(a)) {
                if (this._cacheLimitReached) {
                  (0, n.warn)("GlobalImageCache.setData - cache limit reached.");
                  return;
                }
                this._imageCache.put(a, N);
              }
            }
            clear(a = !1) {
              a || this._refCache.clear(), this._imageCache.clear();
            }
          };
          Ut(f, "NUM_PAGES_THRESHOLD", 2), Ut(f, "MIN_IMAGES_TO_CACHE", 10), Ut(f, "MAX_BYTE_SIZE", 5 * n.MAX_IMAGE_SIZE_TO_CACHE);
          let F = f;
          b.GlobalImageCache = F;
        },
        /* 60 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.bidi = x;
          var n = ce(2);
          const P = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], D = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
          function e(a) {
            return (a & 1) !== 0;
          }
          function t(a) {
            return (a & 1) === 0;
          }
          function l(a, N, p) {
            let O, M;
            for (O = N, M = a.length; O < M; ++O)
              if (a[O] !== p)
                return O;
            return O;
          }
          function V(a, N, p, O) {
            for (let M = N; M < p; ++M)
              a[M] = O;
          }
          function te(a, N, p) {
            for (let O = N, M = p - 1; O < M; ++O, --M) {
              const R = a[O];
              a[O] = a[M], a[M] = R;
            }
          }
          function E(a, N, p = !1) {
            let O = "ltr";
            return p ? O = "ttb" : N || (O = "rtl"), {
              str: a,
              dir: O
            };
          }
          const F = [], f = [];
          function x(a, N = -1, p = !1) {
            let O = !0;
            const M = a.length;
            if (M === 0 || p)
              return E(a, O, p);
            F.length = M, f.length = M;
            let R = 0, z, W;
            for (z = 0; z < M; ++z) {
              F[z] = a.charAt(z);
              const d = a.charCodeAt(z);
              let y = "L";
              d <= 255 ? y = P[d] : 1424 <= d && d <= 1524 ? y = "R" : 1536 <= d && d <= 1791 ? (y = D[d & 255], y || (0, n.warn)("Bidi: invalid Unicode character " + d.toString(16))) : (1792 <= d && d <= 2220 || 64336 <= d && d <= 65023 || 65136 <= d && d <= 65279) && (y = "AL"), (y === "R" || y === "AL" || y === "AN") && R++, f[z] = y;
            }
            if (R === 0)
              return O = !0, E(a, O);
            N === -1 && (R / M < 0.3 && M > 4 ? (O = !0, N = 0) : (O = !1, N = 1));
            const g = [];
            for (z = 0; z < M; ++z)
              g[z] = N;
            const T = e(N) ? "R" : "L", o = T, c = o;
            let I = o;
            for (z = 0; z < M; ++z)
              f[z] === "NSM" ? f[z] = I : I = f[z];
            I = o;
            let s;
            for (z = 0; z < M; ++z)
              s = f[z], s === "EN" ? f[z] = I === "AL" ? "AN" : "EN" : (s === "R" || s === "L" || s === "AL") && (I = s);
            for (z = 0; z < M; ++z)
              s = f[z], s === "AL" && (f[z] = "R");
            for (z = 1; z < M - 1; ++z)
              f[z] === "ES" && f[z - 1] === "EN" && f[z + 1] === "EN" && (f[z] = "EN"), f[z] === "CS" && (f[z - 1] === "EN" || f[z - 1] === "AN") && f[z + 1] === f[z - 1] && (f[z] = f[z - 1]);
            for (z = 0; z < M; ++z)
              if (f[z] === "EN") {
                for (let d = z - 1; d >= 0 && f[d] === "ET"; --d)
                  f[d] = "EN";
                for (let d = z + 1; d < M && f[d] === "ET"; ++d)
                  f[d] = "EN";
              }
            for (z = 0; z < M; ++z)
              s = f[z], (s === "WS" || s === "ES" || s === "ET" || s === "CS") && (f[z] = "ON");
            for (I = o, z = 0; z < M; ++z)
              s = f[z], s === "EN" ? f[z] = I === "L" ? "L" : "EN" : (s === "R" || s === "L") && (I = s);
            for (z = 0; z < M; ++z)
              if (f[z] === "ON") {
                const d = l(f, z + 1, "ON");
                let y = o;
                z > 0 && (y = f[z - 1]);
                let _ = c;
                d + 1 < M && (_ = f[d + 1]), y !== "L" && (y = "R"), _ !== "L" && (_ = "R"), y === _ && V(f, z, d, y), z = d - 1;
              }
            for (z = 0; z < M; ++z)
              f[z] === "ON" && (f[z] = T);
            for (z = 0; z < M; ++z)
              s = f[z], t(g[z]) ? s === "R" ? g[z] += 1 : (s === "AN" || s === "EN") && (g[z] += 2) : (s === "L" || s === "AN" || s === "EN") && (g[z] += 1);
            let r = -1, u = 99, C;
            for (z = 0, W = g.length; z < W; ++z)
              C = g[z], r < C && (r = C), u > C && e(C) && (u = C);
            for (C = r; C >= u; --C) {
              let d = -1;
              for (z = 0, W = g.length; z < W; ++z)
                g[z] < C ? d >= 0 && (te(F, d, z), d = -1) : d < 0 && (d = z);
              d >= 0 && te(F, d, g.length);
            }
            for (z = 0, W = F.length; z < W; ++z) {
              const d = F[z];
              (d === "<" || d === ">") && (F[z] = "");
            }
            return E(F.join(""), O);
          }
        },
        /* 61 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.getFontSubstitution = f;
          var n = ce(38), P = ce(3);
          const D = {
            style: "normal",
            weight: "normal"
          }, e = {
            style: "normal",
            weight: "bold"
          }, t = {
            style: "italic",
            weight: "normal"
          }, l = {
            style: "italic",
            weight: "bold"
          }, V = /* @__PURE__ */ new Map([["Times-Roman", {
            local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
            style: D,
            ultimate: "serif"
          }], ["Times-Bold", {
            alias: "Times-Roman",
            style: e,
            ultimate: "serif"
          }], ["Times-Italic", {
            alias: "Times-Roman",
            style: t,
            ultimate: "serif"
          }], ["Times-BoldItalic", {
            alias: "Times-Roman",
            style: l,
            ultimate: "serif"
          }], ["Helvetica", {
            local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
            path: "LiberationSans-Regular.ttf",
            style: D,
            ultimate: "sans-serif"
          }], ["Helvetica-Bold", {
            alias: "Helvetica",
            path: "LiberationSans-Bold.ttf",
            style: e,
            ultimate: "sans-serif"
          }], ["Helvetica-Oblique", {
            alias: "Helvetica",
            path: "LiberationSans-Italic.ttf",
            style: t,
            ultimate: "sans-serif"
          }], ["Helvetica-BoldOblique", {
            alias: "Helvetica",
            path: "LiberationSans-BoldItalic.ttf",
            style: l,
            ultimate: "sans-serif"
          }], ["Courier", {
            local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono"],
            style: D,
            ultimate: "monospace"
          }], ["Courier-Bold", {
            alias: "Courier",
            style: e,
            ultimate: "monospace"
          }], ["Courier-Oblique", {
            alias: "Courier",
            style: t,
            ultimate: "monospace"
          }], ["Courier-BoldOblique", {
            alias: "Courier",
            style: l,
            ultimate: "monospace"
          }], ["ArialBlack", {
            local: ["Arial Black"],
            style: {
              style: "normal",
              weight: "900"
            },
            fallback: "Helvetica-Bold"
          }], ["ArialBlack-Bold", {
            alias: "ArialBlack"
          }], ["ArialBlack-Italic", {
            alias: "ArialBlack",
            style: {
              style: "italic",
              weight: "900"
            },
            fallback: "Helvetica-BoldOblique"
          }], ["ArialBlack-BoldItalic", {
            alias: "ArialBlack-Italic"
          }], ["ArialNarrow", {
            local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
            style: D,
            fallback: "Helvetica"
          }], ["ArialNarrow-Bold", {
            alias: "ArialNarrow",
            style: e,
            fallback: "Helvetica-Bold"
          }], ["ArialNarrow-Italic", {
            alias: "ArialNarrow",
            style: t,
            fallback: "Helvetica-Oblique"
          }], ["ArialNarrow-BoldItalic", {
            alias: "ArialNarrow",
            style: l,
            fallback: "Helvetica-BoldOblique"
          }], ["Calibri", {
            local: ["Calibri", "Carlito"],
            style: D,
            fallback: "Helvetica"
          }], ["Calibri-Bold", {
            alias: "Calibri",
            style: e,
            fallback: "Helvetica-Bold"
          }], ["Calibri-Italic", {
            alias: "Calibri",
            style: t,
            fallback: "Helvetica-Oblique"
          }], ["Calibri-BoldItalic", {
            alias: "Calibri",
            style: l,
            fallback: "Helvetica-BoldOblique"
          }], ["Wingdings", {
            local: ["Wingdings", "URW Dingbats"],
            style: D
          }], ["Wingdings-Regular", {
            alias: "Wingdings"
          }], ["Wingdings-Bold", {
            alias: "Wingdings"
          }]]), te = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
          function E(x) {
            switch (x) {
              case e:
                return "Bold";
              case t:
                return "Italic";
              case l:
                return "Bold Italic";
              default:
                if ((x == null ? void 0 : x.weight) === "bold")
                  return "Bold";
                if ((x == null ? void 0 : x.style) === "italic")
                  return "Italic";
            }
            return "";
          }
          function F({
            alias: x,
            local: a,
            path: N,
            fallback: p,
            style: O,
            ultimate: M
          }, R, z, W = !0, g = !0, T = "") {
            const o = {
              style: null,
              ultimate: null
            };
            if (a) {
              const c = T ? ` ${T}` : "";
              for (const I of a)
                R.push(`local(${I}${c})`);
            }
            if (x) {
              const c = V.get(x), I = T || E(O);
              Object.assign(o, F(c, R, z, W && !p, g && !N, I));
            }
            if (O && (o.style = O), M && (o.ultimate = M), W && p) {
              const c = V.get(p), {
                ultimate: I
              } = F(c, R, z, W, g && !N, T);
              o.ultimate || (o.ultimate = I);
            }
            return g && N && z && R.push(`url(${z}${N})`), o;
          }
          function f(x, a, N, p, O) {
            p = (0, n.normalizeFontName)(p);
            const M = p;
            let R = x.get(M);
            if (R)
              return R;
            let z = V.get(p);
            if (!z) {
              for (const [r, u] of te)
                if (p.startsWith(r)) {
                  p = `${u}${p.substring(r.length)}`, z = V.get(p);
                  break;
                }
            }
            let W = !1;
            z || (z = V.get(O), W = !0);
            const g = `${a.getDocId()}_s${a.createFontId()}`;
            if (!z) {
              if (!(0, P.validateFontName)(p))
                return x.set(M, null), null;
              const r = /bold/gi.test(p), u = /oblique|italic/gi.test(p), C = r && u && l || r && e || u && t || D;
              return R = {
                css: g,
                guessFallback: !0,
                loadedName: g,
                baseFontName: p,
                src: `local(${p})`,
                style: C
              }, x.set(M, R), R;
            }
            const T = [];
            W && (0, P.validateFontName)(p) && T.push(`local(${p})`);
            const {
              style: o,
              ultimate: c
            } = F(z, T, N), I = c === null, s = I ? "" : `,${c}`;
            return R = {
              css: `${g}${s}`,
              guessFallback: I,
              loadedName: g,
              baseFontName: p,
              src: T.join(","),
              style: o
            }, x.set(M, R), R;
          }
        },
        /* 62 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ImageResizer = void 0;
          var n = ce(2);
          const P = 2048, D = 65537, e = 128;
          class t {
            constructor(V, te) {
              this._imgData = V, this._isMask = te;
            }
            static needsToBeResized(V, te) {
              if (V <= this._goodSquareLength && te <= this._goodSquareLength)
                return !1;
              const {
                MAX_DIM: E
              } = this;
              if (V > E || te > E)
                return !0;
              const F = V * te;
              if (this._hasMaxArea)
                return F > this.MAX_AREA;
              if (F < this._goodSquareLength ** 2)
                return !1;
              if (this._areGoodDims(V, te))
                return this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(V * te))), !1;
              this._goodSquareLength = this._guessMax(this._goodSquareLength, E, e, 0);
              const f = this.MAX_AREA = this._goodSquareLength ** 2;
              return F > f;
            }
            static get MAX_DIM() {
              return (0, n.shadow)(this, "MAX_DIM", this._guessMax(P, D, 0, 1));
            }
            static get MAX_AREA() {
              return this._hasMaxArea = !0, (0, n.shadow)(this, "MAX_AREA", this._guessMax(t._goodSquareLength, this.MAX_DIM, e, 0) ** 2);
            }
            static set MAX_AREA(V) {
              V >= 0 && (this._hasMaxArea = !0, (0, n.shadow)(this, "MAX_AREA", V));
            }
            static setMaxArea(V) {
              this._hasMaxArea || (this.MAX_AREA = V >> 2);
            }
            static _areGoodDims(V, te) {
              try {
                const E = new OffscreenCanvas(V, te), F = E.getContext("2d");
                F.fillRect(0, 0, 1, 1);
                const f = F.getImageData(0, 0, 1, 1).data[3];
                return E.width = E.height = 1, f !== 0;
              } catch {
                return !1;
              }
            }
            static _guessMax(V, te, E, F) {
              for (; V + E + 1 < te; ) {
                const f = Math.floor((V + te) / 2), x = F || f;
                this._areGoodDims(f, x) ? V = f : te = f;
              }
              return V;
            }
            static async createImage(V, te = !1) {
              return new t(V, te)._createImage();
            }
            async _createImage() {
              const V = this._encodeBMP(), te = new Blob([V.buffer], {
                type: "image/bmp"
              }), E = createImageBitmap(te), {
                MAX_AREA: F,
                MAX_DIM: f
              } = t, {
                _imgData: x
              } = this, {
                width: a,
                height: N
              } = x, p = Math.max(a / f, N / f, Math.sqrt(a * N / F)), O = Math.max(p, 2), M = Math.round(10 * (p + 1.25)) / 10 / O, R = Math.floor(Math.log2(M)), z = new Array(R + 2).fill(2);
              z[0] = O, z.splice(-1, 1, M / (1 << R));
              let W = a, g = N, T = await E;
              for (const o of z) {
                const c = W, I = g;
                W = Math.floor(W / o) - 1, g = Math.floor(g / o) - 1;
                const s = new OffscreenCanvas(W, g);
                s.getContext("2d").drawImage(T, 0, 0, c, I, 0, 0, W, g), T = s.transferToImageBitmap();
              }
              return x.data = null, x.bitmap = T, x.width = W, x.height = g, x;
            }
            _encodeBMP() {
              const {
                width: V,
                height: te,
                kind: E
              } = this._imgData;
              let F = this._imgData.data, f, x = new Uint8Array(0), a = x, N = 0;
              switch (E) {
                case n.ImageKind.GRAYSCALE_1BPP: {
                  f = 1, x = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
                  const g = V + 7 >> 3, T = g + 3 & -4;
                  if (g !== T) {
                    const o = new Uint8Array(T * te);
                    let c = 0;
                    for (let I = 0, s = te * g; I < s; I += g, c += T)
                      o.set(F.subarray(I, I + g), c);
                    F = o;
                  }
                  break;
                }
                case n.ImageKind.RGB_24BPP: {
                  if (f = 24, V & 3) {
                    const g = 3 * V, T = g + 3 & -4, o = T - g, c = new Uint8Array(T * te);
                    let I = 0;
                    for (let s = 0, r = te * g; s < r; s += g) {
                      const u = F.subarray(s, s + g);
                      for (let C = 0; C < g; C += 3)
                        c[I++] = u[C + 2], c[I++] = u[C + 1], c[I++] = u[C];
                      I += o;
                    }
                    F = c;
                  } else
                    for (let g = 0, T = F.length; g < T; g += 3) {
                      const o = F[g];
                      F[g] = F[g + 2], F[g + 2] = o;
                    }
                  break;
                }
                case n.ImageKind.RGBA_32BPP:
                  f = 32, N = 3, a = new Uint8Array(68);
                  const W = new DataView(a.buffer);
                  n.FeatureTest.isLittleEndian ? (W.setUint32(0, 255, !0), W.setUint32(4, 65280, !0), W.setUint32(8, 16711680, !0), W.setUint32(12, 4278190080, !0)) : (W.setUint32(0, 4278190080, !0), W.setUint32(4, 16711680, !0), W.setUint32(8, 65280, !0), W.setUint32(12, 255, !0));
                  break;
                default:
                  throw new Error("invalid format");
              }
              let p = 0;
              const O = 40 + a.length, M = 14 + O + x.length + F.length, R = new Uint8Array(M), z = new DataView(R.buffer);
              return z.setUint16(p, 19778, !0), p += 2, z.setUint32(p, M, !0), p += 4, z.setUint32(p, 0, !0), p += 4, z.setUint32(p, 14 + O + x.length, !0), p += 4, z.setUint32(p, O, !0), p += 4, z.setInt32(p, V, !0), p += 4, z.setInt32(p, -te, !0), p += 4, z.setUint16(p, 1, !0), p += 2, z.setUint16(p, f, !0), p += 2, z.setUint32(p, N, !0), p += 4, z.setUint32(p, 0, !0), p += 4, z.setInt32(p, 0, !0), p += 4, z.setInt32(p, 0, !0), p += 4, z.setUint32(p, x.length / 4, !0), p += 4, z.setUint32(p, 0, !0), p += 4, R.set(a, p), p += a.length, R.set(x, p), p += x.length, R.set(F, p), R;
            }
          }
          b.ImageResizer = t, t._goodSquareLength = P;
        },
        /* 63 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.MurmurHash3_64 = void 0;
          var n = ce(2);
          const P = 3285377520, D = 4294901760, e = 65535;
          class t {
            constructor(V) {
              this.h1 = V ? V & 4294967295 : P, this.h2 = V ? V & 4294967295 : P;
            }
            update(V) {
              let te, E;
              if (typeof V == "string") {
                te = new Uint8Array(V.length * 2), E = 0;
                for (let g = 0, T = V.length; g < T; g++) {
                  const o = V.charCodeAt(g);
                  o <= 255 ? te[E++] = o : (te[E++] = o >>> 8, te[E++] = o & 255);
                }
              } else if ((0, n.isArrayBuffer)(V))
                te = V.slice(), E = te.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const F = E >> 2, f = E - F * 4, x = new Uint32Array(te.buffer, 0, F);
              let a = 0, N = 0, p = this.h1, O = this.h2;
              const M = 3432918353, R = 461845907, z = M & e, W = R & e;
              for (let g = 0; g < F; g++)
                g & 1 ? (a = x[g], a = a * M & D | a * z & e, a = a << 15 | a >>> 17, a = a * R & D | a * W & e, p ^= a, p = p << 13 | p >>> 19, p = p * 5 + 3864292196) : (N = x[g], N = N * M & D | N * z & e, N = N << 15 | N >>> 17, N = N * R & D | N * W & e, O ^= N, O = O << 13 | O >>> 19, O = O * 5 + 3864292196);
              switch (a = 0, f) {
                case 3:
                  a ^= te[F * 4 + 2] << 16;
                case 2:
                  a ^= te[F * 4 + 1] << 8;
                case 1:
                  a ^= te[F * 4], a = a * M & D | a * z & e, a = a << 15 | a >>> 17, a = a * R & D | a * W & e, F & 1 ? p ^= a : O ^= a;
              }
              this.h1 = p, this.h2 = O;
            }
            hexdigest() {
              let V = this.h1, te = this.h2;
              return V ^= te >>> 1, V = V * 3981806797 & D | V * 36045 & e, te = te * 4283543511 & D | ((te << 16 | V >>> 16) * 2950163797 & D) >>> 16, V ^= te >>> 1, V = V * 444984403 & D | V * 60499 & e, te = te * 3301882366 & D | ((te << 16 | V >>> 16) * 3120437893 & D) >>> 16, V ^= te >>> 1, (V >>> 0).toString(16).padStart(8, "0") + (te >>> 0).toString(16).padStart(8, "0");
            }
          }
          b.MurmurHash3_64 = t;
        },
        /* 64 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.OperatorList = void 0;
          var n = ce(2);
          function P(te, E, F, f, x) {
            let a = te;
            for (let N = 0, p = E.length - 1; N < p; N++) {
              const O = E[N];
              a = a[O] || (a[O] = []);
            }
            a[E.at(-1)] = {
              checkFn: F,
              iterateFn: f,
              processFn: x
            };
          }
          const D = [];
          P(D, [n.OPS.save, n.OPS.transform, n.OPS.paintInlineImageXObject, n.OPS.restore], null, function(E, F) {
            const f = E.fnArray, x = E.iCurr - 3, a = (F - x) % 4;
            switch (a) {
              case 0:
                return f[F] === n.OPS.save;
              case 1:
                return f[F] === n.OPS.transform;
              case 2:
                return f[F] === n.OPS.paintInlineImageXObject;
              case 3:
                return f[F] === n.OPS.restore;
            }
            throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`);
          }, function(E, F) {
            const p = E.fnArray, O = E.argsArray, M = E.iCurr, R = M - 3, z = M - 2, W = M - 1, g = Math.min(Math.floor((F - R) / 4), 200);
            if (g < 10)
              return F - (F - R) % 4;
            let T = 0;
            const o = [];
            let c = 0, I = 1, s = 1;
            for (let _ = 0; _ < g; _++) {
              const $ = O[z + (_ << 2)], S = O[W + (_ << 2)][0];
              I + S.width > 1e3 && (T = Math.max(T, I), s += c + 2, I = 0, c = 0), o.push({
                transform: $,
                x: I,
                y: s,
                w: S.width,
                h: S.height
              }), I += S.width + 2, c = Math.max(c, S.height);
            }
            const r = Math.max(T, I) + 1, u = s + c + 1, C = new Uint8Array(r * u * 4), d = r << 2;
            for (let _ = 0; _ < g; _++) {
              const $ = O[W + (_ << 2)][0].data, S = o[_].w << 2;
              let v = 0, m = o[_].x + o[_].y * r << 2;
              C.set($.subarray(0, S), m - d);
              for (let h = 0, A = o[_].h; h < A; h++)
                C.set($.subarray(v, v + S), m), v += S, m += d;
              for (C.set($.subarray(v - S, v), m); m >= 0; )
                $[m - 4] = $[m], $[m - 3] = $[m + 1], $[m - 2] = $[m + 2], $[m - 1] = $[m + 3], $[m + S] = $[m + S - 4], $[m + S + 1] = $[m + S - 3], $[m + S + 2] = $[m + S - 2], $[m + S + 3] = $[m + S - 1], m -= d;
            }
            const y = {
              width: r,
              height: u
            };
            if (E.isOffscreenCanvasSupported) {
              const _ = new OffscreenCanvas(r, u);
              _.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(C.buffer), r, u), 0, 0), y.bitmap = _.transferToImageBitmap(), y.data = null;
            } else
              y.kind = n.ImageKind.RGBA_32BPP, y.data = C;
            return p.splice(R, g * 4, n.OPS.paintInlineImageXObjectGroup), O.splice(R, g * 4, [y, o]), R + 1;
          }), P(D, [n.OPS.save, n.OPS.transform, n.OPS.paintImageMaskXObject, n.OPS.restore], null, function(E, F) {
            const f = E.fnArray, x = E.iCurr - 3, a = (F - x) % 4;
            switch (a) {
              case 0:
                return f[F] === n.OPS.save;
              case 1:
                return f[F] === n.OPS.transform;
              case 2:
                return f[F] === n.OPS.paintImageMaskXObject;
              case 3:
                return f[F] === n.OPS.restore;
            }
            throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`);
          }, function(E, F) {
            const N = E.fnArray, p = E.argsArray, O = E.iCurr, M = O - 3, R = O - 2, z = O - 1;
            let W = Math.floor((F - M) / 4);
            if (W < 10)
              return F - (F - M) % 4;
            let g = !1, T, o;
            const c = p[z][0], I = p[R][0], s = p[R][1], r = p[R][2], u = p[R][3];
            if (s === r) {
              g = !0, T = R + 4;
              let C = z + 4;
              for (let d = 1; d < W; d++, T += 4, C += 4)
                if (o = p[T], p[C][0] !== c || o[0] !== I || o[1] !== s || o[2] !== r || o[3] !== u) {
                  d < 10 ? g = !1 : W = d;
                  break;
                }
            }
            if (g) {
              W = Math.min(W, 1e3);
              const C = new Float32Array(W * 2);
              T = R;
              for (let d = 0; d < W; d++, T += 4)
                o = p[T], C[d << 1] = o[4], C[(d << 1) + 1] = o[5];
              N.splice(M, W * 4, n.OPS.paintImageMaskXObjectRepeat), p.splice(M, W * 4, [c, I, s, r, u, C]);
            } else {
              W = Math.min(W, 100);
              const C = [];
              for (let d = 0; d < W; d++) {
                o = p[R + (d << 2)];
                const y = p[z + (d << 2)][0];
                C.push({
                  data: y.data,
                  width: y.width,
                  height: y.height,
                  interpolate: y.interpolate,
                  count: y.count,
                  transform: o
                });
              }
              N.splice(M, W * 4, n.OPS.paintImageMaskXObjectGroup), p.splice(M, W * 4, [C]);
            }
            return M + 1;
          }), P(D, [n.OPS.save, n.OPS.transform, n.OPS.paintImageXObject, n.OPS.restore], function(te) {
            const E = te.argsArray, F = te.iCurr - 2;
            return E[F][1] === 0 && E[F][2] === 0;
          }, function(E, F) {
            const f = E.fnArray, x = E.argsArray, a = E.iCurr - 3, N = (F - a) % 4;
            switch (N) {
              case 0:
                return f[F] === n.OPS.save;
              case 1:
                if (f[F] !== n.OPS.transform)
                  return !1;
                const p = E.iCurr - 2, O = x[p][0], M = x[p][3];
                return !(x[F][0] !== O || x[F][1] !== 0 || x[F][2] !== 0 || x[F][3] !== M);
              case 2:
                if (f[F] !== n.OPS.paintImageXObject)
                  return !1;
                const R = E.iCurr - 1, z = x[R][0];
                return x[F][0] === z;
              case 3:
                return f[F] === n.OPS.restore;
            }
            throw new Error(`iterateImageGroup - invalid pos: ${N}`);
          }, function(te, E) {
            const x = te.fnArray, a = te.argsArray, N = te.iCurr, p = N - 3, O = N - 2, M = N - 1, R = a[M][0], z = a[O][0], W = a[O][3], g = Math.min(Math.floor((E - p) / 4), 1e3);
            if (g < 3)
              return E - (E - p) % 4;
            const T = new Float32Array(g * 2);
            let o = O;
            for (let I = 0; I < g; I++, o += 4) {
              const s = a[o];
              T[I << 1] = s[4], T[(I << 1) + 1] = s[5];
            }
            const c = [R, z, W, T];
            return x.splice(p, g * 4, n.OPS.paintImageXObjectRepeat), a.splice(p, g * 4, c), p + 1;
          }), P(D, [n.OPS.beginText, n.OPS.setFont, n.OPS.setTextMatrix, n.OPS.showText, n.OPS.endText], null, function(E, F) {
            const f = E.fnArray, x = E.argsArray, a = E.iCurr - 4, N = (F - a) % 5;
            switch (N) {
              case 0:
                return f[F] === n.OPS.beginText;
              case 1:
                return f[F] === n.OPS.setFont;
              case 2:
                return f[F] === n.OPS.setTextMatrix;
              case 3:
                if (f[F] !== n.OPS.showText)
                  return !1;
                const p = E.iCurr - 3, O = x[p][0], M = x[p][1];
                return !(x[F][0] !== O || x[F][1] !== M);
              case 4:
                return f[F] === n.OPS.endText;
            }
            throw new Error(`iterateShowTextGroup - invalid pos: ${N}`);
          }, function(te, E) {
            const x = te.fnArray, a = te.argsArray, N = te.iCurr, p = N - 4, O = N - 3, M = N - 2, R = N - 1, z = N, W = a[O][0], g = a[O][1];
            let T = Math.min(Math.floor((E - p) / 5), 1e3);
            if (T < 3)
              return E - (E - p) % 5;
            let o = p;
            p >= 4 && x[p - 4] === x[O] && x[p - 3] === x[M] && x[p - 2] === x[R] && x[p - 1] === x[z] && a[p - 4][0] === W && a[p - 4][1] === g && (T++, o -= 5);
            let c = o + 4;
            for (let I = 1; I < T; I++)
              x.splice(c, 3), a.splice(c, 3), c += 2;
            return c + 1;
          });
          class e {
            constructor(E) {
              this.queue = E;
            }
            _optimize() {
            }
            push(E, F) {
              this.queue.fnArray.push(E), this.queue.argsArray.push(F), this._optimize();
            }
            flush() {
            }
            reset() {
            }
          }
          class t extends e {
            constructor(E) {
              super(E), this.state = null, this.context = {
                iCurr: 0,
                fnArray: E.fnArray,
                argsArray: E.argsArray,
                isOffscreenCanvasSupported: !1
              }, this.match = null, this.lastProcessed = 0;
            }
            set isOffscreenCanvasSupported(E) {
              this.context.isOffscreenCanvasSupported = E;
            }
            _optimize() {
              const E = this.queue.fnArray;
              let F = this.lastProcessed, f = E.length, x = this.state, a = this.match;
              if (!x && !a && F + 1 === f && !D[E[F]]) {
                this.lastProcessed = f;
                return;
              }
              const N = this.context;
              for (; F < f; ) {
                if (a) {
                  if ((0, a.iterateFn)(N, F)) {
                    F++;
                    continue;
                  }
                  if (F = (0, a.processFn)(N, F + 1), f = E.length, a = null, x = null, F >= f)
                    break;
                }
                if (x = (x || D)[E[F]], !x || Array.isArray(x)) {
                  F++;
                  continue;
                }
                if (N.iCurr = F, F++, x.checkFn && !(0, x.checkFn)(N)) {
                  x = null;
                  continue;
                }
                a = x, x = null;
              }
              this.state = x, this.match = a, this.lastProcessed = F;
            }
            flush() {
              for (; this.match; ) {
                const E = this.queue.fnArray.length;
                this.lastProcessed = (0, this.match.processFn)(this.context, E), this.match = null, this.state = null, this._optimize();
              }
            }
            reset() {
              this.state = null, this.match = null, this.lastProcessed = 0;
            }
          }
          const V = class V {
            constructor(E = 0, F) {
              this._streamSink = F, this.fnArray = [], this.argsArray = [], this.optimizer = F && !(E & n.RenderingIntentFlag.OPLIST) ? new t(this) : new e(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = F ? null : Promise.resolve();
            }
            set isOffscreenCanvasSupported(E) {
              this.optimizer.isOffscreenCanvasSupported = E;
            }
            get length() {
              return this.argsArray.length;
            }
            get ready() {
              return this._resolved || this._streamSink.ready;
            }
            get totalLength() {
              return this._totalLength + this.length;
            }
            addOp(E, F) {
              this.optimizer.push(E, F), this.weight++, this._streamSink && (this.weight >= V.CHUNK_SIZE ? this.flush() : this.weight >= V.CHUNK_SIZE_ABOUT && (E === n.OPS.restore || E === n.OPS.endText) && this.flush());
            }
            addImageOps(E, F, f) {
              f !== void 0 && this.addOp(n.OPS.beginMarkedContentProps, ["OC", f]), this.addOp(E, F), f !== void 0 && this.addOp(n.OPS.endMarkedContent, []);
            }
            addDependency(E) {
              this.dependencies.has(E) || (this.dependencies.add(E), this.addOp(n.OPS.dependency, [E]));
            }
            addDependencies(E) {
              for (const F of E)
                this.addDependency(F);
            }
            addOpList(E) {
              if (!(E instanceof V)) {
                (0, n.warn)('addOpList - ignoring invalid "opList" parameter.');
                return;
              }
              for (const F of E.dependencies)
                this.dependencies.add(F);
              for (let F = 0, f = E.length; F < f; F++)
                this.addOp(E.fnArray[F], E.argsArray[F]);
            }
            getIR() {
              return {
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                length: this.length
              };
            }
            get _transfers() {
              var a;
              const E = [], {
                fnArray: F,
                argsArray: f,
                length: x
              } = this;
              for (let N = 0; N < x; N++)
                switch (F[N]) {
                  case n.OPS.paintInlineImageXObject:
                  case n.OPS.paintInlineImageXObjectGroup:
                  case n.OPS.paintImageMaskXObject:
                    const p = f[N][0];
                    !p.cached && ((a = p.data) == null ? void 0 : a.buffer) instanceof ArrayBuffer && E.push(p.data.buffer);
                    break;
                }
              return E;
            }
            flush(E = !1, F = null) {
              this.optimizer.flush();
              const f = this.length;
              this._totalLength += f, this._streamSink.enqueue({
                fnArray: this.fnArray,
                argsArray: this.argsArray,
                lastChunk: E,
                separateAnnots: F,
                length: f
              }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
            }
          };
          Ut(V, "CHUNK_SIZE", 1e3), Ut(V, "CHUNK_SIZE_ABOUT", V.CHUNK_SIZE - 5);
          let l = V;
          b.OperatorList = l;
        },
        /* 65 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PDFImage = void 0;
          var n = ce(2), P = ce(28), D = ce(5), e = ce(12), t = ce(18), l = ce(62), V = ce(26), te = ce(30), E = ce(4);
          function F(a, N, p, O) {
            return a = N + a * p, a < 0 ? a = 0 : a > O && (a = O), a;
          }
          function f(a, N, p, O, M, R) {
            const z = M * R;
            let W;
            N <= 8 ? W = new Uint8Array(z) : N <= 16 ? W = new Uint16Array(z) : W = new Uint32Array(z);
            const g = p / M, T = O / R;
            let o, c, I, s = 0, r;
            const u = new Uint16Array(M), C = p;
            for (o = 0; o < M; o++)
              u[o] = Math.floor(o * g);
            for (o = 0; o < R; o++)
              for (I = Math.floor(o * T) * C, c = 0; c < M; c++)
                r = I + u[c], W[s++] = a[r];
            return W;
          }
          class x {
            constructor({
              xref: N,
              res: p,
              image: O,
              isInline: M = !1,
              smask: R = null,
              mask: z = null,
              isMask: W = !1,
              pdfFunctionFactory: g,
              localColorSpaceCache: T
            }) {
              var C;
              this.image = O;
              const o = O.dict, c = o.get("F", "Filter");
              let I;
              if (c instanceof E.Name)
                I = c.name;
              else if (Array.isArray(c)) {
                const d = N.fetchIfRef(c[0]);
                d instanceof E.Name && (I = d.name);
              }
              switch (I) {
                case "JPXDecode":
                  const d = new te.JpxImage();
                  d.parseImageProperties(O.stream), O.stream.reset(), O.width = d.width, O.height = d.height, O.bitsPerComponent = d.bitsPerComponent, O.numComps = d.componentsCount;
                  break;
                case "JBIG2Decode":
                  O.bitsPerComponent = 1, O.numComps = 1;
                  break;
              }
              let s = o.get("W", "Width"), r = o.get("H", "Height");
              if (Number.isInteger(O.width) && O.width > 0 && Number.isInteger(O.height) && O.height > 0 && (O.width !== s || O.height !== r) && ((0, n.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), s = O.width, r = O.height), s < 1 || r < 1)
                throw new n.FormatError(`Invalid image width: ${s} or height: ${r}`);
              this.width = s, this.height = r, this.interpolate = o.get("I", "Interpolate"), this.imageMask = o.get("IM", "ImageMask") || !1, this.matte = o.get("Matte") || !1;
              let u = O.bitsPerComponent;
              if (!u && (u = o.get("BPC", "BitsPerComponent"), !u))
                if (this.imageMask)
                  u = 1;
                else
                  throw new n.FormatError(`Bits per component missing in image: ${this.imageMask}`);
              if (this.bpc = u, !this.imageMask) {
                let d = o.getRaw("CS") || o.getRaw("ColorSpace");
                if (!d)
                  switch ((0, n.info)("JPX images (which do not require color spaces)"), O.numComps) {
                    case 1:
                      d = E.Name.get("DeviceGray");
                      break;
                    case 3:
                      d = E.Name.get("DeviceRGB");
                      break;
                    case 4:
                      d = E.Name.get("DeviceCMYK");
                      break;
                    default:
                      throw new Error(`JPX images with ${O.numComps} color components not supported.`);
                  }
                this.colorSpace = e.ColorSpace.parse({
                  cs: d,
                  xref: N,
                  resources: M ? p : null,
                  pdfFunctionFactory: g,
                  localColorSpaceCache: T
                }), this.numComps = this.colorSpace.numComps;
              }
              if (this.decode = o.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, u) || W && !e.ColorSpace.isDefaultDecode(this.decode, 1))) {
                this.needsDecode = !0;
                const d = (1 << u) - 1;
                this.decodeCoefficients = [], this.decodeAddends = [];
                const y = ((C = this.colorSpace) == null ? void 0 : C.name) === "Indexed";
                for (let _ = 0, $ = 0; _ < this.decode.length; _ += 2, ++$) {
                  const S = this.decode[_], v = this.decode[_ + 1];
                  this.decodeCoefficients[$] = y ? (v - S) / d : v - S, this.decodeAddends[$] = y ? S : d * S;
                }
              }
              R ? this.smask = new x({
                xref: N,
                res: p,
                image: R,
                isInline: M,
                pdfFunctionFactory: g,
                localColorSpaceCache: T
              }) : z && (z instanceof D.BaseStream ? z.dict.get("IM", "ImageMask") ? this.mask = new x({
                xref: N,
                res: p,
                image: z,
                isInline: M,
                isMask: !0,
                pdfFunctionFactory: g,
                localColorSpaceCache: T
              }) : (0, n.warn)("Ignoring /Mask in image without /ImageMask.") : this.mask = z);
            }
            static async buildImage({
              xref: N,
              res: p,
              image: O,
              isInline: M = !1,
              pdfFunctionFactory: R,
              localColorSpaceCache: z
            }) {
              const W = O;
              let g = null, T = null;
              const o = O.dict.get("SMask"), c = O.dict.get("Mask");
              return o ? o instanceof D.BaseStream ? g = o : (0, n.warn)("Unsupported /SMask format.") : c && (c instanceof D.BaseStream || Array.isArray(c) ? T = c : (0, n.warn)("Unsupported /Mask format.")), new x({
                xref: N,
                res: p,
                image: W,
                isInline: M,
                smask: g,
                mask: T,
                pdfFunctionFactory: R,
                localColorSpaceCache: z
              });
            }
            static createRawMask({
              imgArray: N,
              width: p,
              height: O,
              imageIsFromDecodeStream: M,
              inverseDecode: R,
              interpolate: z
            }) {
              const W = (p + 7 >> 3) * O, g = N.byteLength, T = W === g;
              let o, c;
              if (M && (!R || T) ? o = N : R ? (o = new Uint8Array(W), o.set(N), o.fill(255, g)) : o = new Uint8Array(N), R)
                for (c = 0; c < g; c++)
                  o[c] ^= 255;
              return {
                data: o,
                width: p,
                height: O,
                interpolate: z
              };
            }
            static async createMask({
              imgArray: N,
              width: p,
              height: O,
              imageIsFromDecodeStream: M,
              inverseDecode: R,
              interpolate: z,
              isOffscreenCanvasSupported: W = !1
            }) {
              const g = p === 1 && O === 1 && R === (N.length === 0 || !!(N[0] & 128));
              if (g)
                return {
                  isSingleOpaquePixel: g
                };
              if (W) {
                if (l.ImageResizer.needsToBeResized(p, O)) {
                  const s = new Uint8ClampedArray(p * O * 4);
                  return (0, P.convertBlackAndWhiteToRGBA)({
                    src: N,
                    dest: s,
                    width: p,
                    height: O,
                    nonBlackColor: 0,
                    inverseDecode: R
                  }), l.ImageResizer.createImage({
                    kind: n.ImageKind.RGBA_32BPP,
                    data: s,
                    width: p,
                    height: O,
                    interpolate: z
                  });
                }
                const T = new OffscreenCanvas(p, O), o = T.getContext("2d"), c = o.createImageData(p, O);
                (0, P.convertBlackAndWhiteToRGBA)({
                  src: N,
                  dest: c.data,
                  width: p,
                  height: O,
                  nonBlackColor: 0,
                  inverseDecode: R
                }), o.putImageData(c, 0, 0);
                const I = T.transferToImageBitmap();
                return {
                  data: null,
                  width: p,
                  height: O,
                  interpolate: z,
                  bitmap: I
                };
              }
              return this.createRawMask({
                imgArray: N,
                width: p,
                height: O,
                inverseDecode: R,
                imageIsFromDecodeStream: M,
                interpolate: z
              });
            }
            get drawWidth() {
              var N, p;
              return Math.max(this.width, ((N = this.smask) == null ? void 0 : N.width) || 0, ((p = this.mask) == null ? void 0 : p.width) || 0);
            }
            get drawHeight() {
              var N, p;
              return Math.max(this.height, ((N = this.smask) == null ? void 0 : N.height) || 0, ((p = this.mask) == null ? void 0 : p.height) || 0);
            }
            decodeBuffer(N) {
              const p = this.bpc, O = this.numComps, M = this.decodeAddends, R = this.decodeCoefficients, z = (1 << p) - 1;
              let W, g;
              if (p === 1) {
                for (W = 0, g = N.length; W < g; W++)
                  N[W] = +!N[W];
                return;
              }
              let T = 0;
              for (W = 0, g = this.width * this.height; W < g; W++)
                for (let o = 0; o < O; o++)
                  N[T] = F(N[T], M[o], R[o], z), T++;
            }
            getComponents(N) {
              const p = this.bpc;
              if (p === 8)
                return N;
              const O = this.width, M = this.height, R = this.numComps, z = O * M * R;
              let W = 0, g;
              p <= 8 ? g = new Uint8Array(z) : p <= 16 ? g = new Uint16Array(z) : g = new Uint32Array(z);
              const T = O * R, o = (1 << p) - 1;
              let c = 0, I, s;
              if (p === 1) {
                let r, u, C;
                for (let d = 0; d < M; d++) {
                  for (u = c + (T & -8), C = c + T; c < u; )
                    s = N[W++], g[c] = s >> 7 & 1, g[c + 1] = s >> 6 & 1, g[c + 2] = s >> 5 & 1, g[c + 3] = s >> 4 & 1, g[c + 4] = s >> 3 & 1, g[c + 5] = s >> 2 & 1, g[c + 6] = s >> 1 & 1, g[c + 7] = s & 1, c += 8;
                  if (c < C)
                    for (s = N[W++], r = 128; c < C; )
                      g[c++] = +!!(s & r), r >>= 1;
                }
              } else {
                let r = 0;
                for (s = 0, c = 0, I = z; c < I; ++c) {
                  for (c % T === 0 && (s = 0, r = 0); r < p; )
                    s = s << 8 | N[W++], r += 8;
                  const u = r - p;
                  let C = s >> u;
                  C < 0 ? C = 0 : C > o && (C = o), g[c] = C, s &= (1 << u) - 1, r = u;
                }
              }
              return g;
            }
            fillOpacity(N, p, O, M, R) {
              const z = this.smask, W = this.mask;
              let g, T, o, c, I, s;
              if (z)
                T = z.width, o = z.height, g = new Uint8ClampedArray(T * o), z.fillGrayBuffer(g), (T !== p || o !== O) && (g = f(g, z.bpc, T, o, p, O));
              else if (W)
                if (W instanceof x) {
                  for (T = W.width, o = W.height, g = new Uint8ClampedArray(T * o), W.numComps = 1, W.fillGrayBuffer(g), c = 0, I = T * o; c < I; ++c)
                    g[c] = 255 - g[c];
                  (T !== p || o !== O) && (g = f(g, W.bpc, T, o, p, O));
                } else if (Array.isArray(W)) {
                  g = new Uint8ClampedArray(p * O);
                  const r = this.numComps;
                  for (c = 0, I = p * O; c < I; ++c) {
                    let u = 0;
                    const C = c * r;
                    for (s = 0; s < r; ++s) {
                      const d = R[C + s], y = s * 2;
                      if (d < W[y] || d > W[y + 1]) {
                        u = 255;
                        break;
                      }
                    }
                    g[c] = u;
                  }
                } else
                  throw new n.FormatError("Unknown mask format.");
              if (g)
                for (c = 0, s = 3, I = p * M; c < I; ++c, s += 4)
                  N[s] = g[c];
              else
                for (c = 0, s = 3, I = p * M; c < I; ++c, s += 4)
                  N[s] = 255;
            }
            undoPreblend(N, p, O) {
              var o;
              const M = (o = this.smask) == null ? void 0 : o.matte;
              if (!M)
                return;
              const R = this.colorSpace.getRgb(M, 0), z = R[0], W = R[1], g = R[2], T = p * O * 4;
              for (let c = 0; c < T; c += 4) {
                const I = N[c + 3];
                if (I === 0) {
                  N[c] = 255, N[c + 1] = 255, N[c + 2] = 255;
                  continue;
                }
                const s = 255 / I;
                N[c] = (N[c] - z) * s + z, N[c + 1] = (N[c + 1] - W) * s + W, N[c + 2] = (N[c + 2] - g) * s + g;
              }
            }
            async createImageData(N = !1, p = !1) {
              const O = this.drawWidth, M = this.drawHeight, R = {
                width: O,
                height: M,
                interpolate: this.interpolate,
                kind: 0,
                data: null
              }, z = this.numComps, W = this.width, g = this.height, T = this.bpc, o = W * z * T + 7 >> 3, c = p && l.ImageResizer.needsToBeResized(O, M);
              if (!N) {
                let S;
                if (this.colorSpace.name === "DeviceGray" && T === 1 ? S = n.ImageKind.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && T === 8 && !this.needsDecode && (S = n.ImageKind.RGB_24BPP), S && !this.smask && !this.mask && O === W && M === g) {
                  const v = this.getImageBytes(g * o, {});
                  if (p)
                    return c ? l.ImageResizer.createImage({
                      data: v,
                      kind: S,
                      width: O,
                      height: M,
                      interpolate: this.interpolate
                    }, this.needsDecode) : this.createBitmap(S, W, g, v);
                  if (R.kind = S, R.data = v, this.needsDecode) {
                    (0, n.assert)(S === n.ImageKind.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
                    const m = R.data;
                    for (let h = 0, A = m.length; h < A; h++)
                      m[h] ^= 255;
                  }
                  return R;
                }
                if (this.image instanceof V.JpegStream && !this.smask && !this.mask && !this.needsDecode) {
                  let v = g * o;
                  if (p && !c) {
                    let m = !1;
                    switch (this.colorSpace.name) {
                      case "DeviceGray":
                        v *= 4, m = !0;
                        break;
                      case "DeviceRGB":
                        v = v / 3 * 4, m = !0;
                        break;
                      case "DeviceCMYK":
                        m = !0;
                        break;
                    }
                    if (m) {
                      const h = this.getImageBytes(v, {
                        drawWidth: O,
                        drawHeight: M,
                        forceRGBA: !0
                      });
                      return this.createBitmap(n.ImageKind.RGBA_32BPP, O, M, h);
                    }
                  } else
                    switch (this.colorSpace.name) {
                      case "DeviceGray":
                        v *= 3;
                      case "DeviceRGB":
                      case "DeviceCMYK":
                        return R.kind = n.ImageKind.RGB_24BPP, R.data = this.getImageBytes(v, {
                          drawWidth: O,
                          drawHeight: M,
                          forceRGB: !0
                        }), c ? l.ImageResizer.createImage(R) : R;
                    }
                }
              }
              const I = this.getImageBytes(g * o, {
                internal: !0
              }), s = 0 | I.length / o * M / g, r = this.getComponents(I);
              let u, C, d, y, _, $;
              if (p && !c && (d = new OffscreenCanvas(O, M), y = d.getContext("2d"), _ = y.createImageData(O, M), $ = _.data), R.kind = n.ImageKind.RGBA_32BPP, !N && !this.smask && !this.mask ? (!p || c ? (R.kind = n.ImageKind.RGB_24BPP, $ = new Uint8ClampedArray(O * M * 3), u = 0) : (new Uint32Array($.buffer).fill(n.FeatureTest.isLittleEndian ? 4278190080 : 255), u = 1), C = !1) : ((!p || c) && ($ = new Uint8ClampedArray(O * M * 4)), u = 1, C = !0, this.fillOpacity($, O, M, s, r)), this.needsDecode && this.decodeBuffer(r), this.colorSpace.fillRgb($, W, g, O, M, s, T, r, u), C && this.undoPreblend($, O, s), p && !c) {
                y.putImageData(_, 0, 0);
                const S = d.transferToImageBitmap();
                return {
                  data: null,
                  width: O,
                  height: M,
                  bitmap: S,
                  interpolate: this.interpolate
                };
              }
              return R.data = $, c ? l.ImageResizer.createImage(R) : R;
            }
            fillGrayBuffer(N) {
              const p = this.numComps;
              if (p !== 1)
                throw new n.FormatError(`Reading gray scale from a color image: ${p}`);
              const O = this.width, M = this.height, R = this.bpc, z = O * p * R + 7 >> 3, W = this.getImageBytes(M * z, {
                internal: !0
              }), g = this.getComponents(W);
              let T, o;
              if (R === 1) {
                if (o = O * M, this.needsDecode)
                  for (T = 0; T < o; ++T)
                    N[T] = g[T] - 1 & 255;
                else
                  for (T = 0; T < o; ++T)
                    N[T] = -g[T] & 255;
                return;
              }
              this.needsDecode && this.decodeBuffer(g), o = O * M;
              const c = 255 / ((1 << R) - 1);
              for (T = 0; T < o; ++T)
                N[T] = c * g[T];
            }
            createBitmap(N, p, O, M) {
              const R = new OffscreenCanvas(p, O), z = R.getContext("2d");
              let W;
              N === n.ImageKind.RGBA_32BPP ? W = new ImageData(M, p, O) : (W = z.createImageData(p, O), (0, P.convertToRGBA)({
                kind: N,
                src: M,
                dest: new Uint32Array(W.data.buffer),
                width: p,
                height: O,
                inverseDecode: this.needsDecode
              })), z.putImageData(W, 0, 0);
              const g = R.transferToImageBitmap();
              return {
                data: null,
                width: p,
                height: O,
                bitmap: g,
                interpolate: this.interpolate
              };
            }
            getImageBytes(N, {
              drawWidth: p,
              drawHeight: O,
              forceRGBA: M = !1,
              forceRGB: R = !1,
              internal: z = !1
            }) {
              this.image.reset(), this.image.drawWidth = p || this.width, this.image.drawHeight = O || this.height, this.image.forceRGBA = !!M, this.image.forceRGB = !!R;
              const W = this.image.getBytes(N);
              return z || this.image instanceof t.DecodeStream ? W : ((0, n.assert)(W instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(W));
            }
          }
          b.PDFImage = x;
        },
        /* 66 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Catalog = void 0;
          var n = ce(3), P = ce(2), D = ce(4), e = ce(67), t = ce(5), l = ce(68), V = ce(12), te = ce(69), E = ce(59), F = ce(70), f = ce(72);
          function x(N) {
            return N instanceof D.Dict && (N = N.get("D")), Array.isArray(N) ? N : null;
          }
          class a {
            constructor(p, O) {
              if (this.pdfManager = p, this.xref = O, this._catDict = O.getCatalogObj(), !(this._catDict instanceof D.Dict))
                throw new P.FormatError("Catalog object is not a dictionary.");
              this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new D.RefSetCache(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new E.GlobalImageCache(), this.pageKidsCountCache = new D.RefSetCache(), this.pageIndexCache = new D.RefSetCache(), this.nonBlendModesSet = new D.RefSet(), this.systemFontCache = /* @__PURE__ */ new Map();
            }
            cloneDict() {
              return this._catDict.clone();
            }
            get version() {
              const p = this._catDict.get("Version");
              if (p instanceof D.Name) {
                if (n.PDF_VERSION_REGEXP.test(p.name))
                  return (0, P.shadow)(this, "version", p.name);
                (0, P.warn)(`Invalid PDF catalog version: ${p.name}`);
              }
              return (0, P.shadow)(this, "version", null);
            }
            get lang() {
              const p = this._catDict.get("Lang");
              return (0, P.shadow)(this, "lang", typeof p == "string" ? (0, P.stringToPDFString)(p) : null);
            }
            get needsRendering() {
              const p = this._catDict.get("NeedsRendering");
              return (0, P.shadow)(this, "needsRendering", typeof p == "boolean" ? p : !1);
            }
            get collection() {
              let p = null;
              try {
                const O = this._catDict.get("Collection");
                O instanceof D.Dict && O.size > 0 && (p = O);
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.info)("Cannot fetch Collection entry; assuming no collection is present.");
              }
              return (0, P.shadow)(this, "collection", p);
            }
            get acroForm() {
              let p = null;
              try {
                const O = this._catDict.get("AcroForm");
                O instanceof D.Dict && O.size > 0 && (p = O);
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.info)("Cannot fetch AcroForm entry; assuming no forms are present.");
              }
              return (0, P.shadow)(this, "acroForm", p);
            }
            get acroFormRef() {
              const p = this._catDict.getRaw("AcroForm");
              return (0, P.shadow)(this, "acroFormRef", p instanceof D.Ref ? p : null);
            }
            get metadata() {
              var M;
              const p = this._catDict.getRaw("Metadata");
              if (!(p instanceof D.Ref))
                return (0, P.shadow)(this, "metadata", null);
              let O = null;
              try {
                const R = this.xref.fetch(p, !((M = this.xref.encrypt) != null && M.encryptMetadata));
                if (R instanceof t.BaseStream && R.dict instanceof D.Dict) {
                  const z = R.dict.get("Type"), W = R.dict.get("Subtype");
                  if ((0, D.isName)(z, "Metadata") && (0, D.isName)(W, "XML")) {
                    const g = (0, P.stringToUTF8String)(R.getString());
                    g && (O = new F.MetadataParser(g).serializable);
                  }
                }
              } catch (R) {
                if (R instanceof n.MissingDataException)
                  throw R;
                (0, P.info)(`Skipping invalid Metadata: "${R}".`);
              }
              return (0, P.shadow)(this, "metadata", O);
            }
            get markInfo() {
              let p = null;
              try {
                p = this._readMarkInfo();
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)("Unable to read mark info.");
              }
              return (0, P.shadow)(this, "markInfo", p);
            }
            _readMarkInfo() {
              const p = this._catDict.get("MarkInfo");
              if (!(p instanceof D.Dict))
                return null;
              const O = {
                Marked: !1,
                UserProperties: !1,
                Suspects: !1
              };
              for (const M in O) {
                const R = p.get(M);
                typeof R == "boolean" && (O[M] = R);
              }
              return O;
            }
            get structTreeRoot() {
              let p = null;
              try {
                p = this._readStructTreeRoot();
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)("Unable read to structTreeRoot info.");
              }
              return (0, P.shadow)(this, "structTreeRoot", p);
            }
            _readStructTreeRoot() {
              const p = this._catDict.getRaw("StructTreeRoot"), O = this.xref.fetchIfRef(p);
              if (!(O instanceof D.Dict))
                return null;
              const M = new f.StructTreeRoot(O, p);
              return M.init(), M;
            }
            get toplevelPagesDict() {
              const p = this._catDict.get("Pages");
              if (!(p instanceof D.Dict))
                throw new P.FormatError("Invalid top-level pages dictionary.");
              return (0, P.shadow)(this, "toplevelPagesDict", p);
            }
            get documentOutline() {
              let p = null;
              try {
                p = this._readDocumentOutline();
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)("Unable to read document outline.");
              }
              return (0, P.shadow)(this, "documentOutline", p);
            }
            _readDocumentOutline() {
              let p = this._catDict.get("Outlines");
              if (!(p instanceof D.Dict) || (p = p.getRaw("First"), !(p instanceof D.Ref)))
                return null;
              const O = {
                items: []
              }, M = [{
                obj: p,
                parent: O
              }], R = new D.RefSet();
              R.put(p);
              const z = this.xref, W = new Uint8ClampedArray(3);
              for (; M.length > 0; ) {
                const g = M.shift(), T = z.fetchIfRef(g.obj);
                if (T === null)
                  continue;
                if (!T.has("Title"))
                  throw new P.FormatError("Invalid outline item encountered.");
                const o = {
                  url: null,
                  dest: null,
                  action: null
                };
                a.parseDestDictionary({
                  destDict: T,
                  resultObj: o,
                  docBaseUrl: this.baseUrl,
                  docAttachments: this.attachments
                });
                const c = T.get("Title"), I = T.get("F") || 0, s = T.getArray("C"), r = T.get("Count");
                let u = W;
                Array.isArray(s) && s.length === 3 && (s[0] !== 0 || s[1] !== 0 || s[2] !== 0) && (u = V.ColorSpace.singletons.rgb.getRgb(s, 0));
                const C = {
                  action: o.action,
                  attachment: o.attachment,
                  dest: o.dest,
                  url: o.url,
                  unsafeUrl: o.unsafeUrl,
                  newWindow: o.newWindow,
                  setOCGState: o.setOCGState,
                  title: (0, P.stringToPDFString)(c),
                  color: u,
                  count: Number.isInteger(r) ? r : void 0,
                  bold: !!(I & 2),
                  italic: !!(I & 1),
                  items: []
                };
                g.parent.items.push(C), p = T.getRaw("First"), p instanceof D.Ref && !R.has(p) && (M.push({
                  obj: p,
                  parent: C
                }), R.put(p)), p = T.getRaw("Next"), p instanceof D.Ref && !R.has(p) && (M.push({
                  obj: p,
                  parent: g.parent
                }), R.put(p));
              }
              return O.items.length > 0 ? O.items : null;
            }
            get permissions() {
              let p = null;
              try {
                p = this._readPermissions();
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)("Unable to read permissions.");
              }
              return (0, P.shadow)(this, "permissions", p);
            }
            _readPermissions() {
              const p = this.xref.trailer.get("Encrypt");
              if (!(p instanceof D.Dict))
                return null;
              let O = p.get("P");
              if (typeof O != "number")
                return null;
              O += 4294967296;
              const M = [];
              for (const R in P.PermissionFlag) {
                const z = P.PermissionFlag[R];
                O & z && M.push(z);
              }
              return M;
            }
            get optionalContentConfig() {
              let p = null;
              try {
                const O = this._catDict.get("OCProperties");
                if (!O)
                  return (0, P.shadow)(this, "optionalContentConfig", null);
                const M = O.get("D");
                if (!M)
                  return (0, P.shadow)(this, "optionalContentConfig", null);
                const R = O.get("OCGs");
                if (!Array.isArray(R))
                  return (0, P.shadow)(this, "optionalContentConfig", null);
                const z = [], W = [];
                for (const g of R) {
                  if (!(g instanceof D.Ref))
                    continue;
                  W.push(g);
                  const T = this.xref.fetchIfRef(g);
                  z.push({
                    id: g.toString(),
                    name: typeof T.get("Name") == "string" ? (0, P.stringToPDFString)(T.get("Name")) : null,
                    intent: typeof T.get("Intent") == "string" ? (0, P.stringToPDFString)(T.get("Intent")) : null
                  });
                }
                p = this._readOptionalContentConfig(M, W), p.groups = z;
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)(`Unable to read optional content config: ${O}`);
              }
              return (0, P.shadow)(this, "optionalContentConfig", p);
            }
            _readOptionalContentConfig(p, O) {
              function M(o) {
                const c = [];
                if (Array.isArray(o))
                  for (const I of o)
                    I instanceof D.Ref && O.includes(I) && c.push(I.toString());
                return c;
              }
              function R(o, c = 0) {
                if (!Array.isArray(o))
                  return null;
                const I = [];
                for (const r of o) {
                  if (r instanceof D.Ref && O.includes(r)) {
                    g.put(r), I.push(r.toString());
                    continue;
                  }
                  const u = z(r, c);
                  u && I.push(u);
                }
                if (c > 0)
                  return I;
                const s = [];
                for (const r of O)
                  g.has(r) || s.push(r.toString());
                return s.length && I.push({
                  name: null,
                  order: s
                }), I;
              }
              function z(o, c) {
                if (++c > T)
                  return (0, P.warn)("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
                const I = W.fetchIfRef(o);
                if (!Array.isArray(I))
                  return null;
                const s = W.fetchIfRef(I[0]);
                if (typeof s != "string")
                  return null;
                const r = R(I.slice(1), c);
                return !r || !r.length ? null : {
                  name: (0, P.stringToPDFString)(s),
                  order: r
                };
              }
              const W = this.xref, g = new D.RefSet(), T = 10;
              return {
                name: typeof p.get("Name") == "string" ? (0, P.stringToPDFString)(p.get("Name")) : null,
                creator: typeof p.get("Creator") == "string" ? (0, P.stringToPDFString)(p.get("Creator")) : null,
                baseState: p.get("BaseState") instanceof D.Name ? p.get("BaseState").name : null,
                on: M(p.get("ON")),
                off: M(p.get("OFF")),
                order: R(p.get("Order")),
                groups: null
              };
            }
            setActualNumPages(p = null) {
              this._actualNumPages = p;
            }
            get hasActualNumPages() {
              return this._actualNumPages !== null;
            }
            get _pagesCount() {
              const p = this.toplevelPagesDict.get("Count");
              if (!Number.isInteger(p))
                throw new P.FormatError("Page count in top-level pages dictionary is not an integer.");
              return (0, P.shadow)(this, "_pagesCount", p);
            }
            get numPages() {
              return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
            }
            get destinations() {
              const p = this._readDests(), O = /* @__PURE__ */ Object.create(null);
              if (p instanceof e.NameTree)
                for (const [M, R] of p.getAll()) {
                  const z = x(R);
                  z && (O[(0, P.stringToPDFString)(M)] = z);
                }
              else
                p instanceof D.Dict && p.forEach(function(M, R) {
                  const z = x(R);
                  z && (O[M] = z);
                });
              return (0, P.shadow)(this, "destinations", O);
            }
            getDestination(p) {
              const O = this._readDests();
              if (O instanceof e.NameTree) {
                const M = x(O.get(p));
                if (M)
                  return M;
                const R = this.destinations[p];
                if (R)
                  return (0, P.warn)(`Found "${p}" at an incorrect position in the NameTree.`), R;
              } else if (O instanceof D.Dict) {
                const M = x(O.get(p));
                if (M)
                  return M;
              }
              return null;
            }
            _readDests() {
              const p = this._catDict.get("Names");
              if (p != null && p.has("Dests"))
                return new e.NameTree(p.getRaw("Dests"), this.xref);
              if (this._catDict.has("Dests"))
                return this._catDict.get("Dests");
            }
            get pageLabels() {
              let p = null;
              try {
                p = this._readPageLabels();
              } catch (O) {
                if (O instanceof n.MissingDataException)
                  throw O;
                (0, P.warn)("Unable to read page labels.");
              }
              return (0, P.shadow)(this, "pageLabels", p);
            }
            _readPageLabels() {
              const p = this._catDict.getRaw("PageLabels");
              if (!p)
                return null;
              const O = new Array(this.numPages);
              let M = null, R = "";
              const W = new e.NumberTree(p, this.xref).getAll();
              let g = "", T = 1;
              for (let o = 0, c = this.numPages; o < c; o++) {
                const I = W.get(o);
                if (I !== void 0) {
                  if (!(I instanceof D.Dict))
                    throw new P.FormatError("PageLabel is not a dictionary.");
                  if (I.has("Type") && !(0, D.isName)(I.get("Type"), "PageLabel"))
                    throw new P.FormatError("Invalid type in PageLabel dictionary.");
                  if (I.has("S")) {
                    const s = I.get("S");
                    if (!(s instanceof D.Name))
                      throw new P.FormatError("Invalid style in PageLabel dictionary.");
                    M = s.name;
                  } else
                    M = null;
                  if (I.has("P")) {
                    const s = I.get("P");
                    if (typeof s != "string")
                      throw new P.FormatError("Invalid prefix in PageLabel dictionary.");
                    R = (0, P.stringToPDFString)(s);
                  } else
                    R = "";
                  if (I.has("St")) {
                    const s = I.get("St");
                    if (!(Number.isInteger(s) && s >= 1))
                      throw new P.FormatError("Invalid start in PageLabel dictionary.");
                    T = s;
                  } else
                    T = 1;
                }
                switch (M) {
                  case "D":
                    g = T;
                    break;
                  case "R":
                  case "r":
                    g = (0, n.toRomanNumerals)(T, M === "r");
                    break;
                  case "A":
                  case "a":
                    const s = 26, C = M === "a" ? 97 : 65, d = T - 1;
                    g = String.fromCharCode(C + d % s).repeat(Math.floor(d / s) + 1);
                    break;
                  default:
                    if (M)
                      throw new P.FormatError(`Invalid style "${M}" in PageLabel dictionary.`);
                    g = "";
                }
                O[o] = R + g, T++;
              }
              return O;
            }
            get pageLayout() {
              const p = this._catDict.get("PageLayout");
              let O = "";
              if (p instanceof D.Name)
                switch (p.name) {
                  case "SinglePage":
                  case "OneColumn":
                  case "TwoColumnLeft":
                  case "TwoColumnRight":
                  case "TwoPageLeft":
                  case "TwoPageRight":
                    O = p.name;
                }
              return (0, P.shadow)(this, "pageLayout", O);
            }
            get pageMode() {
              const p = this._catDict.get("PageMode");
              let O = "UseNone";
              if (p instanceof D.Name)
                switch (p.name) {
                  case "UseNone":
                  case "UseOutlines":
                  case "UseThumbs":
                  case "FullScreen":
                  case "UseOC":
                  case "UseAttachments":
                    O = p.name;
                }
              return (0, P.shadow)(this, "pageMode", O);
            }
            get viewerPreferences() {
              const p = this._catDict.get("ViewerPreferences");
              if (!(p instanceof D.Dict))
                return (0, P.shadow)(this, "viewerPreferences", null);
              let O = null;
              for (const M of p.getKeys()) {
                const R = p.get(M);
                let z;
                switch (M) {
                  case "HideToolbar":
                  case "HideMenubar":
                  case "HideWindowUI":
                  case "FitWindow":
                  case "CenterWindow":
                  case "DisplayDocTitle":
                  case "PickTrayByPDFSize":
                    typeof R == "boolean" && (z = R);
                    break;
                  case "NonFullScreenPageMode":
                    if (R instanceof D.Name)
                      switch (R.name) {
                        case "UseNone":
                        case "UseOutlines":
                        case "UseThumbs":
                        case "UseOC":
                          z = R.name;
                          break;
                        default:
                          z = "UseNone";
                      }
                    break;
                  case "Direction":
                    if (R instanceof D.Name)
                      switch (R.name) {
                        case "L2R":
                        case "R2L":
                          z = R.name;
                          break;
                        default:
                          z = "L2R";
                      }
                    break;
                  case "ViewArea":
                  case "ViewClip":
                  case "PrintArea":
                  case "PrintClip":
                    if (R instanceof D.Name)
                      switch (R.name) {
                        case "MediaBox":
                        case "CropBox":
                        case "BleedBox":
                        case "TrimBox":
                        case "ArtBox":
                          z = R.name;
                          break;
                        default:
                          z = "CropBox";
                      }
                    break;
                  case "PrintScaling":
                    if (R instanceof D.Name)
                      switch (R.name) {
                        case "None":
                        case "AppDefault":
                          z = R.name;
                          break;
                        default:
                          z = "AppDefault";
                      }
                    break;
                  case "Duplex":
                    if (R instanceof D.Name)
                      switch (R.name) {
                        case "Simplex":
                        case "DuplexFlipShortEdge":
                        case "DuplexFlipLongEdge":
                          z = R.name;
                          break;
                        default:
                          z = "None";
                      }
                    break;
                  case "PrintPageRange":
                    Array.isArray(R) && R.length % 2 === 0 && R.every((g, T, o) => Number.isInteger(g) && g > 0 && (T === 0 || g >= o[T - 1]) && g <= this.numPages) && (z = R);
                    break;
                  case "NumCopies":
                    Number.isInteger(R) && R > 0 && (z = R);
                    break;
                  default:
                    (0, P.warn)(`Ignoring non-standard key in ViewerPreferences: ${M}.`);
                    continue;
                }
                if (z === void 0) {
                  (0, P.warn)(`Bad value, for key "${M}", in ViewerPreferences: ${R}.`);
                  continue;
                }
                O || (O = /* @__PURE__ */ Object.create(null)), O[M] = z;
              }
              return (0, P.shadow)(this, "viewerPreferences", O);
            }
            get openAction() {
              const p = this._catDict.get("OpenAction"), O = /* @__PURE__ */ Object.create(null);
              if (p instanceof D.Dict) {
                const M = new D.Dict(this.xref);
                M.set("A", p);
                const R = {
                  url: null,
                  dest: null,
                  action: null
                };
                a.parseDestDictionary({
                  destDict: M,
                  resultObj: R
                }), Array.isArray(R.dest) ? O.dest = R.dest : R.action && (O.action = R.action);
              } else
                Array.isArray(p) && (O.dest = p);
              return (0, P.shadow)(this, "openAction", (0, P.objectSize)(O) > 0 ? O : null);
            }
            get attachments() {
              const p = this._catDict.get("Names");
              let O = null;
              if (p instanceof D.Dict && p.has("EmbeddedFiles")) {
                const M = new e.NameTree(p.getRaw("EmbeddedFiles"), this.xref);
                for (const [R, z] of M.getAll()) {
                  const W = new te.FileSpec(z, this.xref);
                  O || (O = /* @__PURE__ */ Object.create(null)), O[(0, P.stringToPDFString)(R)] = W.serializable;
                }
              }
              return (0, P.shadow)(this, "attachments", O);
            }
            get xfaImages() {
              const p = this._catDict.get("Names");
              let O = null;
              if (p instanceof D.Dict && p.has("XFAImages")) {
                const M = new e.NameTree(p.getRaw("XFAImages"), this.xref);
                for (const [R, z] of M.getAll())
                  O || (O = new D.Dict(this.xref)), O.set((0, P.stringToPDFString)(R), z);
              }
              return (0, P.shadow)(this, "xfaImages", O);
            }
            _collectJavaScript() {
              const p = this._catDict.get("Names");
              let O = null;
              function M(z, W) {
                if (!(W instanceof D.Dict) || !(0, D.isName)(W.get("S"), "JavaScript"))
                  return;
                let g = W.get("JS");
                if (g instanceof t.BaseStream)
                  g = g.getString();
                else if (typeof g != "string")
                  return;
                g = (0, P.stringToPDFString)(g).replaceAll("\0", ""), g && (O || (O = /* @__PURE__ */ new Map())).set(z, g);
              }
              if (p instanceof D.Dict && p.has("JavaScript")) {
                const z = new e.NameTree(p.getRaw("JavaScript"), this.xref);
                for (const [W, g] of z.getAll())
                  M((0, P.stringToPDFString)(W), g);
              }
              const R = this._catDict.get("OpenAction");
              return R && M("OpenAction", R), O;
            }
            get jsActions() {
              const p = this._collectJavaScript();
              let O = (0, n.collectActions)(this.xref, this._catDict, P.DocumentActionEventType);
              if (p) {
                O || (O = /* @__PURE__ */ Object.create(null));
                for (const [M, R] of p)
                  M in O ? O[M].push(R) : O[M] = [R];
              }
              return (0, P.shadow)(this, "jsActions", O);
            }
            async fontFallback(p, O) {
              const M = await Promise.all(this.fontCache);
              for (const R of M)
                if (R.loadedName === p) {
                  R.fallback(O);
                  return;
                }
            }
            async cleanup(p = !1) {
              (0, l.clearGlobalCaches)(), this.globalImageCache.clear(p), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.nonBlendModesSet.clear();
              const O = await Promise.all(this.fontCache);
              for (const {
                dict: M
              } of O)
                delete M.cacheKey;
              this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
            }
            async getPageDict(p) {
              const O = [this.toplevelPagesDict], M = new D.RefSet(), R = this._catDict.getRaw("Pages");
              R instanceof D.Ref && M.put(R);
              const z = this.xref, W = this.pageKidsCountCache, g = this.pageIndexCache;
              let T = 0;
              for (; O.length; ) {
                const o = O.pop();
                if (o instanceof D.Ref) {
                  const r = W.get(o);
                  if (r >= 0 && T + r <= p) {
                    T += r;
                    continue;
                  }
                  if (M.has(o))
                    throw new P.FormatError("Pages tree contains circular reference.");
                  M.put(o);
                  const u = await z.fetchAsync(o);
                  if (u instanceof D.Dict) {
                    let C = u.getRaw("Type");
                    if (C instanceof D.Ref && (C = await z.fetchAsync(C)), (0, D.isName)(C, "Page") || !u.has("Kids")) {
                      if (W.has(o) || W.put(o, 1), g.has(o) || g.put(o, T), T === p)
                        return [u, o];
                      T++;
                      continue;
                    }
                  }
                  O.push(u);
                  continue;
                }
                if (!(o instanceof D.Dict))
                  throw new P.FormatError("Page dictionary kid reference points to wrong type of object.");
                const {
                  objId: c
                } = o;
                let I = o.getRaw("Count");
                if (I instanceof D.Ref && (I = await z.fetchAsync(I)), Number.isInteger(I) && I >= 0 && (c && !W.has(c) && W.put(c, I), T + I <= p)) {
                  T += I;
                  continue;
                }
                let s = o.getRaw("Kids");
                if (s instanceof D.Ref && (s = await z.fetchAsync(s)), !Array.isArray(s)) {
                  let r = o.getRaw("Type");
                  if (r instanceof D.Ref && (r = await z.fetchAsync(r)), (0, D.isName)(r, "Page") || !o.has("Kids")) {
                    if (T === p)
                      return [o, null];
                    T++;
                    continue;
                  }
                  throw new P.FormatError("Page dictionary kids object is not an array.");
                }
                for (let r = s.length - 1; r >= 0; r--)
                  O.push(s[r]);
              }
              throw new Error(`Page index ${p} not found.`);
            }
            async getAllPageDicts(p = !1) {
              const {
                ignoreErrors: O
              } = this.pdfManager.evaluatorOptions, M = [{
                currentNode: this.toplevelPagesDict,
                posInKids: 0
              }], R = new D.RefSet(), z = this._catDict.getRaw("Pages");
              z instanceof D.Ref && R.put(z);
              const W = /* @__PURE__ */ new Map(), g = this.xref, T = this.pageIndexCache;
              let o = 0;
              function c(s, r) {
                r && !T.has(r) && T.put(r, o), W.set(o++, [s, r]);
              }
              function I(s) {
                if (s instanceof n.XRefEntryException && !p)
                  throw s;
                p && O && o === 0 && ((0, P.warn)(`getAllPageDicts - Skipping invalid first page: "${s}".`), s = D.Dict.empty), W.set(o++, [s, null]);
              }
              for (; M.length > 0; ) {
                const s = M.at(-1), {
                  currentNode: r,
                  posInKids: u
                } = s;
                let C = r.getRaw("Kids");
                if (C instanceof D.Ref)
                  try {
                    C = await g.fetchAsync(C);
                  } catch ($) {
                    I($);
                    break;
                  }
                if (!Array.isArray(C)) {
                  I(new P.FormatError("Page dictionary kids object is not an array."));
                  break;
                }
                if (u >= C.length) {
                  M.pop();
                  continue;
                }
                const d = C[u];
                let y;
                if (d instanceof D.Ref) {
                  if (R.has(d)) {
                    I(new P.FormatError("Pages tree contains circular reference."));
                    break;
                  }
                  R.put(d);
                  try {
                    y = await g.fetchAsync(d);
                  } catch ($) {
                    I($);
                    break;
                  }
                } else
                  y = d;
                if (!(y instanceof D.Dict)) {
                  I(new P.FormatError("Page dictionary kid reference points to wrong type of object."));
                  break;
                }
                let _ = y.getRaw("Type");
                if (_ instanceof D.Ref)
                  try {
                    _ = await g.fetchAsync(_);
                  } catch ($) {
                    I($);
                    break;
                  }
                (0, D.isName)(_, "Page") || !y.has("Kids") ? c(y, d instanceof D.Ref ? d : null) : M.push({
                  currentNode: y,
                  posInKids: 0
                }), s.posInKids++;
              }
              return W;
            }
            getPageIndex(p) {
              const O = this.pageIndexCache.get(p);
              if (O !== void 0)
                return Promise.resolve(O);
              const M = this.xref;
              function R(g) {
                let T = 0, o;
                return M.fetchAsync(g).then(function(c) {
                  if ((0, D.isRefsEqual)(g, p) && !(0, D.isDict)(c, "Page") && !(c instanceof D.Dict && !c.has("Type") && c.has("Contents")))
                    throw new P.FormatError("The reference does not point to a /Page dictionary.");
                  if (!c)
                    return null;
                  if (!(c instanceof D.Dict))
                    throw new P.FormatError("Node must be a dictionary.");
                  return o = c.getRaw("Parent"), c.getAsync("Parent");
                }).then(function(c) {
                  if (!c)
                    return null;
                  if (!(c instanceof D.Dict))
                    throw new P.FormatError("Parent must be a dictionary.");
                  return c.getAsync("Kids");
                }).then(function(c) {
                  if (!c)
                    return null;
                  const I = [];
                  let s = !1;
                  for (const r of c) {
                    if (!(r instanceof D.Ref))
                      throw new P.FormatError("Kid must be a reference.");
                    if ((0, D.isRefsEqual)(r, g)) {
                      s = !0;
                      break;
                    }
                    I.push(M.fetchAsync(r).then(function(u) {
                      if (!(u instanceof D.Dict))
                        throw new P.FormatError("Kid node must be a dictionary.");
                      u.has("Count") ? T += u.get("Count") : T++;
                    }));
                  }
                  if (!s)
                    throw new P.FormatError("Kid reference not found in parent's kids.");
                  return Promise.all(I).then(function() {
                    return [T, o];
                  });
                });
              }
              let z = 0;
              const W = (g) => R(g).then((T) => {
                if (!T)
                  return this.pageIndexCache.put(p, z), z;
                const [o, c] = T;
                return z += o, W(c);
              });
              return W(p);
            }
            get baseUrl() {
              const p = this._catDict.get("URI");
              if (p instanceof D.Dict) {
                const O = p.get("Base");
                if (typeof O == "string") {
                  const M = (0, P.createValidAbsoluteUrl)(O, null, {
                    tryConvertEncoding: !0
                  });
                  if (M)
                    return (0, P.shadow)(this, "baseUrl", M.href);
                }
              }
              return (0, P.shadow)(this, "baseUrl", this.pdfManager.docBaseUrl);
            }
            static parseDestDictionary({
              destDict: p,
              resultObj: O,
              docBaseUrl: M = null,
              docAttachments: R = null
            }) {
              if (!(p instanceof D.Dict)) {
                (0, P.warn)("parseDestDictionary: `destDict` must be a dictionary.");
                return;
              }
              let z = p.get("A"), W, g;
              if (z instanceof D.Dict || (p.has("Dest") ? z = p.get("Dest") : (z = p.get("AA"), z instanceof D.Dict && (z.has("D") ? z = z.get("D") : z.has("U") && (z = z.get("U"))))), z instanceof D.Dict) {
                const T = z.get("S");
                if (!(T instanceof D.Name)) {
                  (0, P.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                  return;
                }
                const o = T.name;
                switch (o) {
                  case "ResetForm":
                    const c = z.get("Flags"), I = ((typeof c == "number" ? c : 0) & 1) === 0, s = [], r = [];
                    for (const G of z.get("Fields") || [])
                      G instanceof D.Ref ? r.push(G.toString()) : typeof G == "string" && s.push((0, P.stringToPDFString)(G));
                    O.resetForm = {
                      fields: s,
                      refs: r,
                      include: I
                    };
                    break;
                  case "URI":
                    W = z.get("URI"), W instanceof D.Name && (W = "/" + W.name);
                    break;
                  case "GoTo":
                    g = z.get("D");
                    break;
                  case "Launch":
                  case "GoToR":
                    const u = z.get("F");
                    u instanceof D.Dict ? W = u.get("F") || null : typeof u == "string" && (W = u);
                    let C = z.get("D");
                    if (C && (C instanceof D.Name && (C = C.name), typeof W == "string")) {
                      const G = W.split("#")[0];
                      typeof C == "string" ? W = G + "#" + C : Array.isArray(C) && (W = G + "#" + JSON.stringify(C));
                    }
                    const d = z.get("NewWindow");
                    typeof d == "boolean" && (O.newWindow = d);
                    break;
                  case "GoToE":
                    const y = z.get("T");
                    let _;
                    if (R && y instanceof D.Dict) {
                      const G = y.get("R"), J = y.get("N");
                      (0, D.isName)(G, "C") && typeof J == "string" && (_ = R[(0, P.stringToPDFString)(J)]);
                    }
                    _ ? O.attachment = _ : (0, P.warn)('parseDestDictionary - unimplemented "GoToE" action.');
                    break;
                  case "Named":
                    const $ = z.get("N");
                    $ instanceof D.Name && (O.action = $.name);
                    break;
                  case "SetOCGState":
                    const S = z.get("State"), v = z.get("PreserveRB");
                    if (!Array.isArray(S) || S.length === 0)
                      break;
                    const m = [];
                    for (const G of S)
                      if (G instanceof D.Name)
                        switch (G.name) {
                          case "ON":
                          case "OFF":
                          case "Toggle":
                            m.push(G.name);
                            break;
                        }
                      else
                        G instanceof D.Ref && m.push(G.toString());
                    if (m.length !== S.length)
                      break;
                    O.setOCGState = {
                      state: m,
                      preserveRB: typeof v == "boolean" ? v : !0
                    };
                    break;
                  case "JavaScript":
                    const h = z.get("JS");
                    let A;
                    h instanceof t.BaseStream ? A = h.getString() : typeof h == "string" && (A = h);
                    const j = A && (0, n.recoverJsURL)((0, P.stringToPDFString)(A));
                    if (j) {
                      W = j.url, O.newWindow = j.newWindow;
                      break;
                    }
                  default:
                    if (o === "JavaScript" || o === "SubmitForm")
                      break;
                    (0, P.warn)(`parseDestDictionary - unsupported action: "${o}".`);
                    break;
                }
              } else
                p.has("Dest") && (g = p.get("Dest"));
              if (typeof W == "string") {
                const T = (0, P.createValidAbsoluteUrl)(W, M, {
                  addDefaultProtocol: !0,
                  tryConvertEncoding: !0
                });
                T && (O.url = T.href), O.unsafeUrl = W;
              }
              g && (g instanceof D.Name && (g = g.name), typeof g == "string" ? O.dest = (0, P.stringToPDFString)(g) : Array.isArray(g) && (O.dest = g));
            }
          }
          b.Catalog = a;
        },
        /* 67 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.NumberTree = b.NameTree = void 0;
          var n = ce(4), P = ce(2);
          class D {
            constructor(V, te, E) {
              this.constructor === D && (0, P.unreachable)("Cannot initialize NameOrNumberTree."), this.root = V, this.xref = te, this._type = E;
            }
            getAll() {
              const V = /* @__PURE__ */ new Map();
              if (!this.root)
                return V;
              const te = this.xref, E = new n.RefSet();
              E.put(this.root);
              const F = [this.root];
              for (; F.length > 0; ) {
                const f = te.fetchIfRef(F.shift());
                if (!(f instanceof n.Dict))
                  continue;
                if (f.has("Kids")) {
                  const a = f.get("Kids");
                  if (!Array.isArray(a))
                    continue;
                  for (const N of a) {
                    if (E.has(N))
                      throw new P.FormatError(`Duplicate entry in "${this._type}" tree.`);
                    F.push(N), E.put(N);
                  }
                  continue;
                }
                const x = f.get(this._type);
                if (Array.isArray(x))
                  for (let a = 0, N = x.length; a < N; a += 2)
                    V.set(te.fetchIfRef(x[a]), te.fetchIfRef(x[a + 1]));
              }
              return V;
            }
            get(V) {
              if (!this.root)
                return null;
              const te = this.xref;
              let E = te.fetchIfRef(this.root), F = 0;
              const f = 10;
              for (; E.has("Kids"); ) {
                if (++F > f)
                  return (0, P.warn)(`Search depth limit reached for "${this._type}" tree.`), null;
                const a = E.get("Kids");
                if (!Array.isArray(a))
                  return null;
                let N = 0, p = a.length - 1;
                for (; N <= p; ) {
                  const O = N + p >> 1, M = te.fetchIfRef(a[O]), R = M.get("Limits");
                  if (V < te.fetchIfRef(R[0]))
                    p = O - 1;
                  else if (V > te.fetchIfRef(R[1]))
                    N = O + 1;
                  else {
                    E = M;
                    break;
                  }
                }
                if (N > p)
                  return null;
              }
              const x = E.get(this._type);
              if (Array.isArray(x)) {
                let a = 0, N = x.length - 2;
                for (; a <= N; ) {
                  const p = a + N >> 1, O = p + (p & 1), M = te.fetchIfRef(x[O]);
                  if (V < M)
                    N = O - 2;
                  else if (V > M)
                    a = O + 2;
                  else
                    return te.fetchIfRef(x[O + 1]);
                }
              }
              return null;
            }
          }
          class e extends D {
            constructor(V, te) {
              super(V, te, "Names");
            }
          }
          b.NameTree = e;
          class t extends D {
            constructor(V, te) {
              super(V, te, "Nums");
            }
          }
          b.NumberTree = t;
        },
        /* 68 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.clearGlobalCaches = e;
          var n = ce(50), P = ce(4), D = ce(40);
          function e() {
            (0, n.clearPatternCaches)(), (0, P.clearPrimitiveCaches)(), (0, D.clearUnicodeCaches)();
          }
        },
        /* 69 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.FileSpec = void 0;
          var n = ce(2), P = ce(5), D = ce(4);
          function e(l) {
            return l.has("UF") ? l.get("UF") : l.has("F") ? l.get("F") : l.has("Unix") ? l.get("Unix") : l.has("Mac") ? l.get("Mac") : l.has("DOS") ? l.get("DOS") : null;
          }
          class t {
            constructor(V, te) {
              V instanceof D.Dict && (this.xref = te, this.root = V, V.has("FS") && (this.fs = V.get("FS")), this.description = V.has("Desc") ? (0, n.stringToPDFString)(V.get("Desc")) : "", V.has("RF") && (0, n.warn)("Related file specifications are not supported"), this.contentAvailable = !0, V.has("EF") || (this.contentAvailable = !1, (0, n.warn)("Non-embedded file specifications are not supported")));
            }
            get filename() {
              if (!this._filename && this.root) {
                const V = e(this.root) || "unnamed";
                this._filename = (0, n.stringToPDFString)(V).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/");
              }
              return this._filename;
            }
            get content() {
              if (!this.contentAvailable)
                return null;
              !this.contentRef && this.root && (this.contentRef = e(this.root.get("EF")));
              let V = null;
              if (this.contentRef) {
                const te = this.xref.fetchIfRef(this.contentRef);
                te instanceof P.BaseStream ? V = te.getBytes() : (0, n.warn)("Embedded file specification points to non-existing/invalid content");
              } else
                (0, n.warn)("Embedded file specification does not have a content");
              return V;
            }
            get serializable() {
              return {
                filename: this.filename,
                content: this.content
              };
            }
          }
          b.FileSpec = t;
        },
        /* 70 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.MetadataParser = void 0;
          var n = ce(71);
          class P {
            constructor(e) {
              e = this._repair(e);
              const l = new n.SimpleXMLParser({
                lowerCaseName: !0
              }).parseFromString(e);
              this._metadataMap = /* @__PURE__ */ new Map(), this._data = e, l && this._parse(l);
            }
            _repair(e) {
              return e.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(t, l) {
                const V = l.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(E, F, f, x) {
                  return String.fromCharCode(F * 64 + f * 8 + x * 1);
                }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(E, F) {
                  switch (F) {
                    case "amp":
                      return "&";
                    case "apos":
                      return "'";
                    case "gt":
                      return ">";
                    case "lt":
                      return "<";
                    case "quot":
                      return '"';
                  }
                  throw new Error(`_repair: ${F} isn't defined.`);
                }), te = [">"];
                for (let E = 0, F = V.length; E < F; E += 2) {
                  const f = V.charCodeAt(E) * 256 + V.charCodeAt(E + 1);
                  f >= 32 && f < 127 && f !== 60 && f !== 62 && f !== 38 ? te.push(String.fromCharCode(f)) : te.push("&#x" + (65536 + f).toString(16).substring(1) + ";");
                }
                return te.join("");
              });
            }
            _getSequence(e) {
              const t = e.nodeName;
              return t !== "rdf:bag" && t !== "rdf:seq" && t !== "rdf:alt" ? null : e.childNodes.filter((l) => l.nodeName === "rdf:li");
            }
            _parseArray(e) {
              if (!e.hasChildNodes())
                return;
              const [t] = e.childNodes, l = this._getSequence(t) || [];
              this._metadataMap.set(e.nodeName, l.map((V) => V.textContent.trim()));
            }
            _parse(e) {
              let t = e.documentElement;
              if (t.nodeName !== "rdf:rdf")
                for (t = t.firstChild; t && t.nodeName !== "rdf:rdf"; )
                  t = t.nextSibling;
              if (!(!t || t.nodeName !== "rdf:rdf" || !t.hasChildNodes())) {
                for (const l of t.childNodes)
                  if (l.nodeName === "rdf:description")
                    for (const V of l.childNodes) {
                      const te = V.nodeName;
                      switch (te) {
                        case "#text":
                          continue;
                        case "dc:creator":
                        case "dc:subject":
                          this._parseArray(V);
                          continue;
                      }
                      this._metadataMap.set(te, V.textContent.trim());
                    }
              }
            }
            get serializable() {
              return {
                parsedData: this._metadataMap,
                rawData: this._data
              };
            }
          }
          b.MetadataParser = P;
        },
        /* 71 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XMLParserErrorCode = b.XMLParserBase = b.SimpleXMLParser = b.SimpleDOMNode = void 0;
          var n = ce(3);
          const P = {
            NoError: 0,
            EndOfDocument: -1,
            UnterminatedCdat: -2,
            UnterminatedXmlDeclaration: -3,
            UnterminatedDoctypeDeclaration: -4,
            UnterminatedComment: -5,
            MalformedElement: -6,
            OutOfMemory: -7,
            UnterminatedAttributeValue: -8,
            UnterminatedElement: -9,
            ElementNeverBegun: -10
          };
          b.XMLParserErrorCode = P;
          function D(te, E) {
            const F = te[E];
            return F === " " || F === `
` || F === "\r" || F === "	";
          }
          function e(te) {
            for (let E = 0, F = te.length; E < F; E++)
              if (!D(te, E))
                return !1;
            return !0;
          }
          class t {
            _resolveEntities(E) {
              return E.replaceAll(/&([^;]+);/g, (F, f) => {
                if (f.substring(0, 2) === "#x")
                  return String.fromCodePoint(parseInt(f.substring(2), 16));
                if (f.substring(0, 1) === "#")
                  return String.fromCodePoint(parseInt(f.substring(1), 10));
                switch (f) {
                  case "lt":
                    return "<";
                  case "gt":
                    return ">";
                  case "amp":
                    return "&";
                  case "quot":
                    return '"';
                  case "apos":
                    return "'";
                }
                return this.onResolveEntity(f);
              });
            }
            _parseContent(E, F) {
              const f = [];
              let x = F;
              function a() {
                for (; x < E.length && D(E, x); )
                  ++x;
              }
              for (; x < E.length && !D(E, x) && E[x] !== ">" && E[x] !== "/"; )
                ++x;
              const N = E.substring(F, x);
              for (a(); x < E.length && E[x] !== ">" && E[x] !== "/" && E[x] !== "?"; ) {
                a();
                let p = "", O = "";
                for (; x < E.length && !D(E, x) && E[x] !== "="; )
                  p += E[x], ++x;
                if (a(), E[x] !== "=")
                  return null;
                ++x, a();
                const M = E[x];
                if (M !== '"' && M !== "'")
                  return null;
                const R = E.indexOf(M, ++x);
                if (R < 0)
                  return null;
                O = E.substring(x, R), f.push({
                  name: p,
                  value: this._resolveEntities(O)
                }), x = R + 1, a();
              }
              return {
                name: N,
                attributes: f,
                parsed: x - F
              };
            }
            _parseProcessingInstruction(E, F) {
              let f = F;
              function x() {
                for (; f < E.length && D(E, f); )
                  ++f;
              }
              for (; f < E.length && !D(E, f) && E[f] !== ">" && E[f] !== "?" && E[f] !== "/"; )
                ++f;
              const a = E.substring(F, f);
              x();
              const N = f;
              for (; f < E.length && (E[f] !== "?" || E[f + 1] !== ">"); )
                ++f;
              const p = E.substring(N, f);
              return {
                name: a,
                value: p,
                parsed: f - F
              };
            }
            parseXml(E) {
              let F = 0;
              for (; F < E.length; ) {
                const f = E[F];
                let x = F;
                if (f === "<") {
                  ++x;
                  const a = E[x];
                  let N;
                  switch (a) {
                    case "/":
                      if (++x, N = E.indexOf(">", x), N < 0) {
                        this.onError(P.UnterminatedElement);
                        return;
                      }
                      this.onEndElement(E.substring(x, N)), x = N + 1;
                      break;
                    case "?":
                      ++x;
                      const p = this._parseProcessingInstruction(E, x);
                      if (E.substring(x + p.parsed, x + p.parsed + 2) !== "?>") {
                        this.onError(P.UnterminatedXmlDeclaration);
                        return;
                      }
                      this.onPi(p.name, p.value), x += p.parsed + 2;
                      break;
                    case "!":
                      if (E.substring(x + 1, x + 3) === "--") {
                        if (N = E.indexOf("-->", x + 3), N < 0) {
                          this.onError(P.UnterminatedComment);
                          return;
                        }
                        this.onComment(E.substring(x + 3, N)), x = N + 3;
                      } else if (E.substring(x + 1, x + 8) === "[CDATA[") {
                        if (N = E.indexOf("]]>", x + 8), N < 0) {
                          this.onError(P.UnterminatedCdat);
                          return;
                        }
                        this.onCdata(E.substring(x + 8, N)), x = N + 3;
                      } else if (E.substring(x + 1, x + 8) === "DOCTYPE") {
                        const R = E.indexOf("[", x + 8);
                        let z = !1;
                        if (N = E.indexOf(">", x + 8), N < 0) {
                          this.onError(P.UnterminatedDoctypeDeclaration);
                          return;
                        }
                        if (R > 0 && N > R) {
                          if (N = E.indexOf("]>", x + 8), N < 0) {
                            this.onError(P.UnterminatedDoctypeDeclaration);
                            return;
                          }
                          z = !0;
                        }
                        const W = E.substring(x + 8, N + (z ? 1 : 0));
                        this.onDoctype(W), x = N + (z ? 2 : 1);
                      } else {
                        this.onError(P.MalformedElement);
                        return;
                      }
                      break;
                    default:
                      const O = this._parseContent(E, x);
                      if (O === null) {
                        this.onError(P.MalformedElement);
                        return;
                      }
                      let M = !1;
                      if (E.substring(x + O.parsed, x + O.parsed + 2) === "/>")
                        M = !0;
                      else if (E.substring(x + O.parsed, x + O.parsed + 1) !== ">") {
                        this.onError(P.UnterminatedElement);
                        return;
                      }
                      this.onBeginElement(O.name, O.attributes, M), x += O.parsed + (M ? 2 : 1);
                      break;
                  }
                } else {
                  for (; x < E.length && E[x] !== "<"; )
                    x++;
                  const a = E.substring(F, x);
                  this.onText(this._resolveEntities(a));
                }
                F = x;
              }
            }
            onResolveEntity(E) {
              return `&${E};`;
            }
            onPi(E, F) {
            }
            onComment(E) {
            }
            onCdata(E) {
            }
            onDoctype(E) {
            }
            onText(E) {
            }
            onBeginElement(E, F, f) {
            }
            onEndElement(E) {
            }
            onError(E) {
            }
          }
          b.XMLParserBase = t;
          class l {
            constructor(E, F) {
              this.nodeName = E, this.nodeValue = F, Object.defineProperty(this, "parentNode", {
                value: null,
                writable: !0
              });
            }
            get firstChild() {
              var E;
              return (E = this.childNodes) == null ? void 0 : E[0];
            }
            get nextSibling() {
              const E = this.parentNode.childNodes;
              if (!E)
                return;
              const F = E.indexOf(this);
              if (F !== -1)
                return E[F + 1];
            }
            get textContent() {
              return this.childNodes ? this.childNodes.map(function(E) {
                return E.textContent;
              }).join("") : this.nodeValue || "";
            }
            get children() {
              return this.childNodes || [];
            }
            hasChildNodes() {
              var E;
              return ((E = this.childNodes) == null ? void 0 : E.length) > 0;
            }
            searchNode(E, F) {
              var N;
              if (F >= E.length)
                return this;
              const f = E[F];
              if (f.name.startsWith("#") && F < E.length - 1)
                return this.searchNode(E, F + 1);
              const x = [];
              let a = this;
              for (; ; ) {
                if (f.name === a.nodeName)
                  if (f.pos === 0) {
                    const p = a.searchNode(E, F + 1);
                    if (p !== null)
                      return p;
                  } else {
                    if (x.length === 0)
                      return null;
                    {
                      const [p] = x.pop();
                      let O = 0;
                      for (const M of p.childNodes)
                        if (f.name === M.nodeName) {
                          if (O === f.pos)
                            return M.searchNode(E, F + 1);
                          O++;
                        }
                      return a.searchNode(E, F + 1);
                    }
                  }
                if (((N = a.childNodes) == null ? void 0 : N.length) > 0)
                  x.push([a, 0]), a = a.childNodes[0];
                else {
                  if (x.length === 0)
                    return null;
                  for (; x.length !== 0; ) {
                    const [p, O] = x.pop(), M = O + 1;
                    if (M < p.childNodes.length) {
                      x.push([p, M]), a = p.childNodes[M];
                      break;
                    }
                  }
                  if (x.length === 0)
                    return null;
                }
              }
            }
            dump(E) {
              if (this.nodeName === "#text") {
                E.push((0, n.encodeToXmlString)(this.nodeValue));
                return;
              }
              if (E.push(`<${this.nodeName}`), this.attributes)
                for (const F of this.attributes)
                  E.push(` ${F.name}="${(0, n.encodeToXmlString)(F.value)}"`);
              if (this.hasChildNodes()) {
                E.push(">");
                for (const F of this.childNodes)
                  F.dump(E);
                E.push(`</${this.nodeName}>`);
              } else
                this.nodeValue ? E.push(`>${(0, n.encodeToXmlString)(this.nodeValue)}</${this.nodeName}>`) : E.push("/>");
            }
          }
          b.SimpleDOMNode = l;
          class V extends t {
            constructor({
              hasAttributes: E = !1,
              lowerCaseName: F = !1
            }) {
              super(), this._currentFragment = null, this._stack = null, this._errorCode = P.NoError, this._hasAttributes = E, this._lowerCaseName = F;
            }
            parseFromString(E) {
              if (this._currentFragment = [], this._stack = [], this._errorCode = P.NoError, this.parseXml(E), this._errorCode !== P.NoError)
                return;
              const [F] = this._currentFragment;
              if (F)
                return {
                  documentElement: F
                };
            }
            onText(E) {
              if (e(E))
                return;
              const F = new l("#text", E);
              this._currentFragment.push(F);
            }
            onCdata(E) {
              const F = new l("#text", E);
              this._currentFragment.push(F);
            }
            onBeginElement(E, F, f) {
              this._lowerCaseName && (E = E.toLowerCase());
              const x = new l(E);
              x.childNodes = [], this._hasAttributes && (x.attributes = F), this._currentFragment.push(x), !f && (this._stack.push(this._currentFragment), this._currentFragment = x.childNodes);
            }
            onEndElement(E) {
              this._currentFragment = this._stack.pop() || [];
              const F = this._currentFragment.at(-1);
              if (!F)
                return null;
              for (const f of F.childNodes)
                f.parentNode = F;
              return F;
            }
            onError(E) {
              this._errorCode = E;
            }
          }
          b.SimpleXMLParser = V;
        },
        /* 72 */
        /***/
        (Re, b, ce) => {
          var f, aa, a, Wn, p, ia, M, sa;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.StructTreeRoot = b.StructTreePage = void 0;
          var n = ce(2), P = ce(4), D = ce(67), e = ce(73);
          const t = 40, l = {
            PAGE_CONTENT: 1,
            STREAM_CONTENT: 2,
            OBJECT: 3,
            ANNOTATION: 4,
            ELEMENT: 5
          }, z = class z {
            constructor(g, T) {
              At(this, f);
              this.dict = g, this.ref = T instanceof P.Ref ? T : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
            }
            init() {
              this.readRoleMap();
            }
            addAnnotationIdToPage(g, T) {
              it(this, f, aa).call(this, g, T, l.ANNOTATION);
            }
            readRoleMap() {
              const g = this.dict.get("RoleMap");
              g instanceof P.Dict && g.forEach((T, o) => {
                o instanceof P.Name && this.roleMap.set(T, o.name);
              });
            }
            static async canCreateStructureTree({
              catalogRef: g,
              pdfManager: T,
              newAnnotationsByPage: o
            }) {
              var s;
              if (!(g instanceof P.Ref))
                return (0, n.warn)("Cannot save the struct tree: no catalog reference."), !1;
              let c = 0, I = !0;
              for (const [r, u] of o) {
                const {
                  ref: C
                } = await T.getPage(r);
                if (!(C instanceof P.Ref)) {
                  (0, n.warn)(`Cannot save the struct tree: page ${r} has no ref.`), I = !0;
                  break;
                }
                for (const d of u)
                  (s = d.accessibilityData) != null && s.type && (d.parentTreeId = c++, I = !1);
              }
              if (I) {
                for (const r of o.values())
                  for (const u of r)
                    delete u.parentTreeId;
                return !1;
              }
              return !0;
            }
            static async createStructureTree({
              newAnnotationsByPage: g,
              xref: T,
              catalogRef: o,
              pdfManager: c,
              newRefs: I
            }) {
              const s = c.catalog.cloneDict(), r = T.getNewTemporaryRef();
              s.set("StructTreeRoot", r);
              const u = [];
              await (0, e.writeObject)(o, s, u, T), I.push({
                ref: o,
                data: u.join("")
              });
              const C = new P.Dict(T);
              C.set("Type", P.Name.get("StructTreeRoot"));
              const d = T.getNewTemporaryRef();
              C.set("ParentTree", d);
              const y = [];
              C.set("K", y);
              const _ = new P.Dict(T), $ = [];
              _.set("Nums", $);
              const S = await it(this, a, Wn).call(this, {
                newAnnotationsByPage: g,
                structTreeRootRef: r,
                kids: y,
                nums: $,
                xref: T,
                pdfManager: c,
                newRefs: I,
                buffer: u
              });
              C.set("ParentTreeNextKey", S), u.length = 0, await (0, e.writeObject)(d, _, u, T), I.push({
                ref: d,
                data: u.join("")
              }), u.length = 0, await (0, e.writeObject)(r, C, u, T), I.push({
                ref: r,
                data: u.join("")
              });
            }
            async canUpdateStructTree({
              pdfManager: g,
              newAnnotationsByPage: T
            }) {
              var u, C;
              if (!this.ref)
                return (0, n.warn)("Cannot update the struct tree: no root reference."), !1;
              let o = this.dict.get("ParentTreeNextKey");
              if (!Number.isInteger(o) || o < 0)
                return (0, n.warn)("Cannot update the struct tree: invalid next key."), !1;
              const c = this.dict.get("ParentTree");
              if (!(c instanceof P.Dict))
                return (0, n.warn)("Cannot update the struct tree: ParentTree isn't a dict."), !1;
              const I = c.get("Nums");
              if (!Array.isArray(I))
                return (0, n.warn)("Cannot update the struct tree: nums isn't an array."), !1;
              const {
                numPages: s
              } = g.catalog;
              for (const d of T.keys()) {
                const {
                  pageDict: y,
                  ref: _
                } = await g.getPage(d);
                if (!(_ instanceof P.Ref))
                  return (0, n.warn)(`Cannot save the struct tree: page ${d} has no ref.`), !1;
                const $ = y.get("StructParents");
                if (!Number.isInteger($) || $ < 0 || $ >= s)
                  return (0, n.warn)(`Cannot save the struct tree: page ${d} has no id.`), !1;
              }
              let r = !0;
              for (const [d, y] of T) {
                const {
                  pageDict: _
                } = await g.getPage(d);
                it(u = z, p, ia).call(u, {
                  elements: y,
                  xref: this.dict.xref,
                  pageDict: _,
                  parentTree: c
                });
                for (const $ of y)
                  (C = $.accessibilityData) != null && C.type && ($.parentTreeId = o++, r = !1);
              }
              if (r) {
                for (const d of T.values())
                  for (const y of d)
                    delete y.parentTreeId, delete y.structTreeParent;
                return !1;
              }
              return !0;
            }
            async updateStructureTree({
              newAnnotationsByPage: g,
              pdfManager: T,
              newRefs: o
            }) {
              var v;
              const c = this.dict.xref, I = this.dict.clone(), s = this.ref;
              let r = I.getRaw("ParentTree"), u;
              r instanceof P.Ref ? u = c.fetch(r) : (u = r, r = c.getNewTemporaryRef(), I.set("ParentTree", r)), u = u.clone();
              let C = u.getRaw("Nums"), d = null;
              C instanceof P.Ref && (d = C, C = c.fetch(d)), C = C.slice(), d || u.set("Nums", C);
              let y = I.getRaw("K"), _ = null;
              y instanceof P.Ref ? (_ = y, y = c.fetch(_)) : (_ = c.getNewTemporaryRef(), I.set("K", _)), y = Array.isArray(y) ? y.slice() : [y];
              const $ = [], S = await it(v = z, a, Wn).call(v, {
                newAnnotationsByPage: g,
                structTreeRootRef: s,
                kids: y,
                nums: C,
                xref: c,
                pdfManager: T,
                newRefs: o,
                buffer: $
              });
              I.set("ParentTreeNextKey", S), $.length = 0, await (0, e.writeObject)(_, y, $, c), o.push({
                ref: _,
                data: $.join("")
              }), d && ($.length = 0, await (0, e.writeObject)(d, C, $, c), o.push({
                ref: d,
                data: $.join("")
              })), $.length = 0, await (0, e.writeObject)(r, u, $, c), o.push({
                ref: r,
                data: $.join("")
              }), $.length = 0, await (0, e.writeObject)(s, I, $, c), o.push({
                ref: s,
                data: $.join("")
              });
            }
          };
          f = new WeakSet(), aa = function(g, T, o) {
            if (!(g instanceof P.Ref) || T < 0)
              return;
            this.structParentIds || (this.structParentIds = new P.RefSetCache());
            let c = this.structParentIds.get(g);
            c || (c = [], this.structParentIds.put(g, c)), c.push([T, o]);
          }, a = new WeakSet(), Wn = async function({
            newAnnotationsByPage: g,
            structTreeRootRef: T,
            kids: o,
            nums: c,
            xref: I,
            pdfManager: s,
            newRefs: r,
            buffer: u
          }) {
            const C = P.Name.get("OBJR");
            let d = -1 / 0;
            for (const [y, _] of g) {
              const {
                ref: $
              } = await s.getPage(y);
              for (const {
                accessibilityData: {
                  type: S,
                  title: v,
                  lang: m,
                  alt: h,
                  expanded: A,
                  actualText: j
                },
                ref: G,
                parentTreeId: J,
                structTreeParent: oe
              } of _) {
                d = Math.max(d, J);
                const q = I.getNewTemporaryRef(), re = new P.Dict(I);
                re.set("S", P.Name.get(S)), v && re.set("T", v), m && re.set("Lang", m), h && re.set("Alt", h), A && re.set("E", A), j && re.set("ActualText", j), oe ? await it(this, M, sa).call(this, {
                  structTreeParent: oe,
                  tagDict: re,
                  newTagRef: q,
                  fallbackRef: T,
                  xref: I,
                  newRefs: r,
                  buffer: u
                }) : re.set("P", T);
                const K = new P.Dict(I);
                re.set("K", K), K.set("Type", C), K.set("Pg", $), K.set("Obj", G), u.length = 0, await (0, e.writeObject)(q, re, u, I), r.push({
                  ref: q,
                  data: u.join("")
                }), c.push(J, q), o.push(q);
              }
            }
            return d + 1;
          }, p = new WeakSet(), ia = function({
            elements: g,
            xref: T,
            pageDict: o,
            parentTree: c
          }) {
            const I = /* @__PURE__ */ new Map();
            for (const d of g)
              if (d.structTreeParentId) {
                const y = parseInt(d.structTreeParentId.split("_mc")[1], 10);
                I.set(y, d);
              }
            const s = o.get("StructParents"), u = new D.NumberTree(c, T).get(s);
            if (!Array.isArray(u))
              return;
            const C = (d, y, _) => {
              const $ = I.get(d);
              if ($) {
                const S = y.getRaw("P"), v = T.fetchIfRef(S);
                return S instanceof P.Ref && v instanceof P.Dict && ($.structTreeParent = {
                  ref: _,
                  dict: y
                }), !0;
              }
              return !1;
            };
            for (const d of u) {
              if (!(d instanceof P.Ref))
                continue;
              const y = T.fetch(d), _ = y.get("K");
              if (Number.isInteger(_)) {
                C(_, y, d);
                continue;
              }
              if (Array.isArray(_)) {
                for (let $ of _)
                  if ($ = T.fetchIfRef($), Number.isInteger($) && C($, y, d))
                    break;
              }
            }
          }, M = new WeakSet(), sa = async function({
            structTreeParent: {
              ref: g,
              dict: T
            },
            tagDict: o,
            newTagRef: c,
            fallbackRef: I,
            xref: s,
            newRefs: r,
            buffer: u
          }) {
            const C = T.getRaw("P");
            let d = s.fetchIfRef(C);
            o.set("P", C);
            let y = !1, _, $ = d.getRaw("K");
            if ($ instanceof P.Ref ? _ = s.fetch($) : (_ = $, $ = s.getNewTemporaryRef(), d = d.clone(), d.set("K", $), y = !0), Array.isArray(_)) {
              const S = _.indexOf(g);
              if (S >= 0)
                _ = _.slice(), _.splice(S + 1, 0, c);
              else {
                (0, n.warn)("Cannot update the struct tree: parent kid not found."), o.set("P", I);
                return;
              }
            } else
              _ instanceof P.Dict && (_ = [$, c], $ = s.getNewTemporaryRef(), d.set("K", $), y = !0);
            u.length = 0, await (0, e.writeObject)($, _, u, s), r.push({
              ref: $,
              data: u.join("")
            }), y && (u.length = 0, await (0, e.writeObject)(C, d, u, s), r.push({
              ref: C,
              data: u.join("")
            }));
          }, At(z, a), At(z, p), At(z, M);
          let V = z;
          b.StructTreeRoot = V;
          class te {
            constructor(g, T) {
              this.tree = g, this.dict = T, this.kids = [], this.parseKids();
            }
            get role() {
              const g = this.dict.get("S"), T = g instanceof P.Name ? g.name : "", {
                root: o
              } = this.tree;
              return o.roleMap.has(T) ? o.roleMap.get(T) : T;
            }
            parseKids() {
              let g = null;
              const T = this.dict.getRaw("Pg");
              T instanceof P.Ref && (g = T.toString());
              const o = this.dict.get("K");
              if (Array.isArray(o))
                for (const c of o) {
                  const I = this.parseKid(g, c);
                  I && this.kids.push(I);
                }
              else {
                const c = this.parseKid(g, o);
                c && this.kids.push(c);
              }
            }
            parseKid(g, T) {
              if (Number.isInteger(T))
                return this.tree.pageDict.objId !== g ? null : new E({
                  type: l.PAGE_CONTENT,
                  mcid: T,
                  pageObjId: g
                });
              let o = null;
              if (T instanceof P.Ref ? o = this.dict.xref.fetch(T) : T instanceof P.Dict && (o = T), !o)
                return null;
              const c = o.getRaw("Pg");
              c instanceof P.Ref && (g = c.toString());
              const I = o.get("Type") instanceof P.Name ? o.get("Type").name : null;
              if (I === "MCR") {
                if (this.tree.pageDict.objId !== g)
                  return null;
                const s = o.getRaw("Stm");
                return new E({
                  type: l.STREAM_CONTENT,
                  refObjId: s instanceof P.Ref ? s.toString() : null,
                  pageObjId: g,
                  mcid: o.get("MCID")
                });
              }
              if (I === "OBJR") {
                if (this.tree.pageDict.objId !== g)
                  return null;
                const s = o.getRaw("Obj");
                return new E({
                  type: l.OBJECT,
                  refObjId: s instanceof P.Ref ? s.toString() : null,
                  pageObjId: g
                });
              }
              return new E({
                type: l.ELEMENT,
                dict: o
              });
            }
          }
          class E {
            constructor({
              type: g,
              dict: T = null,
              mcid: o = null,
              pageObjId: c = null,
              refObjId: I = null
            }) {
              this.type = g, this.dict = T, this.mcid = o, this.pageObjId = c, this.refObjId = I, this.parentNode = null;
            }
          }
          class F {
            constructor(g, T) {
              this.root = g, this.rootDict = g ? g.dict : null, this.pageDict = T, this.nodes = [];
            }
            parse(g) {
              var r, u;
              if (!this.root || !this.rootDict)
                return;
              const T = this.rootDict.get("ParentTree");
              if (!T)
                return;
              const o = this.pageDict.get("StructParents"), c = g instanceof P.Ref && ((r = this.root.structParentIds) == null ? void 0 : r.get(g));
              if (!Number.isInteger(o) && !c)
                return;
              const I = /* @__PURE__ */ new Map(), s = new D.NumberTree(T, this.rootDict.xref);
              if (Number.isInteger(o)) {
                const C = s.get(o);
                if (Array.isArray(C))
                  for (const d of C)
                    d instanceof P.Ref && this.addNode(this.rootDict.xref.fetch(d), I);
              }
              if (c)
                for (const [C, d] of c) {
                  const y = s.get(C);
                  if (y) {
                    const _ = this.addNode(this.rootDict.xref.fetchIfRef(y), I);
                    ((u = _ == null ? void 0 : _.kids) == null ? void 0 : u.length) === 1 && _.kids[0].type === l.OBJECT && (_.kids[0].type = d);
                  }
                }
            }
            addNode(g, T, o = 0) {
              if (o > t)
                return (0, n.warn)("StructTree MAX_DEPTH reached."), null;
              if (T.has(g))
                return T.get(g);
              const c = new te(this, g);
              T.set(g, c);
              const I = g.get("P");
              if (!I || (0, P.isName)(I.get("Type"), "StructTreeRoot"))
                return this.addTopLevelNode(g, c) || T.delete(g), c;
              const s = this.addNode(I, T, o + 1);
              if (!s)
                return c;
              let r = !1;
              for (const u of s.kids)
                u.type === l.ELEMENT && u.dict === g && (u.parentNode = c, r = !0);
              return r || T.delete(g), c;
            }
            addTopLevelNode(g, T) {
              const o = this.rootDict.get("K");
              if (!o)
                return !1;
              if (o instanceof P.Dict)
                return o.objId !== g.objId ? !1 : (this.nodes[0] = T, !0);
              if (!Array.isArray(o))
                return !0;
              let c = !1;
              for (let I = 0; I < o.length; I++) {
                const s = o[I];
                (s == null ? void 0 : s.toString()) === g.objId && (this.nodes[I] = T, c = !0);
              }
              return c;
            }
            get serializable() {
              function g(o, c, I = 0) {
                if (I > t) {
                  (0, n.warn)("StructTree too deep to be fully serialized.");
                  return;
                }
                const s = /* @__PURE__ */ Object.create(null);
                s.role = o.role, s.children = [], c.children.push(s);
                const r = o.dict.get("Alt");
                typeof r == "string" && (s.alt = (0, n.stringToPDFString)(r));
                const u = o.dict.get("Lang");
                typeof u == "string" && (s.lang = (0, n.stringToPDFString)(u));
                for (const C of o.kids) {
                  const d = C.type === l.ELEMENT ? C.parentNode : null;
                  if (d) {
                    g(d, s, I + 1);
                    continue;
                  } else
                    C.type === l.PAGE_CONTENT || C.type === l.STREAM_CONTENT ? s.children.push({
                      type: "content",
                      id: `p${C.pageObjId}_mc${C.mcid}`
                    }) : C.type === l.OBJECT ? s.children.push({
                      type: "object",
                      id: C.refObjId
                    }) : C.type === l.ANNOTATION && s.children.push({
                      type: "annotation",
                      id: `${n.AnnotationPrefix}${C.refObjId}`
                    });
                }
              }
              const T = /* @__PURE__ */ Object.create(null);
              T.children = [], T.role = "Root";
              for (const o of this.nodes)
                o && g(o, T);
              return T;
            }
          }
          b.StructTreePage = F;
        },
        /* 73 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.incrementalUpdate = R, b.writeDict = te, b.writeObject = V;
          var n = ce(2), P = ce(4), D = ce(3), e = ce(71), t = ce(5), l = ce(74);
          async function V(z, W, g, {
            encrypt: T = null
          }) {
            const o = T == null ? void 0 : T.createCipherTransform(z.num, z.gen);
            g.push(`${z.num} ${z.gen} obj
`), W instanceof P.Dict ? await te(W, g, o) : W instanceof t.BaseStream ? await E(W, g, o) : Array.isArray(W) && await F(W, g, o), g.push(`
endobj
`);
          }
          async function te(z, W, g) {
            W.push("<<");
            for (const T of z.getKeys())
              W.push(` /${(0, D.escapePDFName)(T)} `), await f(z.getRaw(T), W, g);
            W.push(">>");
          }
          async function E(z, W, g) {
            let T = z.getString();
            const {
              dict: o
            } = z, [c, I] = await Promise.all([o.getAsync("Filter"), o.getAsync("DecodeParms")]), s = Array.isArray(c) ? await o.xref.fetchIfRefAsync(c[0]) : c, r = (0, P.isName)(s, "FlateDecode");
            if (typeof CompressionStream < "u" && (T.length >= 256 || r))
              try {
                const C = (0, n.stringToBytes)(T), d = new CompressionStream("deflate"), y = d.writable.getWriter();
                y.write(C), y.close();
                const _ = await new Response(d.readable).arrayBuffer();
                T = (0, n.bytesToString)(new Uint8Array(_));
                let $, S;
                c ? r || ($ = Array.isArray(c) ? [P.Name.get("FlateDecode"), ...c] : [P.Name.get("FlateDecode"), c], I && (S = Array.isArray(I) ? [null, ...I] : [null, I])) : $ = P.Name.get("FlateDecode"), $ && o.set("Filter", $), S && o.set("DecodeParms", S);
              } catch (C) {
                (0, n.info)(`writeStream - cannot compress data: "${C}".`);
              }
            g && (T = g.encryptString(T)), o.set("Length", T.length), await te(o, W, g), W.push(` stream
`, T, `
endstream`);
          }
          async function F(z, W, g) {
            W.push("[");
            let T = !0;
            for (const o of z)
              T ? T = !1 : W.push(" "), await f(o, W, g);
            W.push("]");
          }
          async function f(z, W, g) {
            z instanceof P.Name ? W.push(`/${(0, D.escapePDFName)(z.name)}`) : z instanceof P.Ref ? W.push(`${z.num} ${z.gen} R`) : Array.isArray(z) ? await F(z, W, g) : typeof z == "string" ? (g && (z = g.encryptString(z)), W.push(`(${(0, D.escapeString)(z)})`)) : typeof z == "number" ? W.push((0, D.numberToString)(z)) : typeof z == "boolean" ? W.push(z.toString()) : z instanceof P.Dict ? await te(z, W, g) : z instanceof t.BaseStream ? await E(z, W, g) : z === null ? W.push("null") : (0, n.warn)(`Unhandled value in writer: ${typeof z}, please file a bug.`);
          }
          function x(z, W, g, T) {
            for (let o = W + g - 1; o > g - 1; o--)
              T[o] = z & 255, z >>= 8;
            return g + W;
          }
          function a(z, W, g) {
            for (let T = 0, o = z.length; T < o; T++)
              g[W + T] = z.charCodeAt(T) & 255;
          }
          function N(z, W) {
            const g = Math.floor(Date.now() / 1e3), T = W.filename || "", o = [g.toString(), T, z.toString()];
            let c = o.reduce((r, u) => r + u.length, 0);
            for (const r of Object.values(W.info))
              o.push(r), c += r.length;
            const I = new Uint8Array(c);
            let s = 0;
            for (const r of o)
              a(r, s, I), s += r.length;
            return (0, n.bytesToString)((0, l.calculateMD5)(I));
          }
          function p(z, W) {
            const g = new e.SimpleXMLParser({
              hasAttributes: !0
            }).parseFromString(z);
            for (const {
              xfa: o
            } of W) {
              if (!o)
                continue;
              const {
                path: c,
                value: I
              } = o;
              if (!c)
                continue;
              const s = (0, D.parseXFAPath)(c);
              let r = g.documentElement.searchNode(s, 0);
              !r && s.length > 1 && (r = g.documentElement.searchNode([s.at(-1)], 0)), r ? r.childNodes = Array.isArray(I) ? I.map((u) => new e.SimpleDOMNode("value", u)) : [new e.SimpleDOMNode("#text", I)] : (0, n.warn)(`Node not found for path: ${c}`);
            }
            const T = [];
            return g.documentElement.dump(T), T.join("");
          }
          async function O({
            xref: z,
            acroForm: W,
            acroFormRef: g,
            hasXfa: T,
            hasXfaDatasetsEntry: o,
            xfaDatasetsRef: c,
            needAppearances: I,
            newRefs: s
          }) {
            if (T && !o && !c && (0, n.warn)("XFA - Cannot save it"), !I && (!T || !c || o))
              return;
            const r = W.clone();
            if (T && !o) {
              const C = W.get("XFA").slice();
              C.splice(2, 0, "datasets"), C.splice(3, 0, c), r.set("XFA", C);
            }
            I && r.set("NeedAppearances", !0);
            const u = [];
            await V(g, r, u, z), s.push({
              ref: g,
              data: u.join("")
            });
          }
          function M({
            xfaData: z,
            xfaDatasetsRef: W,
            newRefs: g,
            xref: T
          }) {
            if (z === null) {
              const I = T.fetchIfRef(W);
              z = p(I.getString(), g);
            }
            const o = T.encrypt;
            o && (z = o.createCipherTransform(W.num, W.gen).encryptString(z));
            const c = `${W.num} ${W.gen} obj
<< /Type /EmbeddedFile /Length ${z.length}>>
stream
` + z + `
endstream
endobj
`;
            g.push({
              ref: W,
              data: c
            });
          }
          async function R({
            originalData: z,
            xrefInfo: W,
            newRefs: g,
            xref: T = null,
            hasXfa: o = !1,
            xfaDatasetsRef: c = null,
            hasXfaDatasetsEntry: I = !1,
            needAppearances: s,
            acroFormRef: r = null,
            acroForm: u = null,
            xfaData: C = null
          }) {
            await O({
              xref: T,
              acroForm: u,
              acroFormRef: r,
              hasXfa: o,
              hasXfaDatasetsEntry: I,
              xfaDatasetsRef: c,
              needAppearances: s,
              newRefs: g
            }), o && M({
              xfaData: C,
              xfaDatasetsRef: c,
              newRefs: g,
              xref: T
            });
            const d = new P.Dict(null), y = W.newRef;
            let _, $;
            const S = z.at(-1);
            S === 10 || S === 13 ? (_ = [], $ = z.length) : (_ = [`
`], $ = z.length + 1), d.set("Size", y.num + 1), d.set("Prev", W.startXRef), d.set("Type", P.Name.get("XRef")), W.rootRef !== null && d.set("Root", W.rootRef), W.infoRef !== null && d.set("Info", W.infoRef), W.encryptRef !== null && d.set("Encrypt", W.encryptRef), g.push({
              ref: y,
              data: ""
            }), g = g.sort((Z, w) => Z.ref.num - w.ref.num);
            const v = [[0, 1, 65535]], m = [0, 1];
            let h = 0;
            for (const {
              ref: Z,
              data: w
            } of g)
              h = Math.max(h, $), v.push([1, $, Math.min(Z.gen, 65535)]), $ += w.length, m.push(Z.num, 1), _.push(w);
            if (d.set("Index", m), Array.isArray(W.fileIds) && W.fileIds.length > 0) {
              const Z = N($, W);
              d.set("ID", [W.fileIds[0], Z]);
            }
            const j = [1, Math.ceil(Math.log2(h) / 8), 2], J = (j[0] + j[1] + j[2]) * v.length;
            d.set("W", j), d.set("Length", J), _.push(`${y.num} ${y.gen} obj
`), await te(d, _, null), _.push(` stream
`);
            const oe = _.reduce((Z, w) => Z + w.length, 0), q = `
endstream
endobj
startxref
${$}
%%EOF
`, re = new Uint8Array(z.length + oe + J + q.length);
            re.set(z);
            let K = z.length;
            for (const Z of _)
              a(Z, K, re), K += Z.length;
            for (const [Z, w, k] of v)
              K = x(Z, j[0], K, re), K = x(w, j[1], K, re), K = x(k, j[2], K, re);
            return a(q, K, re), re;
          }
        },
        /* 74 */
        /***/
        (Re, b, ce) => {
          var R, z, ra, g, Vn, o, oa, I, Sn, r, Kn;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.calculateSHA256 = b.calculateMD5 = b.PDF20 = b.PDF17 = b.CipherTransformFactory = b.ARCFourCipher = b.AES256Cipher = b.AES128Cipher = void 0, b.calculateSHA384 = E, b.calculateSHA512 = void 0;
          var n = ce(2), P = ce(4), D = ce(75);
          class e {
            constructor(y) {
              this.a = 0, this.b = 0;
              const _ = new Uint8Array(256), $ = y.length;
              for (let S = 0; S < 256; ++S)
                _[S] = S;
              for (let S = 0, v = 0; S < 256; ++S) {
                const m = _[S];
                v = v + m + y[S % $] & 255, _[S] = _[v], _[v] = m;
              }
              this.s = _;
            }
            encryptBlock(y) {
              let _ = this.a, $ = this.b;
              const S = this.s, v = y.length, m = new Uint8Array(v);
              for (let h = 0; h < v; ++h) {
                _ = _ + 1 & 255;
                const A = S[_];
                $ = $ + A & 255;
                const j = S[$];
                S[_] = j, S[$] = A, m[h] = y[h] ^ S[A + j & 255];
              }
              return this.a = _, this.b = $, m;
            }
            decryptBlock(y) {
              return this.encryptBlock(y);
            }
            encrypt(y) {
              return this.encryptBlock(y);
            }
          }
          b.ARCFourCipher = e;
          const t = function() {
            const y = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), _ = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
            function $(S, v, m) {
              let h = 1732584193, A = -271733879, j = -1732584194, G = 271733878;
              const J = m + 72 & -64, oe = new Uint8Array(J);
              let q, re;
              for (q = 0; q < m; ++q)
                oe[q] = S[v++];
              oe[q++] = 128;
              const K = J - 8;
              for (; q < K; )
                oe[q++] = 0;
              oe[q++] = m << 3 & 255, oe[q++] = m >> 5 & 255, oe[q++] = m >> 13 & 255, oe[q++] = m >> 21 & 255, oe[q++] = m >>> 29 & 255, oe[q++] = 0, oe[q++] = 0, oe[q++] = 0;
              const Z = new Int32Array(16);
              for (q = 0; q < J; ) {
                for (re = 0; re < 16; ++re, q += 4)
                  Z[re] = oe[q] | oe[q + 1] << 8 | oe[q + 2] << 16 | oe[q + 3] << 24;
                let w = h, k = A, X = j, H = G, Y, ie;
                for (re = 0; re < 64; ++re) {
                  re < 16 ? (Y = k & X | ~k & H, ie = re) : re < 32 ? (Y = H & k | ~H & X, ie = 5 * re + 1 & 15) : re < 48 ? (Y = k ^ X ^ H, ie = 3 * re + 5 & 15) : (Y = X ^ (k | ~H), ie = 7 * re & 15);
                  const ne = H, U = w + Y + _[re] + Z[ie] | 0, ae = y[re];
                  H = X, X = k, k = k + (U << ae | U >>> 32 - ae) | 0, w = ne;
                }
                h = h + w | 0, A = A + k | 0, j = j + X | 0, G = G + H | 0;
              }
              return new Uint8Array([h & 255, h >> 8 & 255, h >> 16 & 255, h >>> 24 & 255, A & 255, A >> 8 & 255, A >> 16 & 255, A >>> 24 & 255, j & 255, j >> 8 & 255, j >> 16 & 255, j >>> 24 & 255, G & 255, G >> 8 & 255, G >> 16 & 255, G >>> 24 & 255]);
            }
            return $;
          }();
          b.calculateMD5 = t;
          class l {
            constructor(y, _) {
              this.high = y | 0, this.low = _ | 0;
            }
            and(y) {
              this.high &= y.high, this.low &= y.low;
            }
            xor(y) {
              this.high ^= y.high, this.low ^= y.low;
            }
            or(y) {
              this.high |= y.high, this.low |= y.low;
            }
            shiftRight(y) {
              y >= 32 ? (this.low = this.high >>> y - 32 | 0, this.high = 0) : (this.low = this.low >>> y | this.high << 32 - y, this.high = this.high >>> y | 0);
            }
            shiftLeft(y) {
              y >= 32 ? (this.high = this.low << y - 32, this.low = 0) : (this.high = this.high << y | this.low >>> 32 - y, this.low <<= y);
            }
            rotateRight(y) {
              let _, $;
              y & 32 ? ($ = this.low, _ = this.high) : (_ = this.low, $ = this.high), y &= 31, this.low = _ >>> y | $ << 32 - y, this.high = $ >>> y | _ << 32 - y;
            }
            not() {
              this.high = ~this.high, this.low = ~this.low;
            }
            add(y) {
              const _ = (this.low >>> 0) + (y.low >>> 0);
              let $ = (this.high >>> 0) + (y.high >>> 0);
              _ > 4294967295 && ($ += 1), this.low = _ | 0, this.high = $ | 0;
            }
            copyTo(y, _) {
              y[_] = this.high >>> 24 & 255, y[_ + 1] = this.high >> 16 & 255, y[_ + 2] = this.high >> 8 & 255, y[_ + 3] = this.high & 255, y[_ + 4] = this.low >>> 24 & 255, y[_ + 5] = this.low >> 16 & 255, y[_ + 6] = this.low >> 8 & 255, y[_ + 7] = this.low & 255;
            }
            assign(y) {
              this.high = y.high, this.low = y.low;
            }
          }
          const V = /* @__PURE__ */ function() {
            function y(G, J) {
              return G >>> J | G << 32 - J;
            }
            function _(G, J, oe) {
              return G & J ^ ~G & oe;
            }
            function $(G, J, oe) {
              return G & J ^ G & oe ^ J & oe;
            }
            function S(G) {
              return y(G, 2) ^ y(G, 13) ^ y(G, 22);
            }
            function v(G) {
              return y(G, 6) ^ y(G, 11) ^ y(G, 25);
            }
            function m(G) {
              return y(G, 7) ^ y(G, 18) ^ G >>> 3;
            }
            function h(G) {
              return y(G, 17) ^ y(G, 19) ^ G >>> 10;
            }
            const A = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
            function j(G, J, oe) {
              let q = 1779033703, re = 3144134277, K = 1013904242, Z = 2773480762, w = 1359893119, k = 2600822924, X = 528734635, H = 1541459225;
              const Y = Math.ceil((oe + 9) / 64) * 64, ie = new Uint8Array(Y);
              let ne, U;
              for (ne = 0; ne < oe; ++ne)
                ie[ne] = G[J++];
              ie[ne++] = 128;
              const ae = Y - 8;
              for (; ne < ae; )
                ie[ne++] = 0;
              ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = oe >>> 29 & 255, ie[ne++] = oe >> 21 & 255, ie[ne++] = oe >> 13 & 255, ie[ne++] = oe >> 5 & 255, ie[ne++] = oe << 3 & 255;
              const Q = new Uint32Array(64);
              for (ne = 0; ne < Y; ) {
                for (U = 0; U < 16; ++U)
                  Q[U] = ie[ne] << 24 | ie[ne + 1] << 16 | ie[ne + 2] << 8 | ie[ne + 3], ne += 4;
                for (U = 16; U < 64; ++U)
                  Q[U] = h(Q[U - 2]) + Q[U - 7] + m(Q[U - 15]) + Q[U - 16] | 0;
                let L = q, ee = re, se = K, le = Z, ue = w, de = k, ge = X, me = H, pe, xe;
                for (U = 0; U < 64; ++U)
                  pe = me + v(ue) + _(ue, de, ge) + A[U] + Q[U], xe = S(L) + $(L, ee, se), me = ge, ge = de, de = ue, ue = le + pe | 0, le = se, se = ee, ee = L, L = pe + xe | 0;
                q = q + L | 0, re = re + ee | 0, K = K + se | 0, Z = Z + le | 0, w = w + ue | 0, k = k + de | 0, X = X + ge | 0, H = H + me | 0;
              }
              return new Uint8Array([q >> 24 & 255, q >> 16 & 255, q >> 8 & 255, q & 255, re >> 24 & 255, re >> 16 & 255, re >> 8 & 255, re & 255, K >> 24 & 255, K >> 16 & 255, K >> 8 & 255, K & 255, Z >> 24 & 255, Z >> 16 & 255, Z >> 8 & 255, Z & 255, w >> 24 & 255, w >> 16 & 255, w >> 8 & 255, w & 255, k >> 24 & 255, k >> 16 & 255, k >> 8 & 255, k & 255, X >> 24 & 255, X >> 16 & 255, X >> 8 & 255, X & 255, H >> 24 & 255, H >> 16 & 255, H >> 8 & 255, H & 255]);
            }
            return j;
          }();
          b.calculateSHA256 = V;
          const te = function() {
            function y(j, G, J, oe, q) {
              j.assign(G), j.and(J), q.assign(G), q.not(), q.and(oe), j.xor(q);
            }
            function _(j, G, J, oe, q) {
              j.assign(G), j.and(J), q.assign(G), q.and(oe), j.xor(q), q.assign(J), q.and(oe), j.xor(q);
            }
            function $(j, G, J) {
              j.assign(G), j.rotateRight(28), J.assign(G), J.rotateRight(34), j.xor(J), J.assign(G), J.rotateRight(39), j.xor(J);
            }
            function S(j, G, J) {
              j.assign(G), j.rotateRight(14), J.assign(G), J.rotateRight(18), j.xor(J), J.assign(G), J.rotateRight(41), j.xor(J);
            }
            function v(j, G, J) {
              j.assign(G), j.rotateRight(1), J.assign(G), J.rotateRight(8), j.xor(J), J.assign(G), J.shiftRight(7), j.xor(J);
            }
            function m(j, G, J) {
              j.assign(G), j.rotateRight(19), J.assign(G), J.rotateRight(61), j.xor(J), J.assign(G), J.shiftRight(6), j.xor(J);
            }
            const h = [new l(1116352408, 3609767458), new l(1899447441, 602891725), new l(3049323471, 3964484399), new l(3921009573, 2173295548), new l(961987163, 4081628472), new l(1508970993, 3053834265), new l(2453635748, 2937671579), new l(2870763221, 3664609560), new l(3624381080, 2734883394), new l(310598401, 1164996542), new l(607225278, 1323610764), new l(1426881987, 3590304994), new l(1925078388, 4068182383), new l(2162078206, 991336113), new l(2614888103, 633803317), new l(3248222580, 3479774868), new l(3835390401, 2666613458), new l(4022224774, 944711139), new l(264347078, 2341262773), new l(604807628, 2007800933), new l(770255983, 1495990901), new l(1249150122, 1856431235), new l(1555081692, 3175218132), new l(1996064986, 2198950837), new l(2554220882, 3999719339), new l(2821834349, 766784016), new l(2952996808, 2566594879), new l(3210313671, 3203337956), new l(3336571891, 1034457026), new l(3584528711, 2466948901), new l(113926993, 3758326383), new l(338241895, 168717936), new l(666307205, 1188179964), new l(773529912, 1546045734), new l(1294757372, 1522805485), new l(1396182291, 2643833823), new l(1695183700, 2343527390), new l(1986661051, 1014477480), new l(2177026350, 1206759142), new l(2456956037, 344077627), new l(2730485921, 1290863460), new l(2820302411, 3158454273), new l(3259730800, 3505952657), new l(3345764771, 106217008), new l(3516065817, 3606008344), new l(3600352804, 1432725776), new l(4094571909, 1467031594), new l(275423344, 851169720), new l(430227734, 3100823752), new l(506948616, 1363258195), new l(659060556, 3750685593), new l(883997877, 3785050280), new l(958139571, 3318307427), new l(1322822218, 3812723403), new l(1537002063, 2003034995), new l(1747873779, 3602036899), new l(1955562222, 1575990012), new l(2024104815, 1125592928), new l(2227730452, 2716904306), new l(2361852424, 442776044), new l(2428436474, 593698344), new l(2756734187, 3733110249), new l(3204031479, 2999351573), new l(3329325298, 3815920427), new l(3391569614, 3928383900), new l(3515267271, 566280711), new l(3940187606, 3454069534), new l(4118630271, 4000239992), new l(116418474, 1914138554), new l(174292421, 2731055270), new l(289380356, 3203993006), new l(460393269, 320620315), new l(685471733, 587496836), new l(852142971, 1086792851), new l(1017036298, 365543100), new l(1126000580, 2618297676), new l(1288033470, 3409855158), new l(1501505948, 4234509866), new l(1607167915, 987167468), new l(1816402316, 1246189591)];
            function A(j, G, J, oe = !1) {
              let q, re, K, Z, w, k, X, H;
              oe ? (q = new l(3418070365, 3238371032), re = new l(1654270250, 914150663), K = new l(2438529370, 812702999), Z = new l(355462360, 4144912697), w = new l(1731405415, 4290775857), k = new l(2394180231, 1750603025), X = new l(3675008525, 1694076839), H = new l(1203062813, 3204075428)) : (q = new l(1779033703, 4089235720), re = new l(3144134277, 2227873595), K = new l(1013904242, 4271175723), Z = new l(2773480762, 1595750129), w = new l(1359893119, 2917565137), k = new l(2600822924, 725511199), X = new l(528734635, 4215389547), H = new l(1541459225, 327033209));
              const Y = Math.ceil((J + 17) / 128) * 128, ie = new Uint8Array(Y);
              let ne, U;
              for (ne = 0; ne < J; ++ne)
                ie[ne] = j[G++];
              ie[ne++] = 128;
              const ae = Y - 16;
              for (; ne < ae; )
                ie[ne++] = 0;
              ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = 0, ie[ne++] = J >>> 29 & 255, ie[ne++] = J >> 21 & 255, ie[ne++] = J >> 13 & 255, ie[ne++] = J >> 5 & 255, ie[ne++] = J << 3 & 255;
              const Q = new Array(80);
              for (ne = 0; ne < 80; ne++)
                Q[ne] = new l(0, 0);
              let L = new l(0, 0), ee = new l(0, 0), se = new l(0, 0), le = new l(0, 0), ue = new l(0, 0), de = new l(0, 0), ge = new l(0, 0), me = new l(0, 0);
              const pe = new l(0, 0), xe = new l(0, 0), we = new l(0, 0), Ae = new l(0, 0);
              let be;
              for (ne = 0; ne < Y; ) {
                for (U = 0; U < 16; ++U)
                  Q[U].high = ie[ne] << 24 | ie[ne + 1] << 16 | ie[ne + 2] << 8 | ie[ne + 3], Q[U].low = ie[ne + 4] << 24 | ie[ne + 5] << 16 | ie[ne + 6] << 8 | ie[ne + 7], ne += 8;
                for (U = 16; U < 80; ++U)
                  be = Q[U], m(be, Q[U - 2], Ae), be.add(Q[U - 7]), v(we, Q[U - 15], Ae), be.add(we), be.add(Q[U - 16]);
                for (L.assign(q), ee.assign(re), se.assign(K), le.assign(Z), ue.assign(w), de.assign(k), ge.assign(X), me.assign(H), U = 0; U < 80; ++U)
                  pe.assign(me), S(we, ue, Ae), pe.add(we), y(we, ue, de, ge, Ae), pe.add(we), pe.add(h[U]), pe.add(Q[U]), $(xe, L, Ae), _(we, L, ee, se, Ae), xe.add(we), be = me, me = ge, ge = de, de = ue, le.add(pe), ue = le, le = se, se = ee, ee = L, be.assign(pe), be.add(xe), L = be;
                q.add(L), re.add(ee), K.add(se), Z.add(le), w.add(ue), k.add(de), X.add(ge), H.add(me);
              }
              let he;
              return oe ? (he = new Uint8Array(48), q.copyTo(he, 0), re.copyTo(he, 8), K.copyTo(he, 16), Z.copyTo(he, 24), w.copyTo(he, 32), k.copyTo(he, 40)) : (he = new Uint8Array(64), q.copyTo(he, 0), re.copyTo(he, 8), K.copyTo(he, 16), Z.copyTo(he, 24), w.copyTo(he, 32), k.copyTo(he, 40), X.copyTo(he, 48), H.copyTo(he, 56)), he;
            }
            return A;
          }();
          b.calculateSHA512 = te;
          function E(d, y, _) {
            return te(d, y, _, !0);
          }
          class F {
            decryptBlock(y) {
              return y;
            }
            encrypt(y) {
              return y;
            }
          }
          class f {
            constructor() {
              this.constructor === f && (0, n.unreachable)("Cannot initialize AESBaseCipher."), this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
              for (let y = 0; y < 256; y++)
                this._mixCol[y] = y < 128 ? y << 1 : y << 1 ^ 27;
              this.buffer = new Uint8Array(16), this.bufferPosition = 0;
            }
            _expandKey(y) {
              (0, n.unreachable)("Cannot call `_expandKey` on the base class");
            }
            _decrypt(y, _) {
              let $, S, v;
              const m = new Uint8Array(16);
              m.set(y);
              for (let h = 0, A = this._keySize; h < 16; ++h, ++A)
                m[h] ^= _[A];
              for (let h = this._cyclesOfRepetition - 1; h >= 1; --h) {
                $ = m[13], m[13] = m[9], m[9] = m[5], m[5] = m[1], m[1] = $, $ = m[14], S = m[10], m[14] = m[6], m[10] = m[2], m[6] = $, m[2] = S, $ = m[15], S = m[11], v = m[7], m[15] = m[3], m[11] = $, m[7] = S, m[3] = v;
                for (let A = 0; A < 16; ++A)
                  m[A] = this._inv_s[m[A]];
                for (let A = 0, j = h * 16; A < 16; ++A, ++j)
                  m[A] ^= _[j];
                for (let A = 0; A < 16; A += 4) {
                  const j = this._mix[m[A]], G = this._mix[m[A + 1]], J = this._mix[m[A + 2]], oe = this._mix[m[A + 3]];
                  $ = j ^ G >>> 8 ^ G << 24 ^ J >>> 16 ^ J << 16 ^ oe >>> 24 ^ oe << 8, m[A] = $ >>> 24 & 255, m[A + 1] = $ >> 16 & 255, m[A + 2] = $ >> 8 & 255, m[A + 3] = $ & 255;
                }
              }
              $ = m[13], m[13] = m[9], m[9] = m[5], m[5] = m[1], m[1] = $, $ = m[14], S = m[10], m[14] = m[6], m[10] = m[2], m[6] = $, m[2] = S, $ = m[15], S = m[11], v = m[7], m[15] = m[3], m[11] = $, m[7] = S, m[3] = v;
              for (let h = 0; h < 16; ++h)
                m[h] = this._inv_s[m[h]], m[h] ^= _[h];
              return m;
            }
            _encrypt(y, _) {
              const $ = this._s;
              let S, v, m;
              const h = new Uint8Array(16);
              h.set(y);
              for (let A = 0; A < 16; ++A)
                h[A] ^= _[A];
              for (let A = 1; A < this._cyclesOfRepetition; A++) {
                for (let j = 0; j < 16; ++j)
                  h[j] = $[h[j]];
                m = h[1], h[1] = h[5], h[5] = h[9], h[9] = h[13], h[13] = m, m = h[2], v = h[6], h[2] = h[10], h[6] = h[14], h[10] = m, h[14] = v, m = h[3], v = h[7], S = h[11], h[3] = h[15], h[7] = m, h[11] = v, h[15] = S;
                for (let j = 0; j < 16; j += 4) {
                  const G = h[j + 0], J = h[j + 1], oe = h[j + 2], q = h[j + 3];
                  S = G ^ J ^ oe ^ q, h[j + 0] ^= S ^ this._mixCol[G ^ J], h[j + 1] ^= S ^ this._mixCol[J ^ oe], h[j + 2] ^= S ^ this._mixCol[oe ^ q], h[j + 3] ^= S ^ this._mixCol[q ^ G];
                }
                for (let j = 0, G = A * 16; j < 16; ++j, ++G)
                  h[j] ^= _[G];
              }
              for (let A = 0; A < 16; ++A)
                h[A] = $[h[A]];
              m = h[1], h[1] = h[5], h[5] = h[9], h[9] = h[13], h[13] = m, m = h[2], v = h[6], h[2] = h[10], h[6] = h[14], h[10] = m, h[14] = v, m = h[3], v = h[7], S = h[11], h[3] = h[15], h[7] = m, h[11] = v, h[15] = S;
              for (let A = 0, j = this._keySize; A < 16; ++A, ++j)
                h[A] ^= _[j];
              return h;
            }
            _decryptBlock2(y, _) {
              const $ = y.length;
              let S = this.buffer, v = this.bufferPosition;
              const m = [];
              let h = this.iv;
              for (let G = 0; G < $; ++G) {
                if (S[v] = y[G], ++v, v < 16)
                  continue;
                const J = this._decrypt(S, this._key);
                for (let oe = 0; oe < 16; ++oe)
                  J[oe] ^= h[oe];
                h = S, m.push(J), S = new Uint8Array(16), v = 0;
              }
              if (this.buffer = S, this.bufferLength = v, this.iv = h, m.length === 0)
                return new Uint8Array(0);
              let A = 16 * m.length;
              if (_) {
                const G = m.at(-1);
                let J = G[15];
                if (J <= 16) {
                  for (let oe = 15, q = 16 - J; oe >= q; --oe)
                    if (G[oe] !== J) {
                      J = 0;
                      break;
                    }
                  A -= J, m[m.length - 1] = G.subarray(0, 16 - J);
                }
              }
              const j = new Uint8Array(A);
              for (let G = 0, J = 0, oe = m.length; G < oe; ++G, J += 16)
                j.set(m[G], J);
              return j;
            }
            decryptBlock(y, _, $ = null) {
              const S = y.length, v = this.buffer;
              let m = this.bufferPosition;
              if ($)
                this.iv = $;
              else {
                for (let h = 0; m < 16 && h < S; ++h, ++m)
                  v[m] = y[h];
                if (m < 16)
                  return this.bufferLength = m, new Uint8Array(0);
                this.iv = v, y = y.subarray(16);
              }
              return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(y, _);
            }
            encrypt(y, _) {
              const $ = y.length;
              let S = this.buffer, v = this.bufferPosition;
              const m = [];
              _ || (_ = new Uint8Array(16));
              for (let j = 0; j < $; ++j) {
                if (S[v] = y[j], ++v, v < 16)
                  continue;
                for (let J = 0; J < 16; ++J)
                  S[J] ^= _[J];
                const G = this._encrypt(S, this._key);
                _ = G, m.push(G), S = new Uint8Array(16), v = 0;
              }
              if (this.buffer = S, this.bufferLength = v, this.iv = _, m.length === 0)
                return new Uint8Array(0);
              const h = 16 * m.length, A = new Uint8Array(h);
              for (let j = 0, G = 0, J = m.length; j < J; ++j, G += 16)
                A.set(m[j], G);
              return A;
            }
          }
          class x extends f {
            constructor(y) {
              super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(y);
            }
            _expandKey(y) {
              const $ = this._s, S = this._rcon, v = new Uint8Array(176);
              v.set(y);
              for (let m = 16, h = 1; m < 176; ++h) {
                let A = v[m - 3], j = v[m - 2], G = v[m - 1], J = v[m - 4];
                A = $[A], j = $[j], G = $[G], J = $[J], A ^= S[h];
                for (let oe = 0; oe < 4; ++oe)
                  v[m] = A ^= v[m - 16], m++, v[m] = j ^= v[m - 16], m++, v[m] = G ^= v[m - 16], m++, v[m] = J ^= v[m - 16], m++;
              }
              return v;
            }
          }
          b.AES128Cipher = x;
          class a extends f {
            constructor(y) {
              super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(y);
            }
            _expandKey(y) {
              const $ = this._s, S = new Uint8Array(240);
              S.set(y);
              let v = 1, m, h, A, j;
              for (let G = 32, J = 1; G < 240; ++J) {
                G % 32 === 16 ? (m = $[m], h = $[h], A = $[A], j = $[j]) : G % 32 === 0 && (m = S[G - 3], h = S[G - 2], A = S[G - 1], j = S[G - 4], m = $[m], h = $[h], A = $[A], j = $[j], m ^= v, (v <<= 1) >= 256 && (v = (v ^ 27) & 255));
                for (let oe = 0; oe < 4; ++oe)
                  S[G] = m ^= S[G - 32], G++, S[G] = h ^= S[G - 32], G++, S[G] = A ^= S[G - 32], G++, S[G] = j ^= S[G - 32], G++;
              }
              return S;
            }
          }
          b.AES256Cipher = a;
          class N {
            checkOwnerPassword(y, _, $, S) {
              const v = new Uint8Array(y.length + 56);
              v.set(y, 0), v.set(_, y.length), v.set($, y.length + _.length);
              const m = V(v, 0, v.length);
              return (0, n.isArrayEqual)(m, S);
            }
            checkUserPassword(y, _, $) {
              const S = new Uint8Array(y.length + 8);
              S.set(y, 0), S.set(_, y.length);
              const v = V(S, 0, S.length);
              return (0, n.isArrayEqual)(v, $);
            }
            getOwnerKey(y, _, $, S) {
              const v = new Uint8Array(y.length + 56);
              v.set(y, 0), v.set(_, y.length), v.set($, y.length + _.length);
              const m = V(v, 0, v.length);
              return new a(m).decryptBlock(S, !1, new Uint8Array(16));
            }
            getUserKey(y, _, $) {
              const S = new Uint8Array(y.length + 8);
              S.set(y, 0), S.set(_, y.length);
              const v = V(S, 0, S.length);
              return new a(v).decryptBlock($, !1, new Uint8Array(16));
            }
          }
          b.PDF17 = N;
          class p {
            _hash(y, _, $) {
              let S = V(_, 0, _.length).subarray(0, 32), v = [0], m = 0;
              for (; m < 64 || v.at(-1) > m - 32; ) {
                const h = y.length + S.length + $.length, A = new Uint8Array(h);
                let j = 0;
                A.set(y, j), j += y.length, A.set(S, j), j += S.length, A.set($, j);
                const G = new Uint8Array(h * 64);
                for (let q = 0, re = 0; q < 64; q++, re += h)
                  G.set(A, re);
                v = new x(S.subarray(0, 16)).encrypt(G, S.subarray(16, 32));
                const oe = v.slice(0, 16).reduce((q, re) => q + re, 0) % 3;
                oe === 0 ? S = V(v, 0, v.length) : oe === 1 ? S = E(v, 0, v.length) : oe === 2 && (S = te(v, 0, v.length)), m++;
              }
              return S.subarray(0, 32);
            }
            checkOwnerPassword(y, _, $, S) {
              const v = new Uint8Array(y.length + 56);
              v.set(y, 0), v.set(_, y.length), v.set($, y.length + _.length);
              const m = this._hash(y, v, $);
              return (0, n.isArrayEqual)(m, S);
            }
            checkUserPassword(y, _, $) {
              const S = new Uint8Array(y.length + 8);
              S.set(y, 0), S.set(_, y.length);
              const v = this._hash(y, S, []);
              return (0, n.isArrayEqual)(v, $);
            }
            getOwnerKey(y, _, $, S) {
              const v = new Uint8Array(y.length + 56);
              v.set(y, 0), v.set(_, y.length), v.set($, y.length + _.length);
              const m = this._hash(y, v, $);
              return new a(m).decryptBlock(S, !1, new Uint8Array(16));
            }
            getUserKey(y, _, $) {
              const S = new Uint8Array(y.length + 8);
              S.set(y, 0), S.set(_, y.length);
              const v = this._hash(y, S, []);
              return new a(v).decryptBlock($, !1, new Uint8Array(16));
            }
          }
          b.PDF20 = p;
          class O {
            constructor(y, _) {
              this.StringCipherConstructor = y, this.StreamCipherConstructor = _;
            }
            createStream(y, _) {
              const $ = new this.StreamCipherConstructor();
              return new D.DecryptStream(y, _, function(v, m) {
                return $.decryptBlock(v, m);
              });
            }
            decryptString(y) {
              const _ = new this.StringCipherConstructor();
              let $ = (0, n.stringToBytes)(y);
              return $ = _.decryptBlock($, !0), (0, n.bytesToString)($);
            }
            encryptString(y) {
              const _ = new this.StringCipherConstructor();
              if (_ instanceof f) {
                const v = 16 - y.length % 16;
                y += String.fromCharCode(v).repeat(v);
                const m = new Uint8Array(16);
                if (typeof crypto < "u")
                  crypto.getRandomValues(m);
                else
                  for (let j = 0; j < 16; j++)
                    m[j] = Math.floor(256 * Math.random());
                let h = (0, n.stringToBytes)(y);
                h = _.encrypt(h, m);
                const A = new Uint8Array(16 + h.length);
                return A.set(m), A.set(h, 16), (0, n.bytesToString)(A);
              }
              let $ = (0, n.stringToBytes)(y);
              return $ = _.encrypt($), (0, n.bytesToString)($);
            }
          }
          const C = class C {
            constructor(y, _, $) {
              At(this, z);
              At(this, g);
              At(this, o);
              At(this, I);
              At(this, r);
              const S = y.get("Filter");
              if (!(0, P.isName)(S, "Standard"))
                throw new n.FormatError("unknown encryption method");
              this.filterName = S.name, this.dict = y;
              const v = y.get("V");
              if (!Number.isInteger(v) || v !== 1 && v !== 2 && v !== 4 && v !== 5)
                throw new n.FormatError("unsupported encryption algorithm");
              this.algorithm = v;
              let m = y.get("Length");
              if (!m)
                if (v <= 3)
                  m = 40;
                else {
                  const w = y.get("CF"), k = y.get("StmF");
                  if (w instanceof P.Dict && k instanceof P.Name) {
                    w.suppressEncryption = !0;
                    const X = w.get(k.name);
                    m = (X == null ? void 0 : X.get("Length")) || 128, m < 40 && (m <<= 3);
                  }
                }
              if (!Number.isInteger(m) || m < 40 || m % 8 !== 0)
                throw new n.FormatError("invalid key length");
              const h = (0, n.stringToBytes)(y.get("O")), A = (0, n.stringToBytes)(y.get("U")), j = h.subarray(0, 32), G = A.subarray(0, 32), J = y.get("P"), oe = y.get("R"), q = (v === 4 || v === 5) && y.get("EncryptMetadata") !== !1;
              this.encryptMetadata = q;
              const re = (0, n.stringToBytes)(_);
              let K;
              if ($) {
                if (oe === 6)
                  try {
                    $ = (0, n.utf8StringToString)($);
                  } catch {
                    (0, n.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                  }
                K = (0, n.stringToBytes)($);
              }
              let Z;
              if (v !== 5)
                Z = it(this, g, Vn).call(this, re, K, j, G, J, oe, m, q);
              else {
                const w = h.subarray(32, 40), k = h.subarray(40, 48), X = A.subarray(0, 48), H = A.subarray(32, 40), Y = A.subarray(40, 48), ie = (0, n.stringToBytes)(y.get("OE")), ne = (0, n.stringToBytes)(y.get("UE")), U = (0, n.stringToBytes)(y.get("Perms"));
                Z = it(this, z, ra).call(this, oe, K, j, w, k, X, G, H, Y, ie, ne, U);
              }
              if (!Z && !$)
                throw new n.PasswordException("No password given", n.PasswordResponses.NEED_PASSWORD);
              if (!Z && $) {
                const w = it(this, o, oa).call(this, K, j, oe, m);
                Z = it(this, g, Vn).call(this, re, w, j, G, J, oe, m, q);
              }
              if (!Z)
                throw new n.PasswordException("Incorrect Password", n.PasswordResponses.INCORRECT_PASSWORD);
              if (this.encryptionKey = Z, v >= 4) {
                const w = y.get("CF");
                w instanceof P.Dict && (w.suppressEncryption = !0), this.cf = w, this.stmf = y.get("StmF") || P.Name.get("Identity"), this.strf = y.get("StrF") || P.Name.get("Identity"), this.eff = y.get("EFF") || this.stmf;
              }
            }
            createCipherTransform(y, _) {
              if (this.algorithm === 4 || this.algorithm === 5)
                return new O(it(this, r, Kn).call(this, this.cf, this.strf, y, _, this.encryptionKey), it(this, r, Kn).call(this, this.cf, this.stmf, y, _, this.encryptionKey));
              const $ = it(this, I, Sn).call(this, y, _, this.encryptionKey, !1), S = function() {
                return new e($);
              };
              return new O(S, S);
            }
          };
          R = new WeakMap(), z = new WeakSet(), ra = function(y, _, $, S, v, m, h, A, j, G, J, oe) {
            if (_) {
              const re = Math.min(127, _.length);
              _ = _.subarray(0, re);
            } else
              _ = [];
            const q = y === 6 ? new p() : new N();
            return q.checkUserPassword(_, A, h) ? q.getUserKey(_, j, J) : _.length && q.checkOwnerPassword(_, S, m, $) ? q.getOwnerKey(_, v, m, G) : null;
          }, g = new WeakSet(), Vn = function(y, _, $, S, v, m, h, A) {
            const j = 40 + $.length + y.length, G = new Uint8Array(j);
            let J = 0, oe, q;
            if (_)
              for (q = Math.min(32, _.length); J < q; ++J)
                G[J] = _[J];
            for (oe = 0; J < 32; )
              G[J++] = Lt(C, R)[oe++];
            for (oe = 0, q = $.length; oe < q; ++oe)
              G[J++] = $[oe];
            for (G[J++] = v & 255, G[J++] = v >> 8 & 255, G[J++] = v >> 16 & 255, G[J++] = v >>> 24 & 255, oe = 0, q = y.length; oe < q; ++oe)
              G[J++] = y[oe];
            m >= 4 && !A && (G[J++] = 255, G[J++] = 255, G[J++] = 255, G[J++] = 255);
            let re = t(G, 0, J);
            const K = h >> 3;
            if (m >= 3)
              for (oe = 0; oe < 50; ++oe)
                re = t(re, 0, K);
            const Z = re.subarray(0, K);
            let w, k;
            if (m >= 3) {
              for (J = 0; J < 32; ++J)
                G[J] = Lt(C, R)[J];
              for (oe = 0, q = y.length; oe < q; ++oe)
                G[J++] = y[oe];
              w = new e(Z), k = w.encryptBlock(t(G, 0, J)), q = Z.length;
              const X = new Uint8Array(q);
              for (oe = 1; oe <= 19; ++oe) {
                for (let H = 0; H < q; ++H)
                  X[H] = Z[H] ^ oe;
                w = new e(X), k = w.encryptBlock(k);
              }
              for (oe = 0, q = k.length; oe < q; ++oe)
                if (S[oe] !== k[oe])
                  return null;
            } else
              for (w = new e(Z), k = w.encryptBlock(Lt(C, R)), oe = 0, q = k.length; oe < q; ++oe)
                if (S[oe] !== k[oe])
                  return null;
            return Z;
          }, o = new WeakSet(), oa = function(y, _, $, S) {
            const v = new Uint8Array(32);
            let m = 0;
            const h = Math.min(32, y.length);
            for (; m < h; ++m)
              v[m] = y[m];
            let A = 0;
            for (; m < 32; )
              v[m++] = Lt(C, R)[A++];
            let j = t(v, 0, m);
            const G = S >> 3;
            if ($ >= 3)
              for (A = 0; A < 50; ++A)
                j = t(j, 0, j.length);
            let J, oe;
            if ($ >= 3) {
              oe = _;
              const q = new Uint8Array(G);
              for (A = 19; A >= 0; A--) {
                for (let re = 0; re < G; ++re)
                  q[re] = j[re] ^ A;
                J = new e(q), oe = J.encryptBlock(oe);
              }
            } else
              J = new e(j.subarray(0, G)), oe = J.encryptBlock(_);
            return oe;
          }, I = new WeakSet(), Sn = function(y, _, $, S = !1) {
            const v = new Uint8Array($.length + 9), m = $.length;
            let h;
            for (h = 0; h < m; ++h)
              v[h] = $[h];
            return v[h++] = y & 255, v[h++] = y >> 8 & 255, v[h++] = y >> 16 & 255, v[h++] = _ & 255, v[h++] = _ >> 8 & 255, S && (v[h++] = 115, v[h++] = 65, v[h++] = 108, v[h++] = 84), t(v, 0, h).subarray(0, Math.min($.length + 5, 16));
          }, r = new WeakSet(), Kn = function(y, _, $, S, v) {
            if (!(_ instanceof P.Name))
              throw new n.FormatError("Invalid crypt filter name.");
            const m = this, h = y.get(_.name), A = h == null ? void 0 : h.get("CFM");
            if (!A || A.name === "None")
              return function() {
                return new F();
              };
            if (A.name === "V2")
              return function() {
                var j;
                return new e(it(j = m, I, Sn).call(j, $, S, v, !1));
              };
            if (A.name === "AESV2")
              return function() {
                var j;
                return new x(it(j = m, I, Sn).call(j, $, S, v, !0));
              };
            if (A.name === "AESV3")
              return function() {
                return new a(v);
              };
            throw new n.FormatError("Unknown crypto method");
          }, At(C, R, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
          let M = C;
          b.CipherTransformFactory = M;
        },
        /* 75 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.DecryptStream = void 0;
          var n = ce(18);
          const P = 512;
          class D extends n.DecodeStream {
            constructor(t, l, V) {
              super(l), this.str = t, this.dict = t.dict, this.decrypt = V, this.nextChunk = null, this.initialized = !1;
            }
            readBlock() {
              var f;
              let t;
              if (this.initialized ? t = this.nextChunk : (t = this.str.getBytes(P), this.initialized = !0), !t || t.length === 0) {
                this.eof = !0;
                return;
              }
              this.nextChunk = this.str.getBytes(P);
              const l = ((f = this.nextChunk) == null ? void 0 : f.length) > 0, V = this.decrypt;
              t = V(t, !l);
              const te = this.bufferLength, E = te + t.length;
              this.ensureBuffer(E).set(t, te), this.bufferLength = E;
            }
          }
          b.DecryptStream = D;
        },
        /* 76 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ObjectLoader = void 0;
          var n = ce(4), P = ce(5), D = ce(3), e = ce(2);
          function t(te) {
            return te instanceof n.Ref || te instanceof n.Dict || te instanceof P.BaseStream || Array.isArray(te);
          }
          function l(te, E) {
            if (te instanceof n.Dict)
              te = te.getRawValues();
            else if (te instanceof P.BaseStream)
              te = te.dict.getRawValues();
            else if (!Array.isArray(te))
              return;
            for (const F of te)
              t(F) && E.push(F);
          }
          class V {
            constructor(E, F, f) {
              this.dict = E, this.keys = F, this.xref = f, this.refSet = null;
            }
            async load() {
              if (this.xref.stream.isDataLoaded)
                return;
              const {
                keys: E,
                dict: F
              } = this;
              this.refSet = new n.RefSet();
              const f = [];
              for (const x of E) {
                const a = F.getRaw(x);
                a !== void 0 && f.push(a);
              }
              return this._walk(f);
            }
            async _walk(E) {
              const F = [], f = [];
              for (; E.length; ) {
                let x = E.pop();
                if (x instanceof n.Ref) {
                  if (this.refSet.has(x))
                    continue;
                  try {
                    this.refSet.put(x), x = this.xref.fetch(x);
                  } catch (a) {
                    if (!(a instanceof D.MissingDataException)) {
                      (0, e.warn)(`ObjectLoader._walk - requesting all data: "${a}".`), this.refSet = null;
                      const {
                        manager: N
                      } = this.xref.stream;
                      return N.requestAllChunks();
                    }
                    F.push(x), f.push({
                      begin: a.begin,
                      end: a.end
                    });
                  }
                }
                if (x instanceof P.BaseStream) {
                  const a = x.getBaseStreams();
                  if (a) {
                    let N = !1;
                    for (const p of a)
                      p.isDataLoaded || (N = !0, f.push({
                        begin: p.start,
                        end: p.end
                      }));
                    N && F.push(x);
                  }
                }
                l(x, E);
              }
              if (f.length) {
                await this.xref.stream.manager.requestRanges(f);
                for (const x of F)
                  x instanceof n.Ref && this.refSet.remove(x);
                return this._walk(F);
              }
              this.refSet = null;
            }
          }
          b.ObjectLoader = V;
        },
        /* 77 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XFAFactory = void 0;
          var n = ce(78), P = ce(79), D = ce(89), e = ce(85), t = ce(84), l = ce(2), V = ce(90), te = ce(100);
          class E {
            constructor(f) {
              try {
                this.root = new V.XFAParser().parse(E._createDocument(f));
                const x = new P.Binder(this.root);
                this.form = x.bind(), this.dataHandler = new D.DataHandler(this.root, x.getData()), this.form[n.$globalData].template = this.form;
              } catch (x) {
                (0, l.warn)(`XFA - an error occurred during parsing and binding: ${x}`);
              }
            }
            isValid() {
              return this.root && this.form;
            }
            _createPagesHelper() {
              const f = this.form[n.$toPages]();
              return new Promise((x, a) => {
                const N = () => {
                  try {
                    const p = f.next();
                    p.done ? x(p.value) : setTimeout(N, 0);
                  } catch (p) {
                    a(p);
                  }
                };
                setTimeout(N, 0);
              });
            }
            async _createPages() {
              try {
                this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((f) => {
                  const {
                    width: x,
                    height: a
                  } = f.attributes.style;
                  return [0, 0, parseInt(x), parseInt(a)];
                });
              } catch (f) {
                (0, l.warn)(`XFA - an error occurred during layout: ${f}`);
              }
            }
            getBoundingBox(f) {
              return this.dims[f];
            }
            async getNumPages() {
              return this.pages || await this._createPages(), this.dims.length;
            }
            setImages(f) {
              this.form[n.$globalData].images = f;
            }
            setFonts(f) {
              this.form[n.$globalData].fontFinder = new e.FontFinder(f);
              const x = [];
              for (let a of this.form[n.$globalData].usedTypefaces)
                a = (0, t.stripQuotes)(a), this.form[n.$globalData].fontFinder.find(a) || x.push(a);
              return x.length > 0 ? x : null;
            }
            appendFonts(f, x) {
              this.form[n.$globalData].fontFinder.add(f, x);
            }
            async getPages() {
              this.pages || await this._createPages();
              const f = this.pages;
              return this.pages = null, f;
            }
            serializeData(f) {
              return this.dataHandler.serialize(f);
            }
            static _createDocument(f) {
              return f["/xdp:xdp"] ? Object.values(f).join("") : f["xdp:xdp"];
            }
            static getRichTextAsHtml(f) {
              if (!f || typeof f != "string")
                return null;
              try {
                let x = new V.XFAParser(te.XhtmlNamespace, !0).parse(f);
                if (!["body", "xhtml"].includes(x[n.$nodeName])) {
                  const O = te.XhtmlNamespace.body({});
                  O[n.$appendChild](x), x = O;
                }
                const a = x[n.$toHTML]();
                if (!a.success)
                  return null;
                const {
                  html: N
                } = a, {
                  attributes: p
                } = N;
                return p && (p.class && (p.class = p.class.filter((O) => !O.startsWith("xfa"))), p.dir = "auto"), {
                  html: N,
                  str: x[n.$text]()
                };
              } catch (x) {
                (0, l.warn)(`XFA - an error occurred during parsing of rich text: ${x}`);
              }
              return null;
            }
          }
          b.XFAFactory = E;
        },
        /* 78 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.$uid = b.$toStyle = b.$toString = b.$toPages = b.$toHTML = b.$text = b.$tabIndex = b.$setValue = b.$setSetAttributes = b.$setId = b.$searchNode = b.$root = b.$resolvePrototypes = b.$removeChild = b.$pushPara = b.$pushGlyphs = b.$popPara = b.$onText = b.$onChildCheck = b.$onChild = b.$nsAttributes = b.$nodeName = b.$namespaceId = b.$lastAttribute = b.$isUsable = b.$isTransparent = b.$isThereMoreWidth = b.$isSplittable = b.$isNsAgnostic = b.$isDescendent = b.$isDataValue = b.$isCDATAXml = b.$isBindable = b.$insertAt = b.$indexOf = b.$ids = b.$hasSettableValue = b.$globalData = b.$getTemplateRoot = b.$getSubformParent = b.$getRealChildrenByNameIt = b.$getParent = b.$getNextPage = b.$getExtra = b.$getDataValue = b.$getContainedChildren = b.$getChildrenByNameIt = b.$getChildrenByName = b.$getChildrenByClass = b.$getChildren = b.$getAvailableSpace = b.$getAttributes = b.$getAttributeIt = b.$flushHTML = b.$finalize = b.$extra = b.$dump = b.$data = b.$content = b.$consumed = b.$clone = b.$cleanup = b.$cleanPage = b.$clean = b.$childrenToHTML = b.$appendChild = b.$addHTML = b.$acceptWhitespace = void 0;
          const ce = Symbol();
          b.$acceptWhitespace = ce;
          const n = Symbol();
          b.$addHTML = n;
          const P = Symbol();
          b.$appendChild = P;
          const D = Symbol();
          b.$childrenToHTML = D;
          const e = Symbol();
          b.$clean = e;
          const t = Symbol();
          b.$cleanPage = t;
          const l = Symbol();
          b.$cleanup = l;
          const V = Symbol();
          b.$clone = V;
          const te = Symbol();
          b.$consumed = te;
          const E = Symbol("content");
          b.$content = E;
          const F = Symbol("data");
          b.$data = F;
          const f = Symbol();
          b.$dump = f;
          const x = Symbol("extra");
          b.$extra = x;
          const a = Symbol();
          b.$finalize = a;
          const N = Symbol();
          b.$flushHTML = N;
          const p = Symbol();
          b.$getAttributeIt = p;
          const O = Symbol();
          b.$getAttributes = O;
          const M = Symbol();
          b.$getAvailableSpace = M;
          const R = Symbol();
          b.$getChildrenByClass = R;
          const z = Symbol();
          b.$getChildrenByName = z;
          const W = Symbol();
          b.$getChildrenByNameIt = W;
          const g = Symbol();
          b.$getDataValue = g;
          const T = Symbol();
          b.$getExtra = T;
          const o = Symbol();
          b.$getRealChildrenByNameIt = o;
          const c = Symbol();
          b.$getChildren = c;
          const I = Symbol();
          b.$getContainedChildren = I;
          const s = Symbol();
          b.$getNextPage = s;
          const r = Symbol();
          b.$getSubformParent = r;
          const u = Symbol();
          b.$getParent = u;
          const C = Symbol();
          b.$getTemplateRoot = C;
          const d = Symbol();
          b.$globalData = d;
          const y = Symbol();
          b.$hasSettableValue = y;
          const _ = Symbol();
          b.$ids = _;
          const $ = Symbol();
          b.$indexOf = $;
          const S = Symbol();
          b.$insertAt = S;
          const v = Symbol();
          b.$isCDATAXml = v;
          const m = Symbol();
          b.$isBindable = m;
          const h = Symbol();
          b.$isDataValue = h;
          const A = Symbol();
          b.$isDescendent = A;
          const j = Symbol();
          b.$isNsAgnostic = j;
          const G = Symbol();
          b.$isSplittable = G;
          const J = Symbol();
          b.$isThereMoreWidth = J;
          const oe = Symbol();
          b.$isTransparent = oe;
          const q = Symbol();
          b.$isUsable = q;
          const re = Symbol();
          b.$lastAttribute = re;
          const K = Symbol("namespaceId");
          b.$namespaceId = K;
          const Z = Symbol("nodeName");
          b.$nodeName = Z;
          const w = Symbol();
          b.$nsAttributes = w;
          const k = Symbol();
          b.$onChild = k;
          const X = Symbol();
          b.$onChildCheck = X;
          const H = Symbol();
          b.$onText = H;
          const Y = Symbol();
          b.$pushGlyphs = Y;
          const ie = Symbol();
          b.$popPara = ie;
          const ne = Symbol();
          b.$pushPara = ne;
          const U = Symbol();
          b.$removeChild = U;
          const ae = Symbol("root");
          b.$root = ae;
          const Q = Symbol();
          b.$resolvePrototypes = Q;
          const L = Symbol();
          b.$searchNode = L;
          const ee = Symbol();
          b.$setId = ee;
          const se = Symbol();
          b.$setSetAttributes = se;
          const le = Symbol();
          b.$setValue = le;
          const ue = Symbol();
          b.$tabIndex = ue;
          const de = Symbol();
          b.$text = de;
          const ge = Symbol();
          b.$toPages = ge;
          const me = Symbol();
          b.$toHTML = me;
          const pe = Symbol();
          b.$toString = pe;
          const xe = Symbol();
          b.$toStyle = xe;
          const we = Symbol("uid");
          b.$uid = we;
        },
        /* 79 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Binder = void 0;
          var n = ce(78), P = ce(80), D = ce(88), e = ce(87), t = ce(81), l = ce(2);
          const V = t.NamespaceIds.datasets.id;
          function te(F) {
            const f = new P.Text({});
            return f[n.$content] = F, f;
          }
          class E {
            constructor(f) {
              var x;
              this.root = f, this.datasets = f.datasets, this.data = ((x = f.datasets) == null ? void 0 : x.data) || new e.XmlObject(t.NamespaceIds.datasets.id, "data"), this.emptyMerge = this.data[n.$getChildren]().length === 0, this.root.form = this.form = f.template[n.$clone]();
            }
            _isConsumeData() {
              return !this.emptyMerge && this._mergeMode;
            }
            _isMatchTemplate() {
              return !this._isConsumeData();
            }
            bind() {
              return this._bindElement(this.form, this.data), this.form;
            }
            getData() {
              return this.data;
            }
            _bindValue(f, x, a) {
              var N, p;
              if (f[n.$data] = x, f[n.$hasSettableValue]())
                if (x[n.$isDataValue]()) {
                  const O = x[n.$getDataValue]();
                  f[n.$setValue](te(O));
                } else if (f instanceof P.Field && ((p = (N = f.ui) == null ? void 0 : N.choiceList) == null ? void 0 : p.open) === "multiSelect") {
                  const O = x[n.$getChildren]().map((M) => M[n.$content].trim()).join(`
`);
                  f[n.$setValue](te(O));
                } else
                  this._isConsumeData() && (0, l.warn)("XFA - Nodes haven't the same type.");
              else
                !x[n.$isDataValue]() || this._isMatchTemplate() ? this._bindElement(f, x) : (0, l.warn)("XFA - Nodes haven't the same type.");
            }
            _findDataByNameToConsume(f, x, a, N) {
              if (!f)
                return null;
              let p, O;
              for (let M = 0; M < 3; M++) {
                for (p = a[n.$getRealChildrenByNameIt](f, !1, !0); O = p.next().value, !!O; )
                  if (x === O[n.$isDataValue]())
                    return O;
                if (a[n.$namespaceId] === t.NamespaceIds.datasets.id && a[n.$nodeName] === "data")
                  break;
                a = a[n.$getParent]();
              }
              return N ? (p = this.data[n.$getRealChildrenByNameIt](f, !0, !1), O = p.next().value, O || (p = this.data[n.$getAttributeIt](f, !0), O = p.next().value, O != null && O[n.$isDataValue]()) ? O : null) : null;
            }
            _setProperties(f, x) {
              if (f.hasOwnProperty("setProperty"))
                for (const {
                  ref: a,
                  target: N,
                  connection: p
                } of f.setProperty.children) {
                  if (p || !a)
                    continue;
                  const O = (0, D.searchNode)(this.root, x, a, !1, !1);
                  if (!O) {
                    (0, l.warn)(`XFA - Invalid reference: ${a}.`);
                    continue;
                  }
                  const [M] = O;
                  if (!M[n.$isDescendent](this.data)) {
                    (0, l.warn)("XFA - Invalid node: must be a data node.");
                    continue;
                  }
                  const R = (0, D.searchNode)(this.root, f, N, !1, !1);
                  if (!R) {
                    (0, l.warn)(`XFA - Invalid target: ${N}.`);
                    continue;
                  }
                  const [z] = R;
                  if (!z[n.$isDescendent](f)) {
                    (0, l.warn)("XFA - Invalid target: must be a property or subproperty.");
                    continue;
                  }
                  const W = z[n.$getParent]();
                  if (z instanceof P.SetProperty || W instanceof P.SetProperty) {
                    (0, l.warn)("XFA - Invalid target: cannot be a setProperty or one of its properties.");
                    continue;
                  }
                  if (z instanceof P.BindItems || W instanceof P.BindItems) {
                    (0, l.warn)("XFA - Invalid target: cannot be a bindItems or one of its properties.");
                    continue;
                  }
                  const g = M[n.$text](), T = z[n.$nodeName];
                  if (z instanceof e.XFAAttribute) {
                    const o = /* @__PURE__ */ Object.create(null);
                    o[T] = g;
                    const c = Reflect.construct(Object.getPrototypeOf(W).constructor, [o]);
                    W[T] = c[T];
                    continue;
                  }
                  if (!z.hasOwnProperty(n.$content)) {
                    (0, l.warn)("XFA - Invalid node to use in setProperty");
                    continue;
                  }
                  z[n.$data] = M, z[n.$content] = g, z[n.$finalize]();
                }
            }
            _bindItems(f, x) {
              if (!f.hasOwnProperty("items") || !f.hasOwnProperty("bindItems") || f.bindItems.isEmpty())
                return;
              for (const p of f.items.children)
                f[n.$removeChild](p);
              f.items.clear();
              const a = new P.Items({}), N = new P.Items({});
              f[n.$appendChild](a), f.items.push(a), f[n.$appendChild](N), f.items.push(N);
              for (const {
                ref: p,
                labelRef: O,
                valueRef: M,
                connection: R
              } of f.bindItems.children) {
                if (R || !p)
                  continue;
                const z = (0, D.searchNode)(this.root, x, p, !1, !1);
                if (!z) {
                  (0, l.warn)(`XFA - Invalid reference: ${p}.`);
                  continue;
                }
                for (const W of z) {
                  if (!W[n.$isDescendent](this.datasets)) {
                    (0, l.warn)(`XFA - Invalid ref (${p}): must be a datasets child.`);
                    continue;
                  }
                  const g = (0, D.searchNode)(this.root, W, O, !0, !1);
                  if (!g) {
                    (0, l.warn)(`XFA - Invalid label: ${O}.`);
                    continue;
                  }
                  const [T] = g;
                  if (!T[n.$isDescendent](this.datasets)) {
                    (0, l.warn)("XFA - Invalid label: must be a datasets child.");
                    continue;
                  }
                  const o = (0, D.searchNode)(this.root, W, M, !0, !1);
                  if (!o) {
                    (0, l.warn)(`XFA - Invalid value: ${M}.`);
                    continue;
                  }
                  const [c] = o;
                  if (!c[n.$isDescendent](this.datasets)) {
                    (0, l.warn)("XFA - Invalid value: must be a datasets child.");
                    continue;
                  }
                  const I = te(T[n.$text]()), s = te(c[n.$text]());
                  a[n.$appendChild](I), a.text.push(I), N[n.$appendChild](s), N.text.push(s);
                }
              }
            }
            _bindOccurrences(f, x, a) {
              let N;
              if (x.length > 1 && (N = f[n.$clone](), N[n.$removeChild](N.occur), N.occur = null), this._bindValue(f, x[0], a), this._setProperties(f, x[0]), this._bindItems(f, x[0]), x.length === 1)
                return;
              const p = f[n.$getParent](), O = f[n.$nodeName], M = p[n.$indexOf](f);
              for (let R = 1, z = x.length; R < z; R++) {
                const W = x[R], g = N[n.$clone]();
                p[O].push(g), p[n.$insertAt](M + R, g), this._bindValue(g, W, a), this._setProperties(g, W), this._bindItems(g, W);
              }
            }
            _createOccurrences(f) {
              if (!this.emptyMerge)
                return;
              const {
                occur: x
              } = f;
              if (!x || x.initial <= 1)
                return;
              const a = f[n.$getParent](), N = f[n.$nodeName];
              if (!(a[N] instanceof e.XFAObjectArray))
                return;
              let p;
              f.name ? p = a[N].children.filter((R) => R.name === f.name).length : p = a[N].children.length;
              const O = a[n.$indexOf](f) + 1, M = x.initial - p;
              if (M) {
                const R = f[n.$clone]();
                R[n.$removeChild](R.occur), R.occur = null, a[N].push(R), a[n.$insertAt](O, R);
                for (let z = 1; z < M; z++) {
                  const W = R[n.$clone]();
                  a[N].push(W), a[n.$insertAt](O + z, W);
                }
              }
            }
            _getOccurInfo(f) {
              const {
                name: x,
                occur: a
              } = f;
              if (!a || !x)
                return [1, 1];
              const N = a.max === -1 ? 1 / 0 : a.max;
              return [a.min, N];
            }
            _setAndBind(f, x) {
              this._setProperties(f, x), this._bindItems(f, x), this._bindElement(f, x);
            }
            _bindElement(f, x) {
              const a = [];
              this._createOccurrences(f);
              for (const N of f[n.$getChildren]()) {
                if (N[n.$data])
                  continue;
                if (this._mergeMode === void 0 && N[n.$nodeName] === "subform") {
                  this._mergeMode = N.mergeMode === "consumeData";
                  const g = x[n.$getChildren]();
                  if (g.length > 0)
                    this._bindOccurrences(N, [g[0]], null);
                  else if (this.emptyMerge) {
                    const T = x[n.$namespaceId] === V ? -1 : x[n.$namespaceId], o = N[n.$data] = new e.XmlObject(T, N.name || "root");
                    x[n.$appendChild](o), this._bindElement(N, o);
                  }
                  continue;
                }
                if (!N[n.$isBindable]())
                  continue;
                let p = !1, O = null, M = null, R = null;
                if (N.bind) {
                  switch (N.bind.match) {
                    case "none":
                      this._setAndBind(N, x);
                      continue;
                    case "global":
                      p = !0;
                      break;
                    case "dataRef":
                      if (!N.bind.ref) {
                        (0, l.warn)(`XFA - ref is empty in node ${N[n.$nodeName]}.`), this._setAndBind(N, x);
                        continue;
                      }
                      M = N.bind.ref;
                      break;
                  }
                  N.bind.picture && (O = N.bind.picture[n.$content]);
                }
                const [z, W] = this._getOccurInfo(N);
                if (M)
                  if (R = (0, D.searchNode)(this.root, x, M, !0, !1), R === null) {
                    if (R = (0, D.createDataNode)(this.data, x, M), !R)
                      continue;
                    this._isConsumeData() && (R[n.$consumed] = !0), this._setAndBind(N, R);
                    continue;
                  } else
                    this._isConsumeData() && (R = R.filter((g) => !g[n.$consumed])), R.length > W ? R = R.slice(0, W) : R.length === 0 && (R = null), R && this._isConsumeData() && R.forEach((g) => {
                      g[n.$consumed] = !0;
                    });
                else {
                  if (!N.name) {
                    this._setAndBind(N, x);
                    continue;
                  }
                  if (this._isConsumeData()) {
                    const g = [];
                    for (; g.length < W; ) {
                      const T = this._findDataByNameToConsume(N.name, N[n.$hasSettableValue](), x, p);
                      if (!T)
                        break;
                      T[n.$consumed] = !0, g.push(T);
                    }
                    R = g.length > 0 ? g : null;
                  } else {
                    if (R = x[n.$getRealChildrenByNameIt](N.name, !1, this.emptyMerge).next().value, !R) {
                      if (z === 0) {
                        a.push(N);
                        continue;
                      }
                      const g = x[n.$namespaceId] === V ? -1 : x[n.$namespaceId];
                      R = N[n.$data] = new e.XmlObject(g, N.name), this.emptyMerge && (R[n.$consumed] = !0), x[n.$appendChild](R), this._setAndBind(N, R);
                      continue;
                    }
                    this.emptyMerge && (R[n.$consumed] = !0), R = [R];
                  }
                }
                R ? this._bindOccurrences(N, R, O) : z > 0 ? this._setAndBind(N, x) : a.push(N);
              }
              a.forEach((N) => N[n.$getParent]()[n.$removeChild](N));
            }
          }
          b.Binder = E;
        },
        /* 80 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Value = b.Text = b.TemplateNamespace = b.Template = b.SetProperty = b.Items = b.Field = b.BindItems = void 0;
          var n = ce(78), P = ce(81), D = ce(82), e = ce(83), t = ce(87), l = ce(84), V = ce(2), te = ce(85), E = ce(3), F = ce(88);
          const f = P.NamespaceIds.template.id, x = "http://www.w3.org/2000/svg", a = 2, N = 3, p = 5e3, O = /^H(\d+)$/, M = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), R = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
          function z(ke) {
            if (!ke || !ke.border)
              return {
                w: 0,
                h: 0
              };
            const i = ke.border[n.$getExtra]();
            return i ? {
              w: i.widths[0] + i.widths[2] + i.insets[0] + i.insets[2],
              h: i.widths[1] + i.widths[3] + i.insets[1] + i.insets[3]
            } : {
              w: 0,
              h: 0
            };
          }
          function W(ke) {
            return ke.margin && (ke.margin.topInset || ke.margin.rightInset || ke.margin.bottomInset || ke.margin.leftInset);
          }
          function g(ke, i) {
            if (!ke.value) {
              const B = new tn({});
              ke[n.$appendChild](B), ke.value = B;
            }
            ke.value[n.$setValue](i);
          }
          function* T(ke) {
            for (const i of ke[n.$getChildren]()) {
              if (i instanceof cn) {
                yield* i[n.$getContainedChildren]();
                continue;
              }
              yield i;
            }
          }
          function o(ke) {
            var i;
            return ((i = ke.validate) == null ? void 0 : i.nullTest) === "error";
          }
          function c(ke) {
            for (; ke; ) {
              if (!ke.traversal) {
                ke[n.$tabIndex] = ke[n.$getParent]()[n.$tabIndex];
                return;
              }
              if (ke[n.$tabIndex])
                return;
              let i = null;
              for (const ve of ke.traversal[n.$getChildren]())
                if (ve.operation === "next") {
                  i = ve;
                  break;
                }
              if (!i || !i.ref) {
                ke[n.$tabIndex] = ke[n.$getParent]()[n.$tabIndex];
                return;
              }
              const B = ke[n.$getTemplateRoot]();
              ke[n.$tabIndex] = ++B[n.$tabIndex];
              const Se = B[n.$searchNode](i.ref, ke);
              if (!Se)
                return;
              ke = Se[0];
            }
          }
          function I(ke, i) {
            var Se;
            const B = ke.assist;
            if (B) {
              const ve = B[n.$toHTML]();
              ve && (i.title = ve);
              const _e = B.role.match(O);
              if (_e) {
                const Ke = "heading", Ye = _e[1];
                i.role = Ke, i["aria-level"] = Ye;
              }
            }
            if (ke.layout === "table")
              i.role = "table";
            else if (ke.layout === "row")
              i.role = "row";
            else {
              const ve = ke[n.$getParent]();
              ve.layout === "row" && (i.role = ((Se = ve.assist) == null ? void 0 : Se.role) === "TH" ? "columnheader" : "cell");
            }
          }
          function s(ke) {
            if (!ke.assist)
              return null;
            const i = ke.assist;
            return i.speak && i.speak[n.$content] !== "" ? i.speak[n.$content] : i.toolTip ? i.toolTip[n.$content] : null;
          }
          function r(ke) {
            return l.HTMLResult.success({
              name: "div",
              attributes: {
                class: ["xfaRich"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: [{
                name: "span",
                attributes: {
                  style: /* @__PURE__ */ Object.create(null)
                },
                value: ke
              }]
            });
          }
          function u(ke) {
            const i = ke[n.$getTemplateRoot]();
            i[n.$extra].firstUnsplittable === null && (i[n.$extra].firstUnsplittable = ke, i[n.$extra].noLayoutFailure = !0);
          }
          function C(ke) {
            const i = ke[n.$getTemplateRoot]();
            i[n.$extra].firstUnsplittable === ke && (i[n.$extra].noLayoutFailure = !1);
          }
          function d(ke) {
            if (ke[n.$extra] || (ke[n.$extra] = /* @__PURE__ */ Object.create(null), ke.targetType === "auto"))
              return !1;
            const i = ke[n.$getTemplateRoot]();
            let B = null;
            if (ke.target) {
              if (B = i[n.$searchNode](ke.target, ke[n.$getParent]()), !B)
                return !1;
              B = B[0];
            }
            const {
              currentPageArea: Se,
              currentContentArea: ve
            } = i[n.$extra];
            if (ke.targetType === "pageArea")
              return B instanceof tt || (B = null), ke.startNew ? (ke[n.$extra].target = B || Se, !0) : B && B !== Se ? (ke[n.$extra].target = B, !0) : !1;
            B instanceof ae || (B = null);
            const Te = B && B[n.$getParent]();
            let _e, Ke = Te;
            if (ke.startNew)
              if (B) {
                const Ye = Te.contentArea.children, gt = Ye.indexOf(ve), yt = Ye.indexOf(B);
                gt !== -1 && gt < yt && (Ke = null), _e = yt - 1;
              } else
                _e = Se.contentArea.children.indexOf(ve);
            else if (B && B !== ve)
              _e = Te.contentArea.children.indexOf(B) - 1, Ke = Te === Se ? null : Te;
            else
              return !1;
            return ke[n.$extra].target = Ke, ke[n.$extra].index = _e, !0;
          }
          function y(ke, i, B) {
            const Se = ke[n.$getTemplateRoot](), ve = Se[n.$extra].noLayoutFailure, Te = i[n.$getSubformParent];
            i[n.$getSubformParent] = () => ke, Se[n.$extra].noLayoutFailure = !0;
            const _e = i[n.$toHTML](B);
            ke[n.$addHTML](_e.html, _e.bbox), Se[n.$extra].noLayoutFailure = ve, i[n.$getSubformParent] = Te;
          }
          class _ extends t.StringObject {
            constructor(i) {
              super(f, "appearanceFilter"), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class $ extends t.XFAObject {
            constructor(i) {
              super(f, "arc", !0), this.circular = (0, l.getInteger)({
                data: i.circular,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.hand = (0, l.getStringOption)(i.hand, ["even", "left", "right"]), this.id = i.id || "", this.startAngle = (0, l.getFloat)({
                data: i.startAngle,
                defaultValue: 0,
                validate: (B) => !0
              }), this.sweepAngle = (0, l.getFloat)({
                data: i.sweepAngle,
                defaultValue: 360,
                validate: (B) => !0
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.edge = null, this.fill = null;
            }
            [n.$toHTML]() {
              var Ye;
              const i = this.edge || new xe({}), B = i[n.$toStyle](), Se = /* @__PURE__ */ Object.create(null);
              ((Ye = this.fill) == null ? void 0 : Ye.presence) === "visible" ? Object.assign(Se, this.fill[n.$toStyle]()) : Se.fill = "transparent", Se.strokeWidth = (0, e.measureToString)(i.presence === "visible" ? i.thickness : 0), Se.stroke = B.color;
              let ve;
              const Te = {
                xmlns: x,
                style: {
                  width: "100%",
                  height: "100%",
                  overflow: "visible"
                }
              };
              if (this.sweepAngle === 360)
                ve = {
                  name: "ellipse",
                  attributes: {
                    xmlns: x,
                    cx: "50%",
                    cy: "50%",
                    rx: "50%",
                    ry: "50%",
                    style: Se
                  }
                };
              else {
                const gt = this.startAngle * Math.PI / 180, yt = this.sweepAngle * Math.PI / 180, Tt = this.sweepAngle > 180 ? 1 : 0, [Ft, Et, Bt, xt] = [50 * (1 + Math.cos(gt)), 50 * (1 - Math.sin(gt)), 50 * (1 + Math.cos(gt + yt)), 50 * (1 - Math.sin(gt + yt))];
                ve = {
                  name: "path",
                  attributes: {
                    xmlns: x,
                    d: `M ${Ft} ${Et} A 50 50 0 ${Tt} 0 ${Bt} ${xt}`,
                    vectorEffect: "non-scaling-stroke",
                    style: Se
                  }
                }, Object.assign(Te, {
                  viewBox: "0 0 100 100",
                  preserveAspectRatio: "none"
                });
              }
              const _e = {
                name: "svg",
                children: [ve],
                attributes: Te
              }, Ke = this[n.$getParent]()[n.$getParent]();
              return W(Ke) ? l.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [_e]
              }) : (_e.attributes.style.position = "absolute", l.HTMLResult.success(_e));
            }
          }
          class S extends t.XFAObject {
            constructor(i) {
              super(f, "area", !0), this.colSpan = (0, l.getInteger)({
                data: i.colSpan,
                defaultValue: 1,
                validate: (B) => B >= 1 || B === -1
              }), this.id = i.id || "", this.name = i.name || "", this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.desc = null, this.extras = null, this.area = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[n.$getContainedChildren]() {
              yield* T(this);
            }
            [n.$isTransparent]() {
              return !0;
            }
            [n.$isBindable]() {
              return !0;
            }
            [n.$addHTML](i, B) {
              const [Se, ve, Te, _e] = B;
              this[n.$extra].width = Math.max(this[n.$extra].width, Se + Te), this[n.$extra].height = Math.max(this[n.$extra].height, ve + _e), this[n.$extra].children.push(i);
            }
            [n.$getAvailableSpace]() {
              return this[n.$extra].availableSpace;
            }
            [n.$toHTML](i) {
              const B = (0, e.toStyle)(this, "position"), Se = {
                style: B,
                id: this[n.$uid],
                class: ["xfaArea"]
              };
              (0, e.isPrintOnly)(this) && Se.class.push("xfaPrintOnly"), this.name && (Se.xfaName = this.name);
              const ve = [];
              this[n.$extra] = {
                children: ve,
                width: 0,
                height: 0,
                availableSpace: i
              };
              const Te = this[n.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
                include: !0
              });
              if (!Te.success)
                return Te.isBreak() ? Te : (delete this[n.$extra], l.HTMLResult.FAILURE);
              B.width = (0, e.measureToString)(this[n.$extra].width), B.height = (0, e.measureToString)(this[n.$extra].height);
              const _e = {
                name: "div",
                attributes: Se,
                children: ve
              }, Ke = [this.x, this.y, this[n.$extra].width, this[n.$extra].height];
              return delete this[n.$extra], l.HTMLResult.success(_e, Ke);
            }
          }
          class v extends t.XFAObject {
            constructor(i) {
              super(f, "assist", !0), this.id = i.id || "", this.role = i.role || "", this.use = i.use || "", this.usehref = i.usehref || "", this.speak = null, this.toolTip = null;
            }
            [n.$toHTML]() {
              var i;
              return ((i = this.toolTip) == null ? void 0 : i[n.$content]) || null;
            }
          }
          class m extends t.XFAObject {
            constructor(i) {
              super(f, "barcode", !0), this.charEncoding = (0, l.getKeyword)({
                data: i.charEncoding ? i.charEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (B) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(B) || B.match(/iso-8859-\d{2}/)
              }), this.checksum = (0, l.getStringOption)(i.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = (0, l.getInteger)({
                data: i.dataColumnCount,
                defaultValue: -1,
                validate: (B) => B >= 0
              }), this.dataLength = (0, l.getInteger)({
                data: i.dataLength,
                defaultValue: -1,
                validate: (B) => B >= 0
              }), this.dataPrep = (0, l.getStringOption)(i.dataPrep, ["none", "flateCompress"]), this.dataRowCount = (0, l.getInteger)({
                data: i.dataRowCount,
                defaultValue: -1,
                validate: (B) => B >= 0
              }), this.endChar = i.endChar || "", this.errorCorrectionLevel = (0, l.getInteger)({
                data: i.errorCorrectionLevel,
                defaultValue: -1,
                validate: (B) => B >= 0 && B <= 8
              }), this.id = i.id || "", this.moduleHeight = (0, l.getMeasurement)(i.moduleHeight, "5mm"), this.moduleWidth = (0, l.getMeasurement)(i.moduleWidth, "0.25mm"), this.printCheckDigit = (0, l.getInteger)({
                data: i.printCheckDigit,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.rowColumnRatio = (0, l.getRatio)(i.rowColumnRatio), this.startChar = i.startChar || "", this.textLocation = (0, l.getStringOption)(i.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = (0, l.getInteger)({
                data: i.truncate,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.type = (0, l.getStringOption)(i.type ? i.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = (0, l.getStringOption)(i.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = i.use || "", this.usehref = i.usehref || "", this.wideNarrowRatio = (0, l.getRatio)(i.wideNarrowRatio), this.encrypt = null, this.extras = null;
            }
          }
          class h extends t.XFAObject {
            constructor(i) {
              super(f, "bind", !0), this.match = (0, l.getStringOption)(i.match, ["once", "dataRef", "global", "none"]), this.ref = i.ref || "", this.picture = null;
            }
          }
          class A extends t.XFAObject {
            constructor(i) {
              super(f, "bindItems"), this.connection = i.connection || "", this.labelRef = i.labelRef || "", this.ref = i.ref || "", this.valueRef = i.valueRef || "";
            }
          }
          b.BindItems = A;
          class j extends t.XFAObject {
            constructor(i) {
              super(f, "bookend"), this.id = i.id || "", this.leader = i.leader || "", this.trailer = i.trailer || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class G extends t.Option01 {
            constructor(i) {
              super(f, "boolean"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$toHTML](i) {
              return r(this[n.$content] === 1 ? "1" : "0");
            }
          }
          class J extends t.XFAObject {
            constructor(i) {
              super(f, "border", !0), this.break = (0, l.getStringOption)(i.break, ["close", "open"]), this.hand = (0, l.getStringOption)(i.hand, ["even", "left", "right"]), this.id = i.id || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.extras = null, this.fill = null, this.margin = null;
            }
            [n.$getExtra]() {
              if (!this[n.$extra]) {
                const i = this.edge.children.slice();
                if (i.length < 4) {
                  const ve = i.at(-1) || new xe({});
                  for (let Te = i.length; Te < 4; Te++)
                    i.push(ve);
                }
                const B = i.map((ve) => ve.thickness), Se = [0, 0, 0, 0];
                this.margin && (Se[0] = this.margin.topInset, Se[1] = this.margin.rightInset, Se[2] = this.margin.bottomInset, Se[3] = this.margin.leftInset), this[n.$extra] = {
                  widths: B,
                  insets: Se,
                  edges: i
                };
              }
              return this[n.$extra];
            }
            [n.$toStyle]() {
              var ve;
              const {
                edges: i
              } = this[n.$getExtra](), B = i.map((Te) => {
                const _e = Te[n.$toStyle]();
                return _e.color || (_e.color = "#000000"), _e;
              }), Se = /* @__PURE__ */ Object.create(null);
              if (this.margin && Object.assign(Se, this.margin[n.$toStyle]()), ((ve = this.fill) == null ? void 0 : ve.presence) === "visible" && Object.assign(Se, this.fill[n.$toStyle]()), this.corner.children.some((Te) => Te.radius !== 0)) {
                const Te = this.corner.children.map((_e) => _e[n.$toStyle]());
                if (Te.length === 2 || Te.length === 3) {
                  const _e = Te.at(-1);
                  for (let Ke = Te.length; Ke < 4; Ke++)
                    Te.push(_e);
                }
                Se.borderRadius = Te.map((_e) => _e.radius).join(" ");
              }
              switch (this.presence) {
                case "invisible":
                case "hidden":
                  Se.borderStyle = "";
                  break;
                case "inactive":
                  Se.borderStyle = "none";
                  break;
                default:
                  Se.borderStyle = B.map((Te) => Te.style).join(" ");
                  break;
              }
              return Se.borderWidth = B.map((Te) => Te.width).join(" "), Se.borderColor = B.map((Te) => Te.color).join(" "), Se;
            }
          }
          class oe extends t.XFAObject {
            constructor(i) {
              super(f, "break", !0), this.after = (0, l.getStringOption)(i.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = i.afterTarget || "", this.before = (0, l.getStringOption)(i.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = i.beforeTarget || "", this.bookendLeader = i.bookendLeader || "", this.bookendTrailer = i.bookendTrailer || "", this.id = i.id || "", this.overflowLeader = i.overflowLeader || "", this.overflowTarget = i.overflowTarget || "", this.overflowTrailer = i.overflowTrailer || "", this.startNew = (0, l.getInteger)({
                data: i.startNew,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
          }
          class q extends t.XFAObject {
            constructor(i) {
              super(f, "breakAfter", !0), this.id = i.id || "", this.leader = i.leader || "", this.startNew = (0, l.getInteger)({
                data: i.startNew,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.target = i.target || "", this.targetType = (0, l.getStringOption)(i.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = i.trailer || "", this.use = i.use || "", this.usehref = i.usehref || "", this.script = null;
            }
          }
          class re extends t.XFAObject {
            constructor(i) {
              super(f, "breakBefore", !0), this.id = i.id || "", this.leader = i.leader || "", this.startNew = (0, l.getInteger)({
                data: i.startNew,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.target = i.target || "", this.targetType = (0, l.getStringOption)(i.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = i.trailer || "", this.use = i.use || "", this.usehref = i.usehref || "", this.script = null;
            }
            [n.$toHTML](i) {
              return this[n.$extra] = {}, l.HTMLResult.FAILURE;
            }
          }
          class K extends t.XFAObject {
            constructor(i) {
              super(f, "button", !0), this.highlight = (0, l.getStringOption)(i.highlight, ["inverted", "none", "outline", "push"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
            [n.$toHTML](i) {
              const Se = this[n.$getParent]()[n.$getParent](), ve = {
                name: "button",
                attributes: {
                  id: this[n.$uid],
                  class: ["xfaButton"],
                  style: {}
                },
                children: []
              };
              for (const Te of Se.event.children) {
                if (Te.activity !== "click" || !Te.script)
                  continue;
                const _e = (0, E.recoverJsURL)(Te.script[n.$content]);
                if (!_e)
                  continue;
                const Ke = (0, e.fixURL)(_e.url);
                Ke && ve.children.push({
                  name: "a",
                  attributes: {
                    id: "link" + this[n.$uid],
                    href: Ke,
                    newWindow: _e.newWindow,
                    class: ["xfaLink"],
                    style: {}
                  },
                  children: []
                });
              }
              return l.HTMLResult.success(ve);
            }
          }
          class Z extends t.XFAObject {
            constructor(i) {
              super(f, "calculate", !0), this.id = i.id || "", this.override = (0, l.getStringOption)(i.override, ["disabled", "error", "ignore", "warning"]), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.message = null, this.script = null;
            }
          }
          class w extends t.XFAObject {
            constructor(i) {
              super(f, "caption", !0), this.id = i.id || "", this.placement = (0, l.getStringOption)(i.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil((0, l.getMeasurement)(i.reserve)), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
            }
            [n.$setValue](i) {
              g(this, i);
            }
            [n.$getExtra](i) {
              if (!this[n.$extra]) {
                let {
                  width: B,
                  height: Se
                } = i;
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    B = this.reserve <= 0 ? B : this.reserve;
                    break;
                  case "top":
                  case "bottom":
                    Se = this.reserve <= 0 ? Se : this.reserve;
                    break;
                }
                this[n.$extra] = (0, e.layoutNode)(this, {
                  width: B,
                  height: Se
                });
              }
              return this[n.$extra];
            }
            [n.$toHTML](i) {
              if (!this.value)
                return l.HTMLResult.EMPTY;
              this[n.$pushPara]();
              const B = this.value[n.$toHTML](i).html;
              if (!B)
                return this[n.$popPara](), l.HTMLResult.EMPTY;
              const Se = this.reserve;
              if (this.reserve <= 0) {
                const {
                  w: _e,
                  h: Ke
                } = this[n.$getExtra](i);
                switch (this.placement) {
                  case "left":
                  case "right":
                  case "inline":
                    this.reserve = _e;
                    break;
                  case "top":
                  case "bottom":
                    this.reserve = Ke;
                    break;
                }
              }
              const ve = [];
              typeof B == "string" ? ve.push({
                name: "#text",
                value: B
              }) : ve.push(B);
              const Te = (0, e.toStyle)(this, "font", "margin", "visibility");
              switch (this.placement) {
                case "left":
                case "right":
                  this.reserve > 0 && (Te.width = (0, e.measureToString)(this.reserve));
                  break;
                case "top":
                case "bottom":
                  this.reserve > 0 && (Te.height = (0, e.measureToString)(this.reserve));
                  break;
              }
              return (0, e.setPara)(this, null, B), this[n.$popPara](), this.reserve = Se, l.HTMLResult.success({
                name: "div",
                attributes: {
                  style: Te,
                  class: ["xfaCaption"]
                },
                children: ve
              });
            }
          }
          class k extends t.StringObject {
            constructor(i) {
              super(f, "certificate"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class X extends t.XFAObject {
            constructor(i) {
              super(f, "certificates", !0), this.credentialServerPolicy = (0, l.getStringOption)(i.credentialServerPolicy, ["optional", "required"]), this.id = i.id || "", this.url = i.url || "", this.urlPolicy = i.urlPolicy || "", this.use = i.use || "", this.usehref = i.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
            }
          }
          class H extends t.XFAObject {
            constructor(i) {
              super(f, "checkButton", !0), this.id = i.id || "", this.mark = (0, l.getStringOption)(i.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = (0, l.getStringOption)(i.shape, ["square", "round"]), this.size = (0, l.getMeasurement)(i.size, "10pt"), this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              var Xt, Dt, Wt;
              const B = (0, e.toStyle)("margin"), Se = (0, e.measureToString)(this.size);
              B.width = B.height = Se;
              let ve, Te, _e;
              const Ke = this[n.$getParent]()[n.$getParent](), Ye = Ke.items.children.length && Ke.items.children[0][n.$toHTML]().html || [], gt = {
                on: (Ye[0] !== void 0 ? Ye[0] : "on").toString(),
                off: (Ye[1] !== void 0 ? Ye[1] : "off").toString()
              }, Tt = (((Xt = Ke.value) == null ? void 0 : Xt[n.$text]()) || "off") === gt.on || void 0, Ft = Ke[n.$getSubformParent](), Et = Ke[n.$uid];
              let Bt;
              Ft instanceof Oe ? (_e = Ft[n.$uid], ve = "radio", Te = "xfaRadio", Bt = ((Dt = Ft[n.$data]) == null ? void 0 : Dt[n.$uid]) || Ft[n.$uid]) : (ve = "checkbox", Te = "xfaCheckbox", Bt = ((Wt = Ke[n.$data]) == null ? void 0 : Wt[n.$uid]) || Ke[n.$uid]);
              const xt = {
                name: "input",
                attributes: {
                  class: [Te],
                  style: B,
                  fieldId: Et,
                  dataId: Bt,
                  type: ve,
                  checked: Tt,
                  xfaOn: gt.on,
                  xfaOff: gt.off,
                  "aria-label": s(Ke),
                  "aria-required": !1
                }
              };
              return _e && (xt.attributes.name = _e), o(Ke) && (xt.attributes["aria-required"] = !0, xt.attributes.required = !0), l.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [xt]
              });
            }
          }
          class Y extends t.XFAObject {
            constructor(i) {
              super(f, "choiceList", !0), this.commitOn = (0, l.getStringOption)(i.commitOn, ["select", "exit"]), this.id = i.id || "", this.open = (0, l.getStringOption)(i.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = (0, l.getInteger)({
                data: i.textEntry,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              var gt, yt, Tt;
              const B = (0, e.toStyle)(this, "border", "margin"), ve = this[n.$getParent]()[n.$getParent](), _e = {
                fontSize: `calc(${((gt = ve.font) == null ? void 0 : gt.size) || 10}px * var(--scale-factor))`
              }, Ke = [];
              if (ve.items.children.length > 0) {
                const Ft = ve.items;
                let Et = 0, Bt = 0;
                Ft.children.length === 2 && (Et = Ft.children[0].save, Bt = 1 - Et);
                const xt = Ft.children[Et][n.$toHTML]().html, Xt = Ft.children[Bt][n.$toHTML]().html;
                let Dt = !1;
                const Wt = ((yt = ve.value) == null ? void 0 : yt[n.$text]()) || "";
                for (let Ht = 0, St = xt.length; Ht < St; Ht++) {
                  const Ze = {
                    name: "option",
                    attributes: {
                      value: Xt[Ht] || xt[Ht],
                      style: _e
                    },
                    value: xt[Ht]
                  };
                  Xt[Ht] === Wt && (Ze.attributes.selected = Dt = !0), Ke.push(Ze);
                }
                Dt || Ke.splice(0, 0, {
                  name: "option",
                  attributes: {
                    hidden: !0,
                    selected: !0
                  },
                  value: " "
                });
              }
              const Ye = {
                class: ["xfaSelect"],
                fieldId: ve[n.$uid],
                dataId: ((Tt = ve[n.$data]) == null ? void 0 : Tt[n.$uid]) || ve[n.$uid],
                style: B,
                "aria-label": s(ve),
                "aria-required": !1
              };
              return o(ve) && (Ye["aria-required"] = !0, Ye.required = !0), this.open === "multiSelect" && (Ye.multiple = !0), l.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [{
                  name: "select",
                  children: Ke,
                  attributes: Ye
                }]
              });
            }
          }
          class ie extends t.XFAObject {
            constructor(i) {
              super(f, "color", !0), this.cSpace = (0, l.getStringOption)(i.cSpace, ["SRGB"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.value = i.value ? (0, l.getColor)(i.value) : "", this.extras = null;
            }
            [n.$hasSettableValue]() {
              return !1;
            }
            [n.$toStyle]() {
              return this.value ? V.Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
            }
          }
          class ne extends t.XFAObject {
            constructor(i) {
              super(f, "comb"), this.id = i.id || "", this.numberOfCells = (0, l.getInteger)({
                data: i.numberOfCells,
                defaultValue: 0,
                validate: (B) => B >= 0
              }), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class U extends t.XFAObject {
            constructor(i) {
              super(f, "connect", !0), this.connection = i.connection || "", this.id = i.id || "", this.ref = i.ref || "", this.usage = (0, l.getStringOption)(i.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = i.use || "", this.usehref = i.usehref || "", this.picture = null;
            }
          }
          class ae extends t.XFAObject {
            constructor(i) {
              super(f, "contentArea", !0), this.h = (0, l.getMeasurement)(i.h), this.id = i.id || "", this.name = i.name || "", this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.w = (0, l.getMeasurement)(i.w), this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.desc = null, this.extras = null;
            }
            [n.$toHTML](i) {
              const B = (0, e.measureToString)(this.x), Se = (0, e.measureToString)(this.y), ve = {
                left: B,
                top: Se,
                width: (0, e.measureToString)(this.w),
                height: (0, e.measureToString)(this.h)
              }, Te = ["xfaContentarea"];
              return (0, e.isPrintOnly)(this) && Te.push("xfaPrintOnly"), l.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {
                  style: ve,
                  class: Te,
                  id: this[n.$uid]
                }
              });
            }
          }
          class Q extends t.XFAObject {
            constructor(i) {
              super(f, "corner", !0), this.id = i.id || "", this.inverted = (0, l.getInteger)({
                data: i.inverted,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.join = (0, l.getStringOption)(i.join, ["square", "round"]), this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = (0, l.getMeasurement)(i.radius), this.stroke = (0, l.getStringOption)(i.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, l.getMeasurement)(i.thickness, "0.5pt"), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle]() {
              const i = (0, e.toStyle)(this, "visibility");
              return i.radius = (0, e.measureToString)(this.join === "square" ? 0 : this.radius), i;
            }
          }
          class L extends t.ContentObject {
            constructor(i) {
              super(f, "date"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = this[n.$content].trim();
              this[n.$content] = i ? new Date(i) : null;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] ? this[n.$content].toString() : "");
            }
          }
          class ee extends t.ContentObject {
            constructor(i) {
              super(f, "dateTime"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = this[n.$content].trim();
              this[n.$content] = i ? new Date(i) : null;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] ? this[n.$content].toString() : "");
            }
          }
          class se extends t.XFAObject {
            constructor(i) {
              super(f, "dateTimeEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(i.hScrollPolicy, ["auto", "off", "on"]), this.id = i.id || "", this.picker = (0, l.getStringOption)(i.picker, ["host", "none"]), this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              var Te;
              const B = (0, e.toStyle)(this, "border", "font", "margin"), Se = this[n.$getParent]()[n.$getParent](), ve = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: Se[n.$uid],
                  dataId: ((Te = Se[n.$data]) == null ? void 0 : Te[n.$uid]) || Se[n.$uid],
                  class: ["xfaTextfield"],
                  style: B,
                  "aria-label": s(Se),
                  "aria-required": !1
                }
              };
              return o(Se) && (ve.attributes["aria-required"] = !0, ve.attributes.required = !0), l.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [ve]
              });
            }
          }
          class le extends t.ContentObject {
            constructor(i) {
              super(f, "decimal"), this.fracDigits = (0, l.getInteger)({
                data: i.fracDigits,
                defaultValue: 2,
                validate: (B) => !0
              }), this.id = i.id || "", this.leadDigits = (0, l.getInteger)({
                data: i.leadDigits,
                defaultValue: -1,
                validate: (B) => !0
              }), this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = parseFloat(this[n.$content].trim());
              this[n.$content] = isNaN(i) ? null : i;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] !== null ? this[n.$content].toString() : "");
            }
          }
          class ue extends t.XFAObject {
            constructor(i) {
              super(f, "defaultUi", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
          }
          class de extends t.XFAObject {
            constructor(i) {
              super(f, "desc", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class ge extends t.OptionObject {
            constructor(i) {
              super(f, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class me extends t.XFAObject {
            constructor(i) {
              super(f, "digestMethods", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.digestMethod = new t.XFAObjectArray();
            }
          }
          class pe extends t.XFAObject {
            constructor(i) {
              super(f, "draw", !0), this.anchorType = (0, l.getStringOption)(i.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
                data: i.colSpan,
                defaultValue: 1,
                validate: (B) => B >= 1 || B === -1
              }), this.h = i.h ? (0, l.getMeasurement)(i.h) : "", this.hAlign = (0, l.getStringOption)(i.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = i.id || "", this.locale = i.locale || "", this.maxH = (0, l.getMeasurement)(i.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(i.maxW, "0pt"), this.minH = (0, l.getMeasurement)(i.minH, "0pt"), this.minW = (0, l.getMeasurement)(i.minW, "0pt"), this.name = i.name || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(i.relevant), this.rotate = (0, l.getInteger)({
                data: i.rotate,
                defaultValue: 0,
                validate: (B) => B % 90 === 0
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.w = i.w ? (0, l.getMeasurement)(i.w) : "", this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new t.XFAObjectArray();
            }
            [n.$setValue](i) {
              g(this, i);
            }
            [n.$toHTML](i) {
              if (c(this), this.presence === "hidden" || this.presence === "inactive")
                return l.HTMLResult.EMPTY;
              (0, e.fixDimensions)(this), this[n.$pushPara]();
              const B = this.w, Se = this.h, {
                w: ve,
                h: Te,
                isBroken: _e
              } = (0, e.layoutNode)(this, i);
              if (ve && this.w === "") {
                if (_e && this[n.$getSubformParent]()[n.$isThereMoreWidth]())
                  return this[n.$popPara](), l.HTMLResult.FAILURE;
                this.w = ve;
              }
              if (Te && this.h === "" && (this.h = Te), u(this), !(0, D.checkDimensions)(this, i))
                return this.w = B, this.h = Se, this[n.$popPara](), l.HTMLResult.FAILURE;
              C(this);
              const Ke = (0, e.toStyle)(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
              (0, e.setMinMaxDimensions)(this, Ke), Ke.margin && (Ke.padding = Ke.margin, delete Ke.margin);
              const Ye = ["xfaDraw"];
              this.font && Ye.push("xfaFont"), (0, e.isPrintOnly)(this) && Ye.push("xfaPrintOnly");
              const gt = {
                style: Ke,
                id: this[n.$uid],
                class: Ye
              };
              this.name && (gt.xfaName = this.name);
              const yt = {
                name: "div",
                attributes: gt,
                children: []
              };
              I(this, gt);
              const Tt = (0, e.computeBbox)(this, yt, i), Ft = this.value ? this.value[n.$toHTML](i).html : null;
              return Ft === null ? (this.w = B, this.h = Se, this[n.$popPara](), l.HTMLResult.success((0, e.createWrapper)(this, yt), Tt)) : (yt.children.push(Ft), (0, e.setPara)(this, Ke, Ft), this.w = B, this.h = Se, this[n.$popPara](), l.HTMLResult.success((0, e.createWrapper)(this, yt), Tt));
            }
          }
          class xe extends t.XFAObject {
            constructor(i) {
              super(f, "edge", !0), this.cap = (0, l.getStringOption)(i.cap, ["square", "butt", "round"]), this.id = i.id || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = (0, l.getStringOption)(i.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = (0, l.getMeasurement)(i.thickness, "0.5pt"), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle]() {
              const i = (0, e.toStyle)(this, "visibility");
              if (Object.assign(i, {
                linecap: this.cap,
                width: (0, e.measureToString)(this.thickness),
                color: this.color ? this.color[n.$toStyle]() : "#000000",
                style: ""
              }), this.presence !== "visible")
                i.style = "none";
              else
                switch (this.stroke) {
                  case "solid":
                    i.style = "solid";
                    break;
                  case "dashDot":
                    i.style = "dashed";
                    break;
                  case "dashDotDot":
                    i.style = "dashed";
                    break;
                  case "dashed":
                    i.style = "dashed";
                    break;
                  case "dotted":
                    i.style = "dotted";
                    break;
                  case "embossed":
                    i.style = "ridge";
                    break;
                  case "etched":
                    i.style = "groove";
                    break;
                  case "lowered":
                    i.style = "inset";
                    break;
                  case "raised":
                    i.style = "outset";
                    break;
                }
              return i;
            }
          }
          class we extends t.OptionObject {
            constructor(i) {
              super(f, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Ae extends t.XFAObject {
            constructor(i) {
              super(f, "encodings", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.encoding = new t.XFAObjectArray();
            }
          }
          class be extends t.XFAObject {
            constructor(i) {
              super(f, "encrypt", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.certificate = null;
            }
          }
          class he extends t.XFAObject {
            constructor(i) {
              super(f, "encryptData", !0), this.id = i.id || "", this.operation = (0, l.getStringOption)(i.operation, ["encrypt", "decrypt"]), this.target = i.target || "", this.use = i.use || "", this.usehref = i.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class fe extends t.XFAObject {
            constructor(i) {
              super(f, "encryption", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class Ce extends t.OptionObject {
            constructor(i) {
              super(f, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class ye extends t.XFAObject {
            constructor(i) {
              super(f, "encryptionMethods", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.encryptionMethod = new t.XFAObjectArray();
            }
          }
          class Le extends t.XFAObject {
            constructor(i) {
              super(f, "event", !0), this.activity = (0, l.getStringOption)(i.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = i.id || "", this.listen = (0, l.getStringOption)(i.listen, ["refOnly", "refAndDescendents"]), this.name = i.name || "", this.ref = i.ref || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
            }
          }
          class Be extends t.ContentObject {
            constructor(i) {
              super(f, "exData"), this.contentType = i.contentType || "", this.href = i.href || "", this.id = i.id || "", this.maxLength = (0, l.getInteger)({
                data: i.maxLength,
                defaultValue: -1,
                validate: (B) => B >= -1
              }), this.name = i.name || "", this.rid = i.rid || "", this.transferEncoding = (0, l.getStringOption)(i.transferEncoding, ["none", "base64", "package"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$isCDATAXml]() {
              return this.contentType === "text/html";
            }
            [n.$onChild](i) {
              return this.contentType === "text/html" && i[n.$namespaceId] === P.NamespaceIds.xhtml.id ? (this[n.$content] = i, !0) : this.contentType === "text/xml" ? (this[n.$content] = i, !0) : !1;
            }
            [n.$toHTML](i) {
              return this.contentType !== "text/html" || !this[n.$content] ? l.HTMLResult.EMPTY : this[n.$content][n.$toHTML](i);
            }
          }
          class nt extends t.XFAObject {
            constructor(i) {
              super(f, "exObject", !0), this.archive = i.archive || "", this.classId = i.classId || "", this.codeBase = i.codeBase || "", this.codeType = i.codeType || "", this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Oe extends t.XFAObject {
            constructor(i) {
              super(f, "exclGroup", !0), this.access = (0, l.getStringOption)(i.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = i.accessKey || "", this.anchorType = (0, l.getStringOption)(i.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
                data: i.colSpan,
                defaultValue: 1,
                validate: (B) => B >= 1 || B === -1
              }), this.h = i.h ? (0, l.getMeasurement)(i.h) : "", this.hAlign = (0, l.getStringOption)(i.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = i.id || "", this.layout = (0, l.getStringOption)(i.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = (0, l.getMeasurement)(i.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(i.maxW, "0pt"), this.minH = (0, l.getMeasurement)(i.minH, "0pt"), this.minW = (0, l.getMeasurement)(i.minW, "0pt"), this.name = i.name || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.w = i.w ? (0, l.getMeasurement)(i.w) : "", this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [n.$isBindable]() {
              return !0;
            }
            [n.$hasSettableValue]() {
              return !0;
            }
            [n.$setValue](i) {
              for (const B of this.field.children) {
                if (!B.value) {
                  const Se = new tn({});
                  B[n.$appendChild](Se), B.value = Se;
                }
                B.value[n.$setValue](i);
              }
            }
            [n.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine > 0 || this[n.$getParent]()[n.$isThereMoreWidth]();
            }
            [n.$isSplittable]() {
              var B;
              const i = this[n.$getSubformParent]();
              return i[n.$isSplittable]() ? this[n.$extra]._isSplittable !== void 0 ? this[n.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[n.$extra]._isSplittable = !1, !1) : (B = i.layout) != null && B.endsWith("-tb") && i[n.$extra].numberInLine !== 0 ? !1 : (this[n.$extra]._isSplittable = !0, !0) : !1;
            }
            [n.$flushHTML]() {
              return (0, D.flushHTML)(this);
            }
            [n.$addHTML](i, B) {
              (0, D.addHTML)(this, i, B);
            }
            [n.$getAvailableSpace]() {
              return (0, D.getAvailableSpace)(this);
            }
            [n.$toHTML](i) {
              if (c(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return l.HTMLResult.EMPTY;
              (0, e.fixDimensions)(this);
              const B = [], Se = {
                id: this[n.$uid],
                class: []
              };
              (0, e.setAccess)(this, Se.class), this[n.$extra] || (this[n.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[n.$extra], {
                children: B,
                attributes: Se,
                attempt: 0,
                line: null,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, i.width),
                  height: Math.min(this.h || 1 / 0, i.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const ve = this[n.$isSplittable]();
              if (ve || u(this), !(0, D.checkDimensions)(this, i))
                return l.HTMLResult.FAILURE;
              const Te = /* @__PURE__ */ new Set(["field"]);
              if (this.layout.includes("row")) {
                const Dt = this[n.$getSubformParent]().columnWidths;
                Array.isArray(Dt) && Dt.length > 0 && (this[n.$extra].columnWidths = Dt, this[n.$extra].currentColumn = 0);
              }
              const _e = (0, e.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), Ke = ["xfaExclgroup"], Ye = (0, e.layoutClass)(this);
              Ye && Ke.push(Ye), (0, e.isPrintOnly)(this) && Ke.push("xfaPrintOnly"), Se.style = _e, Se.class = Ke, this.name && (Se.xfaName = this.name), this[n.$pushPara]();
              const gt = this.layout === "lr-tb" || this.layout === "rl-tb", yt = gt ? a : 1;
              for (; this[n.$extra].attempt < yt; this[n.$extra].attempt++) {
                gt && this[n.$extra].attempt === a - 1 && (this[n.$extra].numberInLine = 0);
                const Dt = this[n.$childrenToHTML]({
                  filter: Te,
                  include: !0
                });
                if (Dt.success)
                  break;
                if (Dt.isBreak())
                  return this[n.$popPara](), Dt;
                if (gt && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine === 0 && !this[n.$getTemplateRoot]()[n.$extra].noLayoutFailure) {
                  this[n.$extra].attempt = yt;
                  break;
                }
              }
              if (this[n.$popPara](), ve || C(this), this[n.$extra].attempt === yt)
                return ve || delete this[n.$extra], l.HTMLResult.FAILURE;
              let Tt = 0, Ft = 0;
              this.margin && (Tt = this.margin.leftInset + this.margin.rightInset, Ft = this.margin.topInset + this.margin.bottomInset);
              const Et = Math.max(this[n.$extra].width + Tt, this.w || 0), Bt = Math.max(this[n.$extra].height + Ft, this.h || 0), xt = [this.x, this.y, Et, Bt];
              this.w === "" && (_e.width = (0, e.measureToString)(Et)), this.h === "" && (_e.height = (0, e.measureToString)(Bt));
              const Xt = {
                name: "div",
                attributes: Se,
                children: B
              };
              return I(this, Se), delete this[n.$extra], l.HTMLResult.success((0, e.createWrapper)(this, Xt), xt);
            }
          }
          class Je extends t.XFAObject {
            constructor(i) {
              super(f, "execute"), this.connection = i.connection || "", this.executeType = (0, l.getStringOption)(i.executeType, ["import", "remerge"]), this.id = i.id || "", this.runAt = (0, l.getStringOption)(i.runAt, ["client", "both", "server"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Ve extends t.XFAObject {
            constructor(i) {
              super(f, "extras", !0), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
          }
          class Pe extends t.XFAObject {
            constructor(i) {
              super(f, "field", !0), this.access = (0, l.getStringOption)(i.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = i.accessKey || "", this.anchorType = (0, l.getStringOption)(i.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
                data: i.colSpan,
                defaultValue: 1,
                validate: (B) => B >= 1 || B === -1
              }), this.h = i.h ? (0, l.getMeasurement)(i.h) : "", this.hAlign = (0, l.getStringOption)(i.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = i.id || "", this.locale = i.locale || "", this.maxH = (0, l.getMeasurement)(i.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(i.maxW, "0pt"), this.minH = (0, l.getMeasurement)(i.minH, "0pt"), this.minW = (0, l.getMeasurement)(i.minW, "0pt"), this.name = i.name || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(i.relevant), this.rotate = (0, l.getInteger)({
                data: i.rotate,
                defaultValue: 0,
                validate: (B) => B % 90 === 0
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.w = i.w ? (0, l.getMeasurement)(i.w) : "", this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new t.XFAObjectArray(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray();
            }
            [n.$isBindable]() {
              return !0;
            }
            [n.$setValue](i) {
              g(this, i);
            }
            [n.$toHTML](i) {
              var Dt, Wt, Ht;
              if (c(this), !this.ui) {
                this.ui = new hn({}), this.ui[n.$globalData] = this[n.$globalData], this[n.$appendChild](this.ui);
                let St;
                switch (this.items.children.length) {
                  case 0:
                    St = new xn({}), this.ui.textEdit = St;
                    break;
                  case 1:
                    St = new H({}), this.ui.checkButton = St;
                    break;
                  case 2:
                    St = new Y({}), this.ui.choiceList = St;
                    break;
                }
                this.ui[n.$appendChild](St);
              }
              if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
                return l.HTMLResult.EMPTY;
              this.caption && delete this.caption[n.$extra], this[n.$pushPara]();
              const B = this.caption ? this.caption[n.$toHTML](i).html : null, Se = this.w, ve = this.h;
              let Te = 0, _e = 0;
              this.margin && (Te = this.margin.leftInset + this.margin.rightInset, _e = this.margin.topInset + this.margin.bottomInset);
              let Ke = null;
              if (this.w === "" || this.h === "") {
                let St = null, Ze = null, Kt = 0, Vt = 0;
                if (this.ui.checkButton)
                  Kt = Vt = this.ui.checkButton.size;
                else {
                  const {
                    w: Zt,
                    h: Jt
                  } = (0, e.layoutNode)(this, i);
                  Zt !== null ? (Kt = Zt, Vt = Jt) : Vt = (0, te.getMetrics)(this.font, !0).lineNoGap;
                }
                if (Ke = z(this.ui[n.$getExtra]()), Kt += Ke.w, Vt += Ke.h, this.caption) {
                  const {
                    w: Zt,
                    h: Jt,
                    isBroken: zt
                  } = this.caption[n.$getExtra](i);
                  if (zt && this[n.$getSubformParent]()[n.$isThereMoreWidth]())
                    return this[n.$popPara](), l.HTMLResult.FAILURE;
                  switch (St = Zt, Ze = Jt, this.caption.placement) {
                    case "left":
                    case "right":
                    case "inline":
                      St += Kt;
                      break;
                    case "top":
                    case "bottom":
                      Ze += Vt;
                      break;
                  }
                } else
                  St = Kt, Ze = Vt;
                St && this.w === "" && (St += Te, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < St ? St : this.minW)), Ze && this.h === "" && (Ze += _e, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < Ze ? Ze : this.minH));
              }
              if (this[n.$popPara](), (0, e.fixDimensions)(this), u(this), !(0, D.checkDimensions)(this, i))
                return this.w = Se, this.h = ve, this[n.$popPara](), l.HTMLResult.FAILURE;
              C(this);
              const Ye = (0, e.toStyle)(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
              (0, e.setMinMaxDimensions)(this, Ye);
              const gt = ["xfaField"];
              this.font && gt.push("xfaFont"), (0, e.isPrintOnly)(this) && gt.push("xfaPrintOnly");
              const yt = {
                style: Ye,
                id: this[n.$uid],
                class: gt
              };
              Ye.margin && (Ye.padding = Ye.margin, delete Ye.margin), (0, e.setAccess)(this, gt), this.name && (yt.xfaName = this.name);
              const Tt = [], Ft = {
                name: "div",
                attributes: yt,
                children: Tt
              };
              I(this, yt);
              const Et = this.border ? this.border[n.$toStyle]() : null, Bt = (0, e.computeBbox)(this, Ft, i), xt = this.ui[n.$toHTML]().html;
              if (!xt)
                return Object.assign(Ye, Et), l.HTMLResult.success((0, e.createWrapper)(this, Ft), Bt);
              this[n.$tabIndex] && ((Dt = xt.children) != null && Dt[0] ? xt.children[0].attributes.tabindex = this[n.$tabIndex] : xt.attributes.tabindex = this[n.$tabIndex]), xt.attributes.style || (xt.attributes.style = /* @__PURE__ */ Object.create(null));
              let Xt = null;
              if (this.ui.button ? (xt.children.length === 1 && ([Xt] = xt.children.splice(0, 1)), Object.assign(xt.attributes.style, Et)) : Object.assign(Ye, Et), Tt.push(xt), this.value) {
                if (this.ui.imageEdit)
                  xt.children.push(this.value[n.$toHTML]().html);
                else if (!this.ui.button) {
                  let St = "";
                  if (this.value.exData)
                    St = this.value.exData[n.$text]();
                  else if (this.value.text)
                    St = this.value.text[n.$getExtra]();
                  else {
                    const Ze = this.value[n.$toHTML]().html;
                    Ze !== null && (St = Ze.children[0].value);
                  }
                  this.ui.textEdit && ((Wt = this.value.text) != null && Wt.maxChars) && (xt.children[0].attributes.maxLength = this.value.text.maxChars), St && (this.ui.numericEdit && (St = parseFloat(St), St = isNaN(St) ? "" : St.toString()), xt.children[0].name === "textarea" ? xt.children[0].attributes.textContent = St : xt.children[0].attributes.value = St);
                }
              }
              if (!this.ui.imageEdit && ((Ht = xt.children) != null && Ht[0]) && this.h) {
                Ke = Ke || z(this.ui[n.$getExtra]());
                let St = 0;
                if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
                  St = this.caption.reserve, St <= 0 && (St = this.caption[n.$getExtra](i).h);
                  const Ze = this.h - St - _e - Ke.h;
                  xt.children[0].attributes.style.height = (0, e.measureToString)(Ze);
                } else
                  xt.children[0].attributes.style.height = "100%";
              }
              if (Xt && xt.children.push(Xt), !B)
                return xt.attributes.class && xt.attributes.class.push("xfaLeft"), this.w = Se, this.h = ve, l.HTMLResult.success((0, e.createWrapper)(this, Ft), Bt);
              if (this.ui.button)
                return Ye.padding && delete Ye.padding, B.name === "div" && (B.name = "span"), xt.children.push(B), l.HTMLResult.success(Ft, Bt);
              switch (this.ui.checkButton && (B.attributes.class[0] = "xfaCaptionForCheckButton"), xt.attributes.class || (xt.attributes.class = []), xt.children.splice(0, 0, B), this.caption.placement) {
                case "left":
                  xt.attributes.class.push("xfaLeft");
                  break;
                case "right":
                  xt.attributes.class.push("xfaRight");
                  break;
                case "top":
                  xt.attributes.class.push("xfaTop");
                  break;
                case "bottom":
                  xt.attributes.class.push("xfaBottom");
                  break;
                case "inline":
                  xt.attributes.class.push("xfaLeft");
                  break;
              }
              return this.w = Se, this.h = ve, l.HTMLResult.success((0, e.createWrapper)(this, Ft), Bt);
            }
          }
          b.Field = Pe;
          class Ge extends t.XFAObject {
            constructor(i) {
              super(f, "fill", !0), this.id = i.id || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
            }
            [n.$toStyle]() {
              var Ke;
              const i = this[n.$getParent](), Se = i[n.$getParent]()[n.$getParent](), ve = /* @__PURE__ */ Object.create(null);
              let Te = "color", _e = Te;
              i instanceof J && (Te = "background-color", _e = "background", Se instanceof hn && (ve.backgroundColor = "white")), (i instanceof lt || i instanceof $) && (Te = _e = "fill", ve.fill = "white");
              for (const Ye of Object.getOwnPropertyNames(this)) {
                if (Ye === "extras" || Ye === "color")
                  continue;
                const gt = this[Ye];
                if (!(gt instanceof t.XFAObject))
                  continue;
                const yt = gt[n.$toStyle](this.color);
                return yt && (ve[yt.startsWith("#") ? Te : _e] = yt), ve;
              }
              if ((Ke = this.color) != null && Ke.value) {
                const Ye = this.color[n.$toStyle]();
                ve[Ye.startsWith("#") ? Te : _e] = Ye;
              }
              return ve;
            }
          }
          class dt extends t.XFAObject {
            constructor(i) {
              super(f, "filter", !0), this.addRevocationInfo = (0, l.getStringOption)(i.addRevocationInfo, ["", "required", "optional", "none"]), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "", this.version = (0, l.getInteger)({
                data: this.version,
                defaultValue: 5,
                validate: (B) => B >= 1 && B <= 5
              }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
            }
          }
          class De extends t.ContentObject {
            constructor(i) {
              super(f, "float"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = parseFloat(this[n.$content].trim());
              this[n.$content] = isNaN(i) ? null : i;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] !== null ? this[n.$content].toString() : "");
            }
          }
          class Qe extends t.XFAObject {
            constructor(i) {
              super(f, "font", !0), this.baselineShift = (0, l.getMeasurement)(i.baselineShift), this.fontHorizontalScale = (0, l.getFloat)({
                data: i.fontHorizontalScale,
                defaultValue: 100,
                validate: (B) => B >= 0
              }), this.fontVerticalScale = (0, l.getFloat)({
                data: i.fontVerticalScale,
                defaultValue: 100,
                validate: (B) => B >= 0
              }), this.id = i.id || "", this.kerningMode = (0, l.getStringOption)(i.kerningMode, ["none", "pair"]), this.letterSpacing = (0, l.getMeasurement)(i.letterSpacing, "0"), this.lineThrough = (0, l.getInteger)({
                data: i.lineThrough,
                defaultValue: 0,
                validate: (B) => B === 1 || B === 2
              }), this.lineThroughPeriod = (0, l.getStringOption)(i.lineThroughPeriod, ["all", "word"]), this.overline = (0, l.getInteger)({
                data: i.overline,
                defaultValue: 0,
                validate: (B) => B === 1 || B === 2
              }), this.overlinePeriod = (0, l.getStringOption)(i.overlinePeriod, ["all", "word"]), this.posture = (0, l.getStringOption)(i.posture, ["normal", "italic"]), this.size = (0, l.getMeasurement)(i.size, "10pt"), this.typeface = i.typeface || "Courier", this.underline = (0, l.getInteger)({
                data: i.underline,
                defaultValue: 0,
                validate: (B) => B === 1 || B === 2
              }), this.underlinePeriod = (0, l.getStringOption)(i.underlinePeriod, ["all", "word"]), this.use = i.use || "", this.usehref = i.usehref || "", this.weight = (0, l.getStringOption)(i.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
            }
            [n.$clean](i) {
              super[n.$clean](i), this[n.$globalData].usedTypefaces.add(this.typeface);
            }
            [n.$toStyle]() {
              const i = (0, e.toStyle)(this, "fill"), B = i.color;
              return B && (B === "#000000" ? delete i.color : B.startsWith("#") || (i.background = B, i.backgroundClip = "text", i.color = "transparent")), this.baselineShift && (i.verticalAlign = (0, e.measureToString)(this.baselineShift)), i.fontKerning = this.kerningMode === "none" ? "none" : "normal", i.letterSpacing = (0, e.measureToString)(this.letterSpacing), this.lineThrough !== 0 && (i.textDecoration = "line-through", this.lineThrough === 2 && (i.textDecorationStyle = "double")), this.overline !== 0 && (i.textDecoration = "overline", this.overline === 2 && (i.textDecorationStyle = "double")), i.fontStyle = this.posture, i.fontSize = (0, e.measureToString)(0.99 * this.size), (0, e.setFontFamily)(this, this, this[n.$globalData].fontFinder, i), this.underline !== 0 && (i.textDecoration = "underline", this.underline === 2 && (i.textDecorationStyle = "double")), i.fontWeight = this.weight, i;
            }
          }
          class st extends t.XFAObject {
            constructor(i) {
              super(f, "format", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.picture = null;
            }
          }
          class wt extends t.StringObject {
            constructor(i) {
              super(f, "handler"), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Ot extends t.XFAObject {
            constructor(i) {
              super(f, "hyphenation"), this.excludeAllCaps = (0, l.getInteger)({
                data: i.excludeAllCaps,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.excludeInitialCap = (0, l.getInteger)({
                data: i.excludeInitialCap,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.hyphenate = (0, l.getInteger)({
                data: i.hyphenate,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.id = i.id || "", this.pushCharacterCount = (0, l.getInteger)({
                data: i.pushCharacterCount,
                defaultValue: 3,
                validate: (B) => B >= 0
              }), this.remainCharacterCount = (0, l.getInteger)({
                data: i.remainCharacterCount,
                defaultValue: 3,
                validate: (B) => B >= 0
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.wordCharacterCount = (0, l.getInteger)({
                data: i.wordCharacterCount,
                defaultValue: 7,
                validate: (B) => B >= 0
              });
            }
          }
          class ze extends t.StringObject {
            constructor(i) {
              super(f, "image"), this.aspect = (0, l.getStringOption)(i.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = i.contentType || "", this.href = i.href || "", this.id = i.id || "", this.name = i.name || "", this.transferEncoding = (0, l.getStringOption)(i.transferEncoding, ["base64", "none", "package"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$toHTML]() {
              if (this.contentType && !M.has(this.contentType.toLowerCase()))
                return l.HTMLResult.EMPTY;
              let i = this[n.$globalData].images && this[n.$globalData].images.get(this.href);
              if (!i && (this.href || !this[n.$content]) || (!i && this.transferEncoding === "base64" && (i = (0, V.stringToBytes)(atob(this[n.$content]))), !i))
                return l.HTMLResult.EMPTY;
              if (!this.contentType) {
                for (const [Te, _e] of R)
                  if (i.length > Te.length && Te.every((Ke, Ye) => Ke === i[Ye])) {
                    this.contentType = _e;
                    break;
                  }
                if (!this.contentType)
                  return l.HTMLResult.EMPTY;
              }
              const B = new Blob([i], {
                type: this.contentType
              });
              let Se;
              switch (this.aspect) {
                case "fit":
                case "actual":
                  break;
                case "height":
                  Se = {
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "none":
                  Se = {
                    width: "100%",
                    height: "100%",
                    objectFit: "fill"
                  };
                  break;
                case "width":
                  Se = {
                    width: "100%",
                    objectFit: "fill"
                  };
                  break;
              }
              const ve = this[n.$getParent]();
              return l.HTMLResult.success({
                name: "img",
                attributes: {
                  class: ["xfaImage"],
                  style: Se,
                  src: URL.createObjectURL(B),
                  alt: ve ? s(ve[n.$getParent]()) : null
                }
              });
            }
          }
          class qe extends t.XFAObject {
            constructor(i) {
              super(f, "imageEdit", !0), this.data = (0, l.getStringOption)(i.data, ["link", "embed"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              return this.data === "embed" ? l.HTMLResult.success({
                name: "div",
                children: [],
                attributes: {}
              }) : l.HTMLResult.EMPTY;
            }
          }
          class Ue extends t.ContentObject {
            constructor(i) {
              super(f, "integer"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = parseInt(this[n.$content].trim(), 10);
              this[n.$content] = isNaN(i) ? null : i;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] !== null ? this[n.$content].toString() : "");
            }
          }
          class bt extends t.XFAObject {
            constructor(i) {
              super(f, "issuers", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class It extends t.XFAObject {
            constructor(i) {
              super(f, "items", !0), this.id = i.id || "", this.name = i.name || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = i.ref || "", this.save = (0, l.getInteger)({
                data: i.save,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [n.$toHTML]() {
              const i = [];
              for (const B of this[n.$getChildren]())
                i.push(B[n.$text]());
              return l.HTMLResult.success(i);
            }
          }
          b.Items = It;
          class kt extends t.XFAObject {
            constructor(i) {
              super(f, "keep", !0), this.id = i.id || "";
              const B = ["none", "contentArea", "pageArea"];
              this.intact = (0, l.getStringOption)(i.intact, B), this.next = (0, l.getStringOption)(i.next, B), this.previous = (0, l.getStringOption)(i.previous, B), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
          }
          class ht extends t.XFAObject {
            constructor(i) {
              super(f, "keyUsage");
              const B = ["", "yes", "no"];
              this.crlSign = (0, l.getStringOption)(i.crlSign, B), this.dataEncipherment = (0, l.getStringOption)(i.dataEncipherment, B), this.decipherOnly = (0, l.getStringOption)(i.decipherOnly, B), this.digitalSignature = (0, l.getStringOption)(i.digitalSignature, B), this.encipherOnly = (0, l.getStringOption)(i.encipherOnly, B), this.id = i.id || "", this.keyAgreement = (0, l.getStringOption)(i.keyAgreement, B), this.keyCertSign = (0, l.getStringOption)(i.keyCertSign, B), this.keyEncipherment = (0, l.getStringOption)(i.keyEncipherment, B), this.nonRepudiation = (0, l.getStringOption)(i.nonRepudiation, B), this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Rt extends t.XFAObject {
            constructor(i) {
              super(f, "line", !0), this.hand = (0, l.getStringOption)(i.hand, ["even", "left", "right"]), this.id = i.id || "", this.slope = (0, l.getStringOption)(i.slope, ["\\", "/"]), this.use = i.use || "", this.usehref = i.usehref || "", this.edge = null;
            }
            [n.$toHTML]() {
              const i = this[n.$getParent]()[n.$getParent](), B = this.edge || new xe({}), Se = B[n.$toStyle](), ve = /* @__PURE__ */ Object.create(null), Te = B.presence === "visible" ? B.thickness : 0;
              ve.strokeWidth = (0, e.measureToString)(Te), ve.stroke = Se.color;
              let _e, Ke, Ye, gt, yt = "100%", Tt = "100%";
              i.w <= Te ? ([_e, Ke, Ye, gt] = ["50%", 0, "50%", "100%"], yt = ve.strokeWidth) : i.h <= Te ? ([_e, Ke, Ye, gt] = [0, "50%", "100%", "50%"], Tt = ve.strokeWidth) : this.slope === "\\" ? [_e, Ke, Ye, gt] = [0, 0, "100%", "100%"] : [_e, Ke, Ye, gt] = [0, "100%", "100%", 0];
              const Et = {
                name: "svg",
                children: [{
                  name: "line",
                  attributes: {
                    xmlns: x,
                    x1: _e,
                    y1: Ke,
                    x2: Ye,
                    y2: gt,
                    style: ve
                  }
                }],
                attributes: {
                  xmlns: x,
                  width: yt,
                  height: Tt,
                  style: {
                    overflow: "visible"
                  }
                }
              };
              return W(i) ? l.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Et]
              }) : (Et.attributes.style.position = "absolute", l.HTMLResult.success(Et));
            }
          }
          class _t extends t.XFAObject {
            constructor(i) {
              super(f, "linear", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle](i) {
              i = i ? i[n.$toStyle]() : "#FFFFFF";
              const B = this.type.replace(/([RBLT])/, " $1").toLowerCase(), Se = this.color ? this.color[n.$toStyle]() : "#000000";
              return `linear-gradient(${B}, ${i}, ${Se})`;
            }
          }
          class Ie extends t.ContentObject {
            constructor(i) {
              super(f, "lockDocument"), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              this[n.$content] = (0, l.getStringOption)(this[n.$content], ["auto", "0", "1"]);
            }
          }
          class Fe extends t.XFAObject {
            constructor(i) {
              super(f, "manifest", !0), this.action = (0, l.getStringOption)(i.action, ["include", "all", "exclude"]), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.ref = new t.XFAObjectArray();
            }
          }
          class Me extends t.XFAObject {
            constructor(i) {
              super(f, "margin", !0), this.bottomInset = (0, l.getMeasurement)(i.bottomInset, "0"), this.id = i.id || "", this.leftInset = (0, l.getMeasurement)(i.leftInset, "0"), this.rightInset = (0, l.getMeasurement)(i.rightInset, "0"), this.topInset = (0, l.getMeasurement)(i.topInset, "0"), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
            [n.$toStyle]() {
              return {
                margin: (0, e.measureToString)(this.topInset) + " " + (0, e.measureToString)(this.rightInset) + " " + (0, e.measureToString)(this.bottomInset) + " " + (0, e.measureToString)(this.leftInset)
              };
            }
          }
          class Ne extends t.XFAObject {
            constructor(i) {
              super(f, "mdp"), this.id = i.id || "", this.permissions = (0, l.getInteger)({
                data: i.permissions,
                defaultValue: 2,
                validate: (B) => B === 1 || B === 3
              }), this.signatureType = (0, l.getStringOption)(i.signatureType, ["filler", "author"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class je extends t.XFAObject {
            constructor(i) {
              super(f, "medium"), this.id = i.id || "", this.imagingBBox = (0, l.getBBox)(i.imagingBBox), this.long = (0, l.getMeasurement)(i.long), this.orientation = (0, l.getStringOption)(i.orientation, ["portrait", "landscape"]), this.short = (0, l.getMeasurement)(i.short), this.stock = i.stock || "", this.trayIn = (0, l.getStringOption)(i.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = (0, l.getStringOption)(i.trayOut, ["auto", "delegate"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class et extends t.XFAObject {
            constructor(i) {
              super(f, "message", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.text = new t.XFAObjectArray();
            }
          }
          class $e extends t.XFAObject {
            constructor(i) {
              super(f, "numericEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(i.hScrollPolicy, ["auto", "off", "on"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              var Te;
              const B = (0, e.toStyle)(this, "border", "font", "margin"), Se = this[n.$getParent]()[n.$getParent](), ve = {
                name: "input",
                attributes: {
                  type: "text",
                  fieldId: Se[n.$uid],
                  dataId: ((Te = Se[n.$data]) == null ? void 0 : Te[n.$uid]) || Se[n.$uid],
                  class: ["xfaTextfield"],
                  style: B,
                  "aria-label": s(Se),
                  "aria-required": !1
                }
              };
              return o(Se) && (ve.attributes["aria-required"] = !0, ve.attributes.required = !0), l.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [ve]
              });
            }
          }
          class Ee extends t.XFAObject {
            constructor(i) {
              super(f, "occur", !0), this.id = i.id || "", this.initial = i.initial !== "" ? (0, l.getInteger)({
                data: i.initial,
                defaultValue: "",
                validate: (B) => !0
              }) : "", this.max = i.max !== "" ? (0, l.getInteger)({
                data: i.max,
                defaultValue: 1,
                validate: (B) => !0
              }) : "", this.min = i.min !== "" ? (0, l.getInteger)({
                data: i.min,
                defaultValue: 1,
                validate: (B) => !0
              }) : "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
            [n.$clean]() {
              const i = this[n.$getParent](), B = this.min;
              this.min === "" && (this.min = i instanceof tt || i instanceof at ? 0 : 1), this.max === "" && (B === "" ? this.max = i instanceof tt || i instanceof at ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = i instanceof ln ? 1 : this.min);
            }
          }
          class He extends t.StringObject {
            constructor(i) {
              super(f, "oid"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class rt extends t.XFAObject {
            constructor(i) {
              super(f, "oids", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.oid = new t.XFAObjectArray();
            }
          }
          class mt extends t.XFAObject {
            constructor(i) {
              super(f, "overflow"), this.id = i.id || "", this.leader = i.leader || "", this.target = i.target || "", this.trailer = i.trailer || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$getExtra]() {
              if (!this[n.$extra]) {
                const i = this[n.$getParent](), B = this[n.$getTemplateRoot](), Se = B[n.$searchNode](this.target, i), ve = B[n.$searchNode](this.leader, i), Te = B[n.$searchNode](this.trailer, i);
                this[n.$extra] = {
                  target: (Se == null ? void 0 : Se[0]) || null,
                  leader: (ve == null ? void 0 : ve[0]) || null,
                  trailer: (Te == null ? void 0 : Te[0]) || null,
                  addLeader: !1,
                  addTrailer: !1
                };
              }
              return this[n.$extra];
            }
          }
          class tt extends t.XFAObject {
            constructor(i) {
              super(f, "pageArea", !0), this.blankOrNotBlank = (0, l.getStringOption)(i.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = i.id || "", this.initialNumber = (0, l.getInteger)({
                data: i.initialNumber,
                defaultValue: 1,
                validate: (B) => !0
              }), this.name = i.name || "", this.numbered = (0, l.getInteger)({
                data: i.numbered,
                defaultValue: 1,
                validate: (B) => !0
              }), this.oddOrEven = (0, l.getStringOption)(i.oddOrEven, ["any", "even", "odd"]), this.pagePosition = (0, l.getStringOption)(i.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray();
            }
            [n.$isUsable]() {
              return this[n.$extra] ? !this.occur || this.occur.max === -1 || this[n.$extra].numberOfUse < this.occur.max : (this[n.$extra] = {
                numberOfUse: 0
              }, !0);
            }
            [n.$cleanPage]() {
              delete this[n.$extra];
            }
            [n.$getNextPage]() {
              this[n.$extra] || (this[n.$extra] = {
                numberOfUse: 0
              });
              const i = this[n.$getParent]();
              return i.relation === "orderedOccurrence" && this[n.$isUsable]() ? (this[n.$extra].numberOfUse += 1, this) : i[n.$getNextPage]();
            }
            [n.$getAvailableSpace]() {
              return this[n.$extra].space || {
                width: 0,
                height: 0
              };
            }
            [n.$toHTML]() {
              this[n.$extra] || (this[n.$extra] = {
                numberOfUse: 1
              });
              const i = [];
              this[n.$extra].children = i;
              const B = /* @__PURE__ */ Object.create(null);
              if (this.medium && this.medium.short && this.medium.long) {
                if (B.width = (0, e.measureToString)(this.medium.short), B.height = (0, e.measureToString)(this.medium.long), this[n.$extra].space = {
                  width: this.medium.short,
                  height: this.medium.long
                }, this.medium.orientation === "landscape") {
                  const Se = B.width;
                  B.width = B.height, B.height = Se, this[n.$extra].space = {
                    width: this.medium.long,
                    height: this.medium.short
                  };
                }
              } else
                (0, V.warn)("XFA - No medium specified in pageArea: please file a bug.");
              return this[n.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
                include: !0
              }), this[n.$childrenToHTML]({
                filter: /* @__PURE__ */ new Set(["contentArea"]),
                include: !0
              }), l.HTMLResult.success({
                name: "div",
                children: i,
                attributes: {
                  class: ["xfaPage"],
                  id: this[n.$uid],
                  style: B,
                  xfaName: this.name
                }
              });
            }
          }
          class at extends t.XFAObject {
            constructor(i) {
              super(f, "pageSet", !0), this.duplexImposition = (0, l.getStringOption)(i.duplexImposition, ["longEdge", "shortEdge"]), this.id = i.id || "", this.name = i.name || "", this.relation = (0, l.getStringOption)(i.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.occur = null, this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray();
            }
            [n.$cleanPage]() {
              for (const i of this.pageArea.children)
                i[n.$cleanPage]();
              for (const i of this.pageSet.children)
                i[n.$cleanPage]();
            }
            [n.$isUsable]() {
              return !this.occur || this.occur.max === -1 || this[n.$extra].numberOfUse < this.occur.max;
            }
            [n.$getNextPage]() {
              if (this[n.$extra] || (this[n.$extra] = {
                numberOfUse: 1,
                pageIndex: -1,
                pageSetIndex: -1
              }), this.relation === "orderedOccurrence") {
                if (this[n.$extra].pageIndex + 1 < this.pageArea.children.length)
                  return this[n.$extra].pageIndex += 1, this.pageArea.children[this[n.$extra].pageIndex][n.$getNextPage]();
                if (this[n.$extra].pageSetIndex + 1 < this.pageSet.children.length)
                  return this[n.$extra].pageSetIndex += 1, this.pageSet.children[this[n.$extra].pageSetIndex][n.$getNextPage]();
                if (this[n.$isUsable]())
                  return this[n.$extra].numberOfUse += 1, this[n.$extra].pageIndex = -1, this[n.$extra].pageSetIndex = -1, this[n.$getNextPage]();
                const Te = this[n.$getParent]();
                return Te instanceof at ? Te[n.$getNextPage]() : (this[n.$cleanPage](), this[n.$getNextPage]());
              }
              const i = this[n.$getTemplateRoot]()[n.$extra].pageNumber, B = i % 2 === 0 ? "even" : "odd", Se = i === 0 ? "first" : "rest";
              let ve = this.pageArea.children.find((Te) => Te.oddOrEven === B && Te.pagePosition === Se);
              return ve || (ve = this.pageArea.children.find((Te) => Te.oddOrEven === "any" && Te.pagePosition === Se), ve) || (ve = this.pageArea.children.find((Te) => Te.oddOrEven === "any" && Te.pagePosition === "any"), ve) ? ve : this.pageArea.children[0];
            }
          }
          class ft extends t.XFAObject {
            constructor(i) {
              super(f, "para", !0), this.hAlign = (0, l.getStringOption)(i.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = i.id || "", this.lineHeight = i.lineHeight ? (0, l.getMeasurement)(i.lineHeight, "0pt") : "", this.marginLeft = i.marginLeft ? (0, l.getMeasurement)(i.marginLeft, "0pt") : "", this.marginRight = i.marginRight ? (0, l.getMeasurement)(i.marginRight, "0pt") : "", this.orphans = (0, l.getInteger)({
                data: i.orphans,
                defaultValue: 0,
                validate: (B) => B >= 0
              }), this.preserve = i.preserve || "", this.radixOffset = i.radixOffset ? (0, l.getMeasurement)(i.radixOffset, "0pt") : "", this.spaceAbove = i.spaceAbove ? (0, l.getMeasurement)(i.spaceAbove, "0pt") : "", this.spaceBelow = i.spaceBelow ? (0, l.getMeasurement)(i.spaceBelow, "0pt") : "", this.tabDefault = i.tabDefault ? (0, l.getMeasurement)(this.tabDefault) : "", this.tabStops = (i.tabStops || "").trim().split(/\s+/).map((B, Se) => Se % 2 === 1 ? (0, l.getMeasurement)(B) : B), this.textIndent = i.textIndent ? (0, l.getMeasurement)(i.textIndent, "0pt") : "", this.use = i.use || "", this.usehref = i.usehref || "", this.vAlign = (0, l.getStringOption)(i.vAlign, ["top", "bottom", "middle"]), this.widows = (0, l.getInteger)({
                data: i.widows,
                defaultValue: 0,
                validate: (B) => B >= 0
              }), this.hyphenation = null;
            }
            [n.$toStyle]() {
              const i = (0, e.toStyle)(this, "hAlign");
              return this.marginLeft !== "" && (i.paddingLeft = (0, e.measureToString)(this.marginLeft)), this.marginRight !== "" && (i.paddingight = (0, e.measureToString)(this.marginRight)), this.spaceAbove !== "" && (i.paddingTop = (0, e.measureToString)(this.spaceAbove)), this.spaceBelow !== "" && (i.paddingBottom = (0, e.measureToString)(this.spaceBelow)), this.textIndent !== "" && (i.textIndent = (0, e.measureToString)(this.textIndent), (0, e.fixTextIndent)(i)), this.lineHeight > 0 && (i.lineHeight = (0, e.measureToString)(this.lineHeight)), this.tabDefault !== "" && (i.tabSize = (0, e.measureToString)(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(i, this.hyphenatation[n.$toStyle]()), i;
            }
          }
          class We extends t.XFAObject {
            constructor(i) {
              super(f, "passwordEdit", !0), this.hScrollPolicy = (0, l.getStringOption)(i.hScrollPolicy, ["auto", "off", "on"]), this.id = i.id || "", this.passwordChar = i.passwordChar || "*", this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.extras = null, this.margin = null;
            }
          }
          class ot extends t.XFAObject {
            constructor(i) {
              super(f, "pattern", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle](i) {
              i = i ? i[n.$toStyle]() : "#FFFFFF";
              const B = this.color ? this.color[n.$toStyle]() : "#000000", Se = 5, ve = "repeating-linear-gradient", Te = `${i},${i} ${Se}px,${B} ${Se}px,${B} ${2 * Se}px`;
              switch (this.type) {
                case "crossHatch":
                  return `${ve}(to top,${Te}) ${ve}(to right,${Te})`;
                case "crossDiagonal":
                  return `${ve}(45deg,${Te}) ${ve}(-45deg,${Te})`;
                case "diagonalLeft":
                  return `${ve}(45deg,${Te})`;
                case "diagonalRight":
                  return `${ve}(-45deg,${Te})`;
                case "horizontal":
                  return `${ve}(to top,${Te})`;
                case "vertical":
                  return `${ve}(to right,${Te})`;
              }
              return "";
            }
          }
          class Xe extends t.StringObject {
            constructor(i) {
              super(f, "picture"), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class ut extends t.XFAObject {
            constructor(i) {
              super(f, "proto", !0), this.appearanceFilter = new t.XFAObjectArray(), this.arc = new t.XFAObjectArray(), this.area = new t.XFAObjectArray(), this.assist = new t.XFAObjectArray(), this.barcode = new t.XFAObjectArray(), this.bindItems = new t.XFAObjectArray(), this.bookend = new t.XFAObjectArray(), this.boolean = new t.XFAObjectArray(), this.border = new t.XFAObjectArray(), this.break = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.button = new t.XFAObjectArray(), this.calculate = new t.XFAObjectArray(), this.caption = new t.XFAObjectArray(), this.certificate = new t.XFAObjectArray(), this.certificates = new t.XFAObjectArray(), this.checkButton = new t.XFAObjectArray(), this.choiceList = new t.XFAObjectArray(), this.color = new t.XFAObjectArray(), this.comb = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.contentArea = new t.XFAObjectArray(), this.corner = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.dateTimeEdit = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.defaultUi = new t.XFAObjectArray(), this.desc = new t.XFAObjectArray(), this.digestMethod = new t.XFAObjectArray(), this.digestMethods = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.edge = new t.XFAObjectArray(), this.encoding = new t.XFAObjectArray(), this.encodings = new t.XFAObjectArray(), this.encrypt = new t.XFAObjectArray(), this.encryptData = new t.XFAObjectArray(), this.encryption = new t.XFAObjectArray(), this.encryptionMethod = new t.XFAObjectArray(), this.encryptionMethods = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.execute = new t.XFAObjectArray(), this.extras = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.fill = new t.XFAObjectArray(), this.filter = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.font = new t.XFAObjectArray(), this.format = new t.XFAObjectArray(), this.handler = new t.XFAObjectArray(), this.hyphenation = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.imageEdit = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.issuers = new t.XFAObjectArray(), this.items = new t.XFAObjectArray(), this.keep = new t.XFAObjectArray(), this.keyUsage = new t.XFAObjectArray(), this.line = new t.XFAObjectArray(), this.linear = new t.XFAObjectArray(), this.lockDocument = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.margin = new t.XFAObjectArray(), this.mdp = new t.XFAObjectArray(), this.medium = new t.XFAObjectArray(), this.message = new t.XFAObjectArray(), this.numericEdit = new t.XFAObjectArray(), this.occur = new t.XFAObjectArray(), this.oid = new t.XFAObjectArray(), this.oids = new t.XFAObjectArray(), this.overflow = new t.XFAObjectArray(), this.pageArea = new t.XFAObjectArray(), this.pageSet = new t.XFAObjectArray(), this.para = new t.XFAObjectArray(), this.passwordEdit = new t.XFAObjectArray(), this.pattern = new t.XFAObjectArray(), this.picture = new t.XFAObjectArray(), this.radial = new t.XFAObjectArray(), this.reason = new t.XFAObjectArray(), this.reasons = new t.XFAObjectArray(), this.rectangle = new t.XFAObjectArray(), this.ref = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray(), this.signature = new t.XFAObjectArray(), this.signing = new t.XFAObjectArray(), this.solid = new t.XFAObjectArray(), this.speak = new t.XFAObjectArray(), this.stipple = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray(), this.subjectDN = new t.XFAObjectArray(), this.subjectDNs = new t.XFAObjectArray(), this.submit = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.textEdit = new t.XFAObjectArray(), this.time = new t.XFAObjectArray(), this.timeStamp = new t.XFAObjectArray(), this.toolTip = new t.XFAObjectArray(), this.traversal = new t.XFAObjectArray(), this.traverse = new t.XFAObjectArray(), this.ui = new t.XFAObjectArray(), this.validate = new t.XFAObjectArray(), this.value = new t.XFAObjectArray(), this.variables = new t.XFAObjectArray();
            }
          }
          class pt extends t.XFAObject {
            constructor(i) {
              super(f, "radial", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["toEdge", "toCenter"]), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle](i) {
              i = i ? i[n.$toStyle]() : "#FFFFFF";
              const B = this.color ? this.color[n.$toStyle]() : "#000000";
              return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${i},${B}` : `${B},${i}`})`;
            }
          }
          class $t extends t.StringObject {
            constructor(i) {
              super(f, "reason"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class ct extends t.XFAObject {
            constructor(i) {
              super(f, "reasons", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.reason = new t.XFAObjectArray();
            }
          }
          class lt extends t.XFAObject {
            constructor(i) {
              super(f, "rectangle", !0), this.hand = (0, l.getStringOption)(i.hand, ["even", "left", "right"]), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.corner = new t.XFAObjectArray(4), this.edge = new t.XFAObjectArray(4), this.fill = null;
            }
            [n.$toHTML]() {
              var gt;
              const i = this.edge.children.length ? this.edge.children[0] : new xe({}), B = i[n.$toStyle](), Se = /* @__PURE__ */ Object.create(null);
              ((gt = this.fill) == null ? void 0 : gt.presence) === "visible" ? Object.assign(Se, this.fill[n.$toStyle]()) : Se.fill = "transparent", Se.strokeWidth = (0, e.measureToString)(i.presence === "visible" ? i.thickness : 0), Se.stroke = B.color;
              const Te = (this.corner.children.length ? this.corner.children[0] : new Q({}))[n.$toStyle](), Ke = {
                name: "svg",
                children: [{
                  name: "rect",
                  attributes: {
                    xmlns: x,
                    width: "100%",
                    height: "100%",
                    x: 0,
                    y: 0,
                    rx: Te.radius,
                    ry: Te.radius,
                    style: Se
                  }
                }],
                attributes: {
                  xmlns: x,
                  style: {
                    overflow: "visible"
                  },
                  width: "100%",
                  height: "100%"
                }
              }, Ye = this[n.$getParent]()[n.$getParent]();
              return W(Ye) ? l.HTMLResult.success({
                name: "div",
                attributes: {
                  style: {
                    display: "inline",
                    width: "100%",
                    height: "100%"
                  }
                },
                children: [Ke]
              }) : (Ke.attributes.style.position = "absolute", l.HTMLResult.success(Ke));
            }
          }
          class vt extends t.StringObject {
            constructor(i) {
              super(f, "ref"), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Nt extends t.StringObject {
            constructor(i) {
              super(f, "script"), this.binding = i.binding || "", this.contentType = i.contentType || "", this.id = i.id || "", this.name = i.name || "", this.runAt = (0, l.getStringOption)(i.runAt, ["client", "both", "server"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class qt extends t.XFAObject {
            constructor(i) {
              super(f, "setProperty"), this.connection = i.connection || "", this.ref = i.ref || "", this.target = i.target || "";
            }
          }
          b.SetProperty = qt;
          class en extends t.XFAObject {
            constructor(i) {
              super(f, "signData", !0), this.id = i.id || "", this.operation = (0, l.getStringOption)(i.operation, ["sign", "clear", "verify"]), this.ref = i.ref || "", this.target = i.target || "", this.use = i.use || "", this.usehref = i.usehref || "", this.filter = null, this.manifest = null;
            }
          }
          class kn extends t.XFAObject {
            constructor(i) {
              super(f, "signature", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["PDF1.3", "PDF1.6"]), this.use = i.use || "", this.usehref = i.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
            }
          }
          class Cn extends t.XFAObject {
            constructor(i) {
              super(f, "signing", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.certificate = new t.XFAObjectArray();
            }
          }
          class vn extends t.XFAObject {
            constructor(i) {
              super(f, "solid", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null;
            }
            [n.$toStyle](i) {
              return i ? i[n.$toStyle]() : "#FFFFFF";
            }
          }
          class Fn extends t.StringObject {
            constructor(i) {
              super(f, "speak"), this.disable = (0, l.getInteger)({
                data: i.disable,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.id = i.id || "", this.priority = (0, l.getStringOption)(i.priority, ["custom", "caption", "name", "toolTip"]), this.rid = i.rid || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class In extends t.XFAObject {
            constructor(i) {
              super(f, "stipple", !0), this.id = i.id || "", this.rate = (0, l.getInteger)({
                data: i.rate,
                defaultValue: 50,
                validate: (B) => B >= 0 && B <= 100
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.color = null, this.extras = null;
            }
            [n.$toStyle](i) {
              const B = this.rate / 100;
              return V.Util.makeHexColor(Math.round(i.value.r * (1 - B) + this.value.r * B), Math.round(i.value.g * (1 - B) + this.value.g * B), Math.round(i.value.b * (1 - B) + this.value.b * B));
            }
          }
          class dn extends t.XFAObject {
            constructor(i) {
              super(f, "subform", !0), this.access = (0, l.getStringOption)(i.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = (0, l.getInteger)({
                data: i.allowMacro,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.anchorType = (0, l.getStringOption)(i.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = (0, l.getInteger)({
                data: i.colSpan,
                defaultValue: 1,
                validate: (B) => B >= 1 || B === -1
              }), this.columnWidths = (i.columnWidths || "").trim().split(/\s+/).map((B) => B === "-1" ? -1 : (0, l.getMeasurement)(B)), this.h = i.h ? (0, l.getMeasurement)(i.h) : "", this.hAlign = (0, l.getStringOption)(i.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = i.id || "", this.layout = (0, l.getStringOption)(i.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = i.locale || "", this.maxH = (0, l.getMeasurement)(i.maxH, "0pt"), this.maxW = (0, l.getMeasurement)(i.maxW, "0pt"), this.mergeMode = (0, l.getStringOption)(i.mergeMode, ["consumeData", "matchTemplate"]), this.minH = (0, l.getMeasurement)(i.minH, "0pt"), this.minW = (0, l.getMeasurement)(i.minW, "0pt"), this.name = i.name || "", this.presence = (0, l.getStringOption)(i.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = (0, l.getRelevant)(i.relevant), this.restoreState = (0, l.getStringOption)(i.restoreState, ["manual", "auto"]), this.scope = (0, l.getStringOption)(i.scope, ["name", "none"]), this.use = i.use || "", this.usehref = i.usehref || "", this.w = i.w ? (0, l.getMeasurement)(i.w) : "", this.x = (0, l.getMeasurement)(i.x, "0pt"), this.y = (0, l.getMeasurement)(i.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new t.XFAObjectArray(), this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.connect = new t.XFAObjectArray(), this.draw = new t.XFAObjectArray(), this.event = new t.XFAObjectArray(), this.exObject = new t.XFAObjectArray(), this.exclGroup = new t.XFAObjectArray(), this.field = new t.XFAObjectArray(), this.proto = new t.XFAObjectArray(), this.setProperty = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            [n.$getSubformParent]() {
              const i = this[n.$getParent]();
              return i instanceof cn ? i[n.$getSubformParent]() : i;
            }
            [n.$isBindable]() {
              return !0;
            }
            [n.$isThereMoreWidth]() {
              return this.layout.endsWith("-tb") && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine > 0 || this[n.$getParent]()[n.$isThereMoreWidth]();
            }
            *[n.$getContainedChildren]() {
              yield* T(this);
            }
            [n.$flushHTML]() {
              return (0, D.flushHTML)(this);
            }
            [n.$addHTML](i, B) {
              (0, D.addHTML)(this, i, B);
            }
            [n.$getAvailableSpace]() {
              return (0, D.getAvailableSpace)(this);
            }
            [n.$isSplittable]() {
              var B;
              const i = this[n.$getSubformParent]();
              return i[n.$isSplittable]() ? this[n.$extra]._isSplittable !== void 0 ? this[n.$extra]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[n.$extra]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[n.$extra]._isSplittable = !1, !1) : (B = i.layout) != null && B.endsWith("-tb") && i[n.$extra].numberInLine !== 0 ? !1 : (this[n.$extra]._isSplittable = !0, !0) : !1;
            }
            [n.$toHTML](i) {
              var St;
              if (c(this), this.break) {
                if (this.break.after !== "auto" || this.break.afterTarget !== "") {
                  const Ze = new q({
                    targetType: this.break.after,
                    target: this.break.afterTarget,
                    startNew: this.break.startNew.toString()
                  });
                  Ze[n.$globalData] = this[n.$globalData], this[n.$appendChild](Ze), this.breakAfter.push(Ze);
                }
                if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
                  const Ze = new re({
                    targetType: this.break.before,
                    target: this.break.beforeTarget,
                    startNew: this.break.startNew.toString()
                  });
                  Ze[n.$globalData] = this[n.$globalData], this[n.$appendChild](Ze), this.breakBefore.push(Ze);
                }
                if (this.break.overflowTarget !== "") {
                  const Ze = new mt({
                    target: this.break.overflowTarget,
                    leader: this.break.overflowLeader,
                    trailer: this.break.overflowTrailer
                  });
                  Ze[n.$globalData] = this[n.$globalData], this[n.$appendChild](Ze), this.overflow.push(Ze);
                }
                this[n.$removeChild](this.break), this.break = null;
              }
              if (this.presence === "hidden" || this.presence === "inactive")
                return l.HTMLResult.EMPTY;
              if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && (0, V.warn)("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
                const Ze = this.breakBefore.children[0];
                if (d(Ze))
                  return l.HTMLResult.breakNode(Ze);
              }
              if ((St = this[n.$extra]) != null && St.afterBreakAfter)
                return l.HTMLResult.EMPTY;
              (0, e.fixDimensions)(this);
              const B = [], Se = {
                id: this[n.$uid],
                class: []
              };
              (0, e.setAccess)(this, Se.class), this[n.$extra] || (this[n.$extra] = /* @__PURE__ */ Object.create(null)), Object.assign(this[n.$extra], {
                children: B,
                line: null,
                attributes: Se,
                attempt: 0,
                numberInLine: 0,
                availableSpace: {
                  width: Math.min(this.w || 1 / 0, i.width),
                  height: Math.min(this.h || 1 / 0, i.height)
                },
                width: 0,
                height: 0,
                prevHeight: 0,
                currentWidth: 0
              });
              const ve = this[n.$getTemplateRoot](), Te = ve[n.$extra].noLayoutFailure, _e = this[n.$isSplittable]();
              if (_e || u(this), !(0, D.checkDimensions)(this, i))
                return l.HTMLResult.FAILURE;
              const Ke = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
              if (this.layout.includes("row")) {
                const Ze = this[n.$getSubformParent]().columnWidths;
                Array.isArray(Ze) && Ze.length > 0 && (this[n.$extra].columnWidths = Ze, this[n.$extra].currentColumn = 0);
              }
              const Ye = (0, e.toStyle)(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), gt = ["xfaSubform"], yt = (0, e.layoutClass)(this);
              if (yt && gt.push(yt), Se.style = Ye, Se.class = gt, this.name && (Se.xfaName = this.name), this.overflow) {
                const Ze = this.overflow[n.$getExtra]();
                Ze.addLeader && (Ze.addLeader = !1, y(this, Ze.leader, i));
              }
              this[n.$pushPara]();
              const Tt = this.layout === "lr-tb" || this.layout === "rl-tb", Ft = Tt ? a : 1;
              for (; this[n.$extra].attempt < Ft; this[n.$extra].attempt++) {
                Tt && this[n.$extra].attempt === a - 1 && (this[n.$extra].numberInLine = 0);
                const Ze = this[n.$childrenToHTML]({
                  filter: Ke,
                  include: !0
                });
                if (Ze.success)
                  break;
                if (Ze.isBreak())
                  return this[n.$popPara](), Ze;
                if (Tt && this[n.$extra].attempt === 0 && this[n.$extra].numberInLine === 0 && !ve[n.$extra].noLayoutFailure) {
                  this[n.$extra].attempt = Ft;
                  break;
                }
              }
              if (this[n.$popPara](), _e || C(this), ve[n.$extra].noLayoutFailure = Te, this[n.$extra].attempt === Ft)
                return this.overflow && (this[n.$getTemplateRoot]()[n.$extra].overflowNode = this.overflow), _e || delete this[n.$extra], l.HTMLResult.FAILURE;
              if (this.overflow) {
                const Ze = this.overflow[n.$getExtra]();
                Ze.addTrailer && (Ze.addTrailer = !1, y(this, Ze.trailer, i));
              }
              let Et = 0, Bt = 0;
              this.margin && (Et = this.margin.leftInset + this.margin.rightInset, Bt = this.margin.topInset + this.margin.bottomInset);
              const xt = Math.max(this[n.$extra].width + Et, this.w || 0), Xt = Math.max(this[n.$extra].height + Bt, this.h || 0), Dt = [this.x, this.y, xt, Xt];
              if (this.w === "" && (Ye.width = (0, e.measureToString)(xt)), this.h === "" && (Ye.height = (0, e.measureToString)(Xt)), (Ye.width === "0px" || Ye.height === "0px") && B.length === 0)
                return l.HTMLResult.EMPTY;
              const Wt = {
                name: "div",
                attributes: Se,
                children: B
              };
              I(this, Se);
              const Ht = l.HTMLResult.success((0, e.createWrapper)(this, Wt), Dt);
              if (this.breakAfter.children.length >= 1) {
                const Ze = this.breakAfter.children[0];
                if (d(Ze))
                  return this[n.$extra].afterBreakAfter = Ht, l.HTMLResult.breakNode(Ze);
              }
              return delete this[n.$extra], Ht;
            }
          }
          class cn extends t.XFAObject {
            constructor(i) {
              super(f, "subformSet", !0), this.id = i.id || "", this.name = i.name || "", this.relation = (0, l.getStringOption)(i.relation, ["ordered", "choice", "unordered"]), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new t.XFAObjectArray(), this.breakBefore = new t.XFAObjectArray(), this.subform = new t.XFAObjectArray(), this.subformSet = new t.XFAObjectArray();
            }
            *[n.$getContainedChildren]() {
              yield* T(this);
            }
            [n.$getSubformParent]() {
              let i = this[n.$getParent]();
              for (; !(i instanceof dn); )
                i = i[n.$getParent]();
              return i;
            }
            [n.$isBindable]() {
              return !0;
            }
          }
          class On extends t.ContentObject {
            constructor(i) {
              super(f, "subjectDN"), this.delimiter = i.delimiter || ",", this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              this[n.$content] = new Map(this[n.$content].split(this.delimiter).map((i) => (i = i.split("=", 2), i[0] = i[0].trim(), i)));
            }
          }
          class Tn extends t.XFAObject {
            constructor(i) {
              super(f, "subjectDNs", !0), this.id = i.id || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "", this.subjectDN = new t.XFAObjectArray();
            }
          }
          class Mn extends t.XFAObject {
            constructor(i) {
              super(f, "submit", !0), this.embedPDF = (0, l.getInteger)({
                data: i.embedPDF,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.format = (0, l.getStringOption)(i.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = i.id || "", this.target = i.target || "", this.textEncoding = (0, l.getKeyword)({
                data: i.textEncoding ? i.textEncoding.toLowerCase() : "",
                defaultValue: "",
                validate: (B) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(B) || B.match(/iso-8859-\d{2}/)
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.xdpContent = i.xdpContent || "", this.encrypt = null, this.encryptData = new t.XFAObjectArray(), this.signData = new t.XFAObjectArray();
            }
          }
          class ln extends t.XFAObject {
            constructor(i) {
              super(f, "template", !0), this.baseProfile = (0, l.getStringOption)(i.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new t.XFAObjectArray();
            }
            [n.$finalize]() {
              this.subform.children.length === 0 && (0, V.warn)("XFA - No subforms in template node."), this.subform.children.length >= 2 && (0, V.warn)("XFA - Several subforms in template node: please file a bug."), this[n.$tabIndex] = p;
            }
            [n.$isSplittable]() {
              return !0;
            }
            [n.$searchNode](i, B) {
              return i.startsWith("#") ? [this[n.$ids].get(i.slice(1))] : (0, F.searchNode)(this, B, i, !0, !0);
            }
            *[n.$toPages]() {
              var Bt, xt, Xt;
              if (!this.subform.children.length)
                return l.HTMLResult.success({
                  name: "div",
                  children: []
                });
              this[n.$extra] = {
                overflowNode: null,
                firstUnsplittable: null,
                currentContentArea: null,
                currentPageArea: null,
                noLayoutFailure: !1,
                pageNumber: 1,
                pagePosition: "first",
                oddOrEven: "odd",
                blankOrNotBlank: "nonBlank",
                paraStack: []
              };
              const i = this.subform.children[0];
              i.pageSet[n.$cleanPage]();
              const B = i.pageSet.pageArea.children, Se = {
                name: "div",
                children: []
              };
              let ve = null, Te = null, _e = null;
              if (i.breakBefore.children.length >= 1 ? (Te = i.breakBefore.children[0], _e = Te.target) : i.subform.children.length >= 1 && i.subform.children[0].breakBefore.children.length >= 1 ? (Te = i.subform.children[0].breakBefore.children[0], _e = Te.target) : (Bt = i.break) != null && Bt.beforeTarget ? (Te = i.break, _e = Te.beforeTarget) : i.subform.children.length >= 1 && ((xt = i.subform.children[0].break) != null && xt.beforeTarget) && (Te = i.subform.children[0].break, _e = Te.beforeTarget), Te) {
                const Dt = this[n.$searchNode](_e, Te[n.$getParent]());
                Dt instanceof tt && (ve = Dt, Te[n.$extra] = {});
              }
              ve || (ve = B[0]), ve[n.$extra] = {
                numberOfUse: 1
              };
              const Ke = ve[n.$getParent]();
              Ke[n.$extra] = {
                numberOfUse: 1,
                pageIndex: Ke.pageArea.children.indexOf(ve),
                pageSetIndex: 0
              };
              let Ye, gt = null, yt = null, Tt = !0, Ft = 0, Et = 0;
              for (; ; ) {
                if (Tt)
                  Ft = 0;
                else if (Se.children.pop(), ++Ft === N)
                  return (0, V.warn)("XFA - Something goes wrong: please file a bug."), Se;
                Ye = null, this[n.$extra].currentPageArea = ve;
                const Dt = ve[n.$toHTML]().html;
                Se.children.push(Dt), gt && (this[n.$extra].noLayoutFailure = !0, Dt.children.push(gt[n.$toHTML](ve[n.$extra].space).html), gt = null), yt && (this[n.$extra].noLayoutFailure = !0, Dt.children.push(yt[n.$toHTML](ve[n.$extra].space).html), yt = null);
                const Wt = ve.contentArea.children, Ht = Dt.children.filter((Ze) => Ze.attributes.class.includes("xfaContentarea"));
                Tt = !1, this[n.$extra].firstUnsplittable = null, this[n.$extra].noLayoutFailure = !1;
                const St = (Ze) => {
                  var Vt;
                  const Kt = i[n.$flushHTML]();
                  Kt && (Tt || (Tt = ((Vt = Kt.children) == null ? void 0 : Vt.length) > 0), Ht[Ze].children.push(Kt));
                };
                for (let Ze = Et, Kt = Wt.length; Ze < Kt; Ze++) {
                  const Vt = this[n.$extra].currentContentArea = Wt[Ze], Zt = {
                    width: Vt.w,
                    height: Vt.h
                  };
                  Et = 0, gt && (Ht[Ze].children.push(gt[n.$toHTML](Zt).html), gt = null), yt && (Ht[Ze].children.push(yt[n.$toHTML](Zt).html), yt = null);
                  const Jt = i[n.$toHTML](Zt);
                  if (Jt.success)
                    return Jt.html ? (Tt || (Tt = ((Xt = Jt.html.children) == null ? void 0 : Xt.length) > 0), Ht[Ze].children.push(Jt.html)) : !Tt && Se.children.length > 1 && Se.children.pop(), Se;
                  if (Jt.isBreak()) {
                    const zt = Jt.breakNode;
                    if (St(Ze), zt.targetType === "auto")
                      continue;
                    zt.leader && (gt = this[n.$searchNode](zt.leader, zt[n.$getParent]()), gt = gt ? gt[0] : null), zt.trailer && (yt = this[n.$searchNode](zt.trailer, zt[n.$getParent]()), yt = yt ? yt[0] : null), zt.targetType === "pageArea" ? (Ye = zt[n.$extra].target, Ze = 1 / 0) : zt[n.$extra].target ? (Ye = zt[n.$extra].target, Et = zt[n.$extra].index + 1, Ze = 1 / 0) : Ze = zt[n.$extra].index;
                    continue;
                  }
                  if (this[n.$extra].overflowNode) {
                    const zt = this[n.$extra].overflowNode;
                    this[n.$extra].overflowNode = null;
                    const un = zt[n.$getExtra](), an = un.target;
                    un.addLeader = un.leader !== null, un.addTrailer = un.trailer !== null, St(Ze);
                    const ha = Ze;
                    if (Ze = 1 / 0, an instanceof tt)
                      Ye = an;
                    else if (an instanceof ae) {
                      const mn = Wt.indexOf(an);
                      mn !== -1 ? mn > ha ? Ze = mn - 1 : Et = mn : (Ye = an[n.$getParent](), Et = Ye.contentArea.children.indexOf(an));
                    }
                    continue;
                  }
                  St(Ze);
                }
                this[n.$extra].pageNumber += 1, Ye && (Ye[n.$isUsable]() ? Ye[n.$extra].numberOfUse += 1 : Ye = null), ve = Ye || ve[n.$getNextPage](), yield null;
              }
            }
          }
          b.Template = ln;
          class gn extends t.ContentObject {
            constructor(i) {
              super(f, "text"), this.id = i.id || "", this.maxChars = (0, l.getInteger)({
                data: i.maxChars,
                defaultValue: 0,
                validate: (B) => B >= 0
              }), this.name = i.name || "", this.rid = i.rid || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$acceptWhitespace]() {
              return !0;
            }
            [n.$onChild](i) {
              return i[n.$namespaceId] === P.NamespaceIds.xhtml.id ? (this[n.$content] = i, !0) : ((0, V.warn)(`XFA - Invalid content in Text: ${i[n.$nodeName]}.`), !1);
            }
            [n.$onText](i) {
              this[n.$content] instanceof t.XFAObject || super[n.$onText](i);
            }
            [n.$finalize]() {
              typeof this[n.$content] == "string" && (this[n.$content] = this[n.$content].replaceAll(`\r
`, `
`));
            }
            [n.$getExtra]() {
              return typeof this[n.$content] == "string" ? this[n.$content].split(/[\u2029\u2028\n]/).reduce((i, B) => (B && i.push(B), i), []).join(`
`) : this[n.$content][n.$text]();
            }
            [n.$toHTML](i) {
              if (typeof this[n.$content] == "string") {
                const B = r(this[n.$content]).html;
                return this[n.$content].includes("\u2029") ? (B.name = "div", B.children = [], this[n.$content].split("\u2029").map((Se) => Se.split(/[\u2028\n]/).reduce((ve, Te) => (ve.push({
                  name: "span",
                  value: Te
                }, {
                  name: "br"
                }), ve), [])).forEach((Se) => {
                  B.children.push({
                    name: "p",
                    children: Se
                  });
                })) : /[\u2028\n]/.test(this[n.$content]) && (B.name = "div", B.children = [], this[n.$content].split(/[\u2028\n]/).forEach((Se) => {
                  B.children.push({
                    name: "span",
                    value: Se
                  }, {
                    name: "br"
                  });
                })), l.HTMLResult.success(B);
              }
              return this[n.$content][n.$toHTML](i);
            }
          }
          b.Text = gn;
          class xn extends t.XFAObject {
            constructor(i) {
              super(f, "textEdit", !0), this.allowRichText = (0, l.getInteger)({
                data: i.allowRichText,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.hScrollPolicy = (0, l.getStringOption)(i.hScrollPolicy, ["auto", "off", "on"]), this.id = i.id || "", this.multiLine = (0, l.getInteger)({
                data: i.multiLine,
                defaultValue: "",
                validate: (B) => B === 0 || B === 1
              }), this.use = i.use || "", this.usehref = i.usehref || "", this.vScrollPolicy = (0, l.getStringOption)(i.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
            }
            [n.$toHTML](i) {
              var Te, _e;
              const B = (0, e.toStyle)(this, "border", "font", "margin");
              let Se;
              const ve = this[n.$getParent]()[n.$getParent]();
              return this.multiLine === "" && (this.multiLine = ve instanceof pe ? 1 : 0), this.multiLine === 1 ? Se = {
                name: "textarea",
                attributes: {
                  dataId: ((Te = ve[n.$data]) == null ? void 0 : Te[n.$uid]) || ve[n.$uid],
                  fieldId: ve[n.$uid],
                  class: ["xfaTextfield"],
                  style: B,
                  "aria-label": s(ve),
                  "aria-required": !1
                }
              } : Se = {
                name: "input",
                attributes: {
                  type: "text",
                  dataId: ((_e = ve[n.$data]) == null ? void 0 : _e[n.$uid]) || ve[n.$uid],
                  fieldId: ve[n.$uid],
                  class: ["xfaTextfield"],
                  style: B,
                  "aria-label": s(ve),
                  "aria-required": !1
                }
              }, o(ve) && (Se.attributes["aria-required"] = !0, Se.attributes.required = !0), l.HTMLResult.success({
                name: "label",
                attributes: {
                  class: ["xfaLabel"]
                },
                children: [Se]
              });
            }
          }
          class Pn extends t.StringObject {
            constructor(i) {
              super(f, "time"), this.id = i.id || "", this.name = i.name || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
            [n.$finalize]() {
              const i = this[n.$content].trim();
              this[n.$content] = i ? new Date(i) : null;
            }
            [n.$toHTML](i) {
              return r(this[n.$content] ? this[n.$content].toString() : "");
            }
          }
          class En extends t.XFAObject {
            constructor(i) {
              super(f, "timeStamp"), this.id = i.id || "", this.server = i.server || "", this.type = (0, l.getStringOption)(i.type, ["optional", "required"]), this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Nn extends t.StringObject {
            constructor(i) {
              super(f, "toolTip"), this.id = i.id || "", this.rid = i.rid || "", this.use = i.use || "", this.usehref = i.usehref || "";
            }
          }
          class Dn extends t.XFAObject {
            constructor(i) {
              super(f, "traversal", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.traverse = new t.XFAObjectArray();
            }
          }
          class Rn extends t.XFAObject {
            constructor(i) {
              super(f, "traverse", !0), this.id = i.id || "", this.operation = (0, l.getStringOption)(i.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = i.ref || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.script = null;
            }
            get name() {
              return this.operation;
            }
            [n.$isTransparent]() {
              return !1;
            }
          }
          class hn extends t.XFAObject {
            constructor(i) {
              super(f, "ui", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
            }
            [n.$getExtra]() {
              if (this[n.$extra] === void 0) {
                for (const i of Object.getOwnPropertyNames(this)) {
                  if (i === "extras" || i === "picture")
                    continue;
                  const B = this[i];
                  if (B instanceof t.XFAObject)
                    return this[n.$extra] = B, B;
                }
                this[n.$extra] = null;
              }
              return this[n.$extra];
            }
            [n.$toHTML](i) {
              const B = this[n.$getExtra]();
              return B ? B[n.$toHTML](i) : l.HTMLResult.EMPTY;
            }
          }
          class Bn extends t.XFAObject {
            constructor(i) {
              super(f, "validate", !0), this.formatTest = (0, l.getStringOption)(i.formatTest, ["warning", "disabled", "error"]), this.id = i.id || "", this.nullTest = (0, l.getStringOption)(i.nullTest, ["disabled", "error", "warning"]), this.scriptTest = (0, l.getStringOption)(i.scriptTest, ["error", "disabled", "warning"]), this.use = i.use || "", this.usehref = i.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
            }
          }
          class tn extends t.XFAObject {
            constructor(i) {
              super(f, "value", !0), this.id = i.id || "", this.override = (0, l.getInteger)({
                data: i.override,
                defaultValue: 0,
                validate: (B) => B === 1
              }), this.relevant = (0, l.getRelevant)(i.relevant), this.use = i.use || "", this.usehref = i.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
            }
            [n.$setValue](i) {
              var ve;
              const B = this[n.$getParent]();
              if (B instanceof Pe && (ve = B.ui) != null && ve.imageEdit) {
                this.image || (this.image = new ze({}), this[n.$appendChild](this.image)), this.image[n.$content] = i[n.$content];
                return;
              }
              const Se = i[n.$nodeName];
              if (this[Se] !== null) {
                this[Se][n.$content] = i[n.$content];
                return;
              }
              for (const Te of Object.getOwnPropertyNames(this)) {
                const _e = this[Te];
                _e instanceof t.XFAObject && (this[Te] = null, this[n.$removeChild](_e));
              }
              this[i[n.$nodeName]] = i, this[n.$appendChild](i);
            }
            [n.$text]() {
              if (this.exData)
                return typeof this.exData[n.$content] == "string" ? this.exData[n.$content].trim() : this.exData[n.$content][n.$text]().trim();
              for (const i of Object.getOwnPropertyNames(this)) {
                if (i === "image")
                  continue;
                const B = this[i];
                if (B instanceof t.XFAObject)
                  return (B[n.$content] || "").toString().trim();
              }
              return null;
            }
            [n.$toHTML](i) {
              for (const B of Object.getOwnPropertyNames(this)) {
                const Se = this[B];
                if (Se instanceof t.XFAObject)
                  return Se[n.$toHTML](i);
              }
              return l.HTMLResult.EMPTY;
            }
          }
          b.Value = tn;
          class Ln extends t.XFAObject {
            constructor(i) {
              super(f, "variables", !0), this.id = i.id || "", this.use = i.use || "", this.usehref = i.usehref || "", this.boolean = new t.XFAObjectArray(), this.date = new t.XFAObjectArray(), this.dateTime = new t.XFAObjectArray(), this.decimal = new t.XFAObjectArray(), this.exData = new t.XFAObjectArray(), this.float = new t.XFAObjectArray(), this.image = new t.XFAObjectArray(), this.integer = new t.XFAObjectArray(), this.manifest = new t.XFAObjectArray(), this.script = new t.XFAObjectArray(), this.text = new t.XFAObjectArray(), this.time = new t.XFAObjectArray();
            }
            [n.$isTransparent]() {
              return !0;
            }
          }
          class nn {
            static [P.$buildXFAObject](i, B) {
              if (nn.hasOwnProperty(i)) {
                const Se = nn[i](B);
                return Se[n.$setSetAttributes](B), Se;
              }
            }
            static appearanceFilter(i) {
              return new _(i);
            }
            static arc(i) {
              return new $(i);
            }
            static area(i) {
              return new S(i);
            }
            static assist(i) {
              return new v(i);
            }
            static barcode(i) {
              return new m(i);
            }
            static bind(i) {
              return new h(i);
            }
            static bindItems(i) {
              return new A(i);
            }
            static bookend(i) {
              return new j(i);
            }
            static boolean(i) {
              return new G(i);
            }
            static border(i) {
              return new J(i);
            }
            static break(i) {
              return new oe(i);
            }
            static breakAfter(i) {
              return new q(i);
            }
            static breakBefore(i) {
              return new re(i);
            }
            static button(i) {
              return new K(i);
            }
            static calculate(i) {
              return new Z(i);
            }
            static caption(i) {
              return new w(i);
            }
            static certificate(i) {
              return new k(i);
            }
            static certificates(i) {
              return new X(i);
            }
            static checkButton(i) {
              return new H(i);
            }
            static choiceList(i) {
              return new Y(i);
            }
            static color(i) {
              return new ie(i);
            }
            static comb(i) {
              return new ne(i);
            }
            static connect(i) {
              return new U(i);
            }
            static contentArea(i) {
              return new ae(i);
            }
            static corner(i) {
              return new Q(i);
            }
            static date(i) {
              return new L(i);
            }
            static dateTime(i) {
              return new ee(i);
            }
            static dateTimeEdit(i) {
              return new se(i);
            }
            static decimal(i) {
              return new le(i);
            }
            static defaultUi(i) {
              return new ue(i);
            }
            static desc(i) {
              return new de(i);
            }
            static digestMethod(i) {
              return new ge(i);
            }
            static digestMethods(i) {
              return new me(i);
            }
            static draw(i) {
              return new pe(i);
            }
            static edge(i) {
              return new xe(i);
            }
            static encoding(i) {
              return new we(i);
            }
            static encodings(i) {
              return new Ae(i);
            }
            static encrypt(i) {
              return new be(i);
            }
            static encryptData(i) {
              return new he(i);
            }
            static encryption(i) {
              return new fe(i);
            }
            static encryptionMethod(i) {
              return new Ce(i);
            }
            static encryptionMethods(i) {
              return new ye(i);
            }
            static event(i) {
              return new Le(i);
            }
            static exData(i) {
              return new Be(i);
            }
            static exObject(i) {
              return new nt(i);
            }
            static exclGroup(i) {
              return new Oe(i);
            }
            static execute(i) {
              return new Je(i);
            }
            static extras(i) {
              return new Ve(i);
            }
            static field(i) {
              return new Pe(i);
            }
            static fill(i) {
              return new Ge(i);
            }
            static filter(i) {
              return new dt(i);
            }
            static float(i) {
              return new De(i);
            }
            static font(i) {
              return new Qe(i);
            }
            static format(i) {
              return new st(i);
            }
            static handler(i) {
              return new wt(i);
            }
            static hyphenation(i) {
              return new Ot(i);
            }
            static image(i) {
              return new ze(i);
            }
            static imageEdit(i) {
              return new qe(i);
            }
            static integer(i) {
              return new Ue(i);
            }
            static issuers(i) {
              return new bt(i);
            }
            static items(i) {
              return new It(i);
            }
            static keep(i) {
              return new kt(i);
            }
            static keyUsage(i) {
              return new ht(i);
            }
            static line(i) {
              return new Rt(i);
            }
            static linear(i) {
              return new _t(i);
            }
            static lockDocument(i) {
              return new Ie(i);
            }
            static manifest(i) {
              return new Fe(i);
            }
            static margin(i) {
              return new Me(i);
            }
            static mdp(i) {
              return new Ne(i);
            }
            static medium(i) {
              return new je(i);
            }
            static message(i) {
              return new et(i);
            }
            static numericEdit(i) {
              return new $e(i);
            }
            static occur(i) {
              return new Ee(i);
            }
            static oid(i) {
              return new He(i);
            }
            static oids(i) {
              return new rt(i);
            }
            static overflow(i) {
              return new mt(i);
            }
            static pageArea(i) {
              return new tt(i);
            }
            static pageSet(i) {
              return new at(i);
            }
            static para(i) {
              return new ft(i);
            }
            static passwordEdit(i) {
              return new We(i);
            }
            static pattern(i) {
              return new ot(i);
            }
            static picture(i) {
              return new Xe(i);
            }
            static proto(i) {
              return new ut(i);
            }
            static radial(i) {
              return new pt(i);
            }
            static reason(i) {
              return new $t(i);
            }
            static reasons(i) {
              return new ct(i);
            }
            static rectangle(i) {
              return new lt(i);
            }
            static ref(i) {
              return new vt(i);
            }
            static script(i) {
              return new Nt(i);
            }
            static setProperty(i) {
              return new qt(i);
            }
            static signData(i) {
              return new en(i);
            }
            static signature(i) {
              return new kn(i);
            }
            static signing(i) {
              return new Cn(i);
            }
            static solid(i) {
              return new vn(i);
            }
            static speak(i) {
              return new Fn(i);
            }
            static stipple(i) {
              return new In(i);
            }
            static subform(i) {
              return new dn(i);
            }
            static subformSet(i) {
              return new cn(i);
            }
            static subjectDN(i) {
              return new On(i);
            }
            static subjectDNs(i) {
              return new Tn(i);
            }
            static submit(i) {
              return new Mn(i);
            }
            static template(i) {
              return new ln(i);
            }
            static text(i) {
              return new gn(i);
            }
            static textEdit(i) {
              return new xn(i);
            }
            static time(i) {
              return new Pn(i);
            }
            static timeStamp(i) {
              return new En(i);
            }
            static toolTip(i) {
              return new Nn(i);
            }
            static traversal(i) {
              return new Dn(i);
            }
            static traverse(i) {
              return new Rn(i);
            }
            static ui(i) {
              return new hn(i);
            }
            static validate(i) {
              return new Bn(i);
            }
            static value(i) {
              return new tn(i);
            }
            static variables(i) {
              return new Ln(i);
            }
          }
          b.TemplateNamespace = nn;
        },
        /* 81 */
        /***/
        (Re, b) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.NamespaceIds = b.$buildXFAObject = void 0;
          const ce = Symbol();
          b.$buildXFAObject = ce;
          const n = {
            config: {
              id: 0,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xci/")
            },
            connectionSet: {
              id: 1,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
            },
            datasets: {
              id: 2,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-data/")
            },
            form: {
              id: 3,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-form/")
            },
            localeSet: {
              id: 4,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
            },
            pdf: {
              id: 5,
              check: (P) => P === "http://ns.adobe.com/xdp/pdf/"
            },
            signature: {
              id: 6,
              check: (P) => P === "http://www.w3.org/2000/09/xmldsig#"
            },
            sourceSet: {
              id: 7,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-source-set/")
            },
            stylesheet: {
              id: 8,
              check: (P) => P === "http://www.w3.org/1999/XSL/Transform"
            },
            template: {
              id: 9,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xfa-template/")
            },
            xdc: {
              id: 10,
              check: (P) => P.startsWith("http://www.xfa.org/schema/xdc/")
            },
            xdp: {
              id: 11,
              check: (P) => P === "http://ns.adobe.com/xdp/"
            },
            xfdf: {
              id: 12,
              check: (P) => P === "http://ns.adobe.com/xfdf/"
            },
            xhtml: {
              id: 13,
              check: (P) => P === "http://www.w3.org/1999/xhtml"
            },
            xmpmeta: {
              id: 14,
              check: (P) => P === "http://ns.adobe.com/xmpmeta/"
            }
          };
          b.NamespaceIds = n;
        },
        /* 82 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.addHTML = t, b.checkDimensions = te, b.flushHTML = e, b.getAvailableSpace = l;
          var n = ce(78), P = ce(83);
          function D(E, F) {
            return {
              name: "div",
              attributes: {
                class: [E.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
              },
              children: F
            };
          }
          function e(E) {
            if (!E[n.$extra])
              return null;
            const f = {
              name: "div",
              attributes: E[n.$extra].attributes,
              children: E[n.$extra].children
            };
            if (E[n.$extra].failingNode) {
              const x = E[n.$extra].failingNode[n.$flushHTML]();
              x && (E.layout.endsWith("-tb") ? f.children.push(D(E, [x])) : f.children.push(x));
            }
            return f.children.length === 0 ? null : f;
          }
          function t(E, F, f) {
            const x = E[n.$extra], a = x.availableSpace, [N, p, O, M] = f;
            switch (E.layout) {
              case "position": {
                x.width = Math.max(x.width, N + O), x.height = Math.max(x.height, p + M), x.children.push(F);
                break;
              }
              case "lr-tb":
              case "rl-tb":
                (!x.line || x.attempt === 1) && (x.line = D(E, []), x.children.push(x.line), x.numberInLine = 0), x.numberInLine += 1, x.line.children.push(F), x.attempt === 0 ? (x.currentWidth += O, x.height = Math.max(x.height, x.prevHeight + M)) : (x.currentWidth = O, x.prevHeight = x.height, x.height += M, x.attempt = 0), x.width = Math.max(x.width, x.currentWidth);
                break;
              case "rl-row":
              case "row": {
                x.children.push(F), x.width += O, x.height = Math.max(x.height, M);
                const R = (0, P.measureToString)(x.height);
                for (const z of x.children)
                  z.attributes.style.height = R;
                break;
              }
              case "table": {
                x.width = Math.min(a.width, Math.max(x.width, O)), x.height += M, x.children.push(F);
                break;
              }
              case "tb": {
                x.width = Math.min(a.width, Math.max(x.width, O)), x.height += M, x.children.push(F);
                break;
              }
            }
          }
          function l(E) {
            const F = E[n.$extra].availableSpace, f = E.margin ? E.margin.topInset + E.margin.bottomInset : 0, x = E.margin ? E.margin.leftInset + E.margin.rightInset : 0;
            switch (E.layout) {
              case "lr-tb":
              case "rl-tb":
                return E[n.$extra].attempt === 0 ? {
                  width: F.width - x - E[n.$extra].currentWidth,
                  height: F.height - f - E[n.$extra].prevHeight
                } : {
                  width: F.width - x,
                  height: F.height - f - E[n.$extra].height
                };
              case "rl-row":
              case "row":
                return {
                  width: E[n.$extra].columnWidths.slice(E[n.$extra].currentColumn).reduce((N, p) => N + p),
                  height: F.height - x
                };
              case "table":
              case "tb":
                return {
                  width: F.width - x,
                  height: F.height - f - E[n.$extra].height
                };
              case "position":
              default:
                return F;
            }
          }
          function V(E) {
            let F = E.w === "" ? NaN : E.w, f = E.h === "" ? NaN : E.h, [x, a] = [0, 0];
            switch (E.anchorType || "") {
              case "bottomCenter":
                [x, a] = [F / 2, f];
                break;
              case "bottomLeft":
                [x, a] = [0, f];
                break;
              case "bottomRight":
                [x, a] = [F, f];
                break;
              case "middleCenter":
                [x, a] = [F / 2, f / 2];
                break;
              case "middleLeft":
                [x, a] = [0, f / 2];
                break;
              case "middleRight":
                [x, a] = [F, f / 2];
                break;
              case "topCenter":
                [x, a] = [F / 2, 0];
                break;
              case "topRight":
                [x, a] = [F, 0];
                break;
            }
            let N, p;
            switch (E.rotate || 0) {
              case 0:
                [N, p] = [-x, -a];
                break;
              case 90:
                [N, p] = [-a, x], [F, f] = [f, -F];
                break;
              case 180:
                [N, p] = [x, a], [F, f] = [-F, -f];
                break;
              case 270:
                [N, p] = [a, -x], [F, f] = [-f, F];
                break;
            }
            return [E.x + N + Math.min(0, F), E.y + p + Math.min(0, f), Math.abs(F), Math.abs(f)];
          }
          function te(E, F) {
            var M;
            if (E[n.$getTemplateRoot]()[n.$extra].firstUnsplittable === null || E.w === 0 || E.h === 0)
              return !0;
            const f = 2, x = E[n.$getSubformParent](), a = ((M = x[n.$extra]) == null ? void 0 : M.attempt) || 0, [, N, p, O] = V(E);
            switch (x.layout) {
              case "lr-tb":
              case "rl-tb":
                return a === 0 ? E[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? E.w !== "" ? Math.round(p - F.width) <= f : F.width > f : E.h !== "" && Math.round(O - F.height) > f ? !1 : E.w !== "" ? Math.round(p - F.width) <= f ? !0 : x[n.$extra].numberInLine === 0 ? F.height > f : !1 : F.width > f : E[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : E.h !== "" && Math.round(O - F.height) > f ? !1 : E.w === "" || Math.round(p - F.width) <= f ? F.height > f : x[n.$isThereMoreWidth]() ? !1 : F.height > f;
              case "table":
              case "tb":
                return E[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : E.h !== "" && !E[n.$isSplittable]() ? Math.round(O - F.height) <= f : E.w === "" || Math.round(p - F.width) <= f ? F.height > f : x[n.$isThereMoreWidth]() ? !1 : F.height > f;
              case "position":
                if (E[n.$getTemplateRoot]()[n.$extra].noLayoutFailure || E.h === "" || Math.round(O + N - F.height) <= f)
                  return !0;
                const R = E[n.$getTemplateRoot]()[n.$extra].currentContentArea;
                return O + N > R.h;
              case "rl-row":
              case "row":
                return E[n.$getTemplateRoot]()[n.$extra].noLayoutFailure ? !0 : E.h !== "" ? Math.round(O - F.height) <= f : !0;
              default:
                return !0;
            }
          }
        },
        /* 83 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.computeBbox = x, b.createWrapper = O, b.fixDimensions = a, b.fixTextIndent = M, b.fixURL = o, b.isPrintOnly = z, b.layoutClass = N, b.layoutNode = f, b.measureToString = V, b.setAccess = R, b.setFontFamily = T, b.setMinMaxDimensions = E, b.setPara = g, b.toStyle = p;
          var n = ce(78), P = ce(2), D = ce(84), e = ce(85), t = ce(86), l = ce(87);
          function V(c) {
            return typeof c == "string" ? "0px" : Number.isInteger(c) ? `${c}px` : `${c.toFixed(2)}px`;
          }
          const te = {
            anchorType(c, I) {
              const s = c[n.$getSubformParent]();
              if (!(!s || s.layout && s.layout !== "position"))
                switch ("transform" in I || (I.transform = ""), c.anchorType) {
                  case "bottomCenter":
                    I.transform += "translate(-50%, -100%)";
                    break;
                  case "bottomLeft":
                    I.transform += "translate(0,-100%)";
                    break;
                  case "bottomRight":
                    I.transform += "translate(-100%,-100%)";
                    break;
                  case "middleCenter":
                    I.transform += "translate(-50%,-50%)";
                    break;
                  case "middleLeft":
                    I.transform += "translate(0,-50%)";
                    break;
                  case "middleRight":
                    I.transform += "translate(-100%,-50%)";
                    break;
                  case "topCenter":
                    I.transform += "translate(-50%,0)";
                    break;
                  case "topRight":
                    I.transform += "translate(-100%,0)";
                    break;
                }
            },
            dimensions(c, I) {
              var C;
              const s = c[n.$getSubformParent]();
              let r = c.w;
              const u = c.h;
              if ((C = s.layout) != null && C.includes("row")) {
                const d = s[n.$extra], y = c.colSpan;
                let _;
                y === -1 ? (_ = d.columnWidths.slice(d.currentColumn).reduce(($, S) => $ + S, 0), d.currentColumn = 0) : (_ = d.columnWidths.slice(d.currentColumn, d.currentColumn + y).reduce(($, S) => $ + S, 0), d.currentColumn = (d.currentColumn + c.colSpan) % d.columnWidths.length), isNaN(_) || (r = c.w = _);
              }
              I.width = r !== "" ? V(r) : "auto", I.height = u !== "" ? V(u) : "auto";
            },
            position(c, I) {
              const s = c[n.$getSubformParent]();
              s != null && s.layout && s.layout !== "position" || (I.position = "absolute", I.left = V(c.x), I.top = V(c.y));
            },
            rotate(c, I) {
              c.rotate && ("transform" in I || (I.transform = ""), I.transform += `rotate(-${c.rotate}deg)`, I.transformOrigin = "top left");
            },
            presence(c, I) {
              switch (c.presence) {
                case "invisible":
                  I.visibility = "hidden";
                  break;
                case "hidden":
                case "inactive":
                  I.display = "none";
                  break;
              }
            },
            hAlign(c, I) {
              if (c[n.$nodeName] === "para")
                switch (c.hAlign) {
                  case "justifyAll":
                    I.textAlign = "justify-all";
                    break;
                  case "radix":
                    I.textAlign = "left";
                    break;
                  default:
                    I.textAlign = c.hAlign;
                }
              else
                switch (c.hAlign) {
                  case "left":
                    I.alignSelf = "start";
                    break;
                  case "center":
                    I.alignSelf = "center";
                    break;
                  case "right":
                    I.alignSelf = "end";
                    break;
                }
            },
            margin(c, I) {
              c.margin && (I.margin = c.margin[n.$toStyle]().margin);
            }
          };
          function E(c, I) {
            c[n.$getSubformParent]().layout === "position" && (c.minW > 0 && (I.minWidth = V(c.minW)), c.maxW > 0 && (I.maxWidth = V(c.maxW)), c.minH > 0 && (I.minHeight = V(c.minH)), c.maxH > 0 && (I.maxHeight = V(c.maxH)));
          }
          function F(c, I, s, r, u, C) {
            const d = new t.TextMeasure(I, s, r, u);
            return typeof c == "string" ? d.addString(c) : c[n.$pushGlyphs](d), d.compute(C);
          }
          function f(c, I) {
            let s = null, r = null, u = !1;
            if ((!c.w || !c.h) && c.value) {
              let C = 0, d = 0;
              c.margin && (C = c.margin.leftInset + c.margin.rightInset, d = c.margin.topInset + c.margin.bottomInset);
              let y = null, _ = null;
              c.para && (_ = /* @__PURE__ */ Object.create(null), y = c.para.lineHeight === "" ? null : c.para.lineHeight, _.top = c.para.spaceAbove === "" ? 0 : c.para.spaceAbove, _.bottom = c.para.spaceBelow === "" ? 0 : c.para.spaceBelow, _.left = c.para.marginLeft === "" ? 0 : c.para.marginLeft, _.right = c.para.marginRight === "" ? 0 : c.para.marginRight);
              let $ = c.font;
              if (!$) {
                const m = c[n.$getTemplateRoot]();
                let h = c[n.$getParent]();
                for (; h && h !== m; ) {
                  if (h.font) {
                    $ = h.font;
                    break;
                  }
                  h = h[n.$getParent]();
                }
              }
              const S = (c.w || I.width) - C, v = c[n.$globalData].fontFinder;
              if (c.value.exData && c.value.exData[n.$content] && c.value.exData.contentType === "text/html") {
                const m = F(c.value.exData[n.$content], $, _, y, v, S);
                r = m.width, s = m.height, u = m.isBroken;
              } else {
                const m = c.value[n.$text]();
                if (m) {
                  const h = F(m, $, _, y, v, S);
                  r = h.width, s = h.height, u = h.isBroken;
                }
              }
              r !== null && !c.w && (r += C), s !== null && !c.h && (s += d);
            }
            return {
              w: r,
              h: s,
              isBroken: u
            };
          }
          function x(c, I, s) {
            let r;
            if (c.w !== "" && c.h !== "")
              r = [c.x, c.y, c.w, c.h];
            else {
              if (!s)
                return null;
              let u = c.w;
              if (u === "") {
                if (c.maxW === 0) {
                  const d = c[n.$getSubformParent]();
                  u = d.layout === "position" && d.w !== "" ? 0 : c.minW;
                } else
                  u = Math.min(c.maxW, s.width);
                I.attributes.style.width = V(u);
              }
              let C = c.h;
              if (C === "") {
                if (c.maxH === 0) {
                  const d = c[n.$getSubformParent]();
                  C = d.layout === "position" && d.h !== "" ? 0 : c.minH;
                } else
                  C = Math.min(c.maxH, s.height);
                I.attributes.style.height = V(C);
              }
              r = [c.x, c.y, u, C];
            }
            return r;
          }
          function a(c) {
            var s;
            const I = c[n.$getSubformParent]();
            if ((s = I.layout) != null && s.includes("row")) {
              const r = I[n.$extra], u = c.colSpan;
              let C;
              u === -1 ? C = r.columnWidths.slice(r.currentColumn).reduce((d, y) => d + y, 0) : C = r.columnWidths.slice(r.currentColumn, r.currentColumn + u).reduce((d, y) => d + y, 0), isNaN(C) || (c.w = C);
            }
            I.layout && I.layout !== "position" && (c.x = c.y = 0), c.layout === "table" && c.w === "" && Array.isArray(c.columnWidths) && (c.w = c.columnWidths.reduce((r, u) => r + u, 0));
          }
          function N(c) {
            switch (c.layout) {
              case "position":
                return "xfaPosition";
              case "lr-tb":
                return "xfaLrTb";
              case "rl-row":
                return "xfaRlRow";
              case "rl-tb":
                return "xfaRlTb";
              case "row":
                return "xfaRow";
              case "table":
                return "xfaTable";
              case "tb":
                return "xfaTb";
              default:
                return "xfaPosition";
            }
          }
          function p(c, ...I) {
            const s = /* @__PURE__ */ Object.create(null);
            for (const r of I) {
              const u = c[r];
              if (u !== null) {
                if (te.hasOwnProperty(r)) {
                  te[r](c, s);
                  continue;
                }
                if (u instanceof l.XFAObject) {
                  const C = u[n.$toStyle]();
                  C ? Object.assign(s, C) : (0, P.warn)(`(DEBUG) - XFA - style for ${r} not implemented yet`);
                }
              }
            }
            return s;
          }
          function O(c, I) {
            const {
              attributes: s
            } = I, {
              style: r
            } = s, u = {
              name: "div",
              attributes: {
                class: ["xfaWrapper"],
                style: /* @__PURE__ */ Object.create(null)
              },
              children: []
            };
            if (s.class.push("xfaWrapped"), c.border) {
              const {
                widths: C,
                insets: d
              } = c.border[n.$extra];
              let y, _, $ = d[0], S = d[3];
              const v = d[0] + d[2], m = d[1] + d[3];
              switch (c.border.hand) {
                case "even":
                  $ -= C[0] / 2, S -= C[3] / 2, y = `calc(100% + ${(C[1] + C[3]) / 2 - m}px)`, _ = `calc(100% + ${(C[0] + C[2]) / 2 - v}px)`;
                  break;
                case "left":
                  $ -= C[0], S -= C[3], y = `calc(100% + ${C[1] + C[3] - m}px)`, _ = `calc(100% + ${C[0] + C[2] - v}px)`;
                  break;
                case "right":
                  y = m ? `calc(100% - ${m}px)` : "100%", _ = v ? `calc(100% - ${v}px)` : "100%";
                  break;
              }
              const h = ["xfaBorder"];
              z(c.border) && h.push("xfaPrintOnly");
              const A = {
                name: "div",
                attributes: {
                  class: h,
                  style: {
                    top: `${$}px`,
                    left: `${S}px`,
                    width: y,
                    height: _
                  }
                },
                children: []
              };
              for (const j of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
                r[j] !== void 0 && (A.attributes.style[j] = r[j], delete r[j]);
              u.children.push(A, I);
            } else
              u.children.push(I);
            for (const C of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
              r[C] !== void 0 && (u.attributes.style[C] = r[C], delete r[C]);
            return u.attributes.style.position = r.position === "absolute" ? "absolute" : "relative", delete r.position, r.alignSelf && (u.attributes.style.alignSelf = r.alignSelf, delete r.alignSelf), u;
          }
          function M(c) {
            const I = (0, D.getMeasurement)(c.textIndent, "0px");
            if (I >= 0)
              return;
            const r = "padding" + ((c.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), u = (0, D.getMeasurement)(c[r], "0px");
            c[r] = `${u - I}px`;
          }
          function R(c, I) {
            switch (c.access) {
              case "nonInteractive":
                I.push("xfaNonInteractive");
                break;
              case "readOnly":
                I.push("xfaReadOnly");
                break;
              case "protected":
                I.push("xfaDisabled");
                break;
            }
          }
          function z(c) {
            return c.relevant.length > 0 && !c.relevant[0].excluded && c.relevant[0].viewname === "print";
          }
          function W(c) {
            const I = c[n.$getTemplateRoot]()[n.$extra].paraStack;
            return I.length ? I.at(-1) : null;
          }
          function g(c, I, s) {
            var r;
            if ((r = s.attributes.class) != null && r.includes("xfaRich")) {
              I && (c.h === "" && (I.height = "auto"), c.w === "" && (I.width = "auto"));
              const u = W(c);
              if (u) {
                const C = s.attributes.style;
                switch (C.display = "flex", C.flexDirection = "column", u.vAlign) {
                  case "top":
                    C.justifyContent = "start";
                    break;
                  case "bottom":
                    C.justifyContent = "end";
                    break;
                  case "middle":
                    C.justifyContent = "center";
                    break;
                }
                const d = u[n.$toStyle]();
                for (const [y, _] of Object.entries(d))
                  y in C || (C[y] = _);
              }
            }
          }
          function T(c, I, s, r) {
            if (!s) {
              delete r.fontFamily;
              return;
            }
            const u = (0, D.stripQuotes)(c.typeface);
            r.fontFamily = `"${u}"`;
            const C = s.find(u);
            if (C) {
              const {
                fontFamily: d
              } = C.regular.cssFontInfo;
              d !== u && (r.fontFamily = `"${d}"`);
              const y = W(I);
              if (y && y.lineHeight !== "" || r.lineHeight)
                return;
              const _ = (0, e.selectFont)(c, C);
              _ && (r.lineHeight = Math.max(1.2, _.lineHeight));
            }
          }
          function o(c) {
            const I = (0, P.createValidAbsoluteUrl)(c, null, {
              addDefaultProtocol: !0,
              tryConvertEncoding: !0
            });
            return I ? I.href : null;
          }
        },
        /* 84 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.HTMLResult = void 0, b.getBBox = a, b.getColor = x, b.getFloat = l, b.getInteger = t, b.getKeyword = V, b.getMeasurement = E, b.getRatio = F, b.getRelevant = f, b.getStringOption = te, b.stripQuotes = e;
          var n = ce(2);
          const P = {
            pt: (p) => p,
            cm: (p) => p / 2.54 * 72,
            mm: (p) => p / (10 * 2.54) * 72,
            in: (p) => p * 72,
            px: (p) => p
          }, D = /([+-]?\d+\.?\d*)(.*)/;
          function e(p) {
            return p.startsWith("'") || p.startsWith('"') ? p.slice(1, -1) : p;
          }
          function t({
            data: p,
            defaultValue: O,
            validate: M
          }) {
            if (!p)
              return O;
            p = p.trim();
            const R = parseInt(p, 10);
            return !isNaN(R) && M(R) ? R : O;
          }
          function l({
            data: p,
            defaultValue: O,
            validate: M
          }) {
            if (!p)
              return O;
            p = p.trim();
            const R = parseFloat(p);
            return !isNaN(R) && M(R) ? R : O;
          }
          function V({
            data: p,
            defaultValue: O,
            validate: M
          }) {
            return p ? (p = p.trim(), M(p) ? p : O) : O;
          }
          function te(p, O) {
            return V({
              data: p,
              defaultValue: O[0],
              validate: (M) => O.includes(M)
            });
          }
          function E(p, O = "0") {
            if (O || (O = "0"), !p)
              return E(O);
            const M = p.trim().match(D);
            if (!M)
              return E(O);
            const [, R, z] = M, W = parseFloat(R);
            if (isNaN(W))
              return E(O);
            if (W === 0)
              return 0;
            const g = P[z];
            return g ? g(W) : W;
          }
          function F(p) {
            if (!p)
              return {
                num: 1,
                den: 1
              };
            const O = p.trim().split(/\s*:\s*/).map((z) => parseFloat(z)).filter((z) => !isNaN(z));
            if (O.length === 1 && O.push(1), O.length === 0)
              return {
                num: 1,
                den: 1
              };
            const [M, R] = O;
            return {
              num: M,
              den: R
            };
          }
          function f(p) {
            return p ? p.trim().split(/\s+/).map((O) => ({
              excluded: O[0] === "-",
              viewname: O.substring(1)
            })) : [];
          }
          function x(p, O = [0, 0, 0]) {
            let [M, R, z] = O;
            if (!p)
              return {
                r: M,
                g: R,
                b: z
              };
            const W = p.trim().split(/\s*,\s*/).map((g) => Math.min(Math.max(0, parseInt(g.trim(), 10)), 255)).map((g) => isNaN(g) ? 0 : g);
            return W.length < 3 ? {
              r: M,
              g: R,
              b: z
            } : ([M, R, z] = W, {
              r: M,
              g: R,
              b: z
            });
          }
          function a(p) {
            if (!p)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const M = p.trim().split(/\s*,\s*/).map((T) => E(T, "-1"));
            if (M.length < 4 || M[2] < 0 || M[3] < 0)
              return {
                x: -1,
                y: -1,
                width: -1,
                height: -1
              };
            const [R, z, W, g] = M;
            return {
              x: R,
              y: z,
              width: W,
              height: g
            };
          }
          class N {
            static get FAILURE() {
              return (0, n.shadow)(this, "FAILURE", new N(!1, null, null, null));
            }
            static get EMPTY() {
              return (0, n.shadow)(this, "EMPTY", new N(!0, null, null, null));
            }
            constructor(O, M, R, z) {
              this.success = O, this.html = M, this.bbox = R, this.breakNode = z;
            }
            isBreak() {
              return !!this.breakNode;
            }
            static breakNode(O) {
              return new N(!1, null, null, O);
            }
            static success(O, M = null) {
              return new N(!0, O, M, null);
            }
          }
          b.HTMLResult = N;
        },
        /* 85 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.FontFinder = void 0, b.getMetrics = l, b.selectFont = t;
          var n = ce(78), P = ce(84), D = ce(2);
          class e {
            constructor(te) {
              this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(te);
            }
            add(te, E = null) {
              for (const f of te)
                this.addPdfFont(f);
              for (const f of this.fonts.values())
                f.regular || (f.regular = f.italic || f.bold || f.bolditalic);
              if (!E || E.size === 0)
                return;
              const F = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
              for (const f of E)
                this.fonts.set(f, F);
            }
            addPdfFont(te) {
              var N, p, O;
              const E = te.cssFontInfo, F = E.fontFamily;
              let f = this.fonts.get(F);
              f || (f = /* @__PURE__ */ Object.create(null), this.fonts.set(F, f), this.defaultFont || (this.defaultFont = f));
              let x = "";
              const a = parseFloat(E.fontWeight);
              parseFloat(E.italicAngle) !== 0 ? x = a >= 700 ? "bolditalic" : "italic" : a >= 700 && (x = "bold"), x || ((te.name.includes("Bold") || (N = te.psName) != null && N.includes("Bold")) && (x = "bold"), (te.name.includes("Italic") || te.name.endsWith("It") || (p = te.psName) != null && p.includes("Italic") || (O = te.psName) != null && O.endsWith("It")) && (x += "italic")), x || (x = "regular"), f[x] = te;
            }
            getDefault() {
              return this.defaultFont;
            }
            find(te, E = !0) {
              var N, p;
              let F = this.fonts.get(te) || this.cache.get(te);
              if (F)
                return F;
              const f = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
              let x = te.replaceAll(f, "");
              if (F = this.fonts.get(x), F)
                return this.cache.set(te, F), F;
              x = x.toLowerCase();
              const a = [];
              for (const [O, M] of this.fonts.entries())
                O.replaceAll(f, "").toLowerCase().startsWith(x) && a.push(M);
              if (a.length === 0)
                for (const [, O] of this.fonts.entries())
                  (N = O.regular.name) != null && N.replaceAll(f, "").toLowerCase().startsWith(x) && a.push(O);
              if (a.length === 0) {
                x = x.replaceAll(/psmt|mt/gi, "");
                for (const [O, M] of this.fonts.entries())
                  O.replaceAll(f, "").toLowerCase().startsWith(x) && a.push(M);
              }
              if (a.length === 0)
                for (const O of this.fonts.values())
                  (p = O.regular.name) != null && p.replaceAll(f, "").toLowerCase().startsWith(x) && a.push(O);
              return a.length >= 1 ? (a.length !== 1 && E && (0, D.warn)(`XFA - Too many choices to guess the correct font: ${te}`), this.cache.set(te, a[0]), a[0]) : (E && !this.warned.has(te) && (this.warned.add(te), (0, D.warn)(`XFA - Cannot find the font: ${te}`)), null);
            }
          }
          b.FontFinder = e;
          function t(V, te) {
            return V.posture === "italic" ? V.weight === "bold" ? te.bolditalic : te.italic : V.weight === "bold" ? te.bold : te.regular;
          }
          function l(V, te = !1) {
            let E = null;
            if (V) {
              const a = (0, P.stripQuotes)(V.typeface), N = V[n.$globalData].fontFinder.find(a);
              E = t(V, N);
            }
            if (!E)
              return {
                lineHeight: 12,
                lineGap: 2,
                lineNoGap: 10
              };
            const F = V.size || 10, f = E.lineHeight ? Math.max(te ? 0 : 1.2, E.lineHeight) : 1.2, x = E.lineGap === void 0 ? 0.2 : E.lineGap;
            return {
              lineHeight: f * F,
              lineGap: x * F,
              lineNoGap: Math.max(1, f - x) * F
            };
          }
        },
        /* 86 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.TextMeasure = void 0;
          var n = ce(85);
          const P = 1.02;
          class D {
            constructor(V, te, E, F) {
              if (this.lineHeight = E, this.paraMargin = te || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
              }, !V) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(F);
                return;
              }
              this.xfaFont = {
                typeface: V.typeface,
                posture: V.posture,
                weight: V.weight,
                size: V.size,
                letterSpacing: V.letterSpacing
              };
              const f = F.find(V.typeface);
              if (!f) {
                [this.pdfFont, this.xfaFont] = this.defaultFont(F);
                return;
              }
              this.pdfFont = (0, n.selectFont)(V, f), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(F));
            }
            defaultFont(V) {
              const te = V.find("Helvetica", !1) || V.find("Myriad Pro", !1) || V.find("Arial", !1) || V.getDefault();
              if (te != null && te.regular) {
                const F = te.regular, x = {
                  typeface: F.cssFontInfo.fontFamily,
                  posture: "normal",
                  weight: "normal",
                  size: 10,
                  letterSpacing: 0
                };
                return [F, x];
              }
              return [null, {
                typeface: "Courier",
                posture: "normal",
                weight: "normal",
                size: 10,
                letterSpacing: 0
              }];
            }
          }
          class e {
            constructor(V, te, E, F) {
              this.fontFinder = F, this.stack = [new D(V, te, E, F)];
            }
            pushData(V, te, E) {
              const F = this.stack.at(-1);
              for (const x of ["typeface", "posture", "weight", "size", "letterSpacing"])
                V[x] || (V[x] = F.xfaFont[x]);
              for (const x of ["top", "bottom", "left", "right"])
                isNaN(te[x]) && (te[x] = F.paraMargin[x]);
              const f = new D(V, te, E || F.lineHeight, this.fontFinder);
              f.pdfFont || (f.pdfFont = F.pdfFont), this.stack.push(f);
            }
            popFont() {
              this.stack.pop();
            }
            topFont() {
              return this.stack.at(-1);
            }
          }
          class t {
            constructor(V, te, E, F) {
              this.glyphs = [], this.fontSelector = new e(V, te, E, F), this.extraHeight = 0;
            }
            pushData(V, te, E) {
              this.fontSelector.pushData(V, te, E);
            }
            popFont(V) {
              return this.fontSelector.popFont();
            }
            addPara() {
              const V = this.fontSelector.topFont();
              this.extraHeight += V.paraMargin.top + V.paraMargin.bottom;
            }
            addString(V) {
              if (!V)
                return;
              const te = this.fontSelector.topFont(), E = te.xfaFont.size;
              if (te.pdfFont) {
                const F = te.xfaFont.letterSpacing, f = te.pdfFont, x = f.lineHeight || 1.2, a = te.lineHeight || Math.max(1.2, x) * E, N = f.lineGap === void 0 ? 0.2 : f.lineGap, p = x - N, O = Math.max(1, p) * E, M = E / 1e3, R = f.defaultWidth || f.charsToGlyphs(" ")[0].width;
                for (const z of V.split(/[\u2029\n]/)) {
                  const W = f.encodeString(z).join(""), g = f.charsToGlyphs(W);
                  for (const T of g) {
                    const o = T.width || R;
                    this.glyphs.push([o * M + F, a, O, T.unicode, !1]);
                  }
                  this.glyphs.push([0, 0, 0, `
`, !0]);
                }
                this.glyphs.pop();
                return;
              }
              for (const F of V.split(/[\u2029\n]/)) {
                for (const f of F.split(""))
                  this.glyphs.push([E, 1.2 * E, E, f, !1]);
                this.glyphs.push([0, 0, 0, `
`, !0]);
              }
              this.glyphs.pop();
            }
            compute(V) {
              let te = -1, E = 0, F = 0, f = 0, x = 0, a = 0, N = !1, p = !0;
              for (let O = 0, M = this.glyphs.length; O < M; O++) {
                const [R, z, W, g, T] = this.glyphs[O], o = g === " ", c = p ? W : z;
                if (T) {
                  F = Math.max(F, x), x = 0, f += a, a = c, te = -1, E = 0, p = !1;
                  continue;
                }
                if (o) {
                  x + R > V ? (F = Math.max(F, x), x = 0, f += a, a = c, te = -1, E = 0, N = !0, p = !1) : (a = Math.max(c, a), E = x, x += R, te = O);
                  continue;
                }
                if (x + R > V) {
                  f += a, a = c, te !== -1 ? (O = te, F = Math.max(F, E), x = 0, te = -1, E = 0) : (F = Math.max(F, x), x = R), N = !0, p = !1;
                  continue;
                }
                x += R, a = Math.max(c, a);
              }
              return F = Math.max(F, x), f += a + this.extraHeight, {
                width: P * F,
                height: f,
                isBroken: N
              };
            }
          }
          b.TextMeasure = t;
        },
        /* 87 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XmlObject = b.XFAObjectArray = b.XFAObject = b.XFAAttribute = b.StringObject = b.OptionObject = b.Option10 = b.Option01 = b.IntegerObject = b.ContentObject = void 0;
          var n = ce(78), P = ce(84), D = ce(2), e = ce(3), t = ce(81), l = ce(88);
          const V = Symbol(), te = Symbol(), E = Symbol(), F = Symbol("_children"), f = Symbol(), x = Symbol(), a = Symbol(), N = Symbol(), p = Symbol(), O = Symbol(), M = Symbol(), R = Symbol(), z = Symbol(), W = Symbol("parent"), g = Symbol(), T = Symbol(), o = Symbol();
          let c = 0;
          const I = t.NamespaceIds.datasets.id;
          class s {
            constructor(h, A, j = !1) {
              this[n.$namespaceId] = h, this[n.$nodeName] = A, this[M] = j, this[W] = null, this[F] = [], this[n.$uid] = `${A}${c++}`, this[n.$globalData] = null;
            }
            get isXFAObject() {
              return !0;
            }
            get isXFAObjectArray() {
              return !1;
            }
            createNodes(h) {
              let A = this, j = null;
              for (const {
                name: G,
                index: J
              } of h) {
                for (let oe = 0, q = isFinite(J) ? J : 0; oe <= q; oe++) {
                  const re = A[n.$namespaceId] === I ? -1 : A[n.$namespaceId];
                  j = new C(re, G), A[n.$appendChild](j);
                }
                A = j;
              }
              return j;
            }
            [n.$onChild](h) {
              if (!this[M] || !this[n.$onChildCheck](h))
                return !1;
              const A = h[n.$nodeName], j = this[A];
              if (j instanceof r) {
                if (j.push(h))
                  return this[n.$appendChild](h), !0;
              } else
                return j !== null && this[n.$removeChild](j), this[A] = h, this[n.$appendChild](h), !0;
              let G = "";
              return this.id ? G = ` (id: ${this.id})` : this.name && (G = ` (name: ${this.name} ${this.h.value})`), (0, D.warn)(`XFA - node "${this[n.$nodeName]}"${G} has already enough "${A}"!`), !1;
            }
            [n.$onChildCheck](h) {
              return this.hasOwnProperty(h[n.$nodeName]) && h[n.$namespaceId] === this[n.$namespaceId];
            }
            [n.$isNsAgnostic]() {
              return !1;
            }
            [n.$acceptWhitespace]() {
              return !1;
            }
            [n.$isCDATAXml]() {
              return !1;
            }
            [n.$isBindable]() {
              return !1;
            }
            [n.$popPara]() {
              this.para && this[n.$getTemplateRoot]()[n.$extra].paraStack.pop();
            }
            [n.$pushPara]() {
              this[n.$getTemplateRoot]()[n.$extra].paraStack.push(this.para);
            }
            [n.$setId](h) {
              this.id && this[n.$namespaceId] === t.NamespaceIds.template.id && h.set(this.id, this);
            }
            [n.$getTemplateRoot]() {
              return this[n.$globalData].template;
            }
            [n.$isSplittable]() {
              return !1;
            }
            [n.$isThereMoreWidth]() {
              return !1;
            }
            [n.$appendChild](h) {
              h[W] = this, this[F].push(h), !h[n.$globalData] && this[n.$globalData] && (h[n.$globalData] = this[n.$globalData]);
            }
            [n.$removeChild](h) {
              const A = this[F].indexOf(h);
              this[F].splice(A, 1);
            }
            [n.$hasSettableValue]() {
              return this.hasOwnProperty("value");
            }
            [n.$setValue](h) {
            }
            [n.$onText](h) {
            }
            [n.$finalize]() {
            }
            [n.$clean](h) {
              delete this[M], this[n.$cleanup] && (h.clean(this[n.$cleanup]), delete this[n.$cleanup]);
            }
            [n.$indexOf](h) {
              return this[F].indexOf(h);
            }
            [n.$insertAt](h, A) {
              A[W] = this, this[F].splice(h, 0, A), !A[n.$globalData] && this[n.$globalData] && (A[n.$globalData] = this[n.$globalData]);
            }
            [n.$isTransparent]() {
              return !this.name;
            }
            [n.$lastAttribute]() {
              return "";
            }
            [n.$text]() {
              return this[F].length === 0 ? this[n.$content] : this[F].map((h) => h[n.$text]()).join("");
            }
            get [E]() {
              const h = Object.getPrototypeOf(this);
              if (!h._attributes) {
                const A = h._attributes = /* @__PURE__ */ new Set();
                for (const j of Object.getOwnPropertyNames(this)) {
                  if (this[j] === null || this[j] instanceof s || this[j] instanceof r)
                    break;
                  A.add(j);
                }
              }
              return (0, D.shadow)(this, E, h._attributes);
            }
            [n.$isDescendent](h) {
              let A = this;
              for (; A; ) {
                if (A === h)
                  return !0;
                A = A[n.$getParent]();
              }
              return !1;
            }
            [n.$getParent]() {
              return this[W];
            }
            [n.$getSubformParent]() {
              return this[n.$getParent]();
            }
            [n.$getChildren](h = null) {
              return h ? this[h] : this[F];
            }
            [n.$dump]() {
              const h = /* @__PURE__ */ Object.create(null);
              this[n.$content] && (h.$content = this[n.$content]);
              for (const A of Object.getOwnPropertyNames(this)) {
                const j = this[A];
                j !== null && (j instanceof s ? h[A] = j[n.$dump]() : j instanceof r ? j.isEmpty() || (h[A] = j.dump()) : h[A] = j);
              }
              return h;
            }
            [n.$toStyle]() {
              return null;
            }
            [n.$toHTML]() {
              return P.HTMLResult.EMPTY;
            }
            *[n.$getContainedChildren]() {
              for (const h of this[n.$getChildren]())
                yield h;
            }
            *[N](h, A) {
              for (const j of this[n.$getContainedChildren]())
                if (!h || A === h.has(j[n.$nodeName])) {
                  const G = this[n.$getAvailableSpace](), J = j[n.$toHTML](G);
                  J.success || (this[n.$extra].failingNode = j), yield J;
                }
            }
            [n.$flushHTML]() {
              return null;
            }
            [n.$addHTML](h, A) {
              this[n.$extra].children.push(h);
            }
            [n.$getAvailableSpace]() {
            }
            [n.$childrenToHTML]({
              filter: h = null,
              include: A = !0
            }) {
              if (!this[n.$extra].generator)
                this[n.$extra].generator = this[N](h, A);
              else {
                const j = this[n.$getAvailableSpace](), G = this[n.$extra].failingNode[n.$toHTML](j);
                if (!G.success)
                  return G;
                G.html && this[n.$addHTML](G.html, G.bbox), delete this[n.$extra].failingNode;
              }
              for (; ; ) {
                const j = this[n.$extra].generator.next();
                if (j.done)
                  break;
                const G = j.value;
                if (!G.success)
                  return G;
                G.html && this[n.$addHTML](G.html, G.bbox);
              }
              return this[n.$extra].generator = null, P.HTMLResult.EMPTY;
            }
            [n.$setSetAttributes](h) {
              this[T] = new Set(Object.keys(h));
            }
            [O](h) {
              const A = this[E], j = this[T];
              return [...h].filter((G) => A.has(G) && !j.has(G));
            }
            [n.$resolvePrototypes](h, A = /* @__PURE__ */ new Set()) {
              for (const j of this[F])
                j[g](h, A);
            }
            [g](h, A) {
              const j = this[p](h, A);
              j ? this[V](j, h, A) : this[n.$resolvePrototypes](h, A);
            }
            [p](h, A) {
              const {
                use: j,
                usehref: G
              } = this;
              if (!j && !G)
                return null;
              let J = null, oe = null, q = null, re = j;
              if (G ? (re = G, G.startsWith("#som(") && G.endsWith(")") ? oe = G.slice(5, -1) : G.startsWith(".#som(") && G.endsWith(")") ? oe = G.slice(6, -1) : G.startsWith("#") ? q = G.slice(1) : G.startsWith(".#") && (q = G.slice(2))) : j.startsWith("#") ? q = j.slice(1) : oe = j, this.use = this.usehref = "", q ? J = h.get(q) : (J = (0, l.searchNode)(h.get(n.$root), this, oe, !0, !1), J && (J = J[0])), !J)
                return (0, D.warn)(`XFA - Invalid prototype reference: ${re}.`), null;
              if (J[n.$nodeName] !== this[n.$nodeName])
                return (0, D.warn)(`XFA - Incompatible prototype: ${J[n.$nodeName]} !== ${this[n.$nodeName]}.`), null;
              if (A.has(J))
                return (0, D.warn)("XFA - Cycle detected in prototypes use."), null;
              A.add(J);
              const K = J[p](h, A);
              return K && J[V](K, h, A), J[n.$resolvePrototypes](h, A), A.delete(J), J;
            }
            [V](h, A, j) {
              if (j.has(h)) {
                (0, D.warn)("XFA - Cycle detected in prototypes use.");
                return;
              }
              !this[n.$content] && h[n.$content] && (this[n.$content] = h[n.$content]), new Set(j).add(h);
              for (const J of this[O](h[T]))
                this[J] = h[J], this[T] && this[T].add(J);
              for (const J of Object.getOwnPropertyNames(this)) {
                if (this[E].has(J))
                  continue;
                const oe = this[J], q = h[J];
                if (oe instanceof r) {
                  for (const re of oe[F])
                    re[g](A, j);
                  for (let re = oe[F].length, K = q[F].length; re < K; re++) {
                    const Z = h[F][re][n.$clone]();
                    if (oe.push(Z))
                      Z[W] = this, this[F].push(Z), Z[g](A, j);
                    else
                      break;
                  }
                  continue;
                }
                if (oe !== null) {
                  oe[n.$resolvePrototypes](A, j), q && oe[V](q, A, j);
                  continue;
                }
                if (q !== null) {
                  const re = q[n.$clone]();
                  re[W] = this, this[J] = re, this[F].push(re), re[g](A, j);
                }
              }
            }
            static [f](h) {
              return Array.isArray(h) ? h.map((A) => s[f](A)) : typeof h == "object" && h !== null ? Object.assign({}, h) : h;
            }
            [n.$clone]() {
              const h = Object.create(Object.getPrototypeOf(this));
              for (const A of Object.getOwnPropertySymbols(this))
                try {
                  h[A] = this[A];
                } catch {
                  (0, D.shadow)(h, A, this[A]);
                }
              h[n.$uid] = `${h[n.$nodeName]}${c++}`, h[F] = [];
              for (const A of Object.getOwnPropertyNames(this)) {
                if (this[E].has(A)) {
                  h[A] = s[f](this[A]);
                  continue;
                }
                const j = this[A];
                h[A] = j instanceof r ? new r(j[R]) : null;
              }
              for (const A of this[F]) {
                const j = A[n.$nodeName], G = A[n.$clone]();
                h[F].push(G), G[W] = h, h[j] === null ? h[j] = G : h[j][F].push(G);
              }
              return h;
            }
            [n.$getChildren](h = null) {
              return h ? this[F].filter((A) => A[n.$nodeName] === h) : this[F];
            }
            [n.$getChildrenByClass](h) {
              return this[h];
            }
            [n.$getChildrenByName](h, A, j = !0) {
              return Array.from(this[n.$getChildrenByNameIt](h, A, j));
            }
            *[n.$getChildrenByNameIt](h, A, j = !0) {
              if (h === "parent") {
                yield this[W];
                return;
              }
              for (const G of this[F])
                G[n.$nodeName] === h && (yield G), G.name === h && (yield G), (A || G[n.$isTransparent]()) && (yield* G[n.$getChildrenByNameIt](h, A, !1));
              j && this[E].has(h) && (yield new u(this, h, this[h]));
            }
          }
          b.XFAObject = s;
          class r {
            constructor(h = 1 / 0) {
              this[R] = h, this[F] = [];
            }
            get isXFAObject() {
              return !1;
            }
            get isXFAObjectArray() {
              return !0;
            }
            push(h) {
              return this[F].length <= this[R] ? (this[F].push(h), !0) : ((0, D.warn)(`XFA - node "${h[n.$nodeName]}" accepts no more than ${this[R]} children`), !1);
            }
            isEmpty() {
              return this[F].length === 0;
            }
            dump() {
              return this[F].length === 1 ? this[F][0][n.$dump]() : this[F].map((h) => h[n.$dump]());
            }
            [n.$clone]() {
              const h = new r(this[R]);
              return h[F] = this[F].map((A) => A[n.$clone]()), h;
            }
            get children() {
              return this[F];
            }
            clear() {
              this[F].length = 0;
            }
          }
          b.XFAObjectArray = r;
          class u {
            constructor(h, A, j) {
              this[W] = h, this[n.$nodeName] = A, this[n.$content] = j, this[n.$consumed] = !1, this[n.$uid] = `attribute${c++}`;
            }
            [n.$getParent]() {
              return this[W];
            }
            [n.$isDataValue]() {
              return !0;
            }
            [n.$getDataValue]() {
              return this[n.$content].trim();
            }
            [n.$setValue](h) {
              h = h.value || "", this[n.$content] = h.toString();
            }
            [n.$text]() {
              return this[n.$content];
            }
            [n.$isDescendent](h) {
              return this[W] === h || this[W][n.$isDescendent](h);
            }
          }
          b.XFAAttribute = u;
          class C extends s {
            constructor(h, A, j = {}) {
              if (super(h, A), this[n.$content] = "", this[x] = null, A !== "#text") {
                const G = /* @__PURE__ */ new Map();
                this[te] = G;
                for (const [J, oe] of Object.entries(j))
                  G.set(J, new u(this, J, oe));
                if (j.hasOwnProperty(n.$nsAttributes)) {
                  const J = j[n.$nsAttributes].xfa.dataNode;
                  J !== void 0 && (J === "dataGroup" ? this[x] = !1 : J === "dataValue" && (this[x] = !0));
                }
              }
              this[n.$consumed] = !1;
            }
            [n.$toString](h) {
              const A = this[n.$nodeName];
              if (A === "#text") {
                h.push((0, e.encodeToXmlString)(this[n.$content]));
                return;
              }
              const j = (0, D.utf8StringToString)(A), G = this[n.$namespaceId] === I ? "xfa:" : "";
              h.push(`<${G}${j}`);
              for (const [J, oe] of this[te].entries()) {
                const q = (0, D.utf8StringToString)(J);
                h.push(` ${q}="${(0, e.encodeToXmlString)(oe[n.$content])}"`);
              }
              if (this[x] !== null && (this[x] ? h.push(' xfa:dataNode="dataValue"') : h.push(' xfa:dataNode="dataGroup"')), !this[n.$content] && this[F].length === 0) {
                h.push("/>");
                return;
              }
              if (h.push(">"), this[n.$content])
                typeof this[n.$content] == "string" ? h.push((0, e.encodeToXmlString)(this[n.$content])) : this[n.$content][n.$toString](h);
              else
                for (const J of this[F])
                  J[n.$toString](h);
              h.push(`</${G}${j}>`);
            }
            [n.$onChild](h) {
              if (this[n.$content]) {
                const A = new C(this[n.$namespaceId], "#text");
                this[n.$appendChild](A), A[n.$content] = this[n.$content], this[n.$content] = "";
              }
              return this[n.$appendChild](h), !0;
            }
            [n.$onText](h) {
              this[n.$content] += h;
            }
            [n.$finalize]() {
              if (this[n.$content] && this[F].length > 0) {
                const h = new C(this[n.$namespaceId], "#text");
                this[n.$appendChild](h), h[n.$content] = this[n.$content], delete this[n.$content];
              }
            }
            [n.$toHTML]() {
              return this[n.$nodeName] === "#text" ? P.HTMLResult.success({
                name: "#text",
                value: this[n.$content]
              }) : P.HTMLResult.EMPTY;
            }
            [n.$getChildren](h = null) {
              return h ? this[F].filter((A) => A[n.$nodeName] === h) : this[F];
            }
            [n.$getAttributes]() {
              return this[te];
            }
            [n.$getChildrenByClass](h) {
              const A = this[te].get(h);
              return A !== void 0 ? A : this[n.$getChildren](h);
            }
            *[n.$getChildrenByNameIt](h, A) {
              const j = this[te].get(h);
              j && (yield j);
              for (const G of this[F])
                G[n.$nodeName] === h && (yield G), A && (yield* G[n.$getChildrenByNameIt](h, A));
            }
            *[n.$getAttributeIt](h, A) {
              const j = this[te].get(h);
              j && (!A || !j[n.$consumed]) && (yield j);
              for (const G of this[F])
                yield* G[n.$getAttributeIt](h, A);
            }
            *[n.$getRealChildrenByNameIt](h, A, j) {
              for (const G of this[F])
                G[n.$nodeName] === h && (!j || !G[n.$consumed]) && (yield G), A && (yield* G[n.$getRealChildrenByNameIt](h, A, j));
            }
            [n.$isDataValue]() {
              return this[x] === null ? this[F].length === 0 || this[F][0][n.$namespaceId] === t.NamespaceIds.xhtml.id : this[x];
            }
            [n.$getDataValue]() {
              return this[x] === null ? this[F].length === 0 ? this[n.$content].trim() : this[F][0][n.$namespaceId] === t.NamespaceIds.xhtml.id ? this[F][0][n.$text]().trim() : null : this[n.$content].trim();
            }
            [n.$setValue](h) {
              h = h.value || "", this[n.$content] = h.toString();
            }
            [n.$dump](h = !1) {
              const A = /* @__PURE__ */ Object.create(null);
              h && (A.$ns = this[n.$namespaceId]), this[n.$content] && (A.$content = this[n.$content]), A.$name = this[n.$nodeName], A.children = [];
              for (const j of this[F])
                A.children.push(j[n.$dump](h));
              A.attributes = /* @__PURE__ */ Object.create(null);
              for (const [j, G] of this[te])
                A.attributes[j] = G[n.$content];
              return A;
            }
          }
          b.XmlObject = C;
          class d extends s {
            constructor(h, A) {
              super(h, A), this[n.$content] = "";
            }
            [n.$onText](h) {
              this[n.$content] += h;
            }
            [n.$finalize]() {
            }
          }
          b.ContentObject = d;
          class y extends d {
            constructor(h, A, j) {
              super(h, A), this[z] = j;
            }
            [n.$finalize]() {
              this[n.$content] = (0, P.getKeyword)({
                data: this[n.$content],
                defaultValue: this[z][0],
                validate: (h) => this[z].includes(h)
              });
            }
            [n.$clean](h) {
              super[n.$clean](h), delete this[z];
            }
          }
          b.OptionObject = y;
          class _ extends d {
            [n.$finalize]() {
              this[n.$content] = this[n.$content].trim();
            }
          }
          b.StringObject = _;
          class $ extends d {
            constructor(h, A, j, G) {
              super(h, A), this[a] = j, this[o] = G;
            }
            [n.$finalize]() {
              this[n.$content] = (0, P.getInteger)({
                data: this[n.$content],
                defaultValue: this[a],
                validate: this[o]
              });
            }
            [n.$clean](h) {
              super[n.$clean](h), delete this[a], delete this[o];
            }
          }
          b.IntegerObject = $;
          class S extends $ {
            constructor(h, A) {
              super(h, A, 0, (j) => j === 1);
            }
          }
          b.Option01 = S;
          class v extends $ {
            constructor(h, A) {
              super(h, A, 1, (j) => j === 0);
            }
          }
          b.Option10 = v;
        },
        /* 88 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.createDataNode = f, b.searchNode = F;
          var n = ce(78), P = ce(2);
          const D = /^[^.[]+/, e = /^[^\]]+/, t = {
            dot: 0,
            dotDot: 1,
            dotHash: 2,
            dotBracket: 3,
            dotParen: 4
          }, l = /* @__PURE__ */ new Map([["$data", (x, a) => x.datasets ? x.datasets.data : x], ["$record", (x, a) => (x.datasets ? x.datasets.data : x)[n.$getChildren]()[0]], ["$template", (x, a) => x.template], ["$connectionSet", (x, a) => x.connectionSet], ["$form", (x, a) => x.form], ["$layout", (x, a) => x.layout], ["$host", (x, a) => x.host], ["$dataWindow", (x, a) => x.dataWindow], ["$event", (x, a) => x.event], ["!", (x, a) => x.datasets], ["$xfa", (x, a) => x], ["xfa", (x, a) => x], ["$", (x, a) => a]]), V = /* @__PURE__ */ new WeakMap();
          function te(x) {
            return x = x.trim(), x === "*" ? 1 / 0 : parseInt(x, 10) || 0;
          }
          function E(x, a, N = !0) {
            let p = x.match(D);
            if (!p)
              return null;
            let [O] = p;
            const M = [{
              name: O,
              cacheName: "." + O,
              index: 0,
              js: null,
              formCalc: null,
              operator: t.dot
            }];
            let R = O.length;
            for (; R < x.length; ) {
              const z = R;
              if (x.charAt(R++) === "[") {
                if (p = x.slice(R).match(e), !p)
                  return (0, P.warn)("XFA - Invalid index in SOM expression"), null;
                M.at(-1).index = te(p[0]), R += p[0].length + 1;
                continue;
              }
              let g;
              switch (x.charAt(R)) {
                case ".":
                  if (!a)
                    return null;
                  R++, g = t.dotDot;
                  break;
                case "#":
                  R++, g = t.dotHash;
                  break;
                case "[":
                  if (N)
                    return (0, P.warn)("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
                  g = t.dotBracket;
                  break;
                case "(":
                  if (N)
                    return (0, P.warn)("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
                  g = t.dotParen;
                  break;
                default:
                  g = t.dot;
                  break;
              }
              if (p = x.slice(R).match(D), !p)
                break;
              [O] = p, R += O.length, M.push({
                name: O,
                cacheName: x.slice(z, R),
                operator: g,
                index: 0,
                js: null,
                formCalc: null
              });
            }
            return M;
          }
          function F(x, a, N, p = !0, O = !0) {
            const M = E(N, p);
            if (!M)
              return null;
            const R = l.get(M[0].name);
            let z = 0, W;
            R ? (W = !0, x = [R(x, a)], z = 1) : (W = a === null, x = [a || x]);
            for (let g = M.length; z < g; z++) {
              const {
                name: T,
                cacheName: o,
                operator: c,
                index: I
              } = M[z], s = [];
              for (const r of x) {
                if (!r.isXFAObject)
                  continue;
                let u, C;
                if (O && (C = V.get(r), C || (C = /* @__PURE__ */ new Map(), V.set(r, C)), u = C.get(o)), !u) {
                  switch (c) {
                    case t.dot:
                      u = r[n.$getChildrenByName](T, !1);
                      break;
                    case t.dotDot:
                      u = r[n.$getChildrenByName](T, !0);
                      break;
                    case t.dotHash:
                      u = r[n.$getChildrenByClass](T), u = u.isXFAObjectArray ? u.children : [u];
                      break;
                  }
                  O && C.set(o, u);
                }
                u.length > 0 && s.push(u);
              }
              if (s.length === 0 && !W && z === 0) {
                if (a = a[n.$getParent](), !a)
                  return null;
                z = -1, x = [a];
                continue;
              }
              x = isFinite(I) ? s.filter((r) => I < r.length).map((r) => r[I]) : s.flat();
            }
            return x.length === 0 ? null : x;
          }
          function f(x, a, N) {
            const p = E(N);
            if (!p || p.some((R) => R.operator === t.dotDot))
              return null;
            const O = l.get(p[0].name);
            let M = 0;
            O ? (x = O(x, a), M = 1) : x = a || x;
            for (let R = p.length; M < R; M++) {
              const {
                name: z,
                operator: W,
                index: g
              } = p[M];
              if (!isFinite(g))
                return p[M].index = 0, x.createNodes(p.slice(M));
              let T;
              switch (W) {
                case t.dot:
                  T = x[n.$getChildrenByName](z, !1);
                  break;
                case t.dotDot:
                  T = x[n.$getChildrenByName](z, !0);
                  break;
                case t.dotHash:
                  T = x[n.$getChildrenByClass](z), T = T.isXFAObjectArray ? T.children : [T];
                  break;
              }
              if (T.length === 0)
                return x.createNodes(p.slice(M));
              if (g < T.length) {
                const o = T[g];
                if (!o.isXFAObject)
                  return (0, P.warn)("XFA - Cannot create a node."), null;
                x = o;
              } else
                return p[M].index = g - T.length, x.createNodes(p.slice(M));
            }
            return null;
          }
        },
        /* 89 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.DataHandler = void 0;
          var n = ce(78);
          class P {
            constructor(e, t) {
              this.data = t, this.dataset = e.datasets || null;
            }
            serialize(e) {
              const t = [[-1, this.data[n.$getChildren]()]];
              for (; t.length > 0; ) {
                const V = t.at(-1), [te, E] = V;
                if (te + 1 === E.length) {
                  t.pop();
                  continue;
                }
                const F = E[++V[0]], f = e.get(F[n.$uid]);
                if (f)
                  F[n.$setValue](f);
                else {
                  const a = F[n.$getAttributes]();
                  for (const N of a.values()) {
                    const p = e.get(N[n.$uid]);
                    if (p) {
                      N[n.$setValue](p);
                      break;
                    }
                  }
                }
                const x = F[n.$getChildren]();
                x.length > 0 && t.push([-1, x]);
              }
              const l = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
              if (this.dataset)
                for (const V of this.dataset[n.$getChildren]())
                  V[n.$nodeName] !== "data" && V[n.$toString](l);
              return this.data[n.$toString](l), l.push("</xfa:datasets>"), l.join("");
            }
          }
          b.DataHandler = P;
        },
        /* 90 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XFAParser = void 0;
          var n = ce(78), P = ce(71), D = ce(91), e = ce(2);
          class t extends P.XMLParserBase {
            constructor(V = null, te = !1) {
              super(), this._builder = new D.Builder(V), this._stack = [], this._globalData = {
                usedTypefaces: /* @__PURE__ */ new Set()
              }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = P.XMLParserErrorCode.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = te;
            }
            parse(V) {
              if (this.parseXml(V), this._errorCode === P.XMLParserErrorCode.NoError)
                return this._current[n.$finalize](), this._current.element;
            }
            onText(V) {
              if (V = V.replace(this._nbsps, (te) => te.slice(1) + " "), this._richText || this._current[n.$acceptWhitespace]()) {
                this._current[n.$onText](V, this._richText);
                return;
              }
              this._whiteRegex.test(V) || this._current[n.$onText](V.trim());
            }
            onCdata(V) {
              this._current[n.$onText](V);
            }
            _mkAttributes(V, te) {
              let E = null, F = null;
              const f = /* @__PURE__ */ Object.create({});
              for (const {
                name: x,
                value: a
              } of V)
                if (x === "xmlns")
                  E ? (0, e.warn)(`XFA - multiple namespace definition in <${te}>`) : E = a;
                else if (x.startsWith("xmlns:")) {
                  const N = x.substring(6);
                  F || (F = []), F.push({
                    prefix: N,
                    value: a
                  });
                } else {
                  const N = x.indexOf(":");
                  if (N === -1)
                    f[x] = a;
                  else {
                    let p = f[n.$nsAttributes];
                    p || (p = f[n.$nsAttributes] = /* @__PURE__ */ Object.create(null));
                    const [O, M] = [x.slice(0, N), x.slice(N + 1)], R = p[O] || (p[O] = /* @__PURE__ */ Object.create(null));
                    R[M] = a;
                  }
                }
              return [E, F, f];
            }
            _getNameAndPrefix(V, te) {
              const E = V.indexOf(":");
              return E === -1 ? [V, null] : [V.substring(E + 1), te ? "" : V.substring(0, E)];
            }
            onBeginElement(V, te, E) {
              const [F, f, x] = this._mkAttributes(te, V), [a, N] = this._getNameAndPrefix(V, this._builder.isNsAgnostic()), p = this._builder.build({
                nsPrefix: N,
                name: a,
                attributes: x,
                namespace: F,
                prefixes: f
              });
              if (p[n.$globalData] = this._globalData, E) {
                p[n.$finalize](), this._current[n.$onChild](p) && p[n.$setId](this._ids), p[n.$clean](this._builder);
                return;
              }
              this._stack.push(this._current), this._current = p;
            }
            onEndElement(V) {
              const te = this._current;
              if (te[n.$isCDATAXml]() && typeof te[n.$content] == "string") {
                const E = new t();
                E._globalData = this._globalData;
                const F = E.parse(te[n.$content]);
                te[n.$content] = null, te[n.$onChild](F);
              }
              te[n.$finalize](), this._current = this._stack.pop(), this._current[n.$onChild](te) && te[n.$setId](this._ids), te[n.$clean](this._builder);
            }
            onError(V) {
              this._errorCode = V;
            }
          }
          b.XFAParser = t;
        },
        /* 91 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.Builder = void 0;
          var n = ce(81), P = ce(78), D = ce(92), e = ce(80), t = ce(101), l = ce(2), V = ce(87);
          class te extends V.XFAObject {
            constructor(x) {
              super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[P.$ids] = x;
            }
            [P.$onChild](x) {
              return this.element = x, !0;
            }
            [P.$finalize]() {
              super[P.$finalize](), this.element.template instanceof e.Template && (this[P.$ids].set(P.$root, this.element), this.element.template[P.$resolvePrototypes](this[P.$ids]), this.element.template[P.$ids] = this[P.$ids]);
            }
          }
          class E extends V.XFAObject {
            constructor() {
              super(-1, "", /* @__PURE__ */ Object.create(null));
            }
            [P.$onChild](x) {
              return !1;
            }
          }
          class F {
            constructor(x = null) {
              this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(n.NamespaceIds).map(({
                id: a
              }) => a)), this._currentNamespace = x || new t.UnknownNamespace(++this._nextNsId);
            }
            buildRoot(x) {
              return new te(x);
            }
            build({
              nsPrefix: x,
              name: a,
              attributes: N,
              namespace: p,
              prefixes: O
            }) {
              const M = p !== null;
              if (M && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(p)), O && this._addNamespacePrefix(O), N.hasOwnProperty(P.$nsAttributes)) {
                const W = D.NamespaceSetUp.datasets, g = N[P.$nsAttributes];
                let T = null;
                for (const [o, c] of Object.entries(g))
                  if (this._getNamespaceToUse(o) === W) {
                    T = {
                      xfa: c
                    };
                    break;
                  }
                T ? N[P.$nsAttributes] = T : delete N[P.$nsAttributes];
              }
              const R = this._getNamespaceToUse(x), z = (R == null ? void 0 : R[n.$buildXFAObject](a, N)) || new E();
              return z[P.$isNsAgnostic]() && this._nsAgnosticLevel++, (M || O || z[P.$isNsAgnostic]()) && (z[P.$cleanup] = {
                hasNamespace: M,
                prefixes: O,
                nsAgnostic: z[P.$isNsAgnostic]()
              }), z;
            }
            isNsAgnostic() {
              return this._nsAgnosticLevel > 0;
            }
            _searchNamespace(x) {
              let a = this._namespaces.get(x);
              if (a)
                return a;
              for (const [N, {
                check: p
              }] of Object.entries(n.NamespaceIds))
                if (p(x)) {
                  if (a = D.NamespaceSetUp[N], a)
                    return this._namespaces.set(x, a), a;
                  break;
                }
              return a = new t.UnknownNamespace(++this._nextNsId), this._namespaces.set(x, a), a;
            }
            _addNamespacePrefix(x) {
              for (const {
                prefix: a,
                value: N
              } of x) {
                const p = this._searchNamespace(N);
                let O = this._namespacePrefixes.get(a);
                O || (O = [], this._namespacePrefixes.set(a, O)), O.push(p);
              }
            }
            _getNamespaceToUse(x) {
              if (!x)
                return this._currentNamespace;
              const a = this._namespacePrefixes.get(x);
              return (a == null ? void 0 : a.length) > 0 ? a.at(-1) : ((0, l.warn)(`Unknown namespace prefix: ${x}.`), null);
            }
            clean(x) {
              const {
                hasNamespace: a,
                prefixes: N,
                nsAgnostic: p
              } = x;
              a && (this._currentNamespace = this._namespaceStack.pop()), N && N.forEach(({
                prefix: O
              }) => {
                this._namespacePrefixes.get(O).pop();
              }), p && this._nsAgnosticLevel--;
            }
          }
          b.Builder = F;
        },
        /* 92 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.NamespaceSetUp = void 0;
          var n = ce(93), P = ce(94), D = ce(95), e = ce(96), t = ce(97), l = ce(98), V = ce(80), te = ce(99), E = ce(100);
          const F = {
            config: n.ConfigNamespace,
            connection: P.ConnectionSetNamespace,
            datasets: D.DatasetsNamespace,
            localeSet: e.LocaleSetNamespace,
            signature: t.SignatureNamespace,
            stylesheet: l.StylesheetNamespace,
            template: V.TemplateNamespace,
            xdp: te.XdpNamespace,
            xhtml: E.XhtmlNamespace
          };
          b.NamespaceSetUp = F;
        },
        /* 93 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ConfigNamespace = void 0;
          var n = ce(81), P = ce(78), D = ce(87), e = ce(84), t = ce(2);
          const l = n.NamespaceIds.config.id;
          class V extends D.XFAObject {
            constructor(B) {
              super(l, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new D.XFAObjectArray();
            }
          }
          class te extends D.XFAObject {
            constructor(B) {
              super(l, "acrobat7", !0), this.dynamicRender = null;
            }
          }
          class E extends D.OptionObject {
            constructor(B) {
              super(l, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
            }
          }
          class F extends D.OptionObject {
            constructor(B) {
              super(l, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
            }
          }
          class f extends D.Option01 {
            constructor(B) {
              super(l, "addSilentPrint");
            }
          }
          class x extends D.Option01 {
            constructor(B) {
              super(l, "addViewerPreferences");
            }
          }
          class a extends D.Option10 {
            constructor(B) {
              super(l, "adjustData");
            }
          }
          class N extends D.IntegerObject {
            constructor(B) {
              super(l, "adobeExtensionLevel", 0, (Se) => Se >= 1 && Se <= 8);
            }
          }
          class p extends D.XFAObject {
            constructor(B) {
              super(l, "agent", !0), this.name = B.name ? B.name.trim() : "", this.common = new D.XFAObjectArray();
            }
          }
          class O extends D.ContentObject {
            constructor(B) {
              super(l, "alwaysEmbed");
            }
          }
          class M extends D.StringObject {
            constructor(B) {
              super(l, "amd");
            }
          }
          class R extends D.XFAObject {
            constructor(B) {
              super(l, "area"), this.level = (0, e.getInteger)({
                data: B.level,
                defaultValue: 0,
                validate: (Se) => Se >= 1 && Se <= 3
              }), this.name = (0, e.getStringOption)(B.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
            }
          }
          class z extends D.OptionObject {
            constructor(B) {
              super(l, "attributes", ["preserve", "delegate", "ignore"]);
            }
          }
          class W extends D.OptionObject {
            constructor(B) {
              super(l, "autoSave", ["disabled", "enabled"]);
            }
          }
          class g extends D.StringObject {
            constructor(B) {
              super(l, "base");
            }
          }
          class T extends D.XFAObject {
            constructor(B) {
              super(l, "batchOutput"), this.format = (0, e.getStringOption)(B.format, ["none", "concat", "zip", "zipCompress"]);
            }
          }
          class o extends D.ContentObject {
            constructor(B) {
              super(l, "behaviorOverride");
            }
            [P.$finalize]() {
              this[P.$content] = new Map(this[P.$content].trim().split(/\s+/).filter((B) => B.includes(":")).map((B) => B.split(":", 2)));
            }
          }
          class c extends D.XFAObject {
            constructor(B) {
              super(l, "cache", !0), this.templateCache = null;
            }
          }
          class I extends D.Option01 {
            constructor(B) {
              super(l, "change");
            }
          }
          class s extends D.XFAObject {
            constructor(B) {
              super(l, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new D.XFAObjectArray();
            }
          }
          class r extends D.XFAObject {
            constructor(B) {
              super(l, "compress"), this.scope = (0, e.getStringOption)(B.scope, ["imageOnly", "document"]);
            }
          }
          class u extends D.Option01 {
            constructor(B) {
              super(l, "compressLogicalStructure");
            }
          }
          class C extends D.Option10 {
            constructor(B) {
              super(l, "compressObjectStream");
            }
          }
          class d extends D.XFAObject {
            constructor(B) {
              super(l, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
            }
          }
          class y extends D.XFAObject {
            constructor(B) {
              super(l, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new D.XFAObjectArray();
            }
          }
          class _ extends D.OptionObject {
            constructor(B) {
              super(l, "conformance", ["A", "B"]);
            }
          }
          class $ extends D.Option01 {
            constructor(B) {
              super(l, "contentCopy");
            }
          }
          class S extends D.IntegerObject {
            constructor(B) {
              super(l, "copies", 1, (Se) => Se >= 1);
            }
          }
          class v extends D.StringObject {
            constructor(B) {
              super(l, "creator");
            }
          }
          class m extends D.IntegerObject {
            constructor(B) {
              super(l, "currentPage", 0, (Se) => Se >= 0);
            }
          }
          class h extends D.XFAObject {
            constructor(B) {
              super(l, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new D.XFAObjectArray(), this.transform = new D.XFAObjectArray();
            }
          }
          class A extends D.XFAObject {
            constructor(B) {
              super(l, "debug", !0), this.uri = null;
            }
          }
          class j extends D.ContentObject {
            constructor(B) {
              super(l, "defaultTypeface"), this.writingScript = (0, e.getStringOption)(B.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
            }
          }
          class G extends D.OptionObject {
            constructor(B) {
              super(l, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
            }
          }
          class J extends D.Option01 {
            constructor(B) {
              super(l, "documentAssembly");
            }
          }
          class oe extends D.XFAObject {
            constructor(B) {
              super(l, "driver", !0), this.name = B.name ? B.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class q extends D.OptionObject {
            constructor(B) {
              super(l, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
            }
          }
          class re extends D.OptionObject {
            constructor(B) {
              super(l, "dynamicRender", ["forbidden", "required"]);
            }
          }
          class K extends D.Option01 {
            constructor(B) {
              super(l, "embed");
            }
          }
          class Z extends D.Option01 {
            constructor(B) {
              super(l, "encrypt");
            }
          }
          class w extends D.XFAObject {
            constructor(B) {
              super(l, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
            }
          }
          class k extends D.OptionObject {
            constructor(B) {
              super(l, "encryptionLevel", ["40bit", "128bit"]);
            }
          }
          class X extends D.StringObject {
            constructor(B) {
              super(l, "enforce");
            }
          }
          class H extends D.XFAObject {
            constructor(B) {
              super(l, "equate"), this.force = (0, e.getInteger)({
                data: B.force,
                defaultValue: 1,
                validate: (Se) => Se === 0
              }), this.from = B.from || "", this.to = B.to || "";
            }
          }
          class Y extends D.XFAObject {
            constructor(B) {
              super(l, "equateRange"), this.from = B.from || "", this.to = B.to || "", this._unicodeRange = B.unicodeRange || "";
            }
            get unicodeRange() {
              const B = [], Se = /U\+([0-9a-fA-F]+)/, ve = this._unicodeRange;
              for (let Te of ve.split(",").map((_e) => _e.trim()).filter((_e) => !!_e))
                Te = Te.split("-", 2).map((_e) => {
                  const Ke = _e.match(Se);
                  return Ke ? parseInt(Ke[1], 16) : 0;
                }), Te.length === 1 && Te.push(Te[0]), B.push(Te);
              return (0, t.shadow)(this, "unicodeRange", B);
            }
          }
          class ie extends D.ContentObject {
            constructor(B) {
              super(l, "exclude");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim().split(/\s+/).filter((B) => B && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(B));
            }
          }
          class ne extends D.StringObject {
            constructor(B) {
              super(l, "excludeNS");
            }
          }
          class U extends D.OptionObject {
            constructor(B) {
              super(l, "flipLabel", ["usePrinterSetting", "on", "off"]);
            }
          }
          class ae extends D.XFAObject {
            constructor(B) {
              super(l, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new D.XFAObjectArray(), this.defaultTypeface = new D.XFAObjectArray(), this.neverEmbed = new D.XFAObjectArray();
            }
          }
          class Q extends D.Option01 {
            constructor(B) {
              super(l, "formFieldFilling");
            }
          }
          class L extends D.StringObject {
            constructor(B) {
              super(l, "groupParent");
            }
          }
          class ee extends D.OptionObject {
            constructor(B) {
              super(l, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
            }
          }
          class se extends D.StringObject {
            constructor(B) {
              super(l, "includeXDPContent");
            }
          }
          class le extends D.OptionObject {
            constructor(B) {
              super(l, "incrementalLoad", ["none", "forwardOnly"]);
            }
          }
          class ue extends D.Option01 {
            constructor(B) {
              super(l, "incrementalMerge");
            }
          }
          class de extends D.Option01 {
            constructor(B) {
              super(l, "interactive");
            }
          }
          class ge extends D.OptionObject {
            constructor(B) {
              super(l, "jog", ["usePrinterSetting", "none", "pageSet"]);
            }
          }
          class me extends D.XFAObject {
            constructor(B) {
              super(l, "labelPrinter", !0), this.name = (0, e.getStringOption)(B.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class pe extends D.OptionObject {
            constructor(B) {
              super(l, "layout", ["paginate", "panel"]);
            }
          }
          class xe extends D.IntegerObject {
            constructor(B) {
              super(l, "level", 0, (Se) => Se > 0);
            }
          }
          class we extends D.Option01 {
            constructor(B) {
              super(l, "linearized");
            }
          }
          class Ae extends D.StringObject {
            constructor(B) {
              super(l, "locale");
            }
          }
          class be extends D.StringObject {
            constructor(B) {
              super(l, "localeSet");
            }
          }
          class he extends D.XFAObject {
            constructor(B) {
              super(l, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
            }
          }
          class fe extends D.XFAObject {
            constructor(B) {
              super(l, "map", !0), this.equate = new D.XFAObjectArray(), this.equateRange = new D.XFAObjectArray();
            }
          }
          class Ce extends D.XFAObject {
            constructor(B) {
              super(l, "mediumInfo", !0), this.map = null;
            }
          }
          class ye extends D.XFAObject {
            constructor(B) {
              super(l, "message", !0), this.msgId = null, this.severity = null;
            }
          }
          class Le extends D.XFAObject {
            constructor(B) {
              super(l, "messaging", !0), this.message = new D.XFAObjectArray();
            }
          }
          class Be extends D.OptionObject {
            constructor(B) {
              super(l, "mode", ["append", "overwrite"]);
            }
          }
          class nt extends D.Option01 {
            constructor(B) {
              super(l, "modifyAnnots");
            }
          }
          class Oe extends D.IntegerObject {
            constructor(B) {
              super(l, "msgId", 1, (Se) => Se >= 1);
            }
          }
          class Je extends D.StringObject {
            constructor(B) {
              super(l, "nameAttr");
            }
          }
          class Ve extends D.ContentObject {
            constructor(B) {
              super(l, "neverEmbed");
            }
          }
          class Pe extends D.IntegerObject {
            constructor(B) {
              super(l, "numberOfCopies", null, (Se) => Se >= 2 && Se <= 5);
            }
          }
          class Ge extends D.XFAObject {
            constructor(B) {
              super(l, "openAction", !0), this.destination = null;
            }
          }
          class dt extends D.XFAObject {
            constructor(B) {
              super(l, "output", !0), this.to = null, this.type = null, this.uri = null;
            }
          }
          class De extends D.StringObject {
            constructor(B) {
              super(l, "outputBin");
            }
          }
          class Qe extends D.XFAObject {
            constructor(B) {
              super(l, "outputXSL", !0), this.uri = null;
            }
          }
          class st extends D.OptionObject {
            constructor(B) {
              super(l, "overprint", ["none", "both", "draw", "field"]);
            }
          }
          class wt extends D.StringObject {
            constructor(B) {
              super(l, "packets");
            }
            [P.$finalize]() {
              this[P.$content] !== "*" && (this[P.$content] = this[P.$content].trim().split(/\s+/).filter((B) => ["config", "datasets", "template", "xfdf", "xslt"].includes(B)));
            }
          }
          class Ot extends D.XFAObject {
            constructor(B) {
              super(l, "pageOffset"), this.x = (0, e.getInteger)({
                data: B.x,
                defaultValue: "useXDCSetting",
                validate: (Se) => !0
              }), this.y = (0, e.getInteger)({
                data: B.y,
                defaultValue: "useXDCSetting",
                validate: (Se) => !0
              });
            }
          }
          class ze extends D.StringObject {
            constructor(B) {
              super(l, "pageRange");
            }
            [P.$finalize]() {
              const B = this[P.$content].trim().split(/\s+/).map((ve) => parseInt(ve, 10)), Se = [];
              for (let ve = 0, Te = B.length; ve < Te; ve += 2)
                Se.push(B.slice(ve, ve + 2));
              this[P.$content] = Se;
            }
          }
          class qe extends D.OptionObject {
            constructor(B) {
              super(l, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
            }
          }
          class Ue extends D.OptionObject {
            constructor(B) {
              super(l, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
            }
          }
          class bt extends D.IntegerObject {
            constructor(B) {
              super(l, "part", 1, (Se) => !1);
            }
          }
          class It extends D.XFAObject {
            constructor(B) {
              super(l, "pcl", !0), this.name = B.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
            }
          }
          class kt extends D.XFAObject {
            constructor(B) {
              super(l, "pdf", !0), this.name = B.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
            }
          }
          class ht extends D.XFAObject {
            constructor(B) {
              super(l, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
            }
          }
          class Rt extends D.XFAObject {
            constructor(B) {
              super(l, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
            }
          }
          class _t extends D.Option01 {
            constructor(B) {
              super(l, "pickTrayByPDFSize");
            }
          }
          class Ie extends D.StringObject {
            constructor(B) {
              super(l, "picture");
            }
          }
          class Fe extends D.Option01 {
            constructor(B) {
              super(l, "plaintextMetadata");
            }
          }
          class Me extends D.OptionObject {
            constructor(B) {
              super(l, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
            }
          }
          class Ne extends D.XFAObject {
            constructor(B) {
              super(l, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new D.XFAObjectArray(), this.labelPrinter = new D.XFAObjectArray(), this.pcl = new D.XFAObjectArray(), this.pdf = new D.XFAObjectArray(), this.ps = new D.XFAObjectArray(), this.submitUrl = new D.XFAObjectArray(), this.webClient = new D.XFAObjectArray(), this.zpl = new D.XFAObjectArray();
            }
          }
          class je extends D.Option01 {
            constructor(B) {
              super(l, "print");
            }
          }
          class et extends D.Option01 {
            constructor(B) {
              super(l, "printHighQuality");
            }
          }
          class $e extends D.OptionObject {
            constructor(B) {
              super(l, "printScaling", ["appdefault", "noScaling"]);
            }
          }
          class Ee extends D.StringObject {
            constructor(B) {
              super(l, "printerName");
            }
          }
          class He extends D.StringObject {
            constructor(B) {
              super(l, "producer");
            }
          }
          class rt extends D.XFAObject {
            constructor(B) {
              super(l, "ps", !0), this.name = B.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
            }
          }
          class mt extends D.ContentObject {
            constructor(B) {
              super(l, "range");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim().split(/\s*,\s*/, 2).map((B) => B.split("-").map((Se) => parseInt(Se.trim(), 10))).filter((B) => B.every((Se) => !isNaN(Se))).map((B) => (B.length === 1 && B.push(B[0]), B));
            }
          }
          class tt extends D.ContentObject {
            constructor(B) {
              super(l, "record");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim();
              const B = parseInt(this[P.$content], 10);
              !isNaN(B) && B >= 0 && (this[P.$content] = B);
            }
          }
          class at extends D.ContentObject {
            constructor(B) {
              super(l, "relevant");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim().split(/\s+/);
            }
          }
          class ft extends D.ContentObject {
            constructor(B) {
              super(l, "rename");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim(), (this[P.$content].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[P.$content])) && (0, t.warn)("XFA - Rename: invalid XFA name");
            }
          }
          class We extends D.OptionObject {
            constructor(B) {
              super(l, "renderPolicy", ["server", "client"]);
            }
          }
          class ot extends D.OptionObject {
            constructor(B) {
              super(l, "runScripts", ["both", "client", "none", "server"]);
            }
          }
          class Xe extends D.XFAObject {
            constructor(B) {
              super(l, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
            }
          }
          class ut extends D.OptionObject {
            constructor(B) {
              super(l, "scriptModel", ["XFA", "none"]);
            }
          }
          class pt extends D.OptionObject {
            constructor(B) {
              super(l, "severity", ["ignore", "error", "information", "trace", "warning"]);
            }
          }
          class $t extends D.XFAObject {
            constructor(B) {
              super(l, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
            }
          }
          class ct extends D.XFAObject {
            constructor(B) {
              super(l, "staple"), this.mode = (0, e.getStringOption)(B.mode, ["usePrinterSetting", "on", "off"]);
            }
          }
          class lt extends D.StringObject {
            constructor(B) {
              super(l, "startNode");
            }
          }
          class vt extends D.IntegerObject {
            constructor(B) {
              super(l, "startPage", 0, (Se) => !0);
            }
          }
          class Nt extends D.OptionObject {
            constructor(B) {
              super(l, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
            }
          }
          class qt extends D.StringObject {
            constructor(B) {
              super(l, "submitUrl");
            }
          }
          class en extends D.IntegerObject {
            constructor(B) {
              super(l, "subsetBelow", 100, (Se) => Se >= 0 && Se <= 100);
            }
          }
          class kn extends D.Option01 {
            constructor(B) {
              super(l, "suppressBanner");
            }
          }
          class Cn extends D.Option01 {
            constructor(B) {
              super(l, "tagged");
            }
          }
          class vn extends D.XFAObject {
            constructor(B) {
              super(l, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
            }
          }
          class Fn extends D.OptionObject {
            constructor(B) {
              super(l, "threshold", ["trace", "error", "information", "warning"]);
            }
          }
          class In extends D.OptionObject {
            constructor(B) {
              super(l, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
            }
          }
          class dn extends D.XFAObject {
            constructor(B) {
              super(l, "templateCache"), this.maxEntries = (0, e.getInteger)({
                data: B.maxEntries,
                defaultValue: 5,
                validate: (Se) => Se >= 0
              });
            }
          }
          class cn extends D.XFAObject {
            constructor(B) {
              super(l, "trace", !0), this.area = new D.XFAObjectArray();
            }
          }
          class On extends D.XFAObject {
            constructor(B) {
              super(l, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
            }
          }
          class Tn extends D.OptionObject {
            constructor(B) {
              super(l, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
            }
          }
          class Mn extends D.StringObject {
            constructor(B) {
              super(l, "uri");
            }
          }
          class ln extends D.OptionObject {
            constructor(B) {
              super(l, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
            }
          }
          class gn extends D.ContentObject {
            constructor(B) {
              super(l, "validateApprovalSignatures");
            }
            [P.$finalize]() {
              this[P.$content] = this[P.$content].trim().split(/\s+/).filter((B) => ["docReady", "postSign"].includes(B));
            }
          }
          class xn extends D.OptionObject {
            constructor(B) {
              super(l, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
            }
          }
          class Pn extends D.OptionObject {
            constructor(B) {
              super(l, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
            }
          }
          class En extends D.XFAObject {
            constructor(B) {
              super(l, "VersionControl"), this.outputBelow = (0, e.getStringOption)(B.outputBelow, ["warn", "error", "update"]), this.sourceAbove = (0, e.getStringOption)(B.sourceAbove, ["warn", "error"]), this.sourceBelow = (0, e.getStringOption)(B.sourceBelow, ["update", "maintain"]);
            }
          }
          class Nn extends D.XFAObject {
            constructor(B) {
              super(l, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
            }
          }
          class Dn extends D.XFAObject {
            constructor(B) {
              super(l, "webClient", !0), this.name = B.name ? B.name.trim() : "", this.fontInfo = null, this.xdc = null;
            }
          }
          class Rn extends D.OptionObject {
            constructor(B) {
              super(l, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
            }
          }
          class hn extends D.ContentObject {
            constructor(B) {
              super(l, "window");
            }
            [P.$finalize]() {
              const B = this[P.$content].trim().split(/\s*,\s*/, 2).map((Se) => parseInt(Se, 10));
              if (B.some((Se) => isNaN(Se))) {
                this[P.$content] = [0, 0];
                return;
              }
              B.length === 1 && B.push(B[0]), this[P.$content] = B;
            }
          }
          class Bn extends D.XFAObject {
            constructor(B) {
              super(l, "xdc", !0), this.uri = new D.XFAObjectArray(), this.xsl = new D.XFAObjectArray();
            }
          }
          class tn extends D.XFAObject {
            constructor(B) {
              super(l, "xdp", !0), this.packets = null;
            }
          }
          class Ln extends D.XFAObject {
            constructor(B) {
              super(l, "xsl", !0), this.debug = null, this.uri = null;
            }
          }
          class nn extends D.XFAObject {
            constructor(B) {
              super(l, "zpl", !0), this.name = B.name ? B.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
            }
          }
          class ke {
            static [n.$buildXFAObject](B, Se) {
              if (ke.hasOwnProperty(B))
                return ke[B](Se);
            }
            static acrobat(B) {
              return new V(B);
            }
            static acrobat7(B) {
              return new te(B);
            }
            static ADBE_JSConsole(B) {
              return new E(B);
            }
            static ADBE_JSDebugger(B) {
              return new F(B);
            }
            static addSilentPrint(B) {
              return new f(B);
            }
            static addViewerPreferences(B) {
              return new x(B);
            }
            static adjustData(B) {
              return new a(B);
            }
            static adobeExtensionLevel(B) {
              return new N(B);
            }
            static agent(B) {
              return new p(B);
            }
            static alwaysEmbed(B) {
              return new O(B);
            }
            static amd(B) {
              return new M(B);
            }
            static area(B) {
              return new R(B);
            }
            static attributes(B) {
              return new z(B);
            }
            static autoSave(B) {
              return new W(B);
            }
            static base(B) {
              return new g(B);
            }
            static batchOutput(B) {
              return new T(B);
            }
            static behaviorOverride(B) {
              return new o(B);
            }
            static cache(B) {
              return new c(B);
            }
            static change(B) {
              return new I(B);
            }
            static common(B) {
              return new s(B);
            }
            static compress(B) {
              return new r(B);
            }
            static compressLogicalStructure(B) {
              return new u(B);
            }
            static compressObjectStream(B) {
              return new C(B);
            }
            static compression(B) {
              return new d(B);
            }
            static config(B) {
              return new y(B);
            }
            static conformance(B) {
              return new _(B);
            }
            static contentCopy(B) {
              return new $(B);
            }
            static copies(B) {
              return new S(B);
            }
            static creator(B) {
              return new v(B);
            }
            static currentPage(B) {
              return new m(B);
            }
            static data(B) {
              return new h(B);
            }
            static debug(B) {
              return new A(B);
            }
            static defaultTypeface(B) {
              return new j(B);
            }
            static destination(B) {
              return new G(B);
            }
            static documentAssembly(B) {
              return new J(B);
            }
            static driver(B) {
              return new oe(B);
            }
            static duplexOption(B) {
              return new q(B);
            }
            static dynamicRender(B) {
              return new re(B);
            }
            static embed(B) {
              return new K(B);
            }
            static encrypt(B) {
              return new Z(B);
            }
            static encryption(B) {
              return new w(B);
            }
            static encryptionLevel(B) {
              return new k(B);
            }
            static enforce(B) {
              return new X(B);
            }
            static equate(B) {
              return new H(B);
            }
            static equateRange(B) {
              return new Y(B);
            }
            static exclude(B) {
              return new ie(B);
            }
            static excludeNS(B) {
              return new ne(B);
            }
            static flipLabel(B) {
              return new U(B);
            }
            static fontInfo(B) {
              return new ae(B);
            }
            static formFieldFilling(B) {
              return new Q(B);
            }
            static groupParent(B) {
              return new L(B);
            }
            static ifEmpty(B) {
              return new ee(B);
            }
            static includeXDPContent(B) {
              return new se(B);
            }
            static incrementalLoad(B) {
              return new le(B);
            }
            static incrementalMerge(B) {
              return new ue(B);
            }
            static interactive(B) {
              return new de(B);
            }
            static jog(B) {
              return new ge(B);
            }
            static labelPrinter(B) {
              return new me(B);
            }
            static layout(B) {
              return new pe(B);
            }
            static level(B) {
              return new xe(B);
            }
            static linearized(B) {
              return new we(B);
            }
            static locale(B) {
              return new Ae(B);
            }
            static localeSet(B) {
              return new be(B);
            }
            static log(B) {
              return new he(B);
            }
            static map(B) {
              return new fe(B);
            }
            static mediumInfo(B) {
              return new Ce(B);
            }
            static message(B) {
              return new ye(B);
            }
            static messaging(B) {
              return new Le(B);
            }
            static mode(B) {
              return new Be(B);
            }
            static modifyAnnots(B) {
              return new nt(B);
            }
            static msgId(B) {
              return new Oe(B);
            }
            static nameAttr(B) {
              return new Je(B);
            }
            static neverEmbed(B) {
              return new Ve(B);
            }
            static numberOfCopies(B) {
              return new Pe(B);
            }
            static openAction(B) {
              return new Ge(B);
            }
            static output(B) {
              return new dt(B);
            }
            static outputBin(B) {
              return new De(B);
            }
            static outputXSL(B) {
              return new Qe(B);
            }
            static overprint(B) {
              return new st(B);
            }
            static packets(B) {
              return new wt(B);
            }
            static pageOffset(B) {
              return new Ot(B);
            }
            static pageRange(B) {
              return new ze(B);
            }
            static pagination(B) {
              return new qe(B);
            }
            static paginationOverride(B) {
              return new Ue(B);
            }
            static part(B) {
              return new bt(B);
            }
            static pcl(B) {
              return new It(B);
            }
            static pdf(B) {
              return new kt(B);
            }
            static pdfa(B) {
              return new ht(B);
            }
            static permissions(B) {
              return new Rt(B);
            }
            static pickTrayByPDFSize(B) {
              return new _t(B);
            }
            static picture(B) {
              return new Ie(B);
            }
            static plaintextMetadata(B) {
              return new Fe(B);
            }
            static presence(B) {
              return new Me(B);
            }
            static present(B) {
              return new Ne(B);
            }
            static print(B) {
              return new je(B);
            }
            static printHighQuality(B) {
              return new et(B);
            }
            static printScaling(B) {
              return new $e(B);
            }
            static printerName(B) {
              return new Ee(B);
            }
            static producer(B) {
              return new He(B);
            }
            static ps(B) {
              return new rt(B);
            }
            static range(B) {
              return new mt(B);
            }
            static record(B) {
              return new tt(B);
            }
            static relevant(B) {
              return new at(B);
            }
            static rename(B) {
              return new ft(B);
            }
            static renderPolicy(B) {
              return new We(B);
            }
            static runScripts(B) {
              return new ot(B);
            }
            static script(B) {
              return new Xe(B);
            }
            static scriptModel(B) {
              return new ut(B);
            }
            static severity(B) {
              return new pt(B);
            }
            static silentPrint(B) {
              return new $t(B);
            }
            static staple(B) {
              return new ct(B);
            }
            static startNode(B) {
              return new lt(B);
            }
            static startPage(B) {
              return new vt(B);
            }
            static submitFormat(B) {
              return new Nt(B);
            }
            static submitUrl(B) {
              return new qt(B);
            }
            static subsetBelow(B) {
              return new en(B);
            }
            static suppressBanner(B) {
              return new kn(B);
            }
            static tagged(B) {
              return new Cn(B);
            }
            static template(B) {
              return new vn(B);
            }
            static templateCache(B) {
              return new dn(B);
            }
            static threshold(B) {
              return new Fn(B);
            }
            static to(B) {
              return new In(B);
            }
            static trace(B) {
              return new cn(B);
            }
            static transform(B) {
              return new On(B);
            }
            static type(B) {
              return new Tn(B);
            }
            static uri(B) {
              return new Mn(B);
            }
            static validate(B) {
              return new ln(B);
            }
            static validateApprovalSignatures(B) {
              return new gn(B);
            }
            static validationMessaging(B) {
              return new xn(B);
            }
            static version(B) {
              return new Pn(B);
            }
            static versionControl(B) {
              return new En(B);
            }
            static viewerPreferences(B) {
              return new Nn(B);
            }
            static webClient(B) {
              return new Dn(B);
            }
            static whitespace(B) {
              return new Rn(B);
            }
            static window(B) {
              return new hn(B);
            }
            static xdc(B) {
              return new Bn(B);
            }
            static xdp(B) {
              return new tn(B);
            }
            static xsl(B) {
              return new Ln(B);
            }
            static zpl(B) {
              return new nn(B);
            }
          }
          b.ConfigNamespace = ke;
        },
        /* 94 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.ConnectionSetNamespace = void 0;
          var n = ce(81), P = ce(87);
          const D = n.NamespaceIds.connectionSet.id;
          class e extends P.XFAObject {
            constructor(R) {
              super(D, "connectionSet", !0), this.wsdlConnection = new P.XFAObjectArray(), this.xmlConnection = new P.XFAObjectArray(), this.xsdConnection = new P.XFAObjectArray();
            }
          }
          class t extends P.XFAObject {
            constructor(R) {
              super(D, "effectiveInputPolicy"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class l extends P.XFAObject {
            constructor(R) {
              super(D, "effectiveOutputPolicy"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class V extends P.StringObject {
            constructor(R) {
              super(D, "operation"), this.id = R.id || "", this.input = R.input || "", this.name = R.name || "", this.output = R.output || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class te extends P.StringObject {
            constructor(R) {
              super(D, "rootElement"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class E extends P.StringObject {
            constructor(R) {
              super(D, "soapAction"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class F extends P.StringObject {
            constructor(R) {
              super(D, "soapAddress"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class f extends P.StringObject {
            constructor(R) {
              super(D, "uri"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class x extends P.StringObject {
            constructor(R) {
              super(D, "wsdlAddress"), this.id = R.id || "", this.name = R.name || "", this.use = R.use || "", this.usehref = R.usehref || "";
            }
          }
          class a extends P.XFAObject {
            constructor(R) {
              super(D, "wsdlConnection", !0), this.dataDescription = R.dataDescription || "", this.name = R.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
            }
          }
          class N extends P.XFAObject {
            constructor(R) {
              super(D, "xmlConnection", !0), this.dataDescription = R.dataDescription || "", this.name = R.name || "", this.uri = null;
            }
          }
          class p extends P.XFAObject {
            constructor(R) {
              super(D, "xsdConnection", !0), this.dataDescription = R.dataDescription || "", this.name = R.name || "", this.rootElement = null, this.uri = null;
            }
          }
          class O {
            static [n.$buildXFAObject](R, z) {
              if (O.hasOwnProperty(R))
                return O[R](z);
            }
            static connectionSet(R) {
              return new e(R);
            }
            static effectiveInputPolicy(R) {
              return new t(R);
            }
            static effectiveOutputPolicy(R) {
              return new l(R);
            }
            static operation(R) {
              return new V(R);
            }
            static rootElement(R) {
              return new te(R);
            }
            static soapAction(R) {
              return new E(R);
            }
            static soapAddress(R) {
              return new F(R);
            }
            static uri(R) {
              return new f(R);
            }
            static wsdlAddress(R) {
              return new x(R);
            }
            static wsdlConnection(R) {
              return new a(R);
            }
            static xmlConnection(R) {
              return new N(R);
            }
            static xsdConnection(R) {
              return new p(R);
            }
          }
          b.ConnectionSetNamespace = O;
        },
        /* 95 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.DatasetsNamespace = void 0;
          var n = ce(78), P = ce(81), D = ce(87);
          const e = P.NamespaceIds.datasets.id;
          class t extends D.XmlObject {
            constructor(E) {
              super(e, "data", E);
            }
            [n.$isNsAgnostic]() {
              return !0;
            }
          }
          class l extends D.XFAObject {
            constructor(E) {
              super(e, "datasets", !0), this.data = null, this.Signature = null;
            }
            [n.$onChild](E) {
              const F = E[n.$nodeName];
              (F === "data" && E[n.$namespaceId] === e || F === "Signature" && E[n.$namespaceId] === P.NamespaceIds.signature.id) && (this[F] = E), this[n.$appendChild](E);
            }
          }
          class V {
            static [P.$buildXFAObject](E, F) {
              if (V.hasOwnProperty(E))
                return V[E](F);
            }
            static datasets(E) {
              return new l(E);
            }
            static data(E) {
              return new t(E);
            }
          }
          b.DatasetsNamespace = V;
        },
        /* 96 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.LocaleSetNamespace = void 0;
          var n = ce(81), P = ce(87), D = ce(84);
          const e = n.NamespaceIds.localeSet.id;
          class t extends P.XFAObject {
            constructor(y) {
              super(e, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new P.XFAObjectArray(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new P.XFAObjectArray(2);
            }
          }
          class l extends P.StringObject {
            constructor(y) {
              super(e, "currencySymbol"), this.name = (0, D.getStringOption)(y.name, ["symbol", "isoname", "decimal"]);
            }
          }
          class V extends P.XFAObject {
            constructor(y) {
              super(e, "currencySymbols", !0), this.currencySymbol = new P.XFAObjectArray(3);
            }
          }
          class te extends P.StringObject {
            constructor(y) {
              super(e, "datePattern"), this.name = (0, D.getStringOption)(y.name, ["full", "long", "med", "short"]);
            }
          }
          class E extends P.XFAObject {
            constructor(y) {
              super(e, "datePatterns", !0), this.datePattern = new P.XFAObjectArray(4);
            }
          }
          class F extends P.ContentObject {
            constructor(y) {
              super(e, "dateTimeSymbols");
            }
          }
          class f extends P.StringObject {
            constructor(y) {
              super(e, "day");
            }
          }
          class x extends P.XFAObject {
            constructor(y) {
              super(e, "dayNames", !0), this.abbr = (0, D.getInteger)({
                data: y.abbr,
                defaultValue: 0,
                validate: (_) => _ === 1
              }), this.day = new P.XFAObjectArray(7);
            }
          }
          class a extends P.StringObject {
            constructor(y) {
              super(e, "era");
            }
          }
          class N extends P.XFAObject {
            constructor(y) {
              super(e, "eraNames", !0), this.era = new P.XFAObjectArray(2);
            }
          }
          class p extends P.XFAObject {
            constructor(y) {
              super(e, "locale", !0), this.desc = y.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
            }
          }
          class O extends P.XFAObject {
            constructor(y) {
              super(e, "localeSet", !0), this.locale = new P.XFAObjectArray();
            }
          }
          class M extends P.StringObject {
            constructor(y) {
              super(e, "meridiem");
            }
          }
          class R extends P.XFAObject {
            constructor(y) {
              super(e, "meridiemNames", !0), this.meridiem = new P.XFAObjectArray(2);
            }
          }
          class z extends P.StringObject {
            constructor(y) {
              super(e, "month");
            }
          }
          class W extends P.XFAObject {
            constructor(y) {
              super(e, "monthNames", !0), this.abbr = (0, D.getInteger)({
                data: y.abbr,
                defaultValue: 0,
                validate: (_) => _ === 1
              }), this.month = new P.XFAObjectArray(12);
            }
          }
          class g extends P.StringObject {
            constructor(y) {
              super(e, "numberPattern"), this.name = (0, D.getStringOption)(y.name, ["full", "long", "med", "short"]);
            }
          }
          class T extends P.XFAObject {
            constructor(y) {
              super(e, "numberPatterns", !0), this.numberPattern = new P.XFAObjectArray(4);
            }
          }
          class o extends P.StringObject {
            constructor(y) {
              super(e, "numberSymbol"), this.name = (0, D.getStringOption)(y.name, ["decimal", "grouping", "percent", "minus", "zero"]);
            }
          }
          class c extends P.XFAObject {
            constructor(y) {
              super(e, "numberSymbols", !0), this.numberSymbol = new P.XFAObjectArray(5);
            }
          }
          class I extends P.StringObject {
            constructor(y) {
              super(e, "timePattern"), this.name = (0, D.getStringOption)(y.name, ["full", "long", "med", "short"]);
            }
          }
          class s extends P.XFAObject {
            constructor(y) {
              super(e, "timePatterns", !0), this.timePattern = new P.XFAObjectArray(4);
            }
          }
          class r extends P.XFAObject {
            constructor(y) {
              super(e, "typeFace", !0), this.name = y.name | "";
            }
          }
          class u extends P.XFAObject {
            constructor(y) {
              super(e, "typeFaces", !0), this.typeFace = new P.XFAObjectArray();
            }
          }
          class C {
            static [n.$buildXFAObject](y, _) {
              if (C.hasOwnProperty(y))
                return C[y](_);
            }
            static calendarSymbols(y) {
              return new t(y);
            }
            static currencySymbol(y) {
              return new l(y);
            }
            static currencySymbols(y) {
              return new V(y);
            }
            static datePattern(y) {
              return new te(y);
            }
            static datePatterns(y) {
              return new E(y);
            }
            static dateTimeSymbols(y) {
              return new F(y);
            }
            static day(y) {
              return new f(y);
            }
            static dayNames(y) {
              return new x(y);
            }
            static era(y) {
              return new a(y);
            }
            static eraNames(y) {
              return new N(y);
            }
            static locale(y) {
              return new p(y);
            }
            static localeSet(y) {
              return new O(y);
            }
            static meridiem(y) {
              return new M(y);
            }
            static meridiemNames(y) {
              return new R(y);
            }
            static month(y) {
              return new z(y);
            }
            static monthNames(y) {
              return new W(y);
            }
            static numberPattern(y) {
              return new g(y);
            }
            static numberPatterns(y) {
              return new T(y);
            }
            static numberSymbol(y) {
              return new o(y);
            }
            static numberSymbols(y) {
              return new c(y);
            }
            static timePattern(y) {
              return new I(y);
            }
            static timePatterns(y) {
              return new s(y);
            }
            static typeFace(y) {
              return new r(y);
            }
            static typeFaces(y) {
              return new u(y);
            }
          }
          b.LocaleSetNamespace = C;
        },
        /* 97 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.SignatureNamespace = void 0;
          var n = ce(81), P = ce(87);
          const D = n.NamespaceIds.signature.id;
          class e extends P.XFAObject {
            constructor(V) {
              super(D, "signature", !0);
            }
          }
          class t {
            static [n.$buildXFAObject](V, te) {
              if (t.hasOwnProperty(V))
                return t[V](te);
            }
            static signature(V) {
              return new e(V);
            }
          }
          b.SignatureNamespace = t;
        },
        /* 98 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.StylesheetNamespace = void 0;
          var n = ce(81), P = ce(87);
          const D = n.NamespaceIds.stylesheet.id;
          class e extends P.XFAObject {
            constructor(V) {
              super(D, "stylesheet", !0);
            }
          }
          class t {
            static [n.$buildXFAObject](V, te) {
              if (t.hasOwnProperty(V))
                return t[V](te);
            }
            static stylesheet(V) {
              return new e(V);
            }
          }
          b.StylesheetNamespace = t;
        },
        /* 99 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XdpNamespace = void 0;
          var n = ce(81), P = ce(78), D = ce(87);
          const e = n.NamespaceIds.xdp.id;
          class t extends D.XFAObject {
            constructor(te) {
              super(e, "xdp", !0), this.uuid = te.uuid || "", this.timeStamp = te.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new D.XFAObjectArray(), this.template = null;
            }
            [P.$onChildCheck](te) {
              const E = n.NamespaceIds[te[P.$nodeName]];
              return E && te[P.$namespaceId] === E.id;
            }
          }
          class l {
            static [n.$buildXFAObject](te, E) {
              if (l.hasOwnProperty(te))
                return l[te](E);
            }
            static xdp(te) {
              return new t(te);
            }
          }
          b.XdpNamespace = l;
        },
        /* 100 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XhtmlNamespace = void 0;
          var n = ce(78), P = ce(81), D = ce(83), e = ce(84), t = ce(87);
          const l = P.NamespaceIds.xhtml.id, V = Symbol(), te = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), E = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (y) => y === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (y) => `scaleX(${Math.max(0, Math.min(parseInt(y) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (y) => `scaleY(${Math.max(0, Math.min(parseInt(y) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (y, _) => (y = _.fontSize = (0, e.getMeasurement)(y), (0, D.measureToString)(0.99 * y))], ["letter-spacing", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["line-height", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["margin", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["margin-bottom", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["margin-left", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["margin-right", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["margin-top", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["text-indent", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))], ["font-family", (y) => y], ["vertical-align", (y) => (0, D.measureToString)((0, e.getMeasurement)(y))]]), F = /\s+/g, f = /[\r\n]+/g, x = /\r\n?/g;
          function a(y, _, $) {
            const S = /* @__PURE__ */ Object.create(null);
            if (!y)
              return S;
            const v = /* @__PURE__ */ Object.create(null);
            for (const [m, h] of y.split(";").map((A) => A.split(":", 2))) {
              const A = E.get(m);
              if (A === "")
                continue;
              let j = h;
              A && (j = typeof A == "string" ? A : A(h, v)), m.endsWith("scale") ? S.transform = S.transform ? `${S[m]} ${j}` : j : S[m.replaceAll(/-([a-zA-Z])/g, (G, J) => J.toUpperCase())] = j;
            }
            if (S.fontFamily && (0, D.setFontFamily)({
              typeface: S.fontFamily,
              weight: S.fontWeight || "normal",
              posture: S.fontStyle || "normal",
              size: v.fontSize || 0
            }, _, _[n.$globalData].fontFinder, S), $ && S.verticalAlign && S.verticalAlign !== "0px" && S.fontSize) {
              const A = (0, e.getMeasurement)(S.fontSize);
              S.fontSize = (0, D.measureToString)(A * 0.583), S.verticalAlign = (0, D.measureToString)(Math.sign((0, e.getMeasurement)(S.verticalAlign)) * A * 0.333);
            }
            return $ && S.fontSize && (S.fontSize = `calc(${S.fontSize} * var(--scale-factor))`), (0, D.fixTextIndent)(S), S;
          }
          function N(y) {
            return y.style ? y.style.trim().split(/\s*;\s*/).filter((_) => !!_).map((_) => _.split(/\s*:\s*/, 2)).filter(([_, $]) => (_ === "font-family" && y[n.$globalData].usedTypefaces.add($), te.has(_))).map((_) => _.join(":")).join(";") : "";
          }
          const p = /* @__PURE__ */ new Set(["body", "html"]);
          class O extends t.XmlObject {
            constructor(_, $) {
              super(l, $), this[V] = !1, this.style = _.style || "";
            }
            [n.$clean](_) {
              super[n.$clean](_), this.style = N(this);
            }
            [n.$acceptWhitespace]() {
              return !p.has(this[n.$nodeName]);
            }
            [n.$onText](_, $ = !1) {
              $ ? this[V] = !0 : (_ = _.replaceAll(f, ""), this.style.includes("xfa-spacerun:yes") || (_ = _.replaceAll(F, " "))), _ && (this[n.$content] += _);
            }
            [n.$pushGlyphs](_, $ = !0) {
              const S = /* @__PURE__ */ Object.create(null), v = {
                top: NaN,
                bottom: NaN,
                left: NaN,
                right: NaN
              };
              let m = null;
              for (const [h, A] of this.style.split(";").map((j) => j.split(":", 2)))
                switch (h) {
                  case "font-family":
                    S.typeface = (0, e.stripQuotes)(A);
                    break;
                  case "font-size":
                    S.size = (0, e.getMeasurement)(A);
                    break;
                  case "font-weight":
                    S.weight = A;
                    break;
                  case "font-style":
                    S.posture = A;
                    break;
                  case "letter-spacing":
                    S.letterSpacing = (0, e.getMeasurement)(A);
                    break;
                  case "margin":
                    const j = A.split(/ \t/).map((G) => (0, e.getMeasurement)(G));
                    switch (j.length) {
                      case 1:
                        v.top = v.bottom = v.left = v.right = j[0];
                        break;
                      case 2:
                        v.top = v.bottom = j[0], v.left = v.right = j[1];
                        break;
                      case 3:
                        v.top = j[0], v.bottom = j[2], v.left = v.right = j[1];
                        break;
                      case 4:
                        v.top = j[0], v.left = j[1], v.bottom = j[2], v.right = j[3];
                        break;
                    }
                    break;
                  case "margin-top":
                    v.top = (0, e.getMeasurement)(A);
                    break;
                  case "margin-bottom":
                    v.bottom = (0, e.getMeasurement)(A);
                    break;
                  case "margin-left":
                    v.left = (0, e.getMeasurement)(A);
                    break;
                  case "margin-right":
                    v.right = (0, e.getMeasurement)(A);
                    break;
                  case "line-height":
                    m = (0, e.getMeasurement)(A);
                    break;
                }
              if (_.pushData(S, v, m), this[n.$content])
                _.addString(this[n.$content]);
              else
                for (const h of this[n.$getChildren]()) {
                  if (h[n.$nodeName] === "#text") {
                    _.addString(h[n.$content]);
                    continue;
                  }
                  h[n.$pushGlyphs](_);
                }
              $ && _.popFont();
            }
            [n.$toHTML](_) {
              const $ = [];
              if (this[n.$extra] = {
                children: $
              }, this[n.$childrenToHTML]({}), $.length === 0 && !this[n.$content])
                return e.HTMLResult.EMPTY;
              let S;
              return this[V] ? S = this[n.$content] ? this[n.$content].replaceAll(x, `
`) : void 0 : S = this[n.$content] || void 0, e.HTMLResult.success({
                name: this[n.$nodeName],
                attributes: {
                  href: this.href,
                  style: a(this.style, this, this[V])
                },
                children: $,
                value: S
              });
            }
          }
          class M extends O {
            constructor(_) {
              super(_, "a"), this.href = (0, D.fixURL)(_.href) || "";
            }
          }
          class R extends O {
            constructor(_) {
              super(_, "b");
            }
            [n.$pushGlyphs](_) {
              _.pushFont({
                weight: "bold"
              }), super[n.$pushGlyphs](_), _.popFont();
            }
          }
          class z extends O {
            constructor(_) {
              super(_, "body");
            }
            [n.$toHTML](_) {
              const $ = super[n.$toHTML](_), {
                html: S
              } = $;
              return S ? (S.name = "div", S.attributes.class = ["xfaRich"], $) : e.HTMLResult.EMPTY;
            }
          }
          class W extends O {
            constructor(_) {
              super(_, "br");
            }
            [n.$text]() {
              return `
`;
            }
            [n.$pushGlyphs](_) {
              _.addString(`
`);
            }
            [n.$toHTML](_) {
              return e.HTMLResult.success({
                name: "br"
              });
            }
          }
          class g extends O {
            constructor(_) {
              super(_, "html");
            }
            [n.$toHTML](_) {
              var S;
              const $ = [];
              if (this[n.$extra] = {
                children: $
              }, this[n.$childrenToHTML]({}), $.length === 0)
                return e.HTMLResult.success({
                  name: "div",
                  attributes: {
                    class: ["xfaRich"],
                    style: {}
                  },
                  value: this[n.$content] || ""
                });
              if ($.length === 1) {
                const v = $[0];
                if ((S = v.attributes) != null && S.class.includes("xfaRich"))
                  return e.HTMLResult.success(v);
              }
              return e.HTMLResult.success({
                name: "div",
                attributes: {
                  class: ["xfaRich"],
                  style: {}
                },
                children: $
              });
            }
          }
          class T extends O {
            constructor(_) {
              super(_, "i");
            }
            [n.$pushGlyphs](_) {
              _.pushFont({
                posture: "italic"
              }), super[n.$pushGlyphs](_), _.popFont();
            }
          }
          class o extends O {
            constructor(_) {
              super(_, "li");
            }
          }
          class c extends O {
            constructor(_) {
              super(_, "ol");
            }
          }
          class I extends O {
            constructor(_) {
              super(_, "p");
            }
            [n.$pushGlyphs](_) {
              super[n.$pushGlyphs](_, !1), _.addString(`
`), _.addPara(), _.popFont();
            }
            [n.$text]() {
              return this[n.$getParent]()[n.$getChildren]().at(-1) === this ? super[n.$text]() : super[n.$text]() + `
`;
            }
          }
          class s extends O {
            constructor(_) {
              super(_, "span");
            }
          }
          class r extends O {
            constructor(_) {
              super(_, "sub");
            }
          }
          class u extends O {
            constructor(_) {
              super(_, "sup");
            }
          }
          class C extends O {
            constructor(_) {
              super(_, "ul");
            }
          }
          class d {
            static [P.$buildXFAObject](_, $) {
              if (d.hasOwnProperty(_))
                return d[_]($);
            }
            static a(_) {
              return new M(_);
            }
            static b(_) {
              return new R(_);
            }
            static body(_) {
              return new z(_);
            }
            static br(_) {
              return new W(_);
            }
            static html(_) {
              return new g(_);
            }
            static i(_) {
              return new T(_);
            }
            static li(_) {
              return new o(_);
            }
            static ol(_) {
              return new c(_);
            }
            static p(_) {
              return new I(_);
            }
            static span(_) {
              return new s(_);
            }
            static sub(_) {
              return new r(_);
            }
            static sup(_) {
              return new u(_);
            }
            static ul(_) {
              return new C(_);
            }
          }
          b.XhtmlNamespace = d;
        },
        /* 101 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.UnknownNamespace = void 0;
          var n = ce(81), P = ce(87);
          class D {
            constructor(t) {
              this.namespaceId = t;
            }
            [n.$buildXFAObject](t, l) {
              return new P.XmlObject(this.namespaceId, t, l);
            }
          }
          b.UnknownNamespace = D;
        },
        /* 102 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.DatasetReader = void 0;
          var n = ce(2), P = ce(3), D = ce(71);
          function e(V) {
            try {
              return (0, n.stringToUTF8String)(V);
            } catch (te) {
              return (0, n.warn)(`UTF-8 decoding failed: "${te}".`), V;
            }
          }
          class t extends D.SimpleXMLParser {
            constructor(te) {
              super(te), this.node = null;
            }
            onEndElement(te) {
              const E = super.onEndElement(te);
              if (E && te === "xfa:datasets")
                throw this.node = E, new Error("Aborting DatasetXMLParser.");
            }
          }
          class l {
            constructor(te) {
              if (te.datasets)
                this.node = new D.SimpleXMLParser({
                  hasAttributes: !0
                }).parseFromString(te.datasets).documentElement;
              else {
                const E = new t({
                  hasAttributes: !0
                });
                try {
                  E.parseFromString(te["xdp:xdp"]);
                } catch {
                }
                this.node = E.node;
              }
            }
            getValue(te) {
              if (!this.node || !te)
                return "";
              const E = this.node.searchNode((0, P.parseXFAPath)(te), 0);
              if (!E)
                return "";
              const F = E.firstChild;
              return (F == null ? void 0 : F.nodeName) === "value" ? E.children.map((f) => e(f.textContent)) : e(E.textContent);
            }
          }
          b.DatasetReader = l;
        },
        /* 103 */
        /***/
        (Re, b, ce) => {
          var te;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.XRef = void 0;
          var n = ce(2), P = ce(4), D = ce(16), e = ce(3), t = ce(5), l = ce(74);
          class V {
            constructor(F, f) {
              At(this, te, null);
              this.stream = F, this.pdfManager = f, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new P.RefSet(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null;
            }
            getNewPersistentRef(F) {
              this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
              const f = this._newPersistentRefNum++;
              return this._cacheMap.set(f, F), P.Ref.get(f, 0);
            }
            getNewTemporaryRef() {
              return this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1), P.Ref.get(this._newTemporaryRefNum++, 0);
            }
            resetNewTemporaryRef() {
              this._newTemporaryRefNum = null;
            }
            setStartXRef(F) {
              this.startXRefQueue = [F];
            }
            parse(F = !1) {
              let f;
              F ? ((0, n.warn)("Indexing all PDF objects"), f = this.indexObjects()) : f = this.readXRef(), f.assignXref(this), this.trailer = f;
              let x;
              try {
                x = f.get("Encrypt");
              } catch (N) {
                if (N instanceof e.MissingDataException)
                  throw N;
                (0, n.warn)(`XRef.parse - Invalid "Encrypt" reference: "${N}".`);
              }
              if (x instanceof P.Dict) {
                const N = f.get("ID"), p = N != null && N.length ? N[0] : "";
                x.suppressEncryption = !0, this.encrypt = new l.CipherTransformFactory(x, p, this.pdfManager.password);
              }
              let a;
              try {
                a = f.get("Root");
              } catch (N) {
                if (N instanceof e.MissingDataException)
                  throw N;
                (0, n.warn)(`XRef.parse - Invalid "Root" reference: "${N}".`);
              }
              if (a instanceof P.Dict)
                try {
                  if (a.get("Pages") instanceof P.Dict) {
                    this.root = a;
                    return;
                  }
                } catch (N) {
                  if (N instanceof e.MissingDataException)
                    throw N;
                  (0, n.warn)(`XRef.parse - Invalid "Pages" reference: "${N}".`);
                }
              throw F ? new n.InvalidPDFException("Invalid Root reference.") : new e.XRefParseException();
            }
            processXRefTable(F) {
              "tableState" in this || (this.tableState = {
                entryNum: 0,
                streamPos: F.lexer.stream.pos,
                parserBuf1: F.buf1,
                parserBuf2: F.buf2
              });
              const f = this.readXRefTable(F);
              if (!(0, P.isCmd)(f, "trailer"))
                throw new n.FormatError("Invalid XRef table: could not find trailer dictionary");
              let x = F.getObj();
              if (!(x instanceof P.Dict) && x.dict && (x = x.dict), !(x instanceof P.Dict))
                throw new n.FormatError("Invalid XRef table: could not parse trailer dictionary");
              return delete this.tableState, x;
            }
            readXRefTable(F) {
              const f = F.lexer.stream, x = this.tableState;
              f.pos = x.streamPos, F.buf1 = x.parserBuf1, F.buf2 = x.parserBuf2;
              let a;
              for (; ; ) {
                if (!("firstEntryNum" in x) || !("entryCount" in x)) {
                  if ((0, P.isCmd)(a = F.getObj(), "trailer"))
                    break;
                  x.firstEntryNum = a, x.entryCount = F.getObj();
                }
                let N = x.firstEntryNum;
                const p = x.entryCount;
                if (!Number.isInteger(N) || !Number.isInteger(p))
                  throw new n.FormatError("Invalid XRef table: wrong types in subsection header");
                for (let O = x.entryNum; O < p; O++) {
                  x.streamPos = f.pos, x.entryNum = O, x.parserBuf1 = F.buf1, x.parserBuf2 = F.buf2;
                  const M = {};
                  M.offset = F.getObj(), M.gen = F.getObj();
                  const R = F.getObj();
                  if (R instanceof P.Cmd)
                    switch (R.cmd) {
                      case "f":
                        M.free = !0;
                        break;
                      case "n":
                        M.uncompressed = !0;
                        break;
                    }
                  if (!Number.isInteger(M.offset) || !Number.isInteger(M.gen) || !(M.free || M.uncompressed))
                    throw new n.FormatError(`Invalid entry in XRef subsection: ${N}, ${p}`);
                  O === 0 && M.free && N === 1 && (N = 0), this.entries[O + N] || (this.entries[O + N] = M);
                }
                x.entryNum = 0, x.streamPos = f.pos, x.parserBuf1 = F.buf1, x.parserBuf2 = F.buf2, delete x.firstEntryNum, delete x.entryCount;
              }
              if (this.entries[0] && !this.entries[0].free)
                throw new n.FormatError("Invalid XRef table: unexpected first object");
              return a;
            }
            processXRefStream(F) {
              if (!("streamState" in this)) {
                const f = F.dict, x = f.get("W");
                let a = f.get("Index");
                a || (a = [0, f.get("Size")]), this.streamState = {
                  entryRanges: a,
                  byteWidths: x,
                  entryNum: 0,
                  streamPos: F.pos
                };
              }
              return this.readXRefStream(F), delete this.streamState, F.dict;
            }
            readXRefStream(F) {
              const f = this.streamState;
              F.pos = f.streamPos;
              const [x, a, N] = f.byteWidths, p = f.entryRanges;
              for (; p.length > 0; ) {
                const [O, M] = p;
                if (!Number.isInteger(O) || !Number.isInteger(M))
                  throw new n.FormatError(`Invalid XRef range fields: ${O}, ${M}`);
                if (!Number.isInteger(x) || !Number.isInteger(a) || !Number.isInteger(N))
                  throw new n.FormatError(`Invalid XRef entry fields length: ${O}, ${M}`);
                for (let R = f.entryNum; R < M; ++R) {
                  f.entryNum = R, f.streamPos = F.pos;
                  let z = 0, W = 0, g = 0;
                  for (let o = 0; o < x; ++o) {
                    const c = F.getByte();
                    if (c === -1)
                      throw new n.FormatError("Invalid XRef byteWidths 'type'.");
                    z = z << 8 | c;
                  }
                  x === 0 && (z = 1);
                  for (let o = 0; o < a; ++o) {
                    const c = F.getByte();
                    if (c === -1)
                      throw new n.FormatError("Invalid XRef byteWidths 'offset'.");
                    W = W << 8 | c;
                  }
                  for (let o = 0; o < N; ++o) {
                    const c = F.getByte();
                    if (c === -1)
                      throw new n.FormatError("Invalid XRef byteWidths 'generation'.");
                    g = g << 8 | c;
                  }
                  const T = {};
                  switch (T.offset = W, T.gen = g, z) {
                    case 0:
                      T.free = !0;
                      break;
                    case 1:
                      T.uncompressed = !0;
                      break;
                    case 2:
                      break;
                    default:
                      throw new n.FormatError(`Invalid XRef entry type: ${z}`);
                  }
                  this.entries[O + R] || (this.entries[O + R] = T);
                }
                f.entryNum = 0, f.streamPos = F.pos, p.splice(0, 2);
              }
            }
            indexObjects() {
              function O(v, m) {
                let h = "", A = v[m];
                for (; A !== 10 && A !== 13 && A !== 60 && !(++m >= v.length); )
                  h += String.fromCharCode(A), A = v[m];
                return h;
              }
              function M(v, m, h) {
                const A = h.length, j = v.length;
                let G = 0;
                for (; m < j; ) {
                  let J = 0;
                  for (; J < A && v[m + J] === h[J]; )
                    ++J;
                  if (J >= A)
                    break;
                  m++, G++;
                }
                return G;
              }
              const R = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, z = /\b(startxref|\d+\s+\d+\s+obj)\b/g, W = /^(\d+)\s+(\d+)\s+obj\b/, g = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), T = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), o = new Uint8Array([47, 88, 82, 101, 102]);
              this.entries.length = 0, this._cacheMap.clear();
              const c = this.stream;
              c.pos = 0;
              const I = c.getBytes(), s = (0, n.bytesToString)(I), r = I.length;
              let u = c.start;
              const C = [], d = [];
              for (; u < r; ) {
                let v = I[u];
                if (v === 9 || v === 10 || v === 13 || v === 32) {
                  ++u;
                  continue;
                }
                if (v === 37) {
                  do {
                    if (++u, u >= r)
                      break;
                    v = I[u];
                  } while (v !== 10 && v !== 13);
                  continue;
                }
                const m = O(I, u);
                let h;
                if (m.startsWith("xref") && (m.length === 4 || /\s/.test(m[4])))
                  u += M(I, u, g), C.push(u), u += M(I, u, T);
                else if (h = W.exec(m)) {
                  const A = h[1] | 0, j = h[2] | 0, G = u + m.length;
                  let J, oe = !1;
                  if (!this.entries[A])
                    oe = !0;
                  else if (this.entries[A].gen === j)
                    try {
                      new D.Parser({
                        lexer: new D.Lexer(c.makeSubStream(G))
                      }).getObj(), oe = !0;
                    } catch (Z) {
                      Z instanceof e.ParserEOFException ? (0, n.warn)(`indexObjects -- checking object (${m}): "${Z}".`) : oe = !0;
                    }
                  oe && (this.entries[A] = {
                    offset: u - c.start,
                    gen: j,
                    uncompressed: !0
                  }), R.lastIndex = G;
                  const q = R.exec(s);
                  q ? (J = R.lastIndex + 1 - u, q[1] !== "endobj" && ((0, n.warn)(`indexObjects: Found "${q[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), J -= q[1].length + 1)) : J = r - u;
                  const re = I.subarray(u, u + J), K = M(re, 0, o);
                  K < J && re[K + 5] < 64 && (d.push(u - c.start), this._xrefStms.add(u - c.start)), u += J;
                } else if (m.startsWith("trailer") && (m.length === 7 || /\s/.test(m[7]))) {
                  C.push(u);
                  const A = u + m.length;
                  let j;
                  z.lastIndex = A;
                  const G = z.exec(s);
                  G ? (j = z.lastIndex + 1 - u, G[1] !== "startxref" && ((0, n.warn)(`indexObjects: Found "${G[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), j -= G[1].length + 1)) : j = r - u, u += j;
                } else
                  u += m.length + 1;
              }
              for (const v of d)
                this.startXRefQueue.push(v), this.readXRef(!0);
              const y = [];
              let _ = !1;
              for (const v of C) {
                c.pos = v;
                const m = new D.Parser({
                  lexer: new D.Lexer(c),
                  xref: this,
                  allowStreams: !0,
                  recoveryMode: !0
                }), h = m.getObj();
                if (!(0, P.isCmd)(h, "trailer"))
                  continue;
                const A = m.getObj();
                A instanceof P.Dict && (y.push(A), A.has("Encrypt") && (_ = !0));
              }
              let $, S;
              for (const v of [...y, "genFallback", ...y]) {
                if (v === "genFallback") {
                  if (!S)
                    break;
                  this._generationFallback = !0;
                  continue;
                }
                let m = !1;
                try {
                  const h = v.get("Root");
                  if (!(h instanceof P.Dict))
                    continue;
                  const A = h.get("Pages");
                  if (!(A instanceof P.Dict))
                    continue;
                  const j = A.get("Count");
                  Number.isInteger(j) && (m = !0);
                } catch (h) {
                  S = h;
                  continue;
                }
                if (m && (!_ || v.has("Encrypt")) && v.has("ID"))
                  return v;
                $ = v;
              }
              if ($)
                return $;
              if (this.topDict)
                return this.topDict;
              throw new n.InvalidPDFException("Invalid PDF structure.");
            }
            readXRef(F = !1) {
              const f = this.stream, x = /* @__PURE__ */ new Set();
              for (; this.startXRefQueue.length; ) {
                try {
                  const a = this.startXRefQueue[0];
                  if (x.has(a)) {
                    (0, n.warn)("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
                    continue;
                  }
                  x.add(a), f.pos = a + f.start;
                  const N = new D.Parser({
                    lexer: new D.Lexer(f),
                    xref: this,
                    allowStreams: !0
                  });
                  let p = N.getObj(), O;
                  if ((0, P.isCmd)(p, "xref"))
                    O = this.processXRefTable(N), this.topDict || (this.topDict = O), p = O.get("XRefStm"), Number.isInteger(p) && !this._xrefStms.has(p) && (this._xrefStms.add(p), this.startXRefQueue.push(p), Lt(this, te) ?? pn(this, te, p));
                  else if (Number.isInteger(p)) {
                    if (!Number.isInteger(N.getObj()) || !(0, P.isCmd)(N.getObj(), "obj") || !((p = N.getObj()) instanceof t.BaseStream))
                      throw new n.FormatError("Invalid XRef stream");
                    if (O = this.processXRefStream(p), this.topDict || (this.topDict = O), !O)
                      throw new n.FormatError("Failed to read XRef stream");
                  } else
                    throw new n.FormatError("Invalid XRef stream header");
                  p = O.get("Prev"), Number.isInteger(p) ? this.startXRefQueue.push(p) : p instanceof P.Ref && this.startXRefQueue.push(p.num);
                } catch (a) {
                  if (a instanceof e.MissingDataException)
                    throw a;
                  (0, n.info)("(while reading XRef): " + a);
                }
                this.startXRefQueue.shift();
              }
              if (this.topDict)
                return this.topDict;
              if (!F)
                throw new e.XRefParseException();
            }
            get lastXRefStreamPos() {
              return Lt(this, te) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
            }
            getEntry(F) {
              const f = this.entries[F];
              return f && !f.free && f.offset ? f : null;
            }
            fetchIfRef(F, f = !1) {
              return F instanceof P.Ref ? this.fetch(F, f) : F;
            }
            fetch(F, f = !1) {
              if (!(F instanceof P.Ref))
                throw new Error("ref object is not a reference");
              const x = F.num, a = this._cacheMap.get(x);
              if (a !== void 0)
                return a instanceof P.Dict && !a.objId && (a.objId = F.toString()), a;
              let N = this.getEntry(x);
              if (N === null)
                return this._cacheMap.set(x, N), N;
              if (this._pendingRefs.has(F))
                return this._pendingRefs.remove(F), (0, n.warn)(`Ignoring circular reference: ${F}.`), P.CIRCULAR_REF;
              this._pendingRefs.put(F);
              try {
                N = N.uncompressed ? this.fetchUncompressed(F, N, f) : this.fetchCompressed(F, N, f), this._pendingRefs.remove(F);
              } catch (p) {
                throw this._pendingRefs.remove(F), p;
              }
              return N instanceof P.Dict ? N.objId = F.toString() : N instanceof t.BaseStream && (N.dict.objId = F.toString()), N;
            }
            fetchUncompressed(F, f, x = !1) {
              const a = F.gen;
              let N = F.num;
              if (f.gen !== a) {
                const W = `Inconsistent generation in XRef: ${F}`;
                if (this._generationFallback && f.gen < a)
                  return (0, n.warn)(W), this.fetchUncompressed(P.Ref.get(N, f.gen), f, x);
                throw new e.XRefEntryException(W);
              }
              const p = this.stream.makeSubStream(f.offset + this.stream.start), O = new D.Parser({
                lexer: new D.Lexer(p),
                xref: this,
                allowStreams: !0
              }), M = O.getObj(), R = O.getObj(), z = O.getObj();
              if (M !== N || R !== a || !(z instanceof P.Cmd))
                throw new e.XRefEntryException(`Bad (uncompressed) XRef entry: ${F}`);
              if (z.cmd !== "obj") {
                if (z.cmd.startsWith("obj") && (N = parseInt(z.cmd.substring(3), 10), !Number.isNaN(N)))
                  return N;
                throw new e.XRefEntryException(`Bad (uncompressed) XRef entry: ${F}`);
              }
              return f = this.encrypt && !x ? O.getObj(this.encrypt.createCipherTransform(N, a)) : O.getObj(), f instanceof t.BaseStream || this._cacheMap.set(N, f), f;
            }
            fetchCompressed(F, f, x = !1) {
              const a = f.offset, N = this.fetch(P.Ref.get(a, 0));
              if (!(N instanceof t.BaseStream))
                throw new n.FormatError("bad ObjStm stream");
              const p = N.dict.get("First"), O = N.dict.get("N");
              if (!Number.isInteger(p) || !Number.isInteger(O))
                throw new n.FormatError("invalid first and n parameters for ObjStm stream");
              let M = new D.Parser({
                lexer: new D.Lexer(N),
                xref: this,
                allowStreams: !0
              });
              const R = new Array(O), z = new Array(O);
              for (let T = 0; T < O; ++T) {
                const o = M.getObj();
                if (!Number.isInteger(o))
                  throw new n.FormatError(`invalid object number in the ObjStm stream: ${o}`);
                const c = M.getObj();
                if (!Number.isInteger(c))
                  throw new n.FormatError(`invalid object offset in the ObjStm stream: ${c}`);
                R[T] = o, z[T] = c;
              }
              const W = (N.start || 0) + p, g = new Array(O);
              for (let T = 0; T < O; ++T) {
                const o = T < O - 1 ? z[T + 1] - z[T] : void 0;
                if (o < 0)
                  throw new n.FormatError("Invalid offset in the ObjStm stream.");
                M = new D.Parser({
                  lexer: new D.Lexer(N.makeSubStream(W + z[T], o, N.dict)),
                  xref: this,
                  allowStreams: !0
                });
                const c = M.getObj();
                if (g[T] = c, c instanceof t.BaseStream)
                  continue;
                const I = R[T], s = this.entries[I];
                s && s.offset === a && s.gen === T && this._cacheMap.set(I, c);
              }
              if (f = g[f.gen], f === void 0)
                throw new e.XRefEntryException(`Bad (compressed) XRef entry: ${F}`);
              return f;
            }
            async fetchIfRefAsync(F, f) {
              return F instanceof P.Ref ? this.fetchAsync(F, f) : F;
            }
            async fetchAsync(F, f) {
              try {
                return this.fetch(F, f);
              } catch (x) {
                if (!(x instanceof e.MissingDataException))
                  throw x;
                return await this.pdfManager.requestRange(x.begin, x.end), this.fetchAsync(F, f);
              }
            }
            getCatalogObj() {
              return this.root;
            }
          }
          te = new WeakMap(), b.XRef = V;
        },
        /* 104 */
        /***/
        (Re, b, ce) => {
          var l, ca, te, la, F, An;
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.MessageHandler = void 0;
          var n = ce(2);
          const P = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, D = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function e(x) {
            switch (x instanceof Error || typeof x == "object" && x !== null || (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), x.name) {
              case "AbortException":
                return new n.AbortException(x.message);
              case "MissingPDFException":
                return new n.MissingPDFException(x.message);
              case "PasswordException":
                return new n.PasswordException(x.message, x.code);
              case "UnexpectedResponseException":
                return new n.UnexpectedResponseException(x.message, x.status);
              case "UnknownErrorException":
                return new n.UnknownErrorException(x.message, x.details);
              default:
                return new n.UnknownErrorException(x.message, x.toString());
            }
          }
          class t {
            constructor(a, N, p) {
              At(this, l);
              At(this, te);
              At(this, F);
              this.sourceName = a, this.targetName = N, this.comObj = p, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (O) => {
                const M = O.data;
                if (M.targetName !== this.sourceName)
                  return;
                if (M.stream) {
                  it(this, te, la).call(this, M);
                  return;
                }
                if (M.callback) {
                  const z = M.callbackId, W = this.callbackCapabilities[z];
                  if (!W)
                    throw new Error(`Cannot resolve callback ${z}`);
                  if (delete this.callbackCapabilities[z], M.callback === P.DATA)
                    W.resolve(M.data);
                  else if (M.callback === P.ERROR)
                    W.reject(e(M.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const R = this.actionHandler[M.action];
                if (!R)
                  throw new Error(`Unknown action from worker: ${M.action}`);
                if (M.callbackId) {
                  const z = this.sourceName, W = M.sourceName;
                  new Promise(function(g) {
                    g(R(M.data));
                  }).then(function(g) {
                    p.postMessage({
                      sourceName: z,
                      targetName: W,
                      callback: P.DATA,
                      callbackId: M.callbackId,
                      data: g
                    });
                  }, function(g) {
                    p.postMessage({
                      sourceName: z,
                      targetName: W,
                      callback: P.ERROR,
                      callbackId: M.callbackId,
                      reason: e(g)
                    });
                  });
                  return;
                }
                if (M.streamId) {
                  it(this, l, ca).call(this, M);
                  return;
                }
                R(M.data);
              }, p.addEventListener("message", this._onComObjOnMessage);
            }
            on(a, N) {
              const p = this.actionHandler;
              if (p[a])
                throw new Error(`There is already an actionName called "${a}"`);
              p[a] = N;
            }
            send(a, N, p) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: a,
                data: N
              }, p);
            }
            sendWithPromise(a, N, p) {
              const O = this.callbackId++, M = new n.PromiseCapability();
              this.callbackCapabilities[O] = M;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: a,
                  callbackId: O,
                  data: N
                }, p);
              } catch (R) {
                M.reject(R);
              }
              return M.promise;
            }
            sendWithStream(a, N, p, O) {
              const M = this.streamId++, R = this.sourceName, z = this.targetName, W = this.comObj;
              return new ReadableStream({
                start: (g) => {
                  const T = new n.PromiseCapability();
                  return this.streamControllers[M] = {
                    controller: g,
                    startCall: T,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, W.postMessage({
                    sourceName: R,
                    targetName: z,
                    action: a,
                    streamId: M,
                    data: N,
                    desiredSize: g.desiredSize
                  }, O), T.promise;
                },
                pull: (g) => {
                  const T = new n.PromiseCapability();
                  return this.streamControllers[M].pullCall = T, W.postMessage({
                    sourceName: R,
                    targetName: z,
                    stream: D.PULL,
                    streamId: M,
                    desiredSize: g.desiredSize
                  }), T.promise;
                },
                cancel: (g) => {
                  (0, n.assert)(g instanceof Error, "cancel must have a valid reason");
                  const T = new n.PromiseCapability();
                  return this.streamControllers[M].cancelCall = T, this.streamControllers[M].isClosed = !0, W.postMessage({
                    sourceName: R,
                    targetName: z,
                    stream: D.CANCEL,
                    streamId: M,
                    reason: e(g)
                  }), T.promise;
                }
              }, p);
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          l = new WeakSet(), ca = function(a) {
            const N = a.streamId, p = this.sourceName, O = a.sourceName, M = this.comObj, R = this, z = this.actionHandler[a.action], W = {
              enqueue(g, T = 1, o) {
                if (this.isCancelled)
                  return;
                const c = this.desiredSize;
                this.desiredSize -= T, c > 0 && this.desiredSize <= 0 && (this.sinkCapability = new n.PromiseCapability(), this.ready = this.sinkCapability.promise), M.postMessage({
                  sourceName: p,
                  targetName: O,
                  stream: D.ENQUEUE,
                  streamId: N,
                  chunk: g
                }, o);
              },
              close() {
                this.isCancelled || (this.isCancelled = !0, M.postMessage({
                  sourceName: p,
                  targetName: O,
                  stream: D.CLOSE,
                  streamId: N
                }), delete R.streamSinks[N]);
              },
              error(g) {
                (0, n.assert)(g instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, M.postMessage({
                  sourceName: p,
                  targetName: O,
                  stream: D.ERROR,
                  streamId: N,
                  reason: e(g)
                }));
              },
              sinkCapability: new n.PromiseCapability(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: a.desiredSize,
              ready: null
            };
            W.sinkCapability.resolve(), W.ready = W.sinkCapability.promise, this.streamSinks[N] = W, new Promise(function(g) {
              g(z(a.data, W));
            }).then(function() {
              M.postMessage({
                sourceName: p,
                targetName: O,
                stream: D.START_COMPLETE,
                streamId: N,
                success: !0
              });
            }, function(g) {
              M.postMessage({
                sourceName: p,
                targetName: O,
                stream: D.START_COMPLETE,
                streamId: N,
                reason: e(g)
              });
            });
          }, te = new WeakSet(), la = function(a) {
            const N = a.streamId, p = this.sourceName, O = a.sourceName, M = this.comObj, R = this.streamControllers[N], z = this.streamSinks[N];
            switch (a.stream) {
              case D.START_COMPLETE:
                a.success ? R.startCall.resolve() : R.startCall.reject(e(a.reason));
                break;
              case D.PULL_COMPLETE:
                a.success ? R.pullCall.resolve() : R.pullCall.reject(e(a.reason));
                break;
              case D.PULL:
                if (!z) {
                  M.postMessage({
                    sourceName: p,
                    targetName: O,
                    stream: D.PULL_COMPLETE,
                    streamId: N,
                    success: !0
                  });
                  break;
                }
                z.desiredSize <= 0 && a.desiredSize > 0 && z.sinkCapability.resolve(), z.desiredSize = a.desiredSize, new Promise(function(W) {
                  var g;
                  W((g = z.onPull) == null ? void 0 : g.call(z));
                }).then(function() {
                  M.postMessage({
                    sourceName: p,
                    targetName: O,
                    stream: D.PULL_COMPLETE,
                    streamId: N,
                    success: !0
                  });
                }, function(W) {
                  M.postMessage({
                    sourceName: p,
                    targetName: O,
                    stream: D.PULL_COMPLETE,
                    streamId: N,
                    reason: e(W)
                  });
                });
                break;
              case D.ENQUEUE:
                if ((0, n.assert)(R, "enqueue should have stream controller"), R.isClosed)
                  break;
                R.controller.enqueue(a.chunk);
                break;
              case D.CLOSE:
                if ((0, n.assert)(R, "close should have stream controller"), R.isClosed)
                  break;
                R.isClosed = !0, R.controller.close(), it(this, F, An).call(this, R, N);
                break;
              case D.ERROR:
                (0, n.assert)(R, "error should have stream controller"), R.controller.error(e(a.reason)), it(this, F, An).call(this, R, N);
                break;
              case D.CANCEL_COMPLETE:
                a.success ? R.cancelCall.resolve() : R.cancelCall.reject(e(a.reason)), it(this, F, An).call(this, R, N);
                break;
              case D.CANCEL:
                if (!z)
                  break;
                new Promise(function(W) {
                  var g;
                  W((g = z.onCancel) == null ? void 0 : g.call(z, e(a.reason)));
                }).then(function() {
                  M.postMessage({
                    sourceName: p,
                    targetName: O,
                    stream: D.CANCEL_COMPLETE,
                    streamId: N,
                    success: !0
                  });
                }, function(W) {
                  M.postMessage({
                    sourceName: p,
                    targetName: O,
                    stream: D.CANCEL_COMPLETE,
                    streamId: N,
                    reason: e(W)
                  });
                }), z.sinkCapability.reject(e(a.reason)), z.isCancelled = !0, delete this.streamSinks[N];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }, F = new WeakSet(), An = async function(a, N) {
            var p, O, M;
            await Promise.allSettled([(p = a.startCall) == null ? void 0 : p.promise, (O = a.pullCall) == null ? void 0 : O.promise, (M = a.cancelCall) == null ? void 0 : M.promise]), delete this.streamControllers[N];
          }, b.MessageHandler = t;
        },
        /* 105 */
        /***/
        (Re, b, ce) => {
          Object.defineProperty(b, "__esModule", {
            value: !0
          }), b.PDFWorkerStream = void 0;
          var n = ce(2);
          class P {
            constructor(l) {
              this._msgHandler = l, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            getFullReader() {
              return (0, n.assert)(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new D(this._msgHandler), this._fullRequestReader;
            }
            getRangeReader(l, V) {
              const te = new e(l, V, this._msgHandler);
              return this._rangeRequestReaders.push(te), te;
            }
            cancelAllRequests(l) {
              var V;
              (V = this._fullRequestReader) == null || V.cancel(l);
              for (const te of this._rangeRequestReaders.slice(0))
                te.cancel(l);
            }
          }
          b.PDFWorkerStream = P;
          class D {
            constructor(l) {
              this._msgHandler = l, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
              const V = this._msgHandler.sendWithStream("GetReader");
              this._reader = V.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((te) => {
                this._isStreamingSupported = te.isStreamingSupported, this._isRangeSupported = te.isRangeSupported, this._contentLength = te.contentLength;
              });
            }
            get headersReady() {
              return this._headersReady;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            async read() {
              const {
                value: l,
                done: V
              } = await this._reader.read();
              return V ? {
                value: void 0,
                done: !0
              } : {
                value: l.buffer,
                done: !1
              };
            }
            cancel(l) {
              this._reader.cancel(l);
            }
          }
          class e {
            constructor(l, V, te) {
              this._msgHandler = te, this.onProgress = null;
              const E = this._msgHandler.sendWithStream("GetRangeReader", {
                begin: l,
                end: V
              });
              this._reader = E.getReader();
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              const {
                value: l,
                done: V
              } = await this._reader.read();
              return V ? {
                value: void 0,
                done: !0
              } : {
                value: l.buffer,
                done: !1
              };
            }
            cancel(l) {
              this._reader.cancel(l);
            }
          }
        }
        /******/
      ], Gt = {};
      function Qt(Re) {
        var b = Gt[Re];
        if (b !== void 0)
          return b.exports;
        var ce = Gt[Re] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return Pt[Re](ce, ce.exports, Qt), ce.exports;
      }
      var Yt = {};
      return (() => {
        var Re = Yt;
        Object.defineProperty(Re, "__esModule", {
          value: !0
        }), Object.defineProperty(Re, "WorkerMessageHandler", {
          enumerable: !0,
          get: function() {
            return b.WorkerMessageHandler;
          }
        });
        var b = Qt(1);
      })(), Yt;
    })()
  ));
})(Jn);
var Sa = Jn.exports;
(typeof window < "u" ? window : {}).pdfjsWorker = Sa;
const Aa = "_wrapper_w1m1u_1", ka = "_viewport_w1m1u_12", Yn = {
  wrapper: Aa,
  viewport: ka
};
function Pa(Ct) {
  return /* @__PURE__ */ jt(
    pa,
    {
      initialState: {
        configOptions: {
          ...ba,
          showPdfThumbnails: Ct.showPdfThumbnails,
          showPdfToolBar: Ct.showPdfToolBar,
          showPdfSearch: Ct.showPdfSearch,
          showPdfZoom: Ct.showPdfZoom,
          showPdfPaging: Ct.showPdfPaging,
          showPdfRotate: Ct.showPdfRotate,
          showPdfTwoPageSpread: Ct.showPdfTwoPageSpread,
          showPdfFullScreen: Ct.showPdfFullScreen,
          canvasHeight: Ct.canvasHeight
        }
      },
      children: /* @__PURE__ */ jt(Ca, { ...Ct })
    }
  );
}
function Ca(Ct) {
  const { annotationBody: Mt } = Ct, { configOptions: Pt } = ya();
  let { pdfNumPages: Gt, pdfPage: Qt, pdfMagLevel: Yt } = Pt;
  const {
    pdfRotationValue: Re,
    pdfFullscreen: b,
    pdfTwoPageSpread: ce,
    pdfToggleThumbnails: n
  } = Pt, P = wa();
  Yt === void 0 && (Yt = 100), Qt === void 0 && (Qt = 1), Gt === void 0 && (Gt = 1);
  const D = Mt.id;
  function e({
    numPages: p
  }) {
    P({
      type: "updateConfigOptions",
      configOptions: { ...Pt, pdfNumPages: p }
    });
  }
  const l = Mt.height || 500 - 50, V = (Mt.width || 355) * (Yt / 100), te = l * (Yt / 100), E = /* @__PURE__ */ jt(
    "div",
    {
      style: {
        margin: "auto",
        width: `${V}px`,
        height: `${te}px`,
        backgroundColor: "#fff"
      }
    }
  ), F = [];
  for (let p = 1; p <= Gt; p++)
    F.push({
      page_num: p,
      doc: /* @__PURE__ */ jt(
        jn,
        {
          file: D,
          rotate: Re,
          loading: E,
          onLoadSuccess: p == 1 ? (O) => e(O) : void 0,
          children: /* @__PURE__ */ jt(
            Un,
            {
              pageNumber: p,
              height: l,
              scale: Yt / 100,
              renderTextLayer: !1,
              renderAnnotationLayer: !1
            }
          )
        }
      )
    });
  const f = [];
  for (let p = 2; p <= Gt; p++)
    f.push([
      {
        page_num: p,
        doc: /* @__PURE__ */ jt(jn, { file: D, rotate: Re, loading: E, children: /* @__PURE__ */ jt(
          Un,
          {
            pageNumber: p,
            height: l,
            scale: Yt / 100,
            renderTextLayer: !1,
            renderAnnotationLayer: !1
          }
        ) })
      },
      {
        page_num: p + 1,
        doc: /* @__PURE__ */ jt(jn, { file: D, rotate: Re, loading: E, children: /* @__PURE__ */ jt(
          Un,
          {
            pageNumber: p + 1,
            height: l,
            scale: Yt / 100,
            renderTextLayer: !1,
            renderAnnotationLayer: !1,
            error: E
          }
        ) })
      }
    ]), p++;
  const x = (p, O) => {
    p && P({
      type: "updateConfigOptions",
      configOptions: {
        ...Pt,
        pdfPage: O,
        pdfEnteredPage: O
      }
    });
  };
  function a(p, O, M) {
    return /* @__PURE__ */ jt(
      xa,
      {
        partialVisibility: !0,
        offset: { top: 260, bottom: 260 },
        onChange: (R) => x(R, p.page_num),
        children: ({ isVisible: R }) => /* @__PURE__ */ jt(
          "div",
          {
            id: `page-${p.page_num}`,
            style: {
              ...M,
              width: `${V}px`,
              height: `${te}px`
            },
            children: R ? p.doc : E
          },
          O
        )
      }
    );
  }
  function N(p, O) {
    return Gt === void 0 && (Gt = 5), /* @__PURE__ */ fn("div", { style: { display: "flex" }, children: [
      /* @__PURE__ */ jt("div", { children: a(p[0], O, { margin: "0.25rem" }) }),
      p[1].page_num > Gt ? /* @__PURE__ */ jt("div", {}) : /* @__PURE__ */ jt("div", { children: a(p[1], O, { margin: "0.25rem" }) })
    ] }, O);
  }
  return /* @__PURE__ */ fn(
    "div",
    {
      id: "pdf-viewer",
      className: `${Yn.wrapper} pdf-viewer-wrapper`,
      style: {
        maxHeight: Pt.canvasHeight
      },
      children: [
        /* @__PURE__ */ jt(
          "div",
          {
            id: "pdf-controls",
            style: { display: "flex", justifyContent: "center" },
            children: /* @__PURE__ */ jt(ma, {})
          }
        ),
        /* @__PURE__ */ fn("div", { id: "pdf-viewport", className: Yn.viewport, children: [
          n && !b && /* @__PURE__ */ jt(ga, { url: D, height: "520px" }),
          /* @__PURE__ */ fn(
            "div",
            {
              style: {
                width: "100%",
                height: l,
                overflow: "scroll",
                backgroundColor: "#F2F2F0",
                maxHeight: b ? "100vh" : "540px",
                textAlign: "center"
              },
              children: [
                F && ce ? /* @__PURE__ */ jt(da, { children: /* @__PURE__ */ fn(
                  "div",
                  {
                    style: {
                      textAlign: "center"
                    },
                    children: [
                      /* @__PURE__ */ jt("div", { children: a(F[0], 0, {
                        margin: "0.25rem auto"
                      }) }),
                      f.map((p, O) => N(p, O))
                    ]
                  }
                ) }) : null,
                F && !ce ? F.map((p, O) => /* @__PURE__ */ jt("div", { children: a(p, O, {
                  margin: "0.25rem auto"
                }) }, O)) : null
              ]
            }
          )
        ] })
      ]
    }
  );
}
export {
  Pa as default
};
